{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/user.jpg","path":"images/user.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/Picture1.png","path":"images/Picture1.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/images/user2.png","path":"images/user2.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1521962313000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1521962313000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1521962313000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1521962313000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1521962313000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1521962313000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1521962313000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1521962313000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1521962313000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1521962313000},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1521962313000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1521962313000},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1521962313000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1521962313000},{"_id":"themes/next/_config.yml","hash":"e40f053d848b115372686f56ab9db603eee45095","modified":1523250797000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1521962313000},{"_id":"source/_posts/Codeforces-498Div3-C.md","hash":"1a8754b49d0d50dac70e32dbcdc6f49f6b7b9654","modified":1533830203236},{"_id":"source/_posts/Graph-Theory-The-shortest-path.md","hash":"43535cf1963d6ddbc40a7b411720f1da0e03ae3e","modified":1536398907382},{"_id":"source/_posts/HDU1016-Prime-Ring-Problem-DFS.md","hash":"79978b5864b1c63f32c69a43aa9a2046535b9e81","modified":1534248494876},{"_id":"source/_posts/HDU2050.md","hash":"2df3ba1cab2ba3a4f9b11e5e2b857e66cfa8de5c","modified":1534248558557},{"_id":"source/_posts/CodeForces-569A.md","hash":"81994b854e2a9e5c7ad46d92c5d0f8862c17f60d","modified":1535443915270},{"_id":"source/_posts/HDU4856-Tunnels.md","hash":"e4d34d375735c588fd6a1c39890a01185cefe8cd","modified":1534248647905},{"_id":"source/_posts/My-little-angel.md","hash":"89c0b7592c49b6ec6d048dc6b68e37a5bf098e64","modified":1528776991095},{"_id":"source/_posts/CodeForces-478C.md","hash":"4a221f9c080ae86a94c4ebe9ca31393ca16b0e16","modified":1535445574822},{"_id":"source/_posts/Nowcoder-Third-A.md","hash":"ac2c64a80826e35da3640fe5501eab1287d3f4e2","modified":1533830285233},{"_id":"source/_posts/HDU5092.md","hash":"51ba3808c7917621d95edbbd6090a5a1af11a383","modified":1528201686754},{"_id":"source/_posts/Nowcoder-Fourth-G.md","hash":"de2d74028d0b4c3cf4a1127d234ad72c754f155a","modified":1533830106075},{"_id":"source/_posts/Uva12096-The-SetStack-Computer-STL.md","hash":"c432f9996b830867d5db3e983e62fd44b857f132","modified":1533867042000},{"_id":"source/_posts/hexo-mathjax.md","hash":"091cbe4ac1063cef0b1813669a3222b238cbc777","modified":1533829630373},{"_id":"source/_posts/new start point.md","hash":"297ab49aab35d308f618255fd55de969998f0a95","modified":1533830493268},{"_id":"source/_posts/new-keyword.md","hash":"59fcd70402807bb875f5db3f67ce64aa7010ab78","modified":1537425593049},{"_id":"source/_posts/pick-numbers.md","hash":"d9a80b924c7b859cabef0fe81e4f43c3588c45f8","modified":1533981616862},{"_id":"source/_posts/quick-matrix.md","hash":"619f7b89a7f5d41ea61c0d11a70fc202505b6150","modified":1533829859904},{"_id":"source/_posts/segtree-intval.md","hash":"5a068b1986a1068accb0a31f4944e2b114452b13","modified":1533829830652},{"_id":"source/_posts/POJ1970-The-Game-DFS.md","hash":"192f308674dfa7048fd316943a9b331c12c313b5","modified":1534249069397},{"_id":"source/_posts/sscanf-sprintf.md","hash":"29c2c6635789deddd5c24a667c0d5dcdf0493766","modified":1537091577780},{"_id":"source/_posts/stringstream.md","hash":"5dca4133453bd5d29403c81547d026dfdde7e1f2","modified":1533743427067},{"_id":"source/_posts/tab-to-spaces.md","hash":"55dd2bdfca8c57e0131d4ed11092c4168e8e5cb2","modified":1533829950793},{"_id":"source/_posts/vultr.md","hash":"4147407957171b4750332d30093075efdacf53f1","modified":1533829685746},{"_id":"source/about/index.md","hash":"3ebd04672d0a84fa7380f3ae3a7aea48f08c07cc","modified":1523175241342},{"_id":"source/_posts/POJ2481.md","hash":"1602b844dcb7801b922b5f1c63dda1a8647680bb","modified":1534248765345},{"_id":"source/commonweal/index.md","hash":"423894f3e9d10b9bbfae31c42cb31f5c3cec81a2","modified":1523179153090},{"_id":"source/schedule/index.md","hash":"73d7ca6fb2a4d82bc89a489befdb0b066599178b","modified":1523179037727},{"_id":"source/sitemap/index.md","hash":"f18cfe801086a113dff7f6862d85c7e2d6727e46","modified":1523179132866},{"_id":"source/tags/index.md","hash":"b23dc9c86fb565af015f51a741bf0c9f890a87fc","modified":1523121942983},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1521962313000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1521962313000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1521962313000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1521962313000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1521962313000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1521962313000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1521962313000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1521962313000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1521962313000},{"_id":"source/_posts/STL-cmp.md","hash":"6320beb1fdb17564b86b15f2316ce63c71e0c264","modified":1533656325000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1521962313000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1521962313000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1521962313000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1521962313000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1521962313000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1521962313000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1521962313000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1521962313000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1521962313000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1521962313000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1521962313000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1521962313000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1521962313000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1521962313000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1521962313000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1521962313000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1521962313000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1521962313000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1521962313000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1521962313000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1521962313000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1521962313000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1521962313000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"source/_posts/Graph-Theory-The-shortest-path/gra.png","hash":"c2a7946e9e78ad6264a4a6d6b581d06160604bfe","modified":1536325837191},{"_id":"source/_posts/Graph-Theory-The-shortest-path/path.png","hash":"b20559aca988d5aaefc0931e513b4fc808c5be21","modified":1536326076832},{"_id":"source/_posts/segtree-template.md","hash":"df3641578af3bfc52c1e19a1ee170253a02b571a","modified":1533829822200},{"_id":"source/categories/index.md","hash":"76f4447e0e8f274e0255fa038aa97656425eae07","modified":1523175315982},{"_id":"source/_posts/HDU1016-Prime-Ring-Problem-DFS/dfs.png","hash":"bfaf09def97b165527bb22bad63dfe38109bdd64","modified":1534088537000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1521962313000},{"_id":"source/_posts/HDU2050/res.gif","hash":"163a87523482ba25a73787e59a0b13ecfb736053","modified":1523247099713},{"_id":"source/_posts/HDU2050/line.jpg","hash":"0b614039e05df58510f6979466289f7ac7190b5f","modified":1523244954809},{"_id":"source/_posts/My-little-angel/moon1.jpg","hash":"c57a51bb30e1ec204f4fb3c01783b8f2e87a1bbd","modified":1528606062541},{"_id":"source/_posts/tab-to-spaces/space.png","hash":"e1202e8eb89c5c09f5e3eb1e4a72be772c4790b6","modified":1528775921000},{"_id":"source/_posts/My-little-angel/together1.jpg","hash":"1783fb05e6a210c1c2de23c413b9fb466c44c03a","modified":1528606083038},{"_id":"source/_posts/POJ1970-The-Game-DFS/Renju.png","hash":"e478edf969416be8f2fda647b3336271dbb13b6a","modified":1534247440000},{"_id":"source/_posts/tab-to-spaces/tab.png","hash":"30312fc2dabd01c3540693ea57af6ea0a11c9fe2","modified":1528775840000},{"_id":"source/_posts/vultr/p2.png","hash":"c797e71775de0c707e10ec8f765a154b37f27197","modified":1523620056000},{"_id":"source/_posts/vultr/p3.png","hash":"67dbd2c65a2c47e6ae09f22051629da1a6c5fdd1","modified":1523620317000},{"_id":"source/_posts/vultr/p5.png","hash":"a7c6230253b7b12375ea294a6386473479cd7d26","modified":1523620767000},{"_id":"source/_posts/vultr/p7.png","hash":"da388ae09f2db520f71e2348bf8a4883adb2666a","modified":1523623834000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1521962313000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1521962313000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1521962313000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1521962313000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1521962313000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1521962313000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1521962313000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1521962313000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1521962313000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1521962313000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1521962313000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1521962313000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1521962313000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1521962313000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1521962313000},{"_id":"source/_posts/vultr/p8.png","hash":"2f5ce1e7aa48769570589a1a15948f1364753a67","modified":1523625511000},{"_id":"source/_posts/vultr/p1.png","hash":"595bda0f3e72f314db02d09c378298daf0840657","modified":1523619807000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1521962313000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1521962313000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1521962313000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1521962313000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1521962313000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1521962313000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1521962313000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1521962313000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1521962313000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1521962313000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1521962313000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1521962313000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1521962313000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1521962313000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1521962313000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1521962313000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1521962313000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1521962313000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1521962313000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1521962313000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1521962313000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1521962313000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1521962313000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1521962313000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1521962313000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1521962313000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1521962313000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1521962313000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1521962313000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1521962313000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1521962313000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1521962313000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1521962313000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1521962313000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1521962313000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1521962313000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1521962313000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1521962313000},{"_id":"source/_posts/My-little-angel/qxy1.jpg","hash":"29c0b85aa8bd9e32c8b239b78ae5f571e8375bd9","modified":1528599176588},{"_id":"source/_posts/vultr/p4.png","hash":"2ee46cf520c7d0585db4245c9586829f5173e680","modified":1523620362000},{"_id":"source/_posts/vultr/p6.png","hash":"47f4048062363375bb49809ceb19a67b5c659bf3","modified":1523621592467},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"source/_posts/vultr/p9.png","hash":"7a099d33cc7ac17bc5e233121d135e46af0549b5","modified":1523625737000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/images/user.jpg","hash":"16b0e60948516954e1f9834e2d593c1deb0ffec4","modified":1490872143020},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1521962313000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1521962313000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1521962313000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1521962313000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1521962313000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1521962313000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1521962313000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1521962313000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1521962313000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1521962313000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1521962313000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1521962313000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1521962313000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1521962313000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1521962313000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1521962313000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1521962313000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1521962313000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1521962313000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1521962313000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1521962313000},{"_id":"themes/next/source/images/Picture1.png","hash":"94067d9a4021d24612d7dad597c915d07d0056c0","modified":1523193407424},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1521962313000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1521962313000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1521962313000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1521962313000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1521962313000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1521962313000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1521962313000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1521962313000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1521962313000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1521962313000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1521962313000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1521962313000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1521962313000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1521962313000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1521962313000},{"_id":"themes/next/source/images/user2.png","hash":"5a825078a61886e5bf8f40244b0c0d3acef801ee","modified":1523193518284},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1521962313000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1521962313000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1521962313000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1521962313000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1521962313000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1521962313000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1521962313000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1521962313000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1521962313000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1521962313000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1521962313000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1521962313000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1521962313000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1521962313000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1521962313000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1521962313000},{"_id":"public/about/index.html","hash":"317d7c64b6d8b5566d0118082a48ea5e03b88d5e","modified":1537425222787},{"_id":"public/commonweal/index.html","hash":"acc291e733e939b635cd51e9e91e4acdd4cee9a9","modified":1537425222787},{"_id":"public/schedule/index.html","hash":"7511782803ef50a562ce46e7814538041fb67ee5","modified":1537425222788},{"_id":"public/sitemap/index.html","hash":"c7a4ec0708e1788bcf4964bfb8003630124640a2","modified":1537425222788},{"_id":"public/tags/index.html","hash":"8a5215d0865483ea1e6d06776750b767843db986","modified":1537425222788},{"_id":"public/categories/index.html","hash":"0c33afa6955ece70b2b5e071ea792999c4349096","modified":1537425222788},{"_id":"public/2018/06/05/HDU5092/index.html","hash":"c4fc8af3d28800f6ef382afbca48d31de13c39aa","modified":1537425222788},{"_id":"public/archives/2018/05/index.html","hash":"b767de5b1ff66153192dd6840d7398e1afc0d528","modified":1537425222788},{"_id":"public/archives/2018/06/index.html","hash":"d153e08bbb0e1db98b1fb01ab28d13c30e937cc3","modified":1537425222789},{"_id":"public/archives/2018/07/index.html","hash":"99e4d70d9aa5997931a9abf842519df81f795c9c","modified":1537425222789},{"_id":"public/archives/2018/09/index.html","hash":"af09fd2c099c6e5c7b5465504801b668f0be1bf9","modified":1537425222789},{"_id":"public/categories/Diary/index.html","hash":"96c4e0a03e9da8cee5b26cc4d5d4b777b865207f","modified":1537425222789},{"_id":"public/categories/Messy-article/index.html","hash":"dc4be02cb8debaab339cfb2730f457e2c53b9a10","modified":1537425222789},{"_id":"public/tags/前缀和/index.html","hash":"373c75815cfcf8871239bca186d6072d07e06089","modified":1537425222789},{"_id":"public/tags/后缀和/index.html","hash":"f91aeb223ce173a449097253fa284dbf84c00bd5","modified":1537425222789},{"_id":"public/tags/DFS/index.html","hash":"e1d47dca1b5f2c6b88235db20fe95aa8dcd8a2cf","modified":1537425222789},{"_id":"public/tags/图论/index.html","hash":"e3939b75f6ecd1abddb7b7c9f3c31b9ed7b2f550","modified":1537425222789},{"_id":"public/tags/HDU/index.html","hash":"be98e918b6908a6b0107cdd4312ad8ba9560066b","modified":1537425222789},{"_id":"public/tags/线切割平面/index.html","hash":"2513accff06e98603a74048246202076ae33198a","modified":1537425222789},{"_id":"public/tags/math/index.html","hash":"c5a144a108c06f45de0ae0c5b5421ed2b7a1eb33","modified":1537425222789},{"_id":"public/tags/思维/index.html","hash":"0945556b4588637b040de649ce231f21883b7fd8","modified":1537425222789},{"_id":"public/tags/状态压缩DP/index.html","hash":"7c5ae8c382703a9c46db805f9ee80ee2a4652304","modified":1537425222789},{"_id":"public/tags/BFS/index.html","hash":"37de41e9180ec48a410e5bcd4f96058b3658a93e","modified":1537425222790},{"_id":"public/tags/Lover/index.html","hash":"1f75831eca961a9836ad3011f4c5f6a0f0c30f8b","modified":1537425222790},{"_id":"public/tags/DP/index.html","hash":"c436e3fbdec73401309a1f197a9d8a9931996f3e","modified":1537425222790},{"_id":"public/tags/01背包/index.html","hash":"657e0db8de6249a6f186497bdfcf4e594a027cb6","modified":1537425222790},{"_id":"public/tags/逆向思维/index.html","hash":"353be2eede5d4bfdf4999f1ed536cb3a23f33ea4","modified":1537425222790},{"_id":"public/tags/stack/index.html","hash":"15aa730ab585cfea322d3096d9a1ff4067b68ea2","modified":1537425222790},{"_id":"public/tags/STL/index.html","hash":"93ead8d46dd1c8412f658e6025a9e2bfc5cdd6e7","modified":1537425222790},{"_id":"public/tags/mathjax/index.html","hash":"c57c36d0d70a422aff47588dbbacdd13f9aebc47","modified":1537425222790},{"_id":"public/tags/hexo插入数学公式/index.html","hash":"d7801df24ea63a2e4f69fb6d11df4c71c3ed619d","modified":1537425222790},{"_id":"public/tags/总结/index.html","hash":"c306099a832314991adc3ce3b6faab1c80e9c7fa","modified":1537425222790},{"_id":"public/tags/生活/index.html","hash":"981a51696d631a92bbec93bb60b81cd545716c5b","modified":1537425222790},{"_id":"public/tags/线段树区间更新/index.html","hash":"4f466af546b7b0ec3fbb16ba3fb21fe27895e1ff","modified":1537425222790},{"_id":"public/tags/POJ/index.html","hash":"82a17e465c75bb287a585d17122a8dc4db131603","modified":1537425222790},{"_id":"public/tags/迷宫问题/index.html","hash":"28e5bf2593314abefbcb8a4080f8fcec8ee04fba","modified":1537425222791},{"_id":"public/tags/字符串/index.html","hash":"eca1a00e77b5f752ff31fa28d0c4ab35a295a518","modified":1537425222791},{"_id":"public/tags/python/index.html","hash":"76beedfac990a820d0e7bfbb49d93be4449f2a81","modified":1537425222791},{"_id":"public/tags/vultr服务器搭建/index.html","hash":"478a60c54d815380ba41b9fbd565c76a22c7e876","modified":1537425222791},{"_id":"public/tags/线段树/index.html","hash":"900e40b74ab84362a7ab352960bc0d3f4b46e68b","modified":1537425222791},{"_id":"public/tags/线段树单点更新/index.html","hash":"370e096046236696a57571ec24b0ce97c3bc1976","modified":1537425222791},{"_id":"public/2018/09/15/sscanf-sprintf/index.html","hash":"875c07a4431a805f6d46ff86f4978ad8b9ed1cb5","modified":1537425222791},{"_id":"public/2018/09/07/Graph-Theory-The-shortest-path/index.html","hash":"c056c5226036934ca3507476fd21ae9e4f9fa728","modified":1537425222791},{"_id":"public/2018/08/28/CodeForces-569A/index.html","hash":"16b923cf9b9d918a7c875a8e8ce2fe23f9dc1b2e","modified":1537425222791},{"_id":"public/2018/08/28/CodeForces-478C/index.html","hash":"d4c748e348b145cdfe82b5ad207c00e0bb74cdbc","modified":1537425222791},{"_id":"public/2018/08/14/POJ1970-The-Game-DFS/index.html","hash":"550612e5520bf8c191f4d107b7fabf27ae25b30d","modified":1537425222791},{"_id":"public/2018/08/12/HDU1016-Prime-Ring-Problem-DFS/index.html","hash":"6f8ffe80ab41883b529f55ac619366393458fecb","modified":1537425222791},{"_id":"public/2018/08/11/pick-numbers/index.html","hash":"67b39a1f776996f8c0420c4bb9a4fc56ddd671e5","modified":1537425222791},{"_id":"public/2018/08/09/Uva12096-The-SetStack-Computer-STL/index.html","hash":"39d6167fd858ed7a9d42431389284c95c5796732","modified":1537425222792},{"_id":"public/2018/08/08/stringstream/index.html","hash":"d0f7f572daf0c593e27e6e3b8f39f36ba22a7f54","modified":1537425222792},{"_id":"public/2018/08/07/STL-cmp/index.html","hash":"e0f8584787ecb611e908d54d583d53204aafb91a","modified":1537425222792},{"_id":"public/2018/07/31/Codeforces-498Div3-C/index.html","hash":"1187efda5dc59e65c0316cf36327b0994cc72dad","modified":1537425222792},{"_id":"public/2018/07/29/Nowcoder-Fourth-G/index.html","hash":"efa813dafb6d1199e59be268316e8ff781fe14b8","modified":1537425222792},{"_id":"public/2018/07/26/Nowcoder-Third-A/index.html","hash":"0c8da9d9b3b5ecec59cac12fcea4057fb386f983","modified":1537425222792},{"_id":"public/2018/06/12/tab-to-spaces/index.html","hash":"50511b611dd788a442a576de2d0b2b025311e0ae","modified":1537425222792},{"_id":"public/2018/06/10/My-little-angel/index.html","hash":"2155194090382204a0ae47496ab58f9298308084","modified":1537425222792},{"_id":"public/2018/05/16/HDU4856-Tunnels/index.html","hash":"1dfba50e7a5b63a33de17532a304bd5198c66f05","modified":1537425222792},{"_id":"public/2018/05/14/quick-matrix/index.html","hash":"473ed4319e5b21784d5f68b2b56bc0c0fabc3452","modified":1537425222792},{"_id":"public/2018/05/08/segtree-intval/index.html","hash":"79dc583fda953ce90bce77c3f1775145ed863f0e","modified":1537425222792},{"_id":"public/2018/05/06/segtree-template/index.html","hash":"2eea0495800fd6fd88b3deca7016ee76ba9cc04a","modified":1537425222792},{"_id":"public/2018/04/22/POJ2481/index.html","hash":"66df01539c778bc0dcddc9911cf015e45aaaf414","modified":1537425222793},{"_id":"public/2018/04/13/vultr/index.html","hash":"4bcb6f2ab8ddaa3e37d9cf70260688565e682aa1","modified":1537425222793},{"_id":"public/2018/04/09/hexo-mathjax/index.html","hash":"7b660cb3ede28ada27ab9d5ba727cb46849b513a","modified":1537425222793},{"_id":"public/2018/04/09/HDU2050/index.html","hash":"17edaa9254e249b8264dfdb5420e74830e330ef9","modified":1537425222793},{"_id":"public/2018/04/08/new start point/index.html","hash":"f1a827d2a535b3b05db5fb67ff33253d4b615795","modified":1537425222793},{"_id":"public/archives/index.html","hash":"8267faede078d66fc461da42309c6e62739c202b","modified":1537425222793},{"_id":"public/archives/page/2/index.html","hash":"63542be17263217aae4d9573efcc7b11ce05e3b1","modified":1537425222793},{"_id":"public/archives/page/3/index.html","hash":"e7ebe22dfd58050b508de361d04eab182fa6727c","modified":1537425222793},{"_id":"public/archives/2018/index.html","hash":"e03fcd8ac23dd9d36ccee8fd8eb755464d360796","modified":1537425222793},{"_id":"public/archives/2018/page/2/index.html","hash":"9a3283f8658fd1c7d9c5b186e8f5775777818108","modified":1537425222793},{"_id":"public/archives/2018/page/3/index.html","hash":"03817dba1839af9d8023d42cc4812666f1d1607c","modified":1537425222793},{"_id":"public/archives/2018/04/index.html","hash":"a060fe17003eab48dfa9e3109bf818d666034075","modified":1537425222793},{"_id":"public/archives/2018/08/index.html","hash":"9f99ad61ea183ecbec522d19c29c567ed28a42a4","modified":1537425222793},{"_id":"public/categories/ACM/index.html","hash":"37ec7635f02282155c7299ce22502cd6b502148f","modified":1537425222793},{"_id":"public/categories/ACM/page/2/index.html","hash":"61a4b4cc31a88263ffa83020a0fa0a99241b8dd8","modified":1537425222794},{"_id":"public/index.html","hash":"d66154bf39e53f8e26b8920b0e1ffa499e114d5e","modified":1537425530590},{"_id":"public/page/2/index.html","hash":"dfdf49f0fe10609edfca94e087724da373c13a79","modified":1537425222794},{"_id":"public/page/3/index.html","hash":"a5fe27ba64e54e45fac1e7588acfe7fa9bf4e1cf","modified":1537425222794},{"_id":"public/tags/C/index.html","hash":"207e8752033dd75112a8c94fd7a3bd7bca4504d2","modified":1537425222804},{"_id":"public/2018/09/20/new-keyword/index.html","hash":"0d08c4b36542b4c2356d1c5dc031a13e6dac8e7a","modified":1537425611093},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1537425222811},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1537425222811},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1537425222811},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1537425222811},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1537425222811},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1537425222811},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1537425222811},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1537425222811},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1537425222811},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1537425222811},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1537425222811},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1537425222811},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1537425222811},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1537425222811},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1537425222812},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1537425222812},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1537425222812},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1537425222812},{"_id":"public/images/user.jpg","hash":"16b0e60948516954e1f9834e2d593c1deb0ffec4","modified":1537425222812},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1537425222812},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1537425222812},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1537425222812},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1537425222812},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1537425222812},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1537425222812},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1537425222812},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1537425222812},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1537425222812},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1537425222812},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1537425222812},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1537425222812},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1537425222813},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1537425222813},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1537425222813},{"_id":"public/2018/08/12/HDU1016-Prime-Ring-Problem-DFS/dfs.png","hash":"bfaf09def97b165527bb22bad63dfe38109bdd64","modified":1537425222813},{"_id":"public/2018/08/14/POJ1970-The-Game-DFS/Renju.png","hash":"e478edf969416be8f2fda647b3336271dbb13b6a","modified":1537425222813},{"_id":"public/2018/09/07/Graph-Theory-The-shortest-path/gra.png","hash":"c2a7946e9e78ad6264a4a6d6b581d06160604bfe","modified":1537425222813},{"_id":"public/2018/09/07/Graph-Theory-The-shortest-path/path.png","hash":"b20559aca988d5aaefc0931e513b4fc808c5be21","modified":1537425222813},{"_id":"public/2018/04/09/HDU2050/line.jpg","hash":"0b614039e05df58510f6979466289f7ac7190b5f","modified":1537425222813},{"_id":"public/2018/04/09/HDU2050/res.gif","hash":"163a87523482ba25a73787e59a0b13ecfb736053","modified":1537425222813},{"_id":"public/2018/06/12/tab-to-spaces/space.png","hash":"e1202e8eb89c5c09f5e3eb1e4a72be772c4790b6","modified":1537425222813},{"_id":"public/2018/06/12/tab-to-spaces/tab.png","hash":"30312fc2dabd01c3540693ea57af6ea0a11c9fe2","modified":1537425222813},{"_id":"public/2018/06/10/My-little-angel/moon1.jpg","hash":"c57a51bb30e1ec204f4fb3c01783b8f2e87a1bbd","modified":1537425222813},{"_id":"public/2018/06/10/My-little-angel/together1.jpg","hash":"1783fb05e6a210c1c2de23c413b9fb466c44c03a","modified":1537425222813},{"_id":"public/2018/04/13/vultr/p1.png","hash":"595bda0f3e72f314db02d09c378298daf0840657","modified":1537425222813},{"_id":"public/2018/04/13/vultr/p2.png","hash":"c797e71775de0c707e10ec8f765a154b37f27197","modified":1537425222813},{"_id":"public/2018/04/13/vultr/p3.png","hash":"67dbd2c65a2c47e6ae09f22051629da1a6c5fdd1","modified":1537425222813},{"_id":"public/2018/04/13/vultr/p5.png","hash":"a7c6230253b7b12375ea294a6386473479cd7d26","modified":1537425222814},{"_id":"public/2018/04/13/vultr/p8.png","hash":"2f5ce1e7aa48769570589a1a15948f1364753a67","modified":1537425222814},{"_id":"public/2018/04/13/vultr/p7.png","hash":"da388ae09f2db520f71e2348bf8a4883adb2666a","modified":1537425222814},{"_id":"public/images/user2.png","hash":"5a825078a61886e5bf8f40244b0c0d3acef801ee","modified":1537425223674},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1537425223677},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1537425223679},{"_id":"public/2018/06/10/My-little-angel/qxy1.jpg","hash":"29c0b85aa8bd9e32c8b239b78ae5f571e8375bd9","modified":1537425223679},{"_id":"public/2018/04/13/vultr/p4.png","hash":"2ee46cf520c7d0585db4245c9586829f5173e680","modified":1537425223679},{"_id":"public/2018/04/13/vultr/p6.png","hash":"47f4048062363375bb49809ceb19a67b5c659bf3","modified":1537425223679},{"_id":"public/2018/04/13/vultr/p9.png","hash":"7a099d33cc7ac17bc5e233121d135e46af0549b5","modified":1537425223680},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1537425223690},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1537425223691},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1537425223691},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1537425223691},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1537425223692},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1537425223692},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1537425223692},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1537425223692},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1537425223692},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1537425223692},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1537425223692},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1537425223692},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1537425223692},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1537425223692},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1537425223692},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1537425223692},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1537425223692},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1537425223692},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1537425223693},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1537425223693},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1537425223693},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1537425223693},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1537425223693},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1537425223693},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1537425223693},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1537425223693},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1537425223693},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1537425223693},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1537425223693},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1537425223693},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1537425223693},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1537425223693},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1537425223694},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1537425223694},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1537425223694},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1537425223694},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1537425223694},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1537425223694},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1537425223694},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1537425223694},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1537425223694},{"_id":"public/css/main.css","hash":"ecf3658739aa2bb34c8f6ded5d319bc54393d4bd","modified":1537425223694},{"_id":"public/images/Picture1.png","hash":"94067d9a4021d24612d7dad597c915d07d0056c0","modified":1537425223694},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1537425223694},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1537425223694},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1537425223694},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1537425223697},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1537425223697},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1537425223698},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1537425223698},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1537425223698},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1537425223698},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1537425223698},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1537425223699},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1537425223708},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1537425223708},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1537425223711},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1537425223711},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1537425223718},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1537425223718},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1537425223719},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1537425223719},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1537425223719},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1537425223719},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1537425223719},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1537425223719},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1537425223721},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1537425223721},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1537425223721},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1537425223722},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1537425223724},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1537425223725},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1537425223727},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1537425223733},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1537425223736}],"Category":[{"name":"ACM","_id":"cjma7a1yu0002sxou2twu1gcv"},{"name":"Diary","_id":"cjma7a1zd000jsxouhtygteui"},{"name":"Messy article","_id":"cjma7a1zq0010sxoudlqre6dr"}],"Data":[],"Page":[{"title":"about","date":"2018-04-08T08:12:48.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-04-08 16:12:48\ntype: \"about\"\n---\n","updated":"2018-04-08T08:14:01.342Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjma7a25l0036sxouo16g166k","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"commonweal","date":"2018-04-08T09:18:33.000Z","type":"commonweal","_content":"","source":"commonweal/index.md","raw":"---\ntitle: commonweal\ndate: 2018-04-08 17:18:33\ntype: \"commonweal\"\n---\n","updated":"2018-04-08T09:19:13.090Z","path":"commonweal/index.html","comments":1,"layout":"page","_id":"cjma7a25o0038sxou8cpfr77v","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"schedule","date":"2018-04-08T09:15:03.000Z","type":"schedule","_content":"","source":"schedule/index.md","raw":"---\ntitle: schedule\ndate: 2018-04-08 17:15:03\ntype: \"schedule\"\n---\n","updated":"2018-04-08T09:17:17.727Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"cjma7a25u003bsxoun3an663k","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"sitemap","date":"2018-04-08T09:18:19.000Z","type":"sitemap","_content":"","source":"sitemap/index.md","raw":"---\ntitle: sitemap\ndate: 2018-04-08 17:18:19\ntype: \"sitemap\"\n---\n","updated":"2018-04-08T09:18:52.866Z","path":"sitemap/index.html","comments":1,"layout":"page","_id":"cjma7a25w003dsxou65t3780u","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-04-07T17:23:59.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-04-08 01:23:59\ntype: \"tags\"\n---\n","updated":"2018-04-07T17:25:42.983Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjma7a25x003hsxouoixw1sst","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2018-04-08T08:14:39.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-04-08 16:14:39\ntype: \"categories\"\n---\n","updated":"2018-04-08T08:15:15.982Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjma7a28y003nsxouraceatcv","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Codeforces-#498Div3-C-前&&后缀和","date":"2018-07-31T15:08:57.000Z","_content":"好题，虽然比较简单，但是觉得这道题的解题思路挺棒的，用到了前缀和，后缀和以及思路的转换．解出来之后还是很开心的，嚯嚯嚯（一个只能做做Div3的小菜鸡|･ω･｀)）\n<!-- more -->\n## 链接\n[Codeforces-#498Div3-C](http://codeforces.com/contest/1006/problem/C)\n## 题解\n题目大意：给定n个整数（范围1~1e9）,要求把这n个整数划分为连续的三段，使得第一段的数的总和与第三段的数的总和相等且要求这个总和尽量大．\n思路：\n因为n的范围是1~2e5，而且又涉及求和，所以应该可以比较自然的想到前缀和，题目又要求是前后两段的总和相等所以后缀和也要统计一下．接下来就要考虑什么时候两端的和相等且最大了，因为第一段和第三段长度不定，所以相当于是两个变量，想到它们的长度变化其实可以归一到第二段数据的长度变化，这样的话复杂度变为O(n)，就可以通过了．具体做法是对于1~n这n个数据，初始化第二段数据区间为[2, n - 1], 然后判断此时第一段和第三段数据和的大小关系，因为已经统计了前缀和和后缀和，所以这部分复杂度是O(1)．如果第一段数据和等于第三段数据和则记录这个数据和同时缩小第二段数据的区间，变为[3, n - 2]，继续判断，看是否还有更大的数据和满足条件；如果第一段数据和大于第三段数据和则保持第二段区间左端点不变收缩右端点，即变为[2, n - 2];同样的如果第一段数据和小于第三段数据和则保持第二段区间右端点不变，左端点收缩，即变为[3, n - 2];以此类推，直到第二段区间消失，此时最后一次记录的数据和即为结果．\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint d[maxn];\nint n;\nlong long psum[maxn], bsum[maxn];\nvector<long long> vec;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", d + i);\n        if(i == 0) psum[i] = d[i];\n        else psum[i] = psum[i - 1] + d[i];\n    }\n    for(int i = n - 1; i >= 0; i--){\n        if(i == n - 1) bsum[i] = d[i];\n        else bsum[i] = bsum[i + 1] + d[i];\n    }\n\n    int i, j;\n    for(i = 0, j = n - 1; i < n;){\n        if(i >= j) break;\n        if(psum[i] == bsum[j]){\n            vec.push_back(psum[i]);\n            i++;\n            j--;\n        }\n        else if(psum[i] < bsum[j]) i++;\n        else if(psum[i] > bsum[j]) j--;\n    }\n    if(vec.size() != 0) printf(\"%lld\\n\", vec[vec.size() - 1]);\n    else printf(\"0\\n\");\n    return 0;\n}\n```","source":"_posts/Codeforces-498Div3-C.md","raw":"---\ntitle: 'Codeforces-#498Div3-C-前&&后缀和'\ndate: 2018-07-31 23:08:57\ncategories:\n- ACM\ntags:\n- 前缀和\n- 后缀和\n---\n好题，虽然比较简单，但是觉得这道题的解题思路挺棒的，用到了前缀和，后缀和以及思路的转换．解出来之后还是很开心的，嚯嚯嚯（一个只能做做Div3的小菜鸡|･ω･｀)）\n<!-- more -->\n## 链接\n[Codeforces-#498Div3-C](http://codeforces.com/contest/1006/problem/C)\n## 题解\n题目大意：给定n个整数（范围1~1e9）,要求把这n个整数划分为连续的三段，使得第一段的数的总和与第三段的数的总和相等且要求这个总和尽量大．\n思路：\n因为n的范围是1~2e5，而且又涉及求和，所以应该可以比较自然的想到前缀和，题目又要求是前后两段的总和相等所以后缀和也要统计一下．接下来就要考虑什么时候两端的和相等且最大了，因为第一段和第三段长度不定，所以相当于是两个变量，想到它们的长度变化其实可以归一到第二段数据的长度变化，这样的话复杂度变为O(n)，就可以通过了．具体做法是对于1~n这n个数据，初始化第二段数据区间为[2, n - 1], 然后判断此时第一段和第三段数据和的大小关系，因为已经统计了前缀和和后缀和，所以这部分复杂度是O(1)．如果第一段数据和等于第三段数据和则记录这个数据和同时缩小第二段数据的区间，变为[3, n - 2]，继续判断，看是否还有更大的数据和满足条件；如果第一段数据和大于第三段数据和则保持第二段区间左端点不变收缩右端点，即变为[2, n - 2];同样的如果第一段数据和小于第三段数据和则保持第二段区间右端点不变，左端点收缩，即变为[3, n - 2];以此类推，直到第二段区间消失，此时最后一次记录的数据和即为结果．\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint d[maxn];\nint n;\nlong long psum[maxn], bsum[maxn];\nvector<long long> vec;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", d + i);\n        if(i == 0) psum[i] = d[i];\n        else psum[i] = psum[i - 1] + d[i];\n    }\n    for(int i = n - 1; i >= 0; i--){\n        if(i == n - 1) bsum[i] = d[i];\n        else bsum[i] = bsum[i + 1] + d[i];\n    }\n\n    int i, j;\n    for(i = 0, j = n - 1; i < n;){\n        if(i >= j) break;\n        if(psum[i] == bsum[j]){\n            vec.push_back(psum[i]);\n            i++;\n            j--;\n        }\n        else if(psum[i] < bsum[j]) i++;\n        else if(psum[i] > bsum[j]) j--;\n    }\n    if(vec.size() != 0) printf(\"%lld\\n\", vec[vec.size() - 1]);\n    else printf(\"0\\n\");\n    return 0;\n}\n```","slug":"Codeforces-498Div3-C","published":1,"updated":"2018-08-09T15:56:43.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1ym0000sxou6j4r9uib","content":"<p>好题，虽然比较简单，但是觉得这道题的解题思路挺棒的，用到了前缀和，后缀和以及思路的转换．解出来之后还是很开心的，嚯嚯嚯（一个只能做做Div3的小菜鸡|･ω･｀)）<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/contest/1006/problem/C\" target=\"_blank\" rel=\"noopener\">Codeforces-#498Div3-C</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意：给定n个整数（范围1~1e9）,要求把这n个整数划分为连续的三段，使得第一段的数的总和与第三段的数的总和相等且要求这个总和尽量大．<br>思路：<br>因为n的范围是1~2e5，而且又涉及求和，所以应该可以比较自然的想到前缀和，题目又要求是前后两段的总和相等所以后缀和也要统计一下．接下来就要考虑什么时候两端的和相等且最大了，因为第一段和第三段长度不定，所以相当于是两个变量，想到它们的长度变化其实可以归一到第二段数据的长度变化，这样的话复杂度变为O(n)，就可以通过了．具体做法是对于1~n这n个数据，初始化第二段数据区间为[2, n - 1], 然后判断此时第一段和第三段数据和的大小关系，因为已经统计了前缀和和后缀和，所以这部分复杂度是O(1)．如果第一段数据和等于第三段数据和则记录这个数据和同时缩小第二段数据的区间，变为[3, n - 2]，继续判断，看是否还有更大的数据和满足条件；如果第一段数据和大于第三段数据和则保持第二段区间左端点不变收缩右端点，即变为[2, n - 2];同样的如果第一段数据和小于第三段数据和则保持第二段区间右端点不变，左端点收缩，即变为[3, n - 2];以此类推，直到第二段区间消失，此时最后一次记录的数据和即为结果．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">2e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> psum[maxn], bsum[maxn];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, d + i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) psum[i] = d[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> psum[i] = psum[i - <span class=\"number\">1</span>] + d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == n - <span class=\"number\">1</span>) bsum[i] = d[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> bsum[i] = bsum[i + <span class=\"number\">1</span>] + d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>, j = n - <span class=\"number\">1</span>; i &lt; n;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt;= j) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(psum[i] == bsum[j])&#123;</span><br><span class=\"line\">            vec.push_back(psum[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(psum[i] &lt; bsum[j]) i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(psum[i] &gt; bsum[j]) j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vec.size() != <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, vec[vec.size() - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>好题，虽然比较简单，但是觉得这道题的解题思路挺棒的，用到了前缀和，后缀和以及思路的转换．解出来之后还是很开心的，嚯嚯嚯（一个只能做做Div3的小菜鸡|･ω･｀)）<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/contest/1006/problem/C\" target=\"_blank\" rel=\"noopener\">Codeforces-#498Div3-C</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意：给定n个整数（范围1~1e9）,要求把这n个整数划分为连续的三段，使得第一段的数的总和与第三段的数的总和相等且要求这个总和尽量大．<br>思路：<br>因为n的范围是1~2e5，而且又涉及求和，所以应该可以比较自然的想到前缀和，题目又要求是前后两段的总和相等所以后缀和也要统计一下．接下来就要考虑什么时候两端的和相等且最大了，因为第一段和第三段长度不定，所以相当于是两个变量，想到它们的长度变化其实可以归一到第二段数据的长度变化，这样的话复杂度变为O(n)，就可以通过了．具体做法是对于1~n这n个数据，初始化第二段数据区间为[2, n - 1], 然后判断此时第一段和第三段数据和的大小关系，因为已经统计了前缀和和后缀和，所以这部分复杂度是O(1)．如果第一段数据和等于第三段数据和则记录这个数据和同时缩小第二段数据的区间，变为[3, n - 2]，继续判断，看是否还有更大的数据和满足条件；如果第一段数据和大于第三段数据和则保持第二段区间左端点不变收缩右端点，即变为[2, n - 2];同样的如果第一段数据和小于第三段数据和则保持第二段区间右端点不变，左端点收缩，即变为[3, n - 2];以此类推，直到第二段区间消失，此时最后一次记录的数据和即为结果．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">2e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> psum[maxn], bsum[maxn];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, d + i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) psum[i] = d[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> psum[i] = psum[i - <span class=\"number\">1</span>] + d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == n - <span class=\"number\">1</span>) bsum[i] = d[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> bsum[i] = bsum[i + <span class=\"number\">1</span>] + d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>, j = n - <span class=\"number\">1</span>; i &lt; n;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt;= j) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(psum[i] == bsum[j])&#123;</span><br><span class=\"line\">            vec.push_back(psum[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(psum[i] &lt; bsum[j]) i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(psum[i] &gt; bsum[j]) j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vec.size() != <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, vec[vec.size() - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"HDU1016-Prime Ring Problem-DFS","date":"2018-08-12T15:16:27.000Z","_content":"渐渐对深搜类的题有了自信, 虽然还只能做一些简单的题, 但是感觉还不错٩('ω')و .\n题目描述：由$1-n$这$n$个自然数组成一个环,要求任意相邻两数之和为素数, 按顺序输出这些数.\n<!-- more -->\n## 链接\n[HDU1016-Prime Ring Problem](http://acm.hdu.edu.cn/showproblem.php?pid=1016)\n## 原题\nA ring is compose of $n$ circles as shown in diagram. Put natural number $1, 2,...,n$ into each circle separately, and the sum of numbers in two adjacent circles should be a prime.\nNote: the number of first circle should always be 1.\n![example](/dfs.png)\n## 题解\nDFS遍历每一种情况.\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 12 Aug 22:10:25 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n;\nvector<int> vec;\nbool vis[maxn];\n\nvoid ans_print(){\n    int cnt = 1;\n    for(auto x : vec){\n        if(cnt == 1) cout << x;\n        else cout << \" \" << x;\n        cnt++;\n    }\n    cout << endl;\n}\n\nbool is_prime(int x){\n    if(x < 2) return false;\n    int tmp = sqrt(x);\n    for(int i = 2; i <= tmp; i++){\n        if(!(x % i)) return false;\n    }\n    return true;\n}\n\nvoid dfs(int dep){\n    if(dep == n - 1){\n        for(int i = 2; i <= n; i++){\n            if(!vis[i] && is_prime(i + vec[dep - 1]) && is_prime(i + 1)){\n                vec.push_back(i);\n                ans_print();\n                vec.pop_back();\n            }\n        }\n        return;\n    }\n    for(int i = 2; i <= n; i++){\n        if(!vis[i] && is_prime(i + vec[dep - 1])){\n            vec.push_back(i);\n            vis[i] = 1;\n            dfs(dep + 1);\n            vec.pop_back();\n            vis[i] = 0;\n        }\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    while(cin >> n){\n        vec.clear();\n        memset(vis, 0, sizeof(0));\n        printf(\"Case %d:\\n\", cnt++);\n        vec.push_back(1);\n        vis[1] = 1;\n        dfs(1);\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/HDU1016-Prime-Ring-Problem-DFS.md","raw":"---\ntitle: HDU1016-Prime Ring Problem-DFS\ndate: 2018-08-12 23:16:27\ncategories:\n- ACM\ntags:\n- DFS\n---\n渐渐对深搜类的题有了自信, 虽然还只能做一些简单的题, 但是感觉还不错٩('ω')و .\n题目描述：由$1-n$这$n$个自然数组成一个环,要求任意相邻两数之和为素数, 按顺序输出这些数.\n<!-- more -->\n## 链接\n[HDU1016-Prime Ring Problem](http://acm.hdu.edu.cn/showproblem.php?pid=1016)\n## 原题\nA ring is compose of $n$ circles as shown in diagram. Put natural number $1, 2,...,n$ into each circle separately, and the sum of numbers in two adjacent circles should be a prime.\nNote: the number of first circle should always be 1.\n![example](/dfs.png)\n## 题解\nDFS遍历每一种情况.\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 12 Aug 22:10:25 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n;\nvector<int> vec;\nbool vis[maxn];\n\nvoid ans_print(){\n    int cnt = 1;\n    for(auto x : vec){\n        if(cnt == 1) cout << x;\n        else cout << \" \" << x;\n        cnt++;\n    }\n    cout << endl;\n}\n\nbool is_prime(int x){\n    if(x < 2) return false;\n    int tmp = sqrt(x);\n    for(int i = 2; i <= tmp; i++){\n        if(!(x % i)) return false;\n    }\n    return true;\n}\n\nvoid dfs(int dep){\n    if(dep == n - 1){\n        for(int i = 2; i <= n; i++){\n            if(!vis[i] && is_prime(i + vec[dep - 1]) && is_prime(i + 1)){\n                vec.push_back(i);\n                ans_print();\n                vec.pop_back();\n            }\n        }\n        return;\n    }\n    for(int i = 2; i <= n; i++){\n        if(!vis[i] && is_prime(i + vec[dep - 1])){\n            vec.push_back(i);\n            vis[i] = 1;\n            dfs(dep + 1);\n            vec.pop_back();\n            vis[i] = 0;\n        }\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    while(cin >> n){\n        vec.clear();\n        memset(vis, 0, sizeof(0));\n        printf(\"Case %d:\\n\", cnt++);\n        vec.push_back(1);\n        vis[1] = 1;\n        dfs(1);\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n","slug":"HDU1016-Prime-Ring-Problem-DFS","published":1,"updated":"2018-08-14T12:08:14.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1ys0001sxoulcf2w6vp","content":"<p>渐渐对深搜类的题有了自信, 虽然还只能做一些简单的题, 但是感觉还不错٩(‘ω’)و .<br>题目描述：由$1-n$这$n$个自然数组成一个环,要求任意相邻两数之和为素数, 按顺序输出这些数.<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1016\" target=\"_blank\" rel=\"noopener\">HDU1016-Prime Ring Problem</a></p>\n<h2 id=\"原题\"><a href=\"#原题\" class=\"headerlink\" title=\"原题\"></a>原题</h2><p>A ring is compose of $n$ circles as shown in diagram. Put natural number $1, 2,…,n$ into each circle separately, and the sum of numbers in two adjacent circles should be a prime.<br>Note: the number of first circle should always be 1.<br><img src=\"/2018/08/12/HDU1016-Prime-Ring-Problem-DFS/dfs.png\" alt=\"example\"></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>DFS遍历每一种情况.</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun 12 Aug 22:10:25 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ans_print</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : vec)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt == <span class=\"number\">1</span>) <span class=\"built_in\">cout</span> &lt;&lt; x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; x;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_prime</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"built_in\">sqrt</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= tmp; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(x % i)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep == n - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[i] &amp;&amp; is_prime(i + vec[dep - <span class=\"number\">1</span>]) &amp;&amp; is_prime(i + <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                vec.push_back(i);</span><br><span class=\"line\">                ans_print();</span><br><span class=\"line\">                vec.pop_back();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i] &amp;&amp; is_prime(i + vec[dep - <span class=\"number\">1</span>]))&#123;</span><br><span class=\"line\">            vec.push_back(i);</span><br><span class=\"line\">            vis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(dep + <span class=\"number\">1</span>);</span><br><span class=\"line\">            vec.pop_back();</span><br><span class=\"line\">            vis[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d:\\n\"</span>, cnt++);</span><br><span class=\"line\">        vec.push_back(<span class=\"number\">1</span>);</span><br><span class=\"line\">        vis[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dfs(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>渐渐对深搜类的题有了自信, 虽然还只能做一些简单的题, 但是感觉还不错٩(‘ω’)و .<br>题目描述：由$1-n$这$n$个自然数组成一个环,要求任意相邻两数之和为素数, 按顺序输出这些数.<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1016\" target=\"_blank\" rel=\"noopener\">HDU1016-Prime Ring Problem</a></p>\n<h2 id=\"原题\"><a href=\"#原题\" class=\"headerlink\" title=\"原题\"></a>原题</h2><p>A ring is compose of $n$ circles as shown in diagram. Put natural number $1, 2,…,n$ into each circle separately, and the sum of numbers in two adjacent circles should be a prime.<br>Note: the number of first circle should always be 1.<br><img src=\"/2018/08/12/HDU1016-Prime-Ring-Problem-DFS/dfs.png\" alt=\"example\"></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>DFS遍历每一种情况.</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun 12 Aug 22:10:25 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ans_print</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : vec)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt == <span class=\"number\">1</span>) <span class=\"built_in\">cout</span> &lt;&lt; x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; x;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_prime</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"built_in\">sqrt</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= tmp; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(x % i)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep == n - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[i] &amp;&amp; is_prime(i + vec[dep - <span class=\"number\">1</span>]) &amp;&amp; is_prime(i + <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                vec.push_back(i);</span><br><span class=\"line\">                ans_print();</span><br><span class=\"line\">                vec.pop_back();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i] &amp;&amp; is_prime(i + vec[dep - <span class=\"number\">1</span>]))&#123;</span><br><span class=\"line\">            vec.push_back(i);</span><br><span class=\"line\">            vis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(dep + <span class=\"number\">1</span>);</span><br><span class=\"line\">            vec.pop_back();</span><br><span class=\"line\">            vis[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d:\\n\"</span>, cnt++);</span><br><span class=\"line\">        vec.push_back(<span class=\"number\">1</span>);</span><br><span class=\"line\">        vis[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dfs(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Graph Theory-The shortest path","date":"2018-09-07T11:57:58.000Z","_content":"$Bellman-Ford、SPFA、Dijkstra$这些单源最短路算法自己一直都在用，但有时候只是需要的时候拿出来当板子敲上去，没有什么深刻的理解，今天花了一下午把这些算法的原理和一些细节基本搞通了，总结一下。\n<!--more-->\n$PS：Floyd-Warshall$多源最短路算法受限于自己对DP的理解，还没有完全搞明白= =，之后再来填坑。\n*Bellman-Ford代码、Dijkstra理解和代码部分参考自《挑战程序设计竞赛》。*\n## 限制和复杂度\n$Bellman-Ford$：不含负圈（可判断出）。运行时间：$O(|V|\\*|E|)$。\n$SPFA$：不含负圈（可判断出）。运行时间：$O(k\\*|E|)$，一般情况下$(k <<|V|)$，可以认为近似线性。\n$Dijkstra$：不含负权边。运行时间：$O(|E|\\*|log|V|)$（优先队列实现）\n## Bellman-Ford\n$Bellman-Ford$算法思想是更新所有的边，每条边都更新$|V|-1$次，由于多余的更新操作是无害的，所有算法可以求得最短路，但同时不可避免的有复杂度冗余的问题。\n先说一下为什么是更新$|V|-1$次：\n首先每一个节点$v$都有一条相对于起点$s$的最短路，因为最短路是简单路径不包含环（如果是负环，最短路不存在；如果是正环，去掉后变短；如果是零环，去掉后不变），所以节点总数为$|V|$的情况下最长的那条最短路的长度不会超过$|V|-1$，又因为每更新一次都必然会确定最短路径上的一条线段，所以最多只需要更新$|V|-1$次，反之，如果更新次数超过$|V|-1$次则说明图中有负环最短路不存在，可以利用这一点来判断图中是否有负环。\n关于“每更新一次都必然会确定最短路径上的一条线段“的进一步解释：\n![graph](/gra.png)\n以上图为例，假设上图中的最长的一条最短路为$A->F$的最短路\n![path](/path.png)\n从原点$A$开始出发，每次进行所有边的更新，第一次更新结束后$A->B$的最短路确定，第二次更新结束后$A->C$的最短路确定，以此类推四次后这条最长的最短路确定。因为这条最短路是最长的，所以在它确定时其它较短的最短路也肯定已经确定。所以在至多$|V|-1$次更新后$Bellman-Ford$算法可以找到任意一条最短路。\n\n$Bellman-Ford$代码：\n```C++\n//从顶点from指向顶点to的权值为cost的边\nstruct edge{\n    int from;\n    int to;\n    int cost;\n};\n\nedge es[MAX_E]; //边\n\nint d[MAX_V];   //最短距离\nint V, E;       //顶点数和边数\n\n//求解从顶点s出发到所有点的最短距离\nvoid short_path(int s){\n    fill(d, d + V, INF);\n    d[s] = 0;\n    while(true){\n        bool update = false;\n        for(int i = 0; i < E; i++){\n            edge e = es[i];\n            if(d[e.from] != INF && d[e.to] > d[e.from] + e.cost){\n                d[e.to] = d[e.from] + e.cost;\n                update = true;\n            }\n        }\n        if(!update) break;\n    }\n}\n```\n## SPFA\n$SPFA$算法可以用一句话概括：”只有被更新了的节点才有资格更新其它节点“。因为如果一个节点自身没有被更新的话，那用它更新与它相邻的其它节点也不会产生新的结果。它用队列来维护那些被更新了节点。值得注意的是虽然一般情况来说$SPFA$的复杂度接近线性，但它不稳定，可以构造出特殊的图使得SPFA的复杂度变为和$Bellman-Ford$一样。\n\n$SPFA$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\n\nvector<edge> G[MAX_V];  //邻接表\n\nint d[MAX_V];\nbool vis[MAX_V];\n\nvoid spfa(int s) \n{\n    queue<int> q;\n    memset(vis, 0, sizeof(vis));\n    fill(d, d + V, INF);\n    d[s] = 0;\n    q.push(s);\n    vis[s] = true;\n    while (!q.empty()) \n    {\n        int v = q.front(); \n        q.pop(); \n        vis[v] = false;\n        for(int i = 0; i < G[v].size(); i++)\n        {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) \n            {\n                d[e.to] = d[v] + e.cost;\n                if (!vis[e.to])\n                {\n                    vis[e.to] = true;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n}\n```\n## Dijkstra\n考虑没有负边的情况。在$Bellman-Ford$算法中，如果$d[i]$还不是最短距离的话，那么即使进行$d[j]=d[i]+l(i, j)$的更新，$d[j]$也不会变成最短距离。而且，即使$d[i]$没有变化，每一次循环也要检查一遍从$i$出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改：\n1. 找到最短距离已经确定的顶点，从它出发更新相邻的顶点的最短距离。\n2. 此后不需要再关心$1$中的”最短距离已经确定的顶点“。\n\n在$1$和$2$中提到的”最短距离已经确定的顶点“要怎么得到是问题的关键。在最开始时，只有起点的最短距离是确定的。而在尚未使用过的顶点中，距离$d[i]$最小的顶点就是已经确定的顶点。这是因为由于不存在负边，所以$d[i]$不会在之后的更新中变小。\n\n$Dijkstra$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s){\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d, d + V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;    //v点的距离已被更新为更小的值，队列中的值丢弃\n        for(int i = 0; i < G[v].size(); i++){\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost){\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n```\n","source":"_posts/Graph-Theory-The-shortest-path.md","raw":"---\ntitle: Graph Theory-The shortest path\ndate: 2018-09-07 19:57:58\ncategories:\n- ACM\ntags:\n- 图论\n---\n$Bellman-Ford、SPFA、Dijkstra$这些单源最短路算法自己一直都在用，但有时候只是需要的时候拿出来当板子敲上去，没有什么深刻的理解，今天花了一下午把这些算法的原理和一些细节基本搞通了，总结一下。\n<!--more-->\n$PS：Floyd-Warshall$多源最短路算法受限于自己对DP的理解，还没有完全搞明白= =，之后再来填坑。\n*Bellman-Ford代码、Dijkstra理解和代码部分参考自《挑战程序设计竞赛》。*\n## 限制和复杂度\n$Bellman-Ford$：不含负圈（可判断出）。运行时间：$O(|V|\\*|E|)$。\n$SPFA$：不含负圈（可判断出）。运行时间：$O(k\\*|E|)$，一般情况下$(k <<|V|)$，可以认为近似线性。\n$Dijkstra$：不含负权边。运行时间：$O(|E|\\*|log|V|)$（优先队列实现）\n## Bellman-Ford\n$Bellman-Ford$算法思想是更新所有的边，每条边都更新$|V|-1$次，由于多余的更新操作是无害的，所有算法可以求得最短路，但同时不可避免的有复杂度冗余的问题。\n先说一下为什么是更新$|V|-1$次：\n首先每一个节点$v$都有一条相对于起点$s$的最短路，因为最短路是简单路径不包含环（如果是负环，最短路不存在；如果是正环，去掉后变短；如果是零环，去掉后不变），所以节点总数为$|V|$的情况下最长的那条最短路的长度不会超过$|V|-1$，又因为每更新一次都必然会确定最短路径上的一条线段，所以最多只需要更新$|V|-1$次，反之，如果更新次数超过$|V|-1$次则说明图中有负环最短路不存在，可以利用这一点来判断图中是否有负环。\n关于“每更新一次都必然会确定最短路径上的一条线段“的进一步解释：\n![graph](/gra.png)\n以上图为例，假设上图中的最长的一条最短路为$A->F$的最短路\n![path](/path.png)\n从原点$A$开始出发，每次进行所有边的更新，第一次更新结束后$A->B$的最短路确定，第二次更新结束后$A->C$的最短路确定，以此类推四次后这条最长的最短路确定。因为这条最短路是最长的，所以在它确定时其它较短的最短路也肯定已经确定。所以在至多$|V|-1$次更新后$Bellman-Ford$算法可以找到任意一条最短路。\n\n$Bellman-Ford$代码：\n```C++\n//从顶点from指向顶点to的权值为cost的边\nstruct edge{\n    int from;\n    int to;\n    int cost;\n};\n\nedge es[MAX_E]; //边\n\nint d[MAX_V];   //最短距离\nint V, E;       //顶点数和边数\n\n//求解从顶点s出发到所有点的最短距离\nvoid short_path(int s){\n    fill(d, d + V, INF);\n    d[s] = 0;\n    while(true){\n        bool update = false;\n        for(int i = 0; i < E; i++){\n            edge e = es[i];\n            if(d[e.from] != INF && d[e.to] > d[e.from] + e.cost){\n                d[e.to] = d[e.from] + e.cost;\n                update = true;\n            }\n        }\n        if(!update) break;\n    }\n}\n```\n## SPFA\n$SPFA$算法可以用一句话概括：”只有被更新了的节点才有资格更新其它节点“。因为如果一个节点自身没有被更新的话，那用它更新与它相邻的其它节点也不会产生新的结果。它用队列来维护那些被更新了节点。值得注意的是虽然一般情况来说$SPFA$的复杂度接近线性，但它不稳定，可以构造出特殊的图使得SPFA的复杂度变为和$Bellman-Ford$一样。\n\n$SPFA$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\n\nvector<edge> G[MAX_V];  //邻接表\n\nint d[MAX_V];\nbool vis[MAX_V];\n\nvoid spfa(int s) \n{\n    queue<int> q;\n    memset(vis, 0, sizeof(vis));\n    fill(d, d + V, INF);\n    d[s] = 0;\n    q.push(s);\n    vis[s] = true;\n    while (!q.empty()) \n    {\n        int v = q.front(); \n        q.pop(); \n        vis[v] = false;\n        for(int i = 0; i < G[v].size(); i++)\n        {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) \n            {\n                d[e.to] = d[v] + e.cost;\n                if (!vis[e.to])\n                {\n                    vis[e.to] = true;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n}\n```\n## Dijkstra\n考虑没有负边的情况。在$Bellman-Ford$算法中，如果$d[i]$还不是最短距离的话，那么即使进行$d[j]=d[i]+l(i, j)$的更新，$d[j]$也不会变成最短距离。而且，即使$d[i]$没有变化，每一次循环也要检查一遍从$i$出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改：\n1. 找到最短距离已经确定的顶点，从它出发更新相邻的顶点的最短距离。\n2. 此后不需要再关心$1$中的”最短距离已经确定的顶点“。\n\n在$1$和$2$中提到的”最短距离已经确定的顶点“要怎么得到是问题的关键。在最开始时，只有起点的最短距离是确定的。而在尚未使用过的顶点中，距离$d[i]$最小的顶点就是已经确定的顶点。这是因为由于不存在负边，所以$d[i]$不会在之后的更新中变小。\n\n$Dijkstra$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s){\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d, d + V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;    //v点的距离已被更新为更小的值，队列中的值丢弃\n        for(int i = 0; i < G[v].size(); i++){\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost){\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n```\n","slug":"Graph-Theory-The-shortest-path","published":1,"updated":"2018-09-08T09:28:27.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1yx0004sxouik4mb6vw","content":"<p>$Bellman-Ford、SPFA、Dijkstra$这些单源最短路算法自己一直都在用，但有时候只是需要的时候拿出来当板子敲上去，没有什么深刻的理解，今天花了一下午把这些算法的原理和一些细节基本搞通了，总结一下。<br><a id=\"more\"></a><br>$PS：Floyd-Warshall$多源最短路算法受限于自己对DP的理解，还没有完全搞明白= =，之后再来填坑。<br><em>Bellman-Ford代码、Dijkstra理解和代码部分参考自《挑战程序设计竞赛》。</em></p>\n<h2 id=\"限制和复杂度\"><a href=\"#限制和复杂度\" class=\"headerlink\" title=\"限制和复杂度\"></a>限制和复杂度</h2><p>$Bellman-Ford$：不含负圈（可判断出）。运行时间：$O(|V|*|E|)$。<br>$SPFA$：不含负圈（可判断出）。运行时间：$O(k*|E|)$，一般情况下$(k &lt;&lt;|V|)$，可以认为近似线性。<br>$Dijkstra$：不含负权边。运行时间：$O(|E|*|log|V|)$（优先队列实现）</p>\n<h2 id=\"Bellman-Ford\"><a href=\"#Bellman-Ford\" class=\"headerlink\" title=\"Bellman-Ford\"></a>Bellman-Ford</h2><p>$Bellman-Ford$算法思想是更新所有的边，每条边都更新$|V|-1$次，由于多余的更新操作是无害的，所有算法可以求得最短路，但同时不可避免的有复杂度冗余的问题。<br>先说一下为什么是更新$|V|-1$次：<br>首先每一个节点$v$都有一条相对于起点$s$的最短路，因为最短路是简单路径不包含环（如果是负环，最短路不存在；如果是正环，去掉后变短；如果是零环，去掉后不变），所以节点总数为$|V|$的情况下最长的那条最短路的长度不会超过$|V|-1$，又因为每更新一次都必然会确定最短路径上的一条线段，所以最多只需要更新$|V|-1$次，反之，如果更新次数超过$|V|-1$次则说明图中有负环最短路不存在，可以利用这一点来判断图中是否有负环。<br>关于“每更新一次都必然会确定最短路径上的一条线段“的进一步解释：<br><img src=\"/2018/09/07/Graph-Theory-The-shortest-path/gra.png\" alt=\"graph\"><br>以上图为例，假设上图中的最长的一条最短路为$A-&gt;F$的最短路<br><img src=\"/2018/09/07/Graph-Theory-The-shortest-path/path.png\" alt=\"path\"><br>从原点$A$开始出发，每次进行所有边的更新，第一次更新结束后$A-&gt;B$的最短路确定，第二次更新结束后$A-&gt;C$的最短路确定，以此类推四次后这条最长的最短路确定。因为这条最短路是最长的，所以在它确定时其它较短的最短路也肯定已经确定。所以在至多$|V|-1$次更新后$Bellman-Ford$算法可以找到任意一条最短路。</p>\n<p>$Bellman-Ford$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从顶点from指向顶点to的权值为cost的边</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">edge es[MAX_E]; <span class=\"comment\">//边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];   <span class=\"comment\">//最短距离</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> V, E;       <span class=\"comment\">//顶点数和边数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求解从顶点s出发到所有点的最短距离</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">short_path</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span></span>&#123;</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> update = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; E; i++)&#123;</span><br><span class=\"line\">            edge e = es[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[e.from] != INF &amp;&amp; d[e.to] &gt; d[e.from] + e.cost)&#123;</span><br><span class=\"line\">                d[e.to] = d[e.from] + e.cost;</span><br><span class=\"line\">                update = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!update) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"SPFA\"><a href=\"#SPFA\" class=\"headerlink\" title=\"SPFA\"></a>SPFA</h2><p>$SPFA$算法可以用一句话概括：”只有被更新了的节点才有资格更新其它节点“。因为如果一个节点自身没有被更新的话，那用它更新与它相邻的其它节点也不会产生新的结果。它用队列来维护那些被更新了节点。值得注意的是虽然一般情况来说$SPFA$的复杂度接近线性，但它不稳定，可以构造出特殊的图使得SPFA的复杂度变为和$Bellman-Ford$一样。</p>\n<p>$SPFA$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;edge&gt; G[MAX_V];  <span class=\"comment\">//邻接表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[MAX_V];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    q.push(s);</span><br><span class=\"line\">    vis[s] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = q.front(); </span><br><span class=\"line\">        q.pop(); </span><br><span class=\"line\">        vis[v] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[v].size(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            edge e = G[v][i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (d[e.to] &gt; d[v] + e.cost) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                d[e.to] = d[v] + e.cost;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!vis[e.to])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    vis[e.to] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    q.push(e.to);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra\"></a>Dijkstra</h2><p>考虑没有负边的情况。在$Bellman-Ford$算法中，如果$d[i]$还不是最短距离的话，那么即使进行$d[j]=d[i]+l(i, j)$的更新，$d[j]$也不会变成最短距离。而且，即使$d[i]$没有变化，每一次循环也要检查一遍从$i$出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改：</p>\n<ol>\n<li>找到最短距离已经确定的顶点，从它出发更新相邻的顶点的最短距离。</li>\n<li>此后不需要再关心$1$中的”最短距离已经确定的顶点“。</li>\n</ol>\n<p>在$1$和$2$中提到的”最短距离已经确定的顶点“要怎么得到是问题的关键。在最开始时，只有起点的最短距离是确定的。而在尚未使用过的顶点中，距离$d[i]$最小的顶点就是已经确定的顶点。这是因为由于不存在负边，所以$d[i]$不会在之后的更新中变小。</p>\n<p>$Dijkstra$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> V;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;edge&gt; G[MAX_V];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;P, <span class=\"built_in\">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    que.push(P(<span class=\"number\">0</span>, s));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        P p = que.top();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = p.second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[v] &lt; p.first) <span class=\"keyword\">continue</span>;    <span class=\"comment\">//v点的距离已被更新为更小的值，队列中的值丢弃</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class=\"line\">            edge e = G[v][i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[e.to] &gt; d[v] + e.cost)&#123;</span><br><span class=\"line\">                d[e.to] = d[v] + e.cost;</span><br><span class=\"line\">                que.push(P(d[e.to], e.to));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>$Bellman-Ford、SPFA、Dijkstra$这些单源最短路算法自己一直都在用，但有时候只是需要的时候拿出来当板子敲上去，没有什么深刻的理解，今天花了一下午把这些算法的原理和一些细节基本搞通了，总结一下。<br></p>","more":"<br>$PS：Floyd-Warshall$多源最短路算法受限于自己对DP的理解，还没有完全搞明白= =，之后再来填坑。<br><em>Bellman-Ford代码、Dijkstra理解和代码部分参考自《挑战程序设计竞赛》。</em><p></p>\n<h2 id=\"限制和复杂度\"><a href=\"#限制和复杂度\" class=\"headerlink\" title=\"限制和复杂度\"></a>限制和复杂度</h2><p>$Bellman-Ford$：不含负圈（可判断出）。运行时间：$O(|V|*|E|)$。<br>$SPFA$：不含负圈（可判断出）。运行时间：$O(k*|E|)$，一般情况下$(k &lt;&lt;|V|)$，可以认为近似线性。<br>$Dijkstra$：不含负权边。运行时间：$O(|E|*|log|V|)$（优先队列实现）</p>\n<h2 id=\"Bellman-Ford\"><a href=\"#Bellman-Ford\" class=\"headerlink\" title=\"Bellman-Ford\"></a>Bellman-Ford</h2><p>$Bellman-Ford$算法思想是更新所有的边，每条边都更新$|V|-1$次，由于多余的更新操作是无害的，所有算法可以求得最短路，但同时不可避免的有复杂度冗余的问题。<br>先说一下为什么是更新$|V|-1$次：<br>首先每一个节点$v$都有一条相对于起点$s$的最短路，因为最短路是简单路径不包含环（如果是负环，最短路不存在；如果是正环，去掉后变短；如果是零环，去掉后不变），所以节点总数为$|V|$的情况下最长的那条最短路的长度不会超过$|V|-1$，又因为每更新一次都必然会确定最短路径上的一条线段，所以最多只需要更新$|V|-1$次，反之，如果更新次数超过$|V|-1$次则说明图中有负环最短路不存在，可以利用这一点来判断图中是否有负环。<br>关于“每更新一次都必然会确定最短路径上的一条线段“的进一步解释：<br><img src=\"/2018/09/07/Graph-Theory-The-shortest-path/gra.png\" alt=\"graph\"><br>以上图为例，假设上图中的最长的一条最短路为$A-&gt;F$的最短路<br><img src=\"/2018/09/07/Graph-Theory-The-shortest-path/path.png\" alt=\"path\"><br>从原点$A$开始出发，每次进行所有边的更新，第一次更新结束后$A-&gt;B$的最短路确定，第二次更新结束后$A-&gt;C$的最短路确定，以此类推四次后这条最长的最短路确定。因为这条最短路是最长的，所以在它确定时其它较短的最短路也肯定已经确定。所以在至多$|V|-1$次更新后$Bellman-Ford$算法可以找到任意一条最短路。</p>\n<p>$Bellman-Ford$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从顶点from指向顶点to的权值为cost的边</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">edge es[MAX_E]; <span class=\"comment\">//边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];   <span class=\"comment\">//最短距离</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> V, E;       <span class=\"comment\">//顶点数和边数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求解从顶点s出发到所有点的最短距离</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">short_path</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span></span>&#123;</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> update = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; E; i++)&#123;</span><br><span class=\"line\">            edge e = es[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[e.from] != INF &amp;&amp; d[e.to] &gt; d[e.from] + e.cost)&#123;</span><br><span class=\"line\">                d[e.to] = d[e.from] + e.cost;</span><br><span class=\"line\">                update = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!update) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"SPFA\"><a href=\"#SPFA\" class=\"headerlink\" title=\"SPFA\"></a>SPFA</h2><p>$SPFA$算法可以用一句话概括：”只有被更新了的节点才有资格更新其它节点“。因为如果一个节点自身没有被更新的话，那用它更新与它相邻的其它节点也不会产生新的结果。它用队列来维护那些被更新了节点。值得注意的是虽然一般情况来说$SPFA$的复杂度接近线性，但它不稳定，可以构造出特殊的图使得SPFA的复杂度变为和$Bellman-Ford$一样。</p>\n<p>$SPFA$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;edge&gt; G[MAX_V];  <span class=\"comment\">//邻接表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[MAX_V];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    q.push(s);</span><br><span class=\"line\">    vis[s] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = q.front(); </span><br><span class=\"line\">        q.pop(); </span><br><span class=\"line\">        vis[v] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[v].size(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            edge e = G[v][i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (d[e.to] &gt; d[v] + e.cost) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                d[e.to] = d[v] + e.cost;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!vis[e.to])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    vis[e.to] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    q.push(e.to);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra\"></a>Dijkstra</h2><p>考虑没有负边的情况。在$Bellman-Ford$算法中，如果$d[i]$还不是最短距离的话，那么即使进行$d[j]=d[i]+l(i, j)$的更新，$d[j]$也不会变成最短距离。而且，即使$d[i]$没有变化，每一次循环也要检查一遍从$i$出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改：</p>\n<ol>\n<li>找到最短距离已经确定的顶点，从它出发更新相邻的顶点的最短距离。</li>\n<li>此后不需要再关心$1$中的”最短距离已经确定的顶点“。</li>\n</ol>\n<p>在$1$和$2$中提到的”最短距离已经确定的顶点“要怎么得到是问题的关键。在最开始时，只有起点的最短距离是确定的。而在尚未使用过的顶点中，距离$d[i]$最小的顶点就是已经确定的顶点。这是因为由于不存在负边，所以$d[i]$不会在之后的更新中变小。</p>\n<p>$Dijkstra$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> V;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;edge&gt; G[MAX_V];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;P, <span class=\"built_in\">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    que.push(P(<span class=\"number\">0</span>, s));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        P p = que.top();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = p.second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[v] &lt; p.first) <span class=\"keyword\">continue</span>;    <span class=\"comment\">//v点的距离已被更新为更小的值，队列中的值丢弃</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class=\"line\">            edge e = G[v][i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[e.to] &gt; d[v] + e.cost)&#123;</span><br><span class=\"line\">                d[e.to] = d[v] + e.cost;</span><br><span class=\"line\">                que.push(P(d[e.to], e.to));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"HDU2050-线切割平面问题-思维+简单dp","date":"2018-04-09T02:42:54.000Z","_content":"和队友一块做这道题，队友们几乎秒杀，而自己想了很久也没有推导出一个清晰的规律...看了[vinacky的线切割平面问题](https://blog.csdn.net/vinacky/article/details/8958326)这篇博客后才豁然开朗,个人感觉一道很好的思维题。\n题目描述就是求n条折线可以分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成七部分。\n![example](/line.jpg)\n<!-- more -->\n## 链接\n[HDU2050](http://acm.hdu.edu.cn/showproblem.php?pid=2050)\n## 题解\n### 直线切割平面\n首先考虑向平面添加直线(简化思维)后的平面分割情况：\n(下面假设新添加的直线与已有直线均相交)\n当平面上没有直线时，有一个平面；\n有１条直线时，没有节点，多出１部分，共２个平面；\n有２条直线时，多了１个节点，多出２部分，共４个平面；\n有３条直线时，多了２个节点，多出３部分，共７个平面；\n...\n至此我们便可以直观的思考一下是什么导致了平面的分割，当添加第i条直线时，因为我们总可以使它和前i-1条直线都相交，所以共有i-1个交点，也即第i条直线被分割成了i段，对每一段来说，它都将自己所在的平面重新分割为两部分。所以添加了第i条直线后，最多可以重新多分割出i个平面。\n所以原始的１个平面,\n添加１条直线后平面数为1+1;\n添加２条直线后平面数为1+1+2;\n添加３条直线后平面数为1+1+2+3；\n...\n得到添加n条直线后的平面数公式：$res = 1 + 1 + 2 + 3 + ... + n = \\frac{n(n+1)}{2} + 1$\n### V型折线切割平面\nV型折线切割平面可以看做同时添加了两条相交直线，但是稍有不同的是，这两条直线的交点有一侧平面合并了,因此而产生的影响是减少了两个平面。\n\n我们仍然可以保证添加的折线与其他折线均有交点，所以添加第i条V型折线时，增加的平面数为：$2\\*i - 1 + 2\\*i - 2$\n得到添加n条折线后的平面数公式：$$res = 1 + (1 + 2) + (3 + 4) + ... + (2n - 1 + 2n) = \\frac{2n(2n + 1)}{2} + 1 - 2n$$\n于是可以公式直接求解，也可以dp求解\n## 代码\n下面给出dp求解代码\n``` C++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nconst int maxn = 1e4 + 7;\nint n;\nlong long dp[maxn] = {1, 2, 7};\n\nint main(){\n    int c;\n    scanf(\"%d\", &c);\n    while(c--){\n    scanf(\"%d\", &n);\n        for(int i = 3; i <= n; i++){\n            dp[i] = dp[i - 1] + ２ * i - 1 + 2 * i - 2;\n        }\n        printf(\"%lld\\n\", dp[n]);\n        \n    }\n    return 0;\n\n}\n```","source":"_posts/HDU2050.md","raw":"---\ntitle: HDU2050-线切割平面问题-思维+简单dp\ndate: 2018-04-09 10:42:54\ncategories:\n- ACM\ntags:\n- HDU\n- 线切割平面\n- math\n- 思维\n---\n和队友一块做这道题，队友们几乎秒杀，而自己想了很久也没有推导出一个清晰的规律...看了[vinacky的线切割平面问题](https://blog.csdn.net/vinacky/article/details/8958326)这篇博客后才豁然开朗,个人感觉一道很好的思维题。\n题目描述就是求n条折线可以分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成七部分。\n![example](/line.jpg)\n<!-- more -->\n## 链接\n[HDU2050](http://acm.hdu.edu.cn/showproblem.php?pid=2050)\n## 题解\n### 直线切割平面\n首先考虑向平面添加直线(简化思维)后的平面分割情况：\n(下面假设新添加的直线与已有直线均相交)\n当平面上没有直线时，有一个平面；\n有１条直线时，没有节点，多出１部分，共２个平面；\n有２条直线时，多了１个节点，多出２部分，共４个平面；\n有３条直线时，多了２个节点，多出３部分，共７个平面；\n...\n至此我们便可以直观的思考一下是什么导致了平面的分割，当添加第i条直线时，因为我们总可以使它和前i-1条直线都相交，所以共有i-1个交点，也即第i条直线被分割成了i段，对每一段来说，它都将自己所在的平面重新分割为两部分。所以添加了第i条直线后，最多可以重新多分割出i个平面。\n所以原始的１个平面,\n添加１条直线后平面数为1+1;\n添加２条直线后平面数为1+1+2;\n添加３条直线后平面数为1+1+2+3；\n...\n得到添加n条直线后的平面数公式：$res = 1 + 1 + 2 + 3 + ... + n = \\frac{n(n+1)}{2} + 1$\n### V型折线切割平面\nV型折线切割平面可以看做同时添加了两条相交直线，但是稍有不同的是，这两条直线的交点有一侧平面合并了,因此而产生的影响是减少了两个平面。\n\n我们仍然可以保证添加的折线与其他折线均有交点，所以添加第i条V型折线时，增加的平面数为：$2\\*i - 1 + 2\\*i - 2$\n得到添加n条折线后的平面数公式：$$res = 1 + (1 + 2) + (3 + 4) + ... + (2n - 1 + 2n) = \\frac{2n(2n + 1)}{2} + 1 - 2n$$\n于是可以公式直接求解，也可以dp求解\n## 代码\n下面给出dp求解代码\n``` C++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nconst int maxn = 1e4 + 7;\nint n;\nlong long dp[maxn] = {1, 2, 7};\n\nint main(){\n    int c;\n    scanf(\"%d\", &c);\n    while(c--){\n    scanf(\"%d\", &n);\n        for(int i = 3; i <= n; i++){\n            dp[i] = dp[i - 1] + ２ * i - 1 + 2 * i - 2;\n        }\n        printf(\"%lld\\n\", dp[n]);\n        \n    }\n    return 0;\n\n}\n```","slug":"HDU2050","published":1,"updated":"2018-08-14T12:09:18.557Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1yy0005sxou4sv4tbrv","content":"<p>和队友一块做这道题，队友们几乎秒杀，而自己想了很久也没有推导出一个清晰的规律…看了<a href=\"https://blog.csdn.net/vinacky/article/details/8958326\" target=\"_blank\" rel=\"noopener\">vinacky的线切割平面问题</a>这篇博客后才豁然开朗,个人感觉一道很好的思维题。<br>题目描述就是求n条折线可以分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成七部分。<br><img src=\"/2018/04/09/HDU2050/line.jpg\" alt=\"example\"><br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2050\" target=\"_blank\" rel=\"noopener\">HDU2050</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><h3 id=\"直线切割平面\"><a href=\"#直线切割平面\" class=\"headerlink\" title=\"直线切割平面\"></a>直线切割平面</h3><p>首先考虑向平面添加直线(简化思维)后的平面分割情况：<br>(下面假设新添加的直线与已有直线均相交)<br>当平面上没有直线时，有一个平面；<br>有１条直线时，没有节点，多出１部分，共２个平面；<br>有２条直线时，多了１个节点，多出２部分，共４个平面；<br>有３条直线时，多了２个节点，多出３部分，共７个平面；<br>…<br>至此我们便可以直观的思考一下是什么导致了平面的分割，当添加第i条直线时，因为我们总可以使它和前i-1条直线都相交，所以共有i-1个交点，也即第i条直线被分割成了i段，对每一段来说，它都将自己所在的平面重新分割为两部分。所以添加了第i条直线后，最多可以重新多分割出i个平面。<br>所以原始的１个平面,<br>添加１条直线后平面数为1+1;<br>添加２条直线后平面数为1+1+2;<br>添加３条直线后平面数为1+1+2+3；<br>…<br>得到添加n条直线后的平面数公式：$res = 1 + 1 + 2 + 3 + … + n = \\frac{n(n+1)}{2} + 1$</p>\n<h3 id=\"V型折线切割平面\"><a href=\"#V型折线切割平面\" class=\"headerlink\" title=\"V型折线切割平面\"></a>V型折线切割平面</h3><p>V型折线切割平面可以看做同时添加了两条相交直线，但是稍有不同的是，这两条直线的交点有一侧平面合并了,因此而产生的影响是减少了两个平面。</p>\n<p>我们仍然可以保证添加的折线与其他折线均有交点，所以添加第i条V型折线时，增加的平面数为：$2*i - 1 + 2*i - 2$<br>得到添加n条折线后的平面数公式：$$res = 1 + (1 + 2) + (3 + 4) + … + (2n - 1 + 2n) = \\frac{2n(2n + 1)}{2} + 1 - 2n$$<br>于是可以公式直接求解，也可以dp求解</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>下面给出dp求解代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e4</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[maxn] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;c);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c--)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + ２ * i - <span class=\"number\">1</span> + <span class=\"number\">2</span> * i - <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, dp[n]);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>和队友一块做这道题，队友们几乎秒杀，而自己想了很久也没有推导出一个清晰的规律…看了<a href=\"https://blog.csdn.net/vinacky/article/details/8958326\" target=\"_blank\" rel=\"noopener\">vinacky的线切割平面问题</a>这篇博客后才豁然开朗,个人感觉一道很好的思维题。<br>题目描述就是求n条折线可以分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成七部分。<br><img src=\"/2018/04/09/HDU2050/line.jpg\" alt=\"example\"><br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2050\" target=\"_blank\" rel=\"noopener\">HDU2050</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><h3 id=\"直线切割平面\"><a href=\"#直线切割平面\" class=\"headerlink\" title=\"直线切割平面\"></a>直线切割平面</h3><p>首先考虑向平面添加直线(简化思维)后的平面分割情况：<br>(下面假设新添加的直线与已有直线均相交)<br>当平面上没有直线时，有一个平面；<br>有１条直线时，没有节点，多出１部分，共２个平面；<br>有２条直线时，多了１个节点，多出２部分，共４个平面；<br>有３条直线时，多了２个节点，多出３部分，共７个平面；<br>…<br>至此我们便可以直观的思考一下是什么导致了平面的分割，当添加第i条直线时，因为我们总可以使它和前i-1条直线都相交，所以共有i-1个交点，也即第i条直线被分割成了i段，对每一段来说，它都将自己所在的平面重新分割为两部分。所以添加了第i条直线后，最多可以重新多分割出i个平面。<br>所以原始的１个平面,<br>添加１条直线后平面数为1+1;<br>添加２条直线后平面数为1+1+2;<br>添加３条直线后平面数为1+1+2+3；<br>…<br>得到添加n条直线后的平面数公式：$res = 1 + 1 + 2 + 3 + … + n = \\frac{n(n+1)}{2} + 1$</p>\n<h3 id=\"V型折线切割平面\"><a href=\"#V型折线切割平面\" class=\"headerlink\" title=\"V型折线切割平面\"></a>V型折线切割平面</h3><p>V型折线切割平面可以看做同时添加了两条相交直线，但是稍有不同的是，这两条直线的交点有一侧平面合并了,因此而产生的影响是减少了两个平面。</p>\n<p>我们仍然可以保证添加的折线与其他折线均有交点，所以添加第i条V型折线时，增加的平面数为：$2*i - 1 + 2*i - 2$<br>得到添加n条折线后的平面数公式：$$res = 1 + (1 + 2) + (3 + 4) + … + (2n - 1 + 2n) = \\frac{2n(2n + 1)}{2} + 1 - 2n$$<br>于是可以公式直接求解，也可以dp求解</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>下面给出dp求解代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e4</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[maxn] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;c);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c--)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + ２ * i - <span class=\"number\">1</span> + <span class=\"number\">2</span> * i - <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, dp[n]);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"HDU4856-Tunnels-BFS+状态压缩DP","date":"2018-05-16T06:03:19.000Z","_content":"最近的几场训练赛做题的时候发现自己对搜索类、动态规划类的题有些恐惧，导致这些类型的题比赛时基本做不出来。仔细想了一下，是自己的递归部分理解的就不够透彻，导致搜索写不出来，动态规划就更无从下手。之前也找了很多递归理解的文章去看，也做了一些递归的题，但是效果不佳。意识到网上的资料对于递归的理解一般会拿经典的斐波那契数列或汉诺塔来举例，这对于递归的理解确实是有帮助的，但是对于锻炼搜索思维的效果不是太有效，于是决定先恶补一部分搜索类的题。\n这道题是准备西安邀请赛时打的模拟赛做到的题，知识点主要用到了BFS和状态压缩DP，可以当做旅行商问题来做，但是最后不返回起点。由于自己DP比较差，所以搞懂这道题还是花了挺长时间。状态压缩DP部分的实现代码参考大白。\n\nPs：在最后会贴几个自己觉得看到的对递归和动态规划理解比较有帮助的文章链接。\n<!-- more -->\n## 题目链接\n[HDU4856-Tunnels](http://acm.hdu.edu.cn/showproblem.php?pid=4856)\n## 题目描述\n一张城市网格图，城市中有m条快速通道，可以从图中任意位置出发，求访问完所有快速通道所用的最少时间，忽略在快速通道内的时间。\n## 题解\n因为在快速通道内的时间是不计的所以只要到达了一个快速通道的入口就相当于访问完了这一条通道，所以可以构造一张$m×m$的邻接表，其中$d[i][j]$表示从第$i$个通道的出口到第$j$个通道的入口的距离，这一部分直接用BFS就能实现，接下来就可以用旅行商问题的解法求解不重复的访问完所有通道所用的时间。\n有两个与旅行商问题不同需要注意的地方：\n**最后不返回起点**\n**起点位置任意，也就是可以将任意一个通道的入口作为起点**\n解决方法详见代码。\n##代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 18;\nconst int maxm = 18;\nconst int inf = 0x3f3f3f3f;\nchar mp[maxn][maxn];\ntypedef pair<int, int> P;\nP in[maxm];\nP out[maxm];\nint n, m;\nint d[maxn][maxn];\nint sx, sy;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint dis[maxm][maxm];\nint dp[1 <<  maxm][maxm];\n\n//状态压缩DP\nvoid dpsolve(){\n    for(int S = 0; S < 1 << m; S++){\n        fill(dp[S], dp[S] + m, inf);\n    }\n    for(int i = 0; i < m; i++){\n        dp[(1 << m) - 1][i] = 0;//因为起点未定，所以终点在任意一个通道都可以\n    }\n    for(int S = (1 << m) - 2; S >= 0; S--){\n        for(int v = 0; v < m; v++){\n            for(int u = 0; u < m; u++){\n                if(!(S >> u & 1)){\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + dis[v][u]);\n                }\n            }\n        }\n    }\n    int res = inf;\n    for(int i = 0; i < m; i++){\n        res = min(res, dp[1 << i][i]);//判断以不同通道为起点的情况下，哪种用时最短\n    }\n    if(res == inf) printf(\"%d\\n\", -1);\n    else printf(\"%d\\n\", res);\n}\n\n//bfs搜索确定两两通道之间最小距离\nvoid bfs(int sx, int sy){\n    queue<P> que;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            d[i][j] = inf;\n        }\n    }\n    d[sx][sy] = 0;\n    que.push(P(sx, sy));\n\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < n && mp[nx][ny] != '#' && d[nx][ny] == inf){\n\n                d[nx][ny] = d[p.first][p.second] + 1;\n                que.push(P(nx, ny));\n            }\n        }\n\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif // ONLINE_JUDGE\n    while(~scanf(\"%d%d\", &n, &m)){\n        for(int i = 0; i < n; i++){\n            scanf(\"%s\", mp[i]);\n        }\n        for(int i = 0; i < m; i++){\n            scanf(\"%d%d%d%d\", &in[i].first, &in[i].second, &out[i].first, &out[i].second);\n        }\n        //构建邻接表\n        for(int i = 0; i < m; i++){\n            bfs(out[i].first - 1, out[i].second - 1);\n            for(int j = 0; j < m; j++){\n                if(i == j) dis[i][j] = 0;\n                else dis[i][j] = d[in[j].first - 1][in[j].second - 1];\n            }\n        }\n\n        dpsolve();\n    }\n    return 0;\n}\n```\n## 关于递归、动态规划理解的文章链接\n[写递归函数的正确思维方法](https://blog.csdn.net/vagrxie/article/details/8470798)\n[递归算法详解](https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/)\n[怎么更好地终极理解递归算法](https://blog.csdn.net/StruggleShu/article/details/51051140)\n[如何有效地理解程序中的递归](https://blog.csdn.net/qq_34773981/article/details/79225588)\n\n[一道题看清动态规划的前世今生（一）](http://www.importnew.com/27323.html)\n[一道题看清动态规划的前世今生（二）](http://www.importnew.com/27444.html)\n\n最后对这些文章的博主表示感谢！\n","source":"_posts/HDU4856-Tunnels.md","raw":"---\ntitle: HDU4856-Tunnels-BFS+状态压缩DP\ndate: 2018-05-16 14:03:19\ncategories:\n- ACM\ntags:\n- HDU\n- 状态压缩DP\n- BFS\n---\n最近的几场训练赛做题的时候发现自己对搜索类、动态规划类的题有些恐惧，导致这些类型的题比赛时基本做不出来。仔细想了一下，是自己的递归部分理解的就不够透彻，导致搜索写不出来，动态规划就更无从下手。之前也找了很多递归理解的文章去看，也做了一些递归的题，但是效果不佳。意识到网上的资料对于递归的理解一般会拿经典的斐波那契数列或汉诺塔来举例，这对于递归的理解确实是有帮助的，但是对于锻炼搜索思维的效果不是太有效，于是决定先恶补一部分搜索类的题。\n这道题是准备西安邀请赛时打的模拟赛做到的题，知识点主要用到了BFS和状态压缩DP，可以当做旅行商问题来做，但是最后不返回起点。由于自己DP比较差，所以搞懂这道题还是花了挺长时间。状态压缩DP部分的实现代码参考大白。\n\nPs：在最后会贴几个自己觉得看到的对递归和动态规划理解比较有帮助的文章链接。\n<!-- more -->\n## 题目链接\n[HDU4856-Tunnels](http://acm.hdu.edu.cn/showproblem.php?pid=4856)\n## 题目描述\n一张城市网格图，城市中有m条快速通道，可以从图中任意位置出发，求访问完所有快速通道所用的最少时间，忽略在快速通道内的时间。\n## 题解\n因为在快速通道内的时间是不计的所以只要到达了一个快速通道的入口就相当于访问完了这一条通道，所以可以构造一张$m×m$的邻接表，其中$d[i][j]$表示从第$i$个通道的出口到第$j$个通道的入口的距离，这一部分直接用BFS就能实现，接下来就可以用旅行商问题的解法求解不重复的访问完所有通道所用的时间。\n有两个与旅行商问题不同需要注意的地方：\n**最后不返回起点**\n**起点位置任意，也就是可以将任意一个通道的入口作为起点**\n解决方法详见代码。\n##代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 18;\nconst int maxm = 18;\nconst int inf = 0x3f3f3f3f;\nchar mp[maxn][maxn];\ntypedef pair<int, int> P;\nP in[maxm];\nP out[maxm];\nint n, m;\nint d[maxn][maxn];\nint sx, sy;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint dis[maxm][maxm];\nint dp[1 <<  maxm][maxm];\n\n//状态压缩DP\nvoid dpsolve(){\n    for(int S = 0; S < 1 << m; S++){\n        fill(dp[S], dp[S] + m, inf);\n    }\n    for(int i = 0; i < m; i++){\n        dp[(1 << m) - 1][i] = 0;//因为起点未定，所以终点在任意一个通道都可以\n    }\n    for(int S = (1 << m) - 2; S >= 0; S--){\n        for(int v = 0; v < m; v++){\n            for(int u = 0; u < m; u++){\n                if(!(S >> u & 1)){\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + dis[v][u]);\n                }\n            }\n        }\n    }\n    int res = inf;\n    for(int i = 0; i < m; i++){\n        res = min(res, dp[1 << i][i]);//判断以不同通道为起点的情况下，哪种用时最短\n    }\n    if(res == inf) printf(\"%d\\n\", -1);\n    else printf(\"%d\\n\", res);\n}\n\n//bfs搜索确定两两通道之间最小距离\nvoid bfs(int sx, int sy){\n    queue<P> que;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            d[i][j] = inf;\n        }\n    }\n    d[sx][sy] = 0;\n    que.push(P(sx, sy));\n\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < n && mp[nx][ny] != '#' && d[nx][ny] == inf){\n\n                d[nx][ny] = d[p.first][p.second] + 1;\n                que.push(P(nx, ny));\n            }\n        }\n\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif // ONLINE_JUDGE\n    while(~scanf(\"%d%d\", &n, &m)){\n        for(int i = 0; i < n; i++){\n            scanf(\"%s\", mp[i]);\n        }\n        for(int i = 0; i < m; i++){\n            scanf(\"%d%d%d%d\", &in[i].first, &in[i].second, &out[i].first, &out[i].second);\n        }\n        //构建邻接表\n        for(int i = 0; i < m; i++){\n            bfs(out[i].first - 1, out[i].second - 1);\n            for(int j = 0; j < m; j++){\n                if(i == j) dis[i][j] = 0;\n                else dis[i][j] = d[in[j].first - 1][in[j].second - 1];\n            }\n        }\n\n        dpsolve();\n    }\n    return 0;\n}\n```\n## 关于递归、动态规划理解的文章链接\n[写递归函数的正确思维方法](https://blog.csdn.net/vagrxie/article/details/8470798)\n[递归算法详解](https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/)\n[怎么更好地终极理解递归算法](https://blog.csdn.net/StruggleShu/article/details/51051140)\n[如何有效地理解程序中的递归](https://blog.csdn.net/qq_34773981/article/details/79225588)\n\n[一道题看清动态规划的前世今生（一）](http://www.importnew.com/27323.html)\n[一道题看清动态规划的前世今生（二）](http://www.importnew.com/27444.html)\n\n最后对这些文章的博主表示感谢！\n","slug":"HDU4856-Tunnels","published":1,"updated":"2018-08-14T12:10:47.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1z00006sxougvacjtnm","content":"<p>最近的几场训练赛做题的时候发现自己对搜索类、动态规划类的题有些恐惧，导致这些类型的题比赛时基本做不出来。仔细想了一下，是自己的递归部分理解的就不够透彻，导致搜索写不出来，动态规划就更无从下手。之前也找了很多递归理解的文章去看，也做了一些递归的题，但是效果不佳。意识到网上的资料对于递归的理解一般会拿经典的斐波那契数列或汉诺塔来举例，这对于递归的理解确实是有帮助的，但是对于锻炼搜索思维的效果不是太有效，于是决定先恶补一部分搜索类的题。<br>这道题是准备西安邀请赛时打的模拟赛做到的题，知识点主要用到了BFS和状态压缩DP，可以当做旅行商问题来做，但是最后不返回起点。由于自己DP比较差，所以搞懂这道题还是花了挺长时间。状态压缩DP部分的实现代码参考大白。</p>\n<p>Ps：在最后会贴几个自己觉得看到的对递归和动态规划理解比较有帮助的文章链接。<br><a id=\"more\"></a></p>\n<h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4856\" target=\"_blank\" rel=\"noopener\">HDU4856-Tunnels</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>一张城市网格图，城市中有m条快速通道，可以从图中任意位置出发，求访问完所有快速通道所用的最少时间，忽略在快速通道内的时间。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为在快速通道内的时间是不计的所以只要到达了一个快速通道的入口就相当于访问完了这一条通道，所以可以构造一张$m×m$的邻接表，其中$d[i][j]$表示从第$i$个通道的出口到第$j$个通道的入口的距离，这一部分直接用BFS就能实现，接下来就可以用旅行商问题的解法求解不重复的访问完所有通道所用的时间。<br>有两个与旅行商问题不同需要注意的地方：<br><strong>最后不返回起点</strong><br><strong>起点位置任意，也就是可以将任意一个通道的入口作为起点</strong><br>解决方法详见代码。</p>\n<p>##代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxm = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> mp[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\">P in[maxm];</span><br><span class=\"line\">P out[maxm];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sx, sy;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxm][maxm];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">1</span> &lt;&lt;  maxm][maxm];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//状态压缩DP</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dpsolve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> S = <span class=\"number\">0</span>; S &lt; <span class=\"number\">1</span> &lt;&lt; m; S++)&#123;</span><br><span class=\"line\">        fill(dp[S], dp[S] + m, inf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">        dp[(<span class=\"number\">1</span> &lt;&lt; m) - <span class=\"number\">1</span>][i] = <span class=\"number\">0</span>;<span class=\"comment\">//因为起点未定，所以终点在任意一个通道都可以</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> S = (<span class=\"number\">1</span> &lt;&lt; m) - <span class=\"number\">2</span>; S &gt;= <span class=\"number\">0</span>; S--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v = <span class=\"number\">0</span>; v &lt; m; v++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> u = <span class=\"number\">0</span>; u &lt; m; u++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!(S &gt;&gt; u &amp; <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                    dp[S][v] = min(dp[S][v], dp[S | <span class=\"number\">1</span> &lt;&lt; u][u] + dis[v][u]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = inf;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">        res = min(res, dp[<span class=\"number\">1</span> &lt;&lt; i][i]);<span class=\"comment\">//判断以不同通道为起点的情况下，哪种用时最短</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(res == inf) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, res);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//bfs搜索确定两两通道之间最小距离</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> sx, <span class=\"keyword\">int</span> sy)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;P&gt; que;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">            d[i][j] = inf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    d[sx][sy] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    que.push(P(sx, sy));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        P p = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nx = p.first + dx[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ny = p.second + dy[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; n &amp;&amp; mp[nx][ny] != <span class=\"string\">'#'</span> &amp;&amp; d[nx][ny] == inf)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                d[nx][ny] = d[p.first][p.second] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                que.push(P(nx, ny));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// ONLINE_JUDGE</span></span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, mp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>, &amp;in[i].first, &amp;in[i].second, &amp;out[i].first, &amp;out[i].second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//构建邻接表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            bfs(out[i].first - <span class=\"number\">1</span>, out[i].second - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == j) dis[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> dis[i][j] = d[in[j].first - <span class=\"number\">1</span>][in[j].second - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        dpsolve();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关于递归、动态规划理解的文章链接\"><a href=\"#关于递归、动态规划理解的文章链接\" class=\"headerlink\" title=\"关于递归、动态规划理解的文章链接\"></a>关于递归、动态规划理解的文章链接</h2><p><a href=\"https://blog.csdn.net/vagrxie/article/details/8470798\" target=\"_blank\" rel=\"noopener\">写递归函数的正确思维方法</a><br><a href=\"https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/\" target=\"_blank\" rel=\"noopener\">递归算法详解</a><br><a href=\"https://blog.csdn.net/StruggleShu/article/details/51051140\" target=\"_blank\" rel=\"noopener\">怎么更好地终极理解递归算法</a><br><a href=\"https://blog.csdn.net/qq_34773981/article/details/79225588\" target=\"_blank\" rel=\"noopener\">如何有效地理解程序中的递归</a></p>\n<p><a href=\"http://www.importnew.com/27323.html\" target=\"_blank\" rel=\"noopener\">一道题看清动态规划的前世今生（一）</a><br><a href=\"http://www.importnew.com/27444.html\" target=\"_blank\" rel=\"noopener\">一道题看清动态规划的前世今生（二）</a></p>\n<p>最后对这些文章的博主表示感谢！</p>\n","site":{"data":{}},"excerpt":"<p>最近的几场训练赛做题的时候发现自己对搜索类、动态规划类的题有些恐惧，导致这些类型的题比赛时基本做不出来。仔细想了一下，是自己的递归部分理解的就不够透彻，导致搜索写不出来，动态规划就更无从下手。之前也找了很多递归理解的文章去看，也做了一些递归的题，但是效果不佳。意识到网上的资料对于递归的理解一般会拿经典的斐波那契数列或汉诺塔来举例，这对于递归的理解确实是有帮助的，但是对于锻炼搜索思维的效果不是太有效，于是决定先恶补一部分搜索类的题。<br>这道题是准备西安邀请赛时打的模拟赛做到的题，知识点主要用到了BFS和状态压缩DP，可以当做旅行商问题来做，但是最后不返回起点。由于自己DP比较差，所以搞懂这道题还是花了挺长时间。状态压缩DP部分的实现代码参考大白。</p>\n<p>Ps：在最后会贴几个自己觉得看到的对递归和动态规划理解比较有帮助的文章链接。<br></p>","more":"<p></p>\n<h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4856\" target=\"_blank\" rel=\"noopener\">HDU4856-Tunnels</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>一张城市网格图，城市中有m条快速通道，可以从图中任意位置出发，求访问完所有快速通道所用的最少时间，忽略在快速通道内的时间。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为在快速通道内的时间是不计的所以只要到达了一个快速通道的入口就相当于访问完了这一条通道，所以可以构造一张$m×m$的邻接表，其中$d[i][j]$表示从第$i$个通道的出口到第$j$个通道的入口的距离，这一部分直接用BFS就能实现，接下来就可以用旅行商问题的解法求解不重复的访问完所有通道所用的时间。<br>有两个与旅行商问题不同需要注意的地方：<br><strong>最后不返回起点</strong><br><strong>起点位置任意，也就是可以将任意一个通道的入口作为起点</strong><br>解决方法详见代码。</p>\n<p>##代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxm = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> mp[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\">P in[maxm];</span><br><span class=\"line\">P out[maxm];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sx, sy;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxm][maxm];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">1</span> &lt;&lt;  maxm][maxm];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//状态压缩DP</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dpsolve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> S = <span class=\"number\">0</span>; S &lt; <span class=\"number\">1</span> &lt;&lt; m; S++)&#123;</span><br><span class=\"line\">        fill(dp[S], dp[S] + m, inf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">        dp[(<span class=\"number\">1</span> &lt;&lt; m) - <span class=\"number\">1</span>][i] = <span class=\"number\">0</span>;<span class=\"comment\">//因为起点未定，所以终点在任意一个通道都可以</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> S = (<span class=\"number\">1</span> &lt;&lt; m) - <span class=\"number\">2</span>; S &gt;= <span class=\"number\">0</span>; S--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v = <span class=\"number\">0</span>; v &lt; m; v++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> u = <span class=\"number\">0</span>; u &lt; m; u++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!(S &gt;&gt; u &amp; <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                    dp[S][v] = min(dp[S][v], dp[S | <span class=\"number\">1</span> &lt;&lt; u][u] + dis[v][u]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = inf;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">        res = min(res, dp[<span class=\"number\">1</span> &lt;&lt; i][i]);<span class=\"comment\">//判断以不同通道为起点的情况下，哪种用时最短</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(res == inf) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, res);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//bfs搜索确定两两通道之间最小距离</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> sx, <span class=\"keyword\">int</span> sy)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;P&gt; que;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">            d[i][j] = inf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    d[sx][sy] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    que.push(P(sx, sy));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        P p = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nx = p.first + dx[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ny = p.second + dy[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; n &amp;&amp; mp[nx][ny] != <span class=\"string\">'#'</span> &amp;&amp; d[nx][ny] == inf)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                d[nx][ny] = d[p.first][p.second] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                que.push(P(nx, ny));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// ONLINE_JUDGE</span></span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, mp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>, &amp;in[i].first, &amp;in[i].second, &amp;out[i].first, &amp;out[i].second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//构建邻接表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            bfs(out[i].first - <span class=\"number\">1</span>, out[i].second - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == j) dis[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> dis[i][j] = d[in[j].first - <span class=\"number\">1</span>][in[j].second - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        dpsolve();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关于递归、动态规划理解的文章链接\"><a href=\"#关于递归、动态规划理解的文章链接\" class=\"headerlink\" title=\"关于递归、动态规划理解的文章链接\"></a>关于递归、动态规划理解的文章链接</h2><p><a href=\"https://blog.csdn.net/vagrxie/article/details/8470798\" target=\"_blank\" rel=\"noopener\">写递归函数的正确思维方法</a><br><a href=\"https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/\" target=\"_blank\" rel=\"noopener\">递归算法详解</a><br><a href=\"https://blog.csdn.net/StruggleShu/article/details/51051140\" target=\"_blank\" rel=\"noopener\">怎么更好地终极理解递归算法</a><br><a href=\"https://blog.csdn.net/qq_34773981/article/details/79225588\" target=\"_blank\" rel=\"noopener\">如何有效地理解程序中的递归</a></p>\n<p><a href=\"http://www.importnew.com/27323.html\" target=\"_blank\" rel=\"noopener\">一道题看清动态规划的前世今生（一）</a><br><a href=\"http://www.importnew.com/27444.html\" target=\"_blank\" rel=\"noopener\">一道题看清动态规划的前世今生（二）</a></p>\n<p>最后对这些文章的博主表示感谢！</p>"},{"title":"CodeForces-569A-Music","date":"2018-08-28T07:15:59.000Z","_content":"也是一道思维题，理解了题意就很简单，但是自己理解题意费了好长时间，，还好最后AC了，背景故事蛮有意思的2333.\n<!--more-->\n## 链接\n[CodeForces-569A-Music](http://codeforces.com/problemset/problem/569/A)\n## 题意\n下载一首时长为$T$的歌，首先下载$S$秒，然后边下载边播放，播放到还未下载的位置就立即返回歌的开头重新播放，求需要返回几次才能最终完整听完这首歌。歌的下载速率为每经过$q$秒下载$q - 1$秒的歌。\n## 题解\n一开始没有理解歌的下载速率的问题，是每经过$q$秒直接得到$q - 1$秒的歌，还是在$q$秒内一直在下载，最后累计得到$q-1$秒的歌，看了样例后发现是第二种，（好像也第二种也更符合实际）。平均每秒的下载速率是$(q-1)/q$，这不是一个整数，甚至很可能是无理数，那结果很可能就不精确了，尤其是最后刚好下载完也刚刚听完的那种情况，会多算或者少算一次，所以不能求出平均下载速率然后来模拟计算。\n然后想到了一种思路，因为听的速率是大于下载的速率的，所以考虑最开始下载的$S$秒，求出这$S$秒被消耗完的时间$t$，$$t = \\frac{S}{1 - \\frac{q - 1}{q}}$$化简得$$t = S * q$$同时$t$也表示在这一时刻，听歌的进度正好赶上了下载的速度，此时判断$t$是否大于等于$T$，若大于等于则表示歌已下载完成，否则需返回歌的开头重新播放（此时的$S$更新为$t$，因为已下载的进度现在是$t$）。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 27 Aug 13:48:09 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long T, S, q;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    cin >> T >> S >> q;\n    while(1){\n        if(S * q >= T) break;\n        else{\n            S = S * q;\n            cnt++;\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}\n```","source":"_posts/CodeForces-569A.md","raw":"---\ntitle: 'CodeForces-569A-Music'\ndate: 2018-08-28 15:15:59\ncategories:\n- ACM\ntags:\n- 思维\n---\n也是一道思维题，理解了题意就很简单，但是自己理解题意费了好长时间，，还好最后AC了，背景故事蛮有意思的2333.\n<!--more-->\n## 链接\n[CodeForces-569A-Music](http://codeforces.com/problemset/problem/569/A)\n## 题意\n下载一首时长为$T$的歌，首先下载$S$秒，然后边下载边播放，播放到还未下载的位置就立即返回歌的开头重新播放，求需要返回几次才能最终完整听完这首歌。歌的下载速率为每经过$q$秒下载$q - 1$秒的歌。\n## 题解\n一开始没有理解歌的下载速率的问题，是每经过$q$秒直接得到$q - 1$秒的歌，还是在$q$秒内一直在下载，最后累计得到$q-1$秒的歌，看了样例后发现是第二种，（好像也第二种也更符合实际）。平均每秒的下载速率是$(q-1)/q$，这不是一个整数，甚至很可能是无理数，那结果很可能就不精确了，尤其是最后刚好下载完也刚刚听完的那种情况，会多算或者少算一次，所以不能求出平均下载速率然后来模拟计算。\n然后想到了一种思路，因为听的速率是大于下载的速率的，所以考虑最开始下载的$S$秒，求出这$S$秒被消耗完的时间$t$，$$t = \\frac{S}{1 - \\frac{q - 1}{q}}$$化简得$$t = S * q$$同时$t$也表示在这一时刻，听歌的进度正好赶上了下载的速度，此时判断$t$是否大于等于$T$，若大于等于则表示歌已下载完成，否则需返回歌的开头重新播放（此时的$S$更新为$t$，因为已下载的进度现在是$t$）。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 27 Aug 13:48:09 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long T, S, q;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    cin >> T >> S >> q;\n    while(1){\n        if(S * q >= T) break;\n        else{\n            S = S * q;\n            cnt++;\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}\n```","slug":"CodeForces-569A","published":1,"updated":"2018-08-28T08:11:55.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1z30009sxour2zlutx6","content":"<p>也是一道思维题，理解了题意就很简单，但是自己理解题意费了好长时间，，还好最后AC了，背景故事蛮有意思的2333.<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/problemset/problem/569/A\" target=\"_blank\" rel=\"noopener\">CodeForces-569A-Music</a></p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>下载一首时长为$T$的歌，首先下载$S$秒，然后边下载边播放，播放到还未下载的位置就立即返回歌的开头重新播放，求需要返回几次才能最终完整听完这首歌。歌的下载速率为每经过$q$秒下载$q - 1$秒的歌。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一开始没有理解歌的下载速率的问题，是每经过$q$秒直接得到$q - 1$秒的歌，还是在$q$秒内一直在下载，最后累计得到$q-1$秒的歌，看了样例后发现是第二种，（好像也第二种也更符合实际）。平均每秒的下载速率是$(q-1)/q$，这不是一个整数，甚至很可能是无理数，那结果很可能就不精确了，尤其是最后刚好下载完也刚刚听完的那种情况，会多算或者少算一次，所以不能求出平均下载速率然后来模拟计算。<br>然后想到了一种思路，因为听的速率是大于下载的速率的，所以考虑最开始下载的$S$秒，求出这$S$秒被消耗完的时间$t$，$$t = \\frac{S}{1 - \\frac{q - 1}{q}}$$化简得$$t = S * q$$同时$t$也表示在这一时刻，听歌的进度正好赶上了下载的速度，此时判断$t$是否大于等于$T$，若大于等于则表示歌已下载完成，否则需返回歌的开头重新播放（此时的$S$更新为$t$，因为已下载的进度现在是$t$）。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon 27 Aug 13:48:09 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> T, S, q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; T &gt;&gt; S &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S * q &gt;= T) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            S = S * q;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; cnt &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>也是一道思维题，理解了题意就很简单，但是自己理解题意费了好长时间，，还好最后AC了，背景故事蛮有意思的2333.<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/problemset/problem/569/A\" target=\"_blank\" rel=\"noopener\">CodeForces-569A-Music</a></p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>下载一首时长为$T$的歌，首先下载$S$秒，然后边下载边播放，播放到还未下载的位置就立即返回歌的开头重新播放，求需要返回几次才能最终完整听完这首歌。歌的下载速率为每经过$q$秒下载$q - 1$秒的歌。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一开始没有理解歌的下载速率的问题，是每经过$q$秒直接得到$q - 1$秒的歌，还是在$q$秒内一直在下载，最后累计得到$q-1$秒的歌，看了样例后发现是第二种，（好像也第二种也更符合实际）。平均每秒的下载速率是$(q-1)/q$，这不是一个整数，甚至很可能是无理数，那结果很可能就不精确了，尤其是最后刚好下载完也刚刚听完的那种情况，会多算或者少算一次，所以不能求出平均下载速率然后来模拟计算。<br>然后想到了一种思路，因为听的速率是大于下载的速率的，所以考虑最开始下载的$S$秒，求出这$S$秒被消耗完的时间$t$，$$t = \\frac{S}{1 - \\frac{q - 1}{q}}$$化简得$$t = S * q$$同时$t$也表示在这一时刻，听歌的进度正好赶上了下载的速度，此时判断$t$是否大于等于$T$，若大于等于则表示歌已下载完成，否则需返回歌的开头重新播放（此时的$S$更新为$t$，因为已下载的进度现在是$t$）。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon 27 Aug 13:48:09 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> T, S, q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; T &gt;&gt; S &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S * q &gt;= T) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            S = S * q;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; cnt &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"My little angel","date":"2018-06-10T01:57:06.000Z","_content":"## 重庆之旅\n　　和邱小笨蛋在一起四个多月了，但是快一年没见了，她在重庆，我在北京，她读高中，我读大学。感觉有些不可思议，能够遇到，能够在一起。感谢女票的勇敢，我是非常怂的，，，。\n在重庆度过了非常非常开心的几天，刚到的那天晚上给女票发消息说到了之后激动的睡不着，第二天早上终于见到了穿着裙裙来找我的女票票～(｡･ω･｡)ﾉ♡\n![邱小雁](/qxy1.jpg)\n<!-- more -->\n　　女票比印象中要瘦了，可能是高中太累了吧，有些心疼，让她多长些肉肉她还不愿意Ծ‸ Ծ 。之后两人一起牵爪爪去逛商场玩了和女票期待已久的密室逃脱，可惜太菜了，小哥哥可能是可怜我们哈哈让我们看了最后的一关。\n　　一直想去女票学校看看的心愿也达成了，想感受一下女票平时给我发的照片里的地方、花花到底是什么样子的。去了女票平时自习的自习室，稍微有点冷，女票下次去的时候多穿一点啊。竟然还遇到了抓早恋的老师＝＝（害怕.jpg），女票好机智，话说我都大三了为什么还怕这种老师。。\n　　第三天早上和女票在一起吃的早餐，还是要说一下女票吃的太少了，多长肉肉啊亲爱的，不用担心，男票抱得动的(•̀⌄•́)。吃了早餐一起去女票住的小区里打了篮球，之前说要教女票投篮可是自己投了十几个才中了一个，，呜呜呜T^T树立了一个篮球小菜鸡的形象，不过一起吃了可爱多很开心(๑❛ᴗ❛๑)。中午去吃了自助，女票怕我吃不了太辣点了清汤的小火锅，委屈重庆小妹纸了。下午一起做了情侣必做的事情，看电影！而且是小哆啦哈哈，抱着女票看电影的感觉好幸福。\n　　女票怕妈妈担心本来是要在家吃晚饭的，我晚上不知道吃什么和女票说想点外卖，女票就从家跑出来陪我了，感动::>_<::（虽然最后在一起抱了好久连外卖也没吃成哈哈哈），感谢我女票票。晚上送女票回家一起在长江边散步也超级开心，女票还热情的给我介绍了重庆的“移动公厕”哈哈。\n<figure class=\"half\">\n    ![邱小雁](/moon1.jpg)　![邱小雁](/together1.jpg)\n</figure>\n\n　　周五要回学校了，女票早上发消息说她准备来找我了，昨晚梦到我突然就不见了，我骗女票说我是9:45的飞机，我已经走了（其实是11:45的飞机，那时候大概7:40左右我刚醒），本来我以为傻女票不会相信，没想到她直接哭着给我打电话问我“你干嘛啊”，天啊，心都要化了。可能是之前和她说机场有点远不想让她送我，所以她才相信我真的走了吧♡。见到女票后果然被打了，，但是那句“你是猪吗”我却听的如痴如醉，怎么会有这么可爱的女孩子啊。\n　　我爱你，傻女票。","source":"_posts/My-little-angel.md","raw":"---\ntitle: My little angel\ndate: 2018-06-10 09:57:06\ncategories:\n- Diary\ntags:\n- Lover\n---\n## 重庆之旅\n　　和邱小笨蛋在一起四个多月了，但是快一年没见了，她在重庆，我在北京，她读高中，我读大学。感觉有些不可思议，能够遇到，能够在一起。感谢女票的勇敢，我是非常怂的，，，。\n在重庆度过了非常非常开心的几天，刚到的那天晚上给女票发消息说到了之后激动的睡不着，第二天早上终于见到了穿着裙裙来找我的女票票～(｡･ω･｡)ﾉ♡\n![邱小雁](/qxy1.jpg)\n<!-- more -->\n　　女票比印象中要瘦了，可能是高中太累了吧，有些心疼，让她多长些肉肉她还不愿意Ծ‸ Ծ 。之后两人一起牵爪爪去逛商场玩了和女票期待已久的密室逃脱，可惜太菜了，小哥哥可能是可怜我们哈哈让我们看了最后的一关。\n　　一直想去女票学校看看的心愿也达成了，想感受一下女票平时给我发的照片里的地方、花花到底是什么样子的。去了女票平时自习的自习室，稍微有点冷，女票下次去的时候多穿一点啊。竟然还遇到了抓早恋的老师＝＝（害怕.jpg），女票好机智，话说我都大三了为什么还怕这种老师。。\n　　第三天早上和女票在一起吃的早餐，还是要说一下女票吃的太少了，多长肉肉啊亲爱的，不用担心，男票抱得动的(•̀⌄•́)。吃了早餐一起去女票住的小区里打了篮球，之前说要教女票投篮可是自己投了十几个才中了一个，，呜呜呜T^T树立了一个篮球小菜鸡的形象，不过一起吃了可爱多很开心(๑❛ᴗ❛๑)。中午去吃了自助，女票怕我吃不了太辣点了清汤的小火锅，委屈重庆小妹纸了。下午一起做了情侣必做的事情，看电影！而且是小哆啦哈哈，抱着女票看电影的感觉好幸福。\n　　女票怕妈妈担心本来是要在家吃晚饭的，我晚上不知道吃什么和女票说想点外卖，女票就从家跑出来陪我了，感动::>_<::（虽然最后在一起抱了好久连外卖也没吃成哈哈哈），感谢我女票票。晚上送女票回家一起在长江边散步也超级开心，女票还热情的给我介绍了重庆的“移动公厕”哈哈。\n<figure class=\"half\">\n    ![邱小雁](/moon1.jpg)　![邱小雁](/together1.jpg)\n</figure>\n\n　　周五要回学校了，女票早上发消息说她准备来找我了，昨晚梦到我突然就不见了，我骗女票说我是9:45的飞机，我已经走了（其实是11:45的飞机，那时候大概7:40左右我刚醒），本来我以为傻女票不会相信，没想到她直接哭着给我打电话问我“你干嘛啊”，天啊，心都要化了。可能是之前和她说机场有点远不想让她送我，所以她才相信我真的走了吧♡。见到女票后果然被打了，，但是那句“你是猪吗”我却听的如痴如醉，怎么会有这么可爱的女孩子啊。\n　　我爱你，傻女票。","slug":"My-little-angel","published":1,"updated":"2018-06-12T04:16:31.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1z5000asxouz1zbogam","content":"<h2 id=\"重庆之旅\"><a href=\"#重庆之旅\" class=\"headerlink\" title=\"重庆之旅\"></a>重庆之旅</h2><p>　　和邱小笨蛋在一起四个多月了，但是快一年没见了，她在重庆，我在北京，她读高中，我读大学。感觉有些不可思议，能够遇到，能够在一起。感谢女票的勇敢，我是非常怂的，，，。<br>在重庆度过了非常非常开心的几天，刚到的那天晚上给女票发消息说到了之后激动的睡不着，第二天早上终于见到了穿着裙裙来找我的女票票～(｡･ω･｡)ﾉ♡<br><img src=\"/2018/06/10/My-little-angel/qxy1.jpg\" alt=\"邱小雁\"><br><a id=\"more\"></a><br>　　女票比印象中要瘦了，可能是高中太累了吧，有些心疼，让她多长些肉肉她还不愿意Ծ‸ Ծ 。之后两人一起牵爪爪去逛商场玩了和女票期待已久的密室逃脱，可惜太菜了，小哥哥可能是可怜我们哈哈让我们看了最后的一关。<br>　　一直想去女票学校看看的心愿也达成了，想感受一下女票平时给我发的照片里的地方、花花到底是什么样子的。去了女票平时自习的自习室，稍微有点冷，女票下次去的时候多穿一点啊。竟然还遇到了抓早恋的老师＝＝（害怕.jpg），女票好机智，话说我都大三了为什么还怕这种老师。。<br>　　第三天早上和女票在一起吃的早餐，还是要说一下女票吃的太少了，多长肉肉啊亲爱的，不用担心，男票抱得动的(•̀⌄•́)。吃了早餐一起去女票住的小区里打了篮球，之前说要教女票投篮可是自己投了十几个才中了一个，，呜呜呜T^T树立了一个篮球小菜鸡的形象，不过一起吃了可爱多很开心(๑❛ᴗ❛๑)。中午去吃了自助，女票怕我吃不了太辣点了清汤的小火锅，委屈重庆小妹纸了。下午一起做了情侣必做的事情，看电影！而且是小哆啦哈哈，抱着女票看电影的感觉好幸福。<br>　　女票怕妈妈担心本来是要在家吃晚饭的，我晚上不知道吃什么和女票说想点外卖，女票就从家跑出来陪我了，感动::&gt;_&lt;::（虽然最后在一起抱了好久连外卖也没吃成哈哈哈），感谢我女票票。晚上送女票回家一起在长江边散步也超级开心，女票还热情的给我介绍了重庆的“移动公厕”哈哈。</p>\n<figure class=\"half\"><br>    <img src=\"/2018/06/10/My-little-angel/moon1.jpg\" alt=\"邱小雁\">　<img src=\"/2018/06/10/My-little-angel/together1.jpg\" alt=\"邱小雁\"><br></figure>\n\n<p>　　周五要回学校了，女票早上发消息说她准备来找我了，昨晚梦到我突然就不见了，我骗女票说我是9:45的飞机，我已经走了（其实是11:45的飞机，那时候大概7:40左右我刚醒），本来我以为傻女票不会相信，没想到她直接哭着给我打电话问我“你干嘛啊”，天啊，心都要化了。可能是之前和她说机场有点远不想让她送我，所以她才相信我真的走了吧♡。见到女票后果然被打了，，但是那句“你是猪吗”我却听的如痴如醉，怎么会有这么可爱的女孩子啊。<br>　　我爱你，傻女票。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"重庆之旅\"><a href=\"#重庆之旅\" class=\"headerlink\" title=\"重庆之旅\"></a>重庆之旅</h2><p>　　和邱小笨蛋在一起四个多月了，但是快一年没见了，她在重庆，我在北京，她读高中，我读大学。感觉有些不可思议，能够遇到，能够在一起。感谢女票的勇敢，我是非常怂的，，，。<br>在重庆度过了非常非常开心的几天，刚到的那天晚上给女票发消息说到了之后激动的睡不着，第二天早上终于见到了穿着裙裙来找我的女票票～(｡･ω･｡)ﾉ♡<br><img src=\"/2018/06/10/My-little-angel/qxy1.jpg\" alt=\"邱小雁\"><br></p>","more":"<br>　　女票比印象中要瘦了，可能是高中太累了吧，有些心疼，让她多长些肉肉她还不愿意Ծ‸ Ծ 。之后两人一起牵爪爪去逛商场玩了和女票期待已久的密室逃脱，可惜太菜了，小哥哥可能是可怜我们哈哈让我们看了最后的一关。<br>　　一直想去女票学校看看的心愿也达成了，想感受一下女票平时给我发的照片里的地方、花花到底是什么样子的。去了女票平时自习的自习室，稍微有点冷，女票下次去的时候多穿一点啊。竟然还遇到了抓早恋的老师＝＝（害怕.jpg），女票好机智，话说我都大三了为什么还怕这种老师。。<br>　　第三天早上和女票在一起吃的早餐，还是要说一下女票吃的太少了，多长肉肉啊亲爱的，不用担心，男票抱得动的(•̀⌄•́)。吃了早餐一起去女票住的小区里打了篮球，之前说要教女票投篮可是自己投了十几个才中了一个，，呜呜呜T^T树立了一个篮球小菜鸡的形象，不过一起吃了可爱多很开心(๑❛ᴗ❛๑)。中午去吃了自助，女票怕我吃不了太辣点了清汤的小火锅，委屈重庆小妹纸了。下午一起做了情侣必做的事情，看电影！而且是小哆啦哈哈，抱着女票看电影的感觉好幸福。<br>　　女票怕妈妈担心本来是要在家吃晚饭的，我晚上不知道吃什么和女票说想点外卖，女票就从家跑出来陪我了，感动::&gt;_&lt;::（虽然最后在一起抱了好久连外卖也没吃成哈哈哈），感谢我女票票。晚上送女票回家一起在长江边散步也超级开心，女票还热情的给我介绍了重庆的“移动公厕”哈哈。<p></p>\n<figure class=\"half\"><br>    <img src=\"/2018/06/10/My-little-angel/moon1.jpg\" alt=\"邱小雁\">　<img src=\"/2018/06/10/My-little-angel/together1.jpg\" alt=\"邱小雁\"><br></figure>\n\n<p>　　周五要回学校了，女票早上发消息说她准备来找我了，昨晚梦到我突然就不见了，我骗女票说我是9:45的飞机，我已经走了（其实是11:45的飞机，那时候大概7:40左右我刚醒），本来我以为傻女票不会相信，没想到她直接哭着给我打电话问我“你干嘛啊”，天啊，心都要化了。可能是之前和她说机场有点远不想让她送我，所以她才相信我真的走了吧♡。见到女票后果然被打了，，但是那句“你是猪吗”我却听的如痴如醉，怎么会有这么可爱的女孩子啊。<br>　　我爱你，傻女票。</p>"},{"title":"CodeForces-478C-Table Decorations","date":"2018-08-28T06:21:27.000Z","_content":"水题，然而自己WA了orz，看到了一种很有意思的解法。\n[参考连接](http://codeforces.com/blog/entry/18619)\n<!--more-->\n## 链接\n[CodeForces-478C-Table Decorations](http://codeforces.com/problemset/problem/478/C)\n## 题目描述\n给定红黄蓝三种气球的数量，要求每个桌子上放三个气球，且三个气球的颜色不能完全相同，求这些气球最多可以装饰几张桌子。\n## 题解\n假定三种气球的数量分别为``a[0]，a[1]，a[2]``，且已按大小排好序，``a[0] <= a[1] <= a[2]``。\n有两种情况:\n+ ``2 * (a[0] + a[1]) <=  a[2]``。这种情况下可以每取一个``a[0]``取两个``a[2]``组成三气球或者每取一个``a[1]``取两个``a[2]``组成三气球，即取球集合为``(1，0，2)``和``(0，1，2)``。答案为``a[0] + a[1]``。\n+ ``2*(a[0] + a[1]) > a[2]``。这种情况下我们从``a[2]``中取两个气球同时从``max(a[0]，a[1])``中取一个气球，直到``a[2] <= max(a[0]，a[1])``。这时满足``max(a[0]，a[1]) - a[2] <= 1``和``max(a[0]，a[1]) - min(a[0]，a[1]) <= 1``。接下来的按集合``(1，1，1)``继续取球。**可以发现这种取法最后剩余球的数量一定是** ``(a[0]+a[1]+a[2]) mod 3``，**除去剩余的这些球(数量小于3)，其它球每三个装饰一张桌子，所以针对这种情况我们直接可以用** ``(a[0]+a[1]+a[2]) div 3`` **来得到最终结果。**\n\n真是神解orz。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 28 Aug 14:12:13 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long d[5];\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    for(int i = 0; i < 3; i++)\n        cin >> d[i];\n    sort(d, d + 3);\n    long long ans;\n    if(2 * (d[0] + d[1]) <= d[2])\n        ans = d[0] + d[1];\n    else \n        ans = (d[0] + d[1] + d[2]) / 3;\n    cout << ans << endl;\n    \n    return 0;\n}\n```\n","source":"_posts/CodeForces-478C.md","raw":"---\ntitle: CodeForces-478C-Table Decorations\ndate: 2018-08-28 14:21:27\ncategories:\n- ACM\ntags:\n- 思维\n---\n水题，然而自己WA了orz，看到了一种很有意思的解法。\n[参考连接](http://codeforces.com/blog/entry/18619)\n<!--more-->\n## 链接\n[CodeForces-478C-Table Decorations](http://codeforces.com/problemset/problem/478/C)\n## 题目描述\n给定红黄蓝三种气球的数量，要求每个桌子上放三个气球，且三个气球的颜色不能完全相同，求这些气球最多可以装饰几张桌子。\n## 题解\n假定三种气球的数量分别为``a[0]，a[1]，a[2]``，且已按大小排好序，``a[0] <= a[1] <= a[2]``。\n有两种情况:\n+ ``2 * (a[0] + a[1]) <=  a[2]``。这种情况下可以每取一个``a[0]``取两个``a[2]``组成三气球或者每取一个``a[1]``取两个``a[2]``组成三气球，即取球集合为``(1，0，2)``和``(0，1，2)``。答案为``a[0] + a[1]``。\n+ ``2*(a[0] + a[1]) > a[2]``。这种情况下我们从``a[2]``中取两个气球同时从``max(a[0]，a[1])``中取一个气球，直到``a[2] <= max(a[0]，a[1])``。这时满足``max(a[0]，a[1]) - a[2] <= 1``和``max(a[0]，a[1]) - min(a[0]，a[1]) <= 1``。接下来的按集合``(1，1，1)``继续取球。**可以发现这种取法最后剩余球的数量一定是** ``(a[0]+a[1]+a[2]) mod 3``，**除去剩余的这些球(数量小于3)，其它球每三个装饰一张桌子，所以针对这种情况我们直接可以用** ``(a[0]+a[1]+a[2]) div 3`` **来得到最终结果。**\n\n真是神解orz。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 28 Aug 14:12:13 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long d[5];\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    for(int i = 0; i < 3; i++)\n        cin >> d[i];\n    sort(d, d + 3);\n    long long ans;\n    if(2 * (d[0] + d[1]) <= d[2])\n        ans = d[0] + d[1];\n    else \n        ans = (d[0] + d[1] + d[2]) / 3;\n    cout << ans << endl;\n    \n    return 0;\n}\n```\n","slug":"CodeForces-478C","published":1,"updated":"2018-08-28T08:39:34.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1z8000esxoulcf5s8yn","content":"<p>水题，然而自己WA了orz，看到了一种很有意思的解法。<br><a href=\"http://codeforces.com/blog/entry/18619\" target=\"_blank\" rel=\"noopener\">参考连接</a><br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/problemset/problem/478/C\" target=\"_blank\" rel=\"noopener\">CodeForces-478C-Table Decorations</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定红黄蓝三种气球的数量，要求每个桌子上放三个气球，且三个气球的颜色不能完全相同，求这些气球最多可以装饰几张桌子。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>假定三种气球的数量分别为<code>a[0]，a[1]，a[2]</code>，且已按大小排好序，<code>a[0] &lt;= a[1] &lt;= a[2]</code>。<br>有两种情况:</p>\n<ul>\n<li><code>2 * (a[0] + a[1]) &lt;=  a[2]</code>。这种情况下可以每取一个<code>a[0]</code>取两个<code>a[2]</code>组成三气球或者每取一个<code>a[1]</code>取两个<code>a[2]</code>组成三气球，即取球集合为<code>(1，0，2)</code>和<code>(0，1，2)</code>。答案为<code>a[0] + a[1]</code>。</li>\n<li><code>2*(a[0] + a[1]) &gt; a[2]</code>。这种情况下我们从<code>a[2]</code>中取两个气球同时从<code>max(a[0]，a[1])</code>中取一个气球，直到<code>a[2] &lt;= max(a[0]，a[1])</code>。这时满足<code>max(a[0]，a[1]) - a[2] &lt;= 1</code>和<code>max(a[0]，a[1]) - min(a[0]，a[1]) &lt;= 1</code>。接下来的按集合<code>(1，1，1)</code>继续取球。<strong>可以发现这种取法最后剩余球的数量一定是</strong> <code>(a[0]+a[1]+a[2]) mod 3</code>，<strong>除去剩余的这些球(数量小于3)，其它球每三个装饰一张桌子，所以针对这种情况我们直接可以用</strong> <code>(a[0]+a[1]+a[2]) div 3</code> <strong>来得到最终结果。</strong></li>\n</ul>\n<p>真是神解orz。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 28 Aug 14:12:13 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d[<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; d[i];</span><br><span class=\"line\">    sort(d, d + <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">2</span> * (d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>]) &lt;= d[<span class=\"number\">2</span>])</span><br><span class=\"line\">        ans = d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        ans = (d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>] + d[<span class=\"number\">2</span>]) / <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>水题，然而自己WA了orz，看到了一种很有意思的解法。<br><a href=\"http://codeforces.com/blog/entry/18619\" target=\"_blank\" rel=\"noopener\">参考连接</a><br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/problemset/problem/478/C\" target=\"_blank\" rel=\"noopener\">CodeForces-478C-Table Decorations</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定红黄蓝三种气球的数量，要求每个桌子上放三个气球，且三个气球的颜色不能完全相同，求这些气球最多可以装饰几张桌子。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>假定三种气球的数量分别为<code>a[0]，a[1]，a[2]</code>，且已按大小排好序，<code>a[0] &lt;= a[1] &lt;= a[2]</code>。<br>有两种情况:</p>\n<ul>\n<li><code>2 * (a[0] + a[1]) &lt;=  a[2]</code>。这种情况下可以每取一个<code>a[0]</code>取两个<code>a[2]</code>组成三气球或者每取一个<code>a[1]</code>取两个<code>a[2]</code>组成三气球，即取球集合为<code>(1，0，2)</code>和<code>(0，1，2)</code>。答案为<code>a[0] + a[1]</code>。</li>\n<li><code>2*(a[0] + a[1]) &gt; a[2]</code>。这种情况下我们从<code>a[2]</code>中取两个气球同时从<code>max(a[0]，a[1])</code>中取一个气球，直到<code>a[2] &lt;= max(a[0]，a[1])</code>。这时满足<code>max(a[0]，a[1]) - a[2] &lt;= 1</code>和<code>max(a[0]，a[1]) - min(a[0]，a[1]) &lt;= 1</code>。接下来的按集合<code>(1，1，1)</code>继续取球。<strong>可以发现这种取法最后剩余球的数量一定是</strong> <code>(a[0]+a[1]+a[2]) mod 3</code>，<strong>除去剩余的这些球(数量小于3)，其它球每三个装饰一张桌子，所以针对这种情况我们直接可以用</strong> <code>(a[0]+a[1]+a[2]) div 3</code> <strong>来得到最终结果。</strong></li>\n</ul>\n<p>真是神解orz。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 28 Aug 14:12:13 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d[<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; d[i];</span><br><span class=\"line\">    sort(d, d + <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">2</span> * (d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>]) &lt;= d[<span class=\"number\">2</span>])</span><br><span class=\"line\">        ans = d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        ans = (d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>] + d[<span class=\"number\">2</span>]) / <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"牛客暑期ACM多校训练营(第三场)A题-PACM Team-多维01背包+记录路径","date":"2018-07-26T15:16:37.000Z","_content":"DP果然是最弱的，记录路径更是十分懵，在多校训练营里被虐的抬不起头，，，算了，只要不死，就会更强(赛亚人的特性其实也就是人的特性)\n<!-- more -->\n## 题目描述\nEddy was a contestant participating in ACM ICPC contests. ACM is short for Algorithm, Coding, Math. Since in the ACM contest, the most important knowledge is about algorithm, followed by coding(implementation ability), then math. However, in the ACM ICPC World Finals 2018, Eddy failed to solve a physics equation, which pushed him away from a potential medal.\n\nSince then on, Eddy found that physics is actually the most important thing in the contest. Thus, he wants to form a team to guide the following contestants to conquer the PACM contests(PACM is short for Physics, Algorithm, Coding, Math). \n\nThere are N candidate groups each composed of pi physics experts, ai algorithm experts, ci coding experts, mi math experts. For each group, Eddy can either invite all of them or none of them. If i-th team is invited, they will bring gi knowledge points which is calculated by Eddy's magic formula. Eddy believes that the higher the total knowledge points is, the better a team could place in a contest. But, Eddy doesn't want too many experts in the same area in the invited groups. Thus, the number of invited physics experts should not exceed P, and A for algorithm experts, C for coding experts, M for math experts.\n\nEddy is still busy in studying Physics. You come to help him to figure out which groups should be invited such that they doesn't exceed the constraint and will bring the most knowledge points in total.\n\n输入描述:\nThe first line contains a positive integer N indicating the number of candidate groups.\nEach of following N lines contains five space-separated integer pi, ai, ci, mi, gi indicating that i-th team consists of pi physics experts, ai algorithm experts, ci coding experts, mi math experts, and will bring gi knowledge points.\nThe last line contains four space-separated integer P, A, C, M indicating the maximum possible number of physics experts, algorithm experts, coding experts, and math experts, respectively.\n\n 1 ≤ N ≤ 36\n 0 ≤ pi,ai,ci,mi,gi ≤ 36\n 0 ≤ P, A, C, M ≤ 36\n输出描述:\n\nThe first line should contain a non-negative integer K indicating the number of invited groups.\nThe second line should contain K space-separated integer indicating the index of invited groups(groups are indexed from 0).\n\nYou can output index in any order as long as each index appears at most once. If there are multiple way to reach the most total knowledge points, you can output any one of them. If none of the groups will be invited, you could either output one line or output a blank line in the second line.\n示例1:\n\n输入:\n2\n1 0 2 1 10\n1 0 2 1 21\n1 0 2 1\n输出:\n1\n1\n\n示例2:\n\n输入:\n1\n2 1 1 0 31\n1 0 2 1\n输出：\n0\n\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 40;\nint p[maxn], a[maxn], c[maxn], m[maxn];\nint v[maxn];\nshort d[maxn][maxn][maxn][maxn][maxn];\nint n;\nint Pm, Am, Cm, Mm;\nint used[maxn];//记录路径\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    memset(used, 0, sizeof(used));\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d%d%d%d%d\", p + i, a + i, c + i, m + i, v + i);\n    }\n\n    scanf(\"%d%d%d%d\", &Pm, &Am, &Cm, &Mm);\n    for(int i = 0; i <= Pm; i++){\n        for(int j = 0; j <= Am; j++){\n            for(int k = 0; k <= Cm; k++){\n                for(int l = 0; l <= Mm; l++){\n                    d[0][i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= Pm; j++){\n            for(int k = 0; k <= Am; k++){\n                for(int l = 0; l <= Cm; l++){\n                    for(int q = 0; q <= Mm; q++){\n                        d[i + 1][j][k][l][q] = d[i][j][k][l][q];\n                        if(j >= p[i] && k >= a[i] && l >= c[i] && q >= m[i]){\n                            int tmp = v[i] + d[i][j - p[i]][k - a[i]][l - c[i]][q - m[i]];\n                            if(tmp > d[i + 1][j][k][l][q]) {\n                                d[i + 1][j][k][l][q] = tmp;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //记录路径部分\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][Pm][Am][Cm][Mm] != d[i][Pm][Am][Cm][Mm]){\n            used[i] = 1;\n            Pm -= p[i];\n            Am -= a[i];\n            Cm -= c[i];\n            Mm -= m[i];\n        }\n    }\n    int cnt = 0;\n    for(int i = 0; i < n; i++){\n        if(used[i] == 1){\n            cnt++;\n        }\n    }\n    printf(\"%d\\n\", cnt);\n    if(cnt){\n        for(int i = 0; i < n; i++){\n            if(used[i]) printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n## 坑点\n数据d的类型要是short类型，int类型会爆内存，char类型会数据溢出．\n\n## 背包记录路径问题总结\n### 方法一核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            if(j < w[i]){\n                d[i + 1][j] = d[i][j];\n            }\n            else{\n                d[i + 1][j] = max(d[i][j], d[i][j - w[i]] + v[i]);\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][W] != d[i][W]){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n### 方法二核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            d[i + 1][j] = d[i][j];\n            if(j >= w[i]){\n                int tmp = d[i][j - w[i]] + v[i];\n                if(tmp > d[i + 1][j]){\n                    d[i + 1][j] = tmp;\n                    path[i][j] = 1;\n                }\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(path[i][W] == 1){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n","source":"_posts/Nowcoder-Third-A.md","raw":"---\ntitle: 牛客暑期ACM多校训练营(第三场)A题-PACM Team-多维01背包+记录路径\ndate: 2018-07-26 23:16:37\ncategories:\n- ACM\ntags:\n- DP\n- 01背包\n---\nDP果然是最弱的，记录路径更是十分懵，在多校训练营里被虐的抬不起头，，，算了，只要不死，就会更强(赛亚人的特性其实也就是人的特性)\n<!-- more -->\n## 题目描述\nEddy was a contestant participating in ACM ICPC contests. ACM is short for Algorithm, Coding, Math. Since in the ACM contest, the most important knowledge is about algorithm, followed by coding(implementation ability), then math. However, in the ACM ICPC World Finals 2018, Eddy failed to solve a physics equation, which pushed him away from a potential medal.\n\nSince then on, Eddy found that physics is actually the most important thing in the contest. Thus, he wants to form a team to guide the following contestants to conquer the PACM contests(PACM is short for Physics, Algorithm, Coding, Math). \n\nThere are N candidate groups each composed of pi physics experts, ai algorithm experts, ci coding experts, mi math experts. For each group, Eddy can either invite all of them or none of them. If i-th team is invited, they will bring gi knowledge points which is calculated by Eddy's magic formula. Eddy believes that the higher the total knowledge points is, the better a team could place in a contest. But, Eddy doesn't want too many experts in the same area in the invited groups. Thus, the number of invited physics experts should not exceed P, and A for algorithm experts, C for coding experts, M for math experts.\n\nEddy is still busy in studying Physics. You come to help him to figure out which groups should be invited such that they doesn't exceed the constraint and will bring the most knowledge points in total.\n\n输入描述:\nThe first line contains a positive integer N indicating the number of candidate groups.\nEach of following N lines contains five space-separated integer pi, ai, ci, mi, gi indicating that i-th team consists of pi physics experts, ai algorithm experts, ci coding experts, mi math experts, and will bring gi knowledge points.\nThe last line contains four space-separated integer P, A, C, M indicating the maximum possible number of physics experts, algorithm experts, coding experts, and math experts, respectively.\n\n 1 ≤ N ≤ 36\n 0 ≤ pi,ai,ci,mi,gi ≤ 36\n 0 ≤ P, A, C, M ≤ 36\n输出描述:\n\nThe first line should contain a non-negative integer K indicating the number of invited groups.\nThe second line should contain K space-separated integer indicating the index of invited groups(groups are indexed from 0).\n\nYou can output index in any order as long as each index appears at most once. If there are multiple way to reach the most total knowledge points, you can output any one of them. If none of the groups will be invited, you could either output one line or output a blank line in the second line.\n示例1:\n\n输入:\n2\n1 0 2 1 10\n1 0 2 1 21\n1 0 2 1\n输出:\n1\n1\n\n示例2:\n\n输入:\n1\n2 1 1 0 31\n1 0 2 1\n输出：\n0\n\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 40;\nint p[maxn], a[maxn], c[maxn], m[maxn];\nint v[maxn];\nshort d[maxn][maxn][maxn][maxn][maxn];\nint n;\nint Pm, Am, Cm, Mm;\nint used[maxn];//记录路径\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    memset(used, 0, sizeof(used));\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d%d%d%d%d\", p + i, a + i, c + i, m + i, v + i);\n    }\n\n    scanf(\"%d%d%d%d\", &Pm, &Am, &Cm, &Mm);\n    for(int i = 0; i <= Pm; i++){\n        for(int j = 0; j <= Am; j++){\n            for(int k = 0; k <= Cm; k++){\n                for(int l = 0; l <= Mm; l++){\n                    d[0][i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= Pm; j++){\n            for(int k = 0; k <= Am; k++){\n                for(int l = 0; l <= Cm; l++){\n                    for(int q = 0; q <= Mm; q++){\n                        d[i + 1][j][k][l][q] = d[i][j][k][l][q];\n                        if(j >= p[i] && k >= a[i] && l >= c[i] && q >= m[i]){\n                            int tmp = v[i] + d[i][j - p[i]][k - a[i]][l - c[i]][q - m[i]];\n                            if(tmp > d[i + 1][j][k][l][q]) {\n                                d[i + 1][j][k][l][q] = tmp;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //记录路径部分\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][Pm][Am][Cm][Mm] != d[i][Pm][Am][Cm][Mm]){\n            used[i] = 1;\n            Pm -= p[i];\n            Am -= a[i];\n            Cm -= c[i];\n            Mm -= m[i];\n        }\n    }\n    int cnt = 0;\n    for(int i = 0; i < n; i++){\n        if(used[i] == 1){\n            cnt++;\n        }\n    }\n    printf(\"%d\\n\", cnt);\n    if(cnt){\n        for(int i = 0; i < n; i++){\n            if(used[i]) printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n## 坑点\n数据d的类型要是short类型，int类型会爆内存，char类型会数据溢出．\n\n## 背包记录路径问题总结\n### 方法一核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            if(j < w[i]){\n                d[i + 1][j] = d[i][j];\n            }\n            else{\n                d[i + 1][j] = max(d[i][j], d[i][j - w[i]] + v[i]);\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][W] != d[i][W]){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n### 方法二核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            d[i + 1][j] = d[i][j];\n            if(j >= w[i]){\n                int tmp = d[i][j - w[i]] + v[i];\n                if(tmp > d[i + 1][j]){\n                    d[i + 1][j] = tmp;\n                    path[i][j] = 1;\n                }\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(path[i][W] == 1){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n","slug":"Nowcoder-Third-A","published":1,"updated":"2018-08-09T15:58:05.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1za000hsxoux4opd8cb","content":"<p>DP果然是最弱的，记录路径更是十分懵，在多校训练营里被虐的抬不起头，，，算了，只要不死，就会更强(赛亚人的特性其实也就是人的特性)<br><a id=\"more\"></a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Eddy was a contestant participating in ACM ICPC contests. ACM is short for Algorithm, Coding, Math. Since in the ACM contest, the most important knowledge is about algorithm, followed by coding(implementation ability), then math. However, in the ACM ICPC World Finals 2018, Eddy failed to solve a physics equation, which pushed him away from a potential medal.</p>\n<p>Since then on, Eddy found that physics is actually the most important thing in the contest. Thus, he wants to form a team to guide the following contestants to conquer the PACM contests(PACM is short for Physics, Algorithm, Coding, Math). </p>\n<p>There are N candidate groups each composed of pi physics experts, ai algorithm experts, ci coding experts, mi math experts. For each group, Eddy can either invite all of them or none of them. If i-th team is invited, they will bring gi knowledge points which is calculated by Eddy’s magic formula. Eddy believes that the higher the total knowledge points is, the better a team could place in a contest. But, Eddy doesn’t want too many experts in the same area in the invited groups. Thus, the number of invited physics experts should not exceed P, and A for algorithm experts, C for coding experts, M for math experts.</p>\n<p>Eddy is still busy in studying Physics. You come to help him to figure out which groups should be invited such that they doesn’t exceed the constraint and will bring the most knowledge points in total.</p>\n<p>输入描述:<br>The first line contains a positive integer N indicating the number of candidate groups.<br>Each of following N lines contains five space-separated integer pi, ai, ci, mi, gi indicating that i-th team consists of pi physics experts, ai algorithm experts, ci coding experts, mi math experts, and will bring gi knowledge points.<br>The last line contains four space-separated integer P, A, C, M indicating the maximum possible number of physics experts, algorithm experts, coding experts, and math experts, respectively.</p>\n<p> 1 ≤ N ≤ 36<br> 0 ≤ pi,ai,ci,mi,gi ≤ 36<br> 0 ≤ P, A, C, M ≤ 36<br>输出描述:</p>\n<p>The first line should contain a non-negative integer K indicating the number of invited groups.<br>The second line should contain K space-separated integer indicating the index of invited groups(groups are indexed from 0).</p>\n<p>You can output index in any order as long as each index appears at most once. If there are multiple way to reach the most total knowledge points, you can output any one of them. If none of the groups will be invited, you could either output one line or output a blank line in the second line.<br>示例1:</p>\n<p>输入:<br>2<br>1 0 2 1 10<br>1 0 2 1 21<br>1 0 2 1<br>输出:<br>1<br>1</p>\n<p>示例2:</p>\n<p>输入:<br>1<br>2 1 1 0 31<br>1 0 2 1<br>输出：<br>0</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">40</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> p[maxn], a[maxn], c[maxn], m[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> v[maxn];</span><br><span class=\"line\"><span class=\"keyword\">short</span> d[maxn][maxn][maxn][maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Pm, Am, Cm, Mm;</span><br><span class=\"line\"><span class=\"keyword\">int</span> used[maxn];<span class=\"comment\">//记录路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(used, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(used));</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d%d\"</span>, p + i, a + i, c + i, m + i, v + i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>, &amp;Pm, &amp;Am, &amp;Cm, &amp;Mm);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= Pm; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= Am; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= Cm; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt;= Mm; l++)&#123;</span><br><span class=\"line\">                    d[<span class=\"number\">0</span>][i][j][k][l] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= Pm; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= Am; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt;= Cm; l++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> q = <span class=\"number\">0</span>; q &lt;= Mm; q++)&#123;</span><br><span class=\"line\">                        d[i + <span class=\"number\">1</span>][j][k][l][q] = d[i][j][k][l][q];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(j &gt;= p[i] &amp;&amp; k &gt;= a[i] &amp;&amp; l &gt;= c[i] &amp;&amp; q &gt;= m[i])&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> tmp = v[i] + d[i][j - p[i]][k - a[i]][l - c[i]][q - m[i]];</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(tmp &gt; d[i + <span class=\"number\">1</span>][j][k][l][q]) &#123;</span><br><span class=\"line\">                                d[i + <span class=\"number\">1</span>][j][k][l][q] = tmp;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//记录路径部分</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[i + <span class=\"number\">1</span>][Pm][Am][Cm][Mm] != d[i][Pm][Am][Cm][Mm])&#123;</span><br><span class=\"line\">            used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            Pm -= p[i];</span><br><span class=\"line\">            Am -= a[i];</span><br><span class=\"line\">            Cm -= c[i];</span><br><span class=\"line\">            Mm -= m[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(used[i] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i]) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>数据d的类型要是short类型，int类型会爆内存，char类型会数据溢出．</p>\n<h2 id=\"背包记录路径问题总结\"><a href=\"#背包记录路径问题总结\" class=\"headerlink\" title=\"背包记录路径问题总结\"></a>背包记录路径问题总结</h2><h3 id=\"方法一核心代码\"><a href=\"#方法一核心代码\" class=\"headerlink\" title=\"方法一核心代码\"></a>方法一核心代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= W; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j &lt; w[i])&#123;</span><br><span class=\"line\">            d[i + <span class=\"number\">1</span>][j] = d[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            d[i + <span class=\"number\">1</span>][j] = max(d[i][j], d[i][j - w[i]] + v[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[i + <span class=\"number\">1</span>][W] != d[i][W])&#123;</span><br><span class=\"line\">        used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        W -= w[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二核心代码\"><a href=\"#方法二核心代码\" class=\"headerlink\" title=\"方法二核心代码\"></a>方法二核心代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= W; j++)&#123;</span><br><span class=\"line\">        d[i + <span class=\"number\">1</span>][j] = d[i][j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j &gt;= w[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = d[i][j - w[i]] + v[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp &gt; d[i + <span class=\"number\">1</span>][j])&#123;</span><br><span class=\"line\">                d[i + <span class=\"number\">1</span>][j] = tmp;</span><br><span class=\"line\">                path[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(path[i][W] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        W -= w[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>DP果然是最弱的，记录路径更是十分懵，在多校训练营里被虐的抬不起头，，，算了，只要不死，就会更强(赛亚人的特性其实也就是人的特性)<br></p>","more":"<p></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Eddy was a contestant participating in ACM ICPC contests. ACM is short for Algorithm, Coding, Math. Since in the ACM contest, the most important knowledge is about algorithm, followed by coding(implementation ability), then math. However, in the ACM ICPC World Finals 2018, Eddy failed to solve a physics equation, which pushed him away from a potential medal.</p>\n<p>Since then on, Eddy found that physics is actually the most important thing in the contest. Thus, he wants to form a team to guide the following contestants to conquer the PACM contests(PACM is short for Physics, Algorithm, Coding, Math). </p>\n<p>There are N candidate groups each composed of pi physics experts, ai algorithm experts, ci coding experts, mi math experts. For each group, Eddy can either invite all of them or none of them. If i-th team is invited, they will bring gi knowledge points which is calculated by Eddy’s magic formula. Eddy believes that the higher the total knowledge points is, the better a team could place in a contest. But, Eddy doesn’t want too many experts in the same area in the invited groups. Thus, the number of invited physics experts should not exceed P, and A for algorithm experts, C for coding experts, M for math experts.</p>\n<p>Eddy is still busy in studying Physics. You come to help him to figure out which groups should be invited such that they doesn’t exceed the constraint and will bring the most knowledge points in total.</p>\n<p>输入描述:<br>The first line contains a positive integer N indicating the number of candidate groups.<br>Each of following N lines contains five space-separated integer pi, ai, ci, mi, gi indicating that i-th team consists of pi physics experts, ai algorithm experts, ci coding experts, mi math experts, and will bring gi knowledge points.<br>The last line contains four space-separated integer P, A, C, M indicating the maximum possible number of physics experts, algorithm experts, coding experts, and math experts, respectively.</p>\n<p> 1 ≤ N ≤ 36<br> 0 ≤ pi,ai,ci,mi,gi ≤ 36<br> 0 ≤ P, A, C, M ≤ 36<br>输出描述:</p>\n<p>The first line should contain a non-negative integer K indicating the number of invited groups.<br>The second line should contain K space-separated integer indicating the index of invited groups(groups are indexed from 0).</p>\n<p>You can output index in any order as long as each index appears at most once. If there are multiple way to reach the most total knowledge points, you can output any one of them. If none of the groups will be invited, you could either output one line or output a blank line in the second line.<br>示例1:</p>\n<p>输入:<br>2<br>1 0 2 1 10<br>1 0 2 1 21<br>1 0 2 1<br>输出:<br>1<br>1</p>\n<p>示例2:</p>\n<p>输入:<br>1<br>2 1 1 0 31<br>1 0 2 1<br>输出：<br>0</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">40</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> p[maxn], a[maxn], c[maxn], m[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> v[maxn];</span><br><span class=\"line\"><span class=\"keyword\">short</span> d[maxn][maxn][maxn][maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Pm, Am, Cm, Mm;</span><br><span class=\"line\"><span class=\"keyword\">int</span> used[maxn];<span class=\"comment\">//记录路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(used, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(used));</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d%d\"</span>, p + i, a + i, c + i, m + i, v + i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>, &amp;Pm, &amp;Am, &amp;Cm, &amp;Mm);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= Pm; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= Am; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= Cm; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt;= Mm; l++)&#123;</span><br><span class=\"line\">                    d[<span class=\"number\">0</span>][i][j][k][l] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= Pm; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= Am; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt;= Cm; l++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> q = <span class=\"number\">0</span>; q &lt;= Mm; q++)&#123;</span><br><span class=\"line\">                        d[i + <span class=\"number\">1</span>][j][k][l][q] = d[i][j][k][l][q];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(j &gt;= p[i] &amp;&amp; k &gt;= a[i] &amp;&amp; l &gt;= c[i] &amp;&amp; q &gt;= m[i])&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> tmp = v[i] + d[i][j - p[i]][k - a[i]][l - c[i]][q - m[i]];</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(tmp &gt; d[i + <span class=\"number\">1</span>][j][k][l][q]) &#123;</span><br><span class=\"line\">                                d[i + <span class=\"number\">1</span>][j][k][l][q] = tmp;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//记录路径部分</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[i + <span class=\"number\">1</span>][Pm][Am][Cm][Mm] != d[i][Pm][Am][Cm][Mm])&#123;</span><br><span class=\"line\">            used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            Pm -= p[i];</span><br><span class=\"line\">            Am -= a[i];</span><br><span class=\"line\">            Cm -= c[i];</span><br><span class=\"line\">            Mm -= m[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(used[i] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i]) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>数据d的类型要是short类型，int类型会爆内存，char类型会数据溢出．</p>\n<h2 id=\"背包记录路径问题总结\"><a href=\"#背包记录路径问题总结\" class=\"headerlink\" title=\"背包记录路径问题总结\"></a>背包记录路径问题总结</h2><h3 id=\"方法一核心代码\"><a href=\"#方法一核心代码\" class=\"headerlink\" title=\"方法一核心代码\"></a>方法一核心代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= W; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j &lt; w[i])&#123;</span><br><span class=\"line\">            d[i + <span class=\"number\">1</span>][j] = d[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            d[i + <span class=\"number\">1</span>][j] = max(d[i][j], d[i][j - w[i]] + v[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[i + <span class=\"number\">1</span>][W] != d[i][W])&#123;</span><br><span class=\"line\">        used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        W -= w[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二核心代码\"><a href=\"#方法二核心代码\" class=\"headerlink\" title=\"方法二核心代码\"></a>方法二核心代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= W; j++)&#123;</span><br><span class=\"line\">        d[i + <span class=\"number\">1</span>][j] = d[i][j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j &gt;= w[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = d[i][j - w[i]] + v[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp &gt; d[i + <span class=\"number\">1</span>][j])&#123;</span><br><span class=\"line\">                d[i + <span class=\"number\">1</span>][j] = tmp;</span><br><span class=\"line\">                path[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(path[i][W] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        W -= w[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"hdu-5092","date":"2018-06-05T12:28:06.000Z","_content":"","source":"_posts/HDU5092.md","raw":"---\ntitle: hdu-5092\ndate: 2018-06-05 20:28:06\ncategories:\ntags:\n---\n","slug":"HDU5092","published":1,"updated":"2018-06-05T12:28:06.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1zf000msxoudbfeopby","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"牛客暑期ACM多校训练营(第四场)G题-Maxinum Mode-思维+map","date":"2018-07-29T12:06:46.000Z","_content":"一道逆向思维的好题,比赛的时候没有做出来,赛后补题的时候按原来的思路写出来了,然而代码超时了= =,阅读了别人的代码后发现自己想复杂了,从逆向来考虑感觉非常巧妙,思路也很顺畅.从正向考虑反而要顾及很多情况,可能就是因为考虑的太多代码冗余就TLE了.\n<!-- more -->\n## 链接\n[Nowcoder-Fourth-G](https://www.nowcoder.com/acm/contest/142/G)\n## 题目描述\nThe mode of an integer sequence is the value that appears most often. Chiaki has n integers a1,a2,...,an. She woud like to delete exactly m of them such that: the rest integers have only one mode and the mode is maximum.\n输入描述:\nThere are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:\nThe first line contains two integers n and m (1 ≤ n ≤ 105, 0 ≤ m < n) -- the length of the sequence and the number of integers to delete.\nThe second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) denoting the sequence.\nIt is guaranteed that the sum of all n does not exceed 106.\n输出描述:\nFor each test case, output an integer denoting the only maximum mode, or -1 if Chiaki cannot achieve it.\n输入:\n5\n5 0\n2 2 3 3 4\n5 1\n2 2 3 3 4\n5 2\n2 2 3 3 4\n5 3\n2 2 3 3 4\n5 4\n2 2 3 3 4\n输出:\n-1\n3\n3\n3\n4\n## 题解\n题目大意是给定n个数,从这n个数中删掉m个数,使得出现次数最多的数只有一个且要求尽量大.求解这个出现次数最多的数.\n思路:\nmap存数据及数据个数, 按键值从大到小排(实际上map会按键值从小到大自动排列,那么就从后往前判断就好了).然后不考虑删除数的情况而是考虑剩余数(逆向思维)的情况,首先判断剩余数的个数是否小于等于最大值的个数,若满足则最终的结果就是最大值;若不满足则把剩余的数进行分配,看是否可以在满足min(d[max] - 1,d[i])的分配条件下将剩余的数分配完(其中d[i]表示第i个数的个数,用d[max]表示了最大的数的个数),如果可以分配完则最终结果就是最大值.若最大值不能满足上述情况则考虑次大值,以此类推,若全都不满足则无解,输出-1.\n\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\ntypedef pair<int, int> P;\nP d[maxn];\nint t;\nint n, m;\nmap<int, int> mp;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &t);\n    while(t--){\n        mp.clear();\n        scanf(\"%d%d\", &n, &m);\n        int tmp;\n        for(int i = 0; i < n; i++){\n            scanf(\"%d\", &tmp);\n            mp[tmp]++;\n        }\n        \n        int cnt = 0;\n        for(auto x : mp){\n            d[cnt].first = x.first;\n            d[cnt].second = x.second;\n            cnt++;\n        }\n        \n        int flag = 0;\n        int rem = n - m;//剩余数的个数\n        int i;\n        for(i = cnt - 1; i >= 0; i--){\n            int res = rem - d[i].second;\n            if(res <= 0){\n                flag = 1;\n                break;\n            }\n            for(int j = 0; j < cnt; j++){\n                if(j == i) continue;\n                res -= min(d[i].second - 1, d[j].second);\n                if(res <= 0){\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag) break;\n        }\n        \n        if(flag) printf(\"%d\\n\", d[i].first);\n        else printf(\"-1\\n\");\n    }\n    \n    return 0;\n}\n```","source":"_posts/Nowcoder-Fourth-G.md","raw":"---\ntitle: 牛客暑期ACM多校训练营(第四场)G题-Maxinum Mode-思维+map\ndate: 2018-07-29 20:06:46\ncategories:\n- ACM\ntags:\n- 逆向思维\n---\n一道逆向思维的好题,比赛的时候没有做出来,赛后补题的时候按原来的思路写出来了,然而代码超时了= =,阅读了别人的代码后发现自己想复杂了,从逆向来考虑感觉非常巧妙,思路也很顺畅.从正向考虑反而要顾及很多情况,可能就是因为考虑的太多代码冗余就TLE了.\n<!-- more -->\n## 链接\n[Nowcoder-Fourth-G](https://www.nowcoder.com/acm/contest/142/G)\n## 题目描述\nThe mode of an integer sequence is the value that appears most often. Chiaki has n integers a1,a2,...,an. She woud like to delete exactly m of them such that: the rest integers have only one mode and the mode is maximum.\n输入描述:\nThere are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:\nThe first line contains two integers n and m (1 ≤ n ≤ 105, 0 ≤ m < n) -- the length of the sequence and the number of integers to delete.\nThe second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) denoting the sequence.\nIt is guaranteed that the sum of all n does not exceed 106.\n输出描述:\nFor each test case, output an integer denoting the only maximum mode, or -1 if Chiaki cannot achieve it.\n输入:\n5\n5 0\n2 2 3 3 4\n5 1\n2 2 3 3 4\n5 2\n2 2 3 3 4\n5 3\n2 2 3 3 4\n5 4\n2 2 3 3 4\n输出:\n-1\n3\n3\n3\n4\n## 题解\n题目大意是给定n个数,从这n个数中删掉m个数,使得出现次数最多的数只有一个且要求尽量大.求解这个出现次数最多的数.\n思路:\nmap存数据及数据个数, 按键值从大到小排(实际上map会按键值从小到大自动排列,那么就从后往前判断就好了).然后不考虑删除数的情况而是考虑剩余数(逆向思维)的情况,首先判断剩余数的个数是否小于等于最大值的个数,若满足则最终的结果就是最大值;若不满足则把剩余的数进行分配,看是否可以在满足min(d[max] - 1,d[i])的分配条件下将剩余的数分配完(其中d[i]表示第i个数的个数,用d[max]表示了最大的数的个数),如果可以分配完则最终结果就是最大值.若最大值不能满足上述情况则考虑次大值,以此类推,若全都不满足则无解,输出-1.\n\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\ntypedef pair<int, int> P;\nP d[maxn];\nint t;\nint n, m;\nmap<int, int> mp;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &t);\n    while(t--){\n        mp.clear();\n        scanf(\"%d%d\", &n, &m);\n        int tmp;\n        for(int i = 0; i < n; i++){\n            scanf(\"%d\", &tmp);\n            mp[tmp]++;\n        }\n        \n        int cnt = 0;\n        for(auto x : mp){\n            d[cnt].first = x.first;\n            d[cnt].second = x.second;\n            cnt++;\n        }\n        \n        int flag = 0;\n        int rem = n - m;//剩余数的个数\n        int i;\n        for(i = cnt - 1; i >= 0; i--){\n            int res = rem - d[i].second;\n            if(res <= 0){\n                flag = 1;\n                break;\n            }\n            for(int j = 0; j < cnt; j++){\n                if(j == i) continue;\n                res -= min(d[i].second - 1, d[j].second);\n                if(res <= 0){\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag) break;\n        }\n        \n        if(flag) printf(\"%d\\n\", d[i].first);\n        else printf(\"-1\\n\");\n    }\n    \n    return 0;\n}\n```","slug":"Nowcoder-Fourth-G","published":1,"updated":"2018-08-09T15:55:06.075Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1zj000psxou5i4q7048","content":"<p>一道逆向思维的好题,比赛的时候没有做出来,赛后补题的时候按原来的思路写出来了,然而代码超时了= =,阅读了别人的代码后发现自己想复杂了,从逆向来考虑感觉非常巧妙,思路也很顺畅.从正向考虑反而要顾及很多情况,可能就是因为考虑的太多代码冗余就TLE了.<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.nowcoder.com/acm/contest/142/G\" target=\"_blank\" rel=\"noopener\">Nowcoder-Fourth-G</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>The mode of an integer sequence is the value that appears most often. Chiaki has n integers a1,a2,…,an. She woud like to delete exactly m of them such that: the rest integers have only one mode and the mode is maximum.<br>输入描述:<br>There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:<br>The first line contains two integers n and m (1 ≤ n ≤ 105, 0 ≤ m &lt; n) – the length of the sequence and the number of integers to delete.<br>The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 109) denoting the sequence.<br>It is guaranteed that the sum of all n does not exceed 106.<br>输出描述:<br>For each test case, output an integer denoting the only maximum mode, or -1 if Chiaki cannot achieve it.<br>输入:<br>5<br>5 0<br>2 2 3 3 4<br>5 1<br>2 2 3 3 4<br>5 2<br>2 2 3 3 4<br>5 3<br>2 2 3 3 4<br>5 4<br>2 2 3 3 4<br>输出:<br>-1<br>3<br>3<br>3<br>4</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意是给定n个数,从这n个数中删掉m个数,使得出现次数最多的数只有一个且要求尽量大.求解这个出现次数最多的数.<br>思路:<br>map存数据及数据个数, 按键值从大到小排(实际上map会按键值从小到大自动排列,那么就从后往前判断就好了).然后不考虑删除数的情况而是考虑剩余数(逆向思维)的情况,首先判断剩余数的个数是否小于等于最大值的个数,若满足则最终的结果就是最大值;若不满足则把剩余的数进行分配,看是否可以在满足min(d[max] - 1,d[i])的分配条件下将剩余的数分配完(其中d[i]表示第i个数的个数,用d[max]表示了最大的数的个数),如果可以分配完则最终结果就是最大值.若最大值不能满足上述情况则考虑次大值,以此类推,若全都不满足则无解,输出-1.</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\">P d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        mp.clear();</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;tmp);</span><br><span class=\"line\">            mp[tmp]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : mp)&#123;</span><br><span class=\"line\">            d[cnt].first = x.first;</span><br><span class=\"line\">            d[cnt].second = x.second;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rem = n - m;<span class=\"comment\">//剩余数的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = cnt - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> res = rem - d[i].second;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(res &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cnt; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j == i) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                res -= min(d[i].second - <span class=\"number\">1</span>, d[j].second);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(res &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, d[i].first);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>一道逆向思维的好题,比赛的时候没有做出来,赛后补题的时候按原来的思路写出来了,然而代码超时了= =,阅读了别人的代码后发现自己想复杂了,从逆向来考虑感觉非常巧妙,思路也很顺畅.从正向考虑反而要顾及很多情况,可能就是因为考虑的太多代码冗余就TLE了.<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.nowcoder.com/acm/contest/142/G\" target=\"_blank\" rel=\"noopener\">Nowcoder-Fourth-G</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>The mode of an integer sequence is the value that appears most often. Chiaki has n integers a1,a2,…,an. She woud like to delete exactly m of them such that: the rest integers have only one mode and the mode is maximum.<br>输入描述:<br>There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:<br>The first line contains two integers n and m (1 ≤ n ≤ 105, 0 ≤ m &lt; n) – the length of the sequence and the number of integers to delete.<br>The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 109) denoting the sequence.<br>It is guaranteed that the sum of all n does not exceed 106.<br>输出描述:<br>For each test case, output an integer denoting the only maximum mode, or -1 if Chiaki cannot achieve it.<br>输入:<br>5<br>5 0<br>2 2 3 3 4<br>5 1<br>2 2 3 3 4<br>5 2<br>2 2 3 3 4<br>5 3<br>2 2 3 3 4<br>5 4<br>2 2 3 3 4<br>输出:<br>-1<br>3<br>3<br>3<br>4</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意是给定n个数,从这n个数中删掉m个数,使得出现次数最多的数只有一个且要求尽量大.求解这个出现次数最多的数.<br>思路:<br>map存数据及数据个数, 按键值从大到小排(实际上map会按键值从小到大自动排列,那么就从后往前判断就好了).然后不考虑删除数的情况而是考虑剩余数(逆向思维)的情况,首先判断剩余数的个数是否小于等于最大值的个数,若满足则最终的结果就是最大值;若不满足则把剩余的数进行分配,看是否可以在满足min(d[max] - 1,d[i])的分配条件下将剩余的数分配完(其中d[i]表示第i个数的个数,用d[max]表示了最大的数的个数),如果可以分配完则最终结果就是最大值.若最大值不能满足上述情况则考虑次大值,以此类推,若全都不满足则无解,输出-1.</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\">P d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        mp.clear();</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;tmp);</span><br><span class=\"line\">            mp[tmp]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : mp)&#123;</span><br><span class=\"line\">            d[cnt].first = x.first;</span><br><span class=\"line\">            d[cnt].second = x.second;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rem = n - m;<span class=\"comment\">//剩余数的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = cnt - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> res = rem - d[i].second;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(res &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cnt; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j == i) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                res -= min(d[i].second - <span class=\"number\">1</span>, d[j].second);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(res &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, d[i].first);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva12096-The SetStack Computer-STL","date":"2018-08-09T14:44:02.000Z","_content":"最近在看刘汝佳老师的《算法竞赛入门经典（第2版）》，收获很大，很多知识都在上面查漏补缺，书上有一道STL的例题，用到了stack、vector、map、set，而且“化集合为ID”的思路很好，记录一下。\n<!-- more -->\n## 链接\n[Uva12096-The SetStack Computer](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3248)\n## 题目描述\n有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且支持一下操作。\n- PUSH:空集“{}”入栈。\n- DUP:把当前栈顶元素复制一份后再入栈。\n- UNION:出栈两个集合，然后把二者的并集入栈。\n- INTERSECT:出栈两个集合，然后把出栈的集合加入到后出栈的集合中，把结果入栈。\n\n每次操作后，输出栈顶集合的大小（即元素个数）。\n\n## 题解\n本题的集合并不是简单的整数集合或者字符串集合，而是集合的集合。为了方便为每个不同的集合分配一个唯一的ID，则每个集合都可以表示成所包含元素的ID的集合，这样就可以用STL的set<int> 来表示了，而整个栈则是一个stack<int>。map用来把集合映射成ID，vector则根据ID取集合。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu  9 Aug 16:19:36 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nint n;\ntypedef set<int> Set;\nmap<Set, int> mp;\nvector<Set> vec;\n\nint ID(Set st){\n    if(mp.count(st)) return mp[st];\n    vec.push_back(st);\n    return mp[st] = vec.size() - 1;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        cin >> n;\n        stack<int> stc;\n        string s;\n        vec.clear();\n        mp.clear();\n        for(int i = 0; i < n; i++){\n            cin >> s;\n            if(s[0] == 'P') stc.push(ID(Set ()));\n            else if(s[0] == 'D') stc.push(stc.top());\n            else{\n                Set st1 = vec[stc.top()]; stc.pop();\n                Set st2 = vec[stc.top()]; stc.pop();\n                Set st;\n                if(s[0] == 'U') set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'I') set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'A') {st = st2; st.insert(ID(st1));}\n                stc.push(ID(st));\n            }\n            cout << vec[stc.top()].size() << endl;\n        }\n        cout << \"***\" << endl;\n    }\n    \n    return 0;\n}\n```\n## 补充\n### 并集\n对两个集合取交集可以使用std::set_union，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n### 交集\n对两个集合取交集可以使用std::set_intersection，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n类似的还有：\n- set_difference:差集，从第一个区间去除第二个区间的元素。\n- set_merge:合并，与set_union不同，set_merge不会去除重复的元素（不能用于set，可用于vector）。\n\n注意：set_union和set_intersection等也可用于vector，但必须是排好序的vector。\n","source":"_posts/Uva12096-The-SetStack-Computer-STL.md","raw":"---\ntitle: Uva12096-The SetStack Computer-STL\ndate: 2018-08-09 22:44:02\ncategories:\n- ACM\ntags:\n- stack\n- STL\n---\n最近在看刘汝佳老师的《算法竞赛入门经典（第2版）》，收获很大，很多知识都在上面查漏补缺，书上有一道STL的例题，用到了stack、vector、map、set，而且“化集合为ID”的思路很好，记录一下。\n<!-- more -->\n## 链接\n[Uva12096-The SetStack Computer](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3248)\n## 题目描述\n有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且支持一下操作。\n- PUSH:空集“{}”入栈。\n- DUP:把当前栈顶元素复制一份后再入栈。\n- UNION:出栈两个集合，然后把二者的并集入栈。\n- INTERSECT:出栈两个集合，然后把出栈的集合加入到后出栈的集合中，把结果入栈。\n\n每次操作后，输出栈顶集合的大小（即元素个数）。\n\n## 题解\n本题的集合并不是简单的整数集合或者字符串集合，而是集合的集合。为了方便为每个不同的集合分配一个唯一的ID，则每个集合都可以表示成所包含元素的ID的集合，这样就可以用STL的set<int> 来表示了，而整个栈则是一个stack<int>。map用来把集合映射成ID，vector则根据ID取集合。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu  9 Aug 16:19:36 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nint n;\ntypedef set<int> Set;\nmap<Set, int> mp;\nvector<Set> vec;\n\nint ID(Set st){\n    if(mp.count(st)) return mp[st];\n    vec.push_back(st);\n    return mp[st] = vec.size() - 1;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        cin >> n;\n        stack<int> stc;\n        string s;\n        vec.clear();\n        mp.clear();\n        for(int i = 0; i < n; i++){\n            cin >> s;\n            if(s[0] == 'P') stc.push(ID(Set ()));\n            else if(s[0] == 'D') stc.push(stc.top());\n            else{\n                Set st1 = vec[stc.top()]; stc.pop();\n                Set st2 = vec[stc.top()]; stc.pop();\n                Set st;\n                if(s[0] == 'U') set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'I') set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'A') {st = st2; st.insert(ID(st1));}\n                stc.push(ID(st));\n            }\n            cout << vec[stc.top()].size() << endl;\n        }\n        cout << \"***\" << endl;\n    }\n    \n    return 0;\n}\n```\n## 补充\n### 并集\n对两个集合取交集可以使用std::set_union，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n### 交集\n对两个集合取交集可以使用std::set_intersection，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n类似的还有：\n- set_difference:差集，从第一个区间去除第二个区间的元素。\n- set_merge:合并，与set_union不同，set_merge不会去除重复的元素（不能用于set，可用于vector）。\n\n注意：set_union和set_intersection等也可用于vector，但必须是排好序的vector。\n","slug":"Uva12096-The-SetStack-Computer-STL","published":1,"updated":"2018-08-10T02:10:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1zl000ssxouba7d0cgm","content":"<p>最近在看刘汝佳老师的《算法竞赛入门经典（第2版）》，收获很大，很多知识都在上面查漏补缺，书上有一道STL的例题，用到了stack、vector、map、set，而且“化集合为ID”的思路很好，记录一下。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3248\" target=\"_blank\" rel=\"noopener\">Uva12096-The SetStack Computer</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且支持一下操作。</p>\n<ul>\n<li>PUSH:空集“{}”入栈。</li>\n<li>DUP:把当前栈顶元素复制一份后再入栈。</li>\n<li>UNION:出栈两个集合，然后把二者的并集入栈。</li>\n<li>INTERSECT:出栈两个集合，然后把出栈的集合加入到后出栈的集合中，把结果入栈。</li>\n</ul>\n<p>每次操作后，输出栈顶集合的大小（即元素个数）。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>本题的集合并不是简单的整数集合或者字符串集合，而是集合的集合。为了方便为每个不同的集合分配一个唯一的ID，则每个集合都可以表示成所包含元素的ID的集合，这样就可以用STL的set<int> 来表示了，而整个栈则是一个stack<int>。map用来把集合映射成ID，vector则根据ID取集合。</int></int></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Thu  9 Aug 16:19:36 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; Set;</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;Set, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Set&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ID</span><span class=\"params\">(Set st)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mp.count(st)) <span class=\"keyword\">return</span> mp[st];</span><br><span class=\"line\">    vec.push_back(st);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mp[st] = vec.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stc;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        mp.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'P'</span>) stc.push(ID(Set ()));</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'D'</span>) stc.push(stc.top());</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                Set st1 = vec[stc.top()]; stc.pop();</span><br><span class=\"line\">                Set st2 = vec[stc.top()]; stc.pop();</span><br><span class=\"line\">                Set st;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'U'</span>) set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'I'</span>) set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'A'</span>) &#123;st = st2; st.insert(ID(st1));&#125;</span><br><span class=\"line\">                stc.push(ID(st));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; vec[stc.top()].size() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"***\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"并集\"><a href=\"#并集\" class=\"headerlink\" title=\"并集\"></a>并集</h3><p>对两个集合取交集可以使用std::set_union，该函数需要两对迭代器，以及一个输出迭代器。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st1;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st2;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"交集\"><a href=\"#交集\" class=\"headerlink\" title=\"交集\"></a>交集</h3><p>对两个集合取交集可以使用std::set_intersection，该函数需要两对迭代器，以及一个输出迭代器。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st1;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st2;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br></pre></td></tr></table></figure></p>\n<p>类似的还有：</p>\n<ul>\n<li>set_difference:差集，从第一个区间去除第二个区间的元素。</li>\n<li>set_merge:合并，与set_union不同，set_merge不会去除重复的元素（不能用于set，可用于vector）。</li>\n</ul>\n<p>注意：set_union和set_intersection等也可用于vector，但必须是排好序的vector。</p>\n","site":{"data":{}},"excerpt":"<p>最近在看刘汝佳老师的《算法竞赛入门经典（第2版）》，收获很大，很多知识都在上面查漏补缺，书上有一道STL的例题，用到了stack、vector、map、set，而且“化集合为ID”的思路很好，记录一下。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3248\" target=\"_blank\" rel=\"noopener\">Uva12096-The SetStack Computer</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且支持一下操作。</p>\n<ul>\n<li>PUSH:空集“{}”入栈。</li>\n<li>DUP:把当前栈顶元素复制一份后再入栈。</li>\n<li>UNION:出栈两个集合，然后把二者的并集入栈。</li>\n<li>INTERSECT:出栈两个集合，然后把出栈的集合加入到后出栈的集合中，把结果入栈。</li>\n</ul>\n<p>每次操作后，输出栈顶集合的大小（即元素个数）。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>本题的集合并不是简单的整数集合或者字符串集合，而是集合的集合。为了方便为每个不同的集合分配一个唯一的ID，则每个集合都可以表示成所包含元素的ID的集合，这样就可以用STL的set<int> 来表示了，而整个栈则是一个stack<int>。map用来把集合映射成ID，vector则根据ID取集合。</int></int></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Thu  9 Aug 16:19:36 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; Set;</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;Set, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Set&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ID</span><span class=\"params\">(Set st)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mp.count(st)) <span class=\"keyword\">return</span> mp[st];</span><br><span class=\"line\">    vec.push_back(st);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mp[st] = vec.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stc;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        mp.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'P'</span>) stc.push(ID(Set ()));</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'D'</span>) stc.push(stc.top());</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                Set st1 = vec[stc.top()]; stc.pop();</span><br><span class=\"line\">                Set st2 = vec[stc.top()]; stc.pop();</span><br><span class=\"line\">                Set st;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'U'</span>) set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'I'</span>) set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'A'</span>) &#123;st = st2; st.insert(ID(st1));&#125;</span><br><span class=\"line\">                stc.push(ID(st));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; vec[stc.top()].size() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"***\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"并集\"><a href=\"#并集\" class=\"headerlink\" title=\"并集\"></a>并集</h3><p>对两个集合取交集可以使用std::set_union，该函数需要两对迭代器，以及一个输出迭代器。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st1;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st2;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"交集\"><a href=\"#交集\" class=\"headerlink\" title=\"交集\"></a>交集</h3><p>对两个集合取交集可以使用std::set_intersection，该函数需要两对迭代器，以及一个输出迭代器。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st1;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st2;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br></pre></td></tr></table></figure></p>\n<p>类似的还有：</p>\n<ul>\n<li>set_difference:差集，从第一个区间去除第二个区间的元素。</li>\n<li>set_merge:合并，与set_union不同，set_merge不会去除重复的元素（不能用于set，可用于vector）。</li>\n</ul>\n<p>注意：set_union和set_intersection等也可用于vector，但必须是排好序的vector。</p>"},{"title":"hexo中mathjax使用坑点","date":"2018-04-09T07:29:50.000Z","_content":"刚刚开始自己的博客之旅，开始真是无比艰难啊，各种被坑。过程中博客需要插入数学公式，下载了mathjax插件(安装之后就可以使用Latex定义的宏写数学公式了)，结果被坑惨(也不算是mathjax的锅，markdown自己也要背)，卡了2个小时，气愤(╯‵□′)╯︵┻━┻\n这里记录一下在mathjax里踩到的坑。\nmathjax的安装配置和使用大家可以参照[Steven's space的博文](http://stevenshi.me/2017/06/26/hexo-insert-formula/)，不再赘述了。\n<!-- more -->\n## 坑点\nmarkdown本身的特殊符号和Latex中的符号会出现冲突。\n- 下划线\\_在markdown中是斜体，但是Latex中下划线是下标的意思，所以这里会冲突。\n- 双斜线\\\\\\\\在markdown中会被转义为\\，所以Latex的\\\\\\\\换行功能也会不正常。\n- 乘法符号\\*在markdown中是粗体＝＝(就是在这被卡了)，所以Latex在写两个数相乘时不能直接写\n```\n$a*b$\n```\n以上情况都会导致无法在mathjax中渲染出来。\n\n## 解决方法\n手动转义：\n比如需要在公式中写乘法*可以写成\n```\n$a\\*b$\n```\n下标写成\n```\n$a\\_1$\n```\n换行写成\n```\n$\\\\\\\\$\n```\n解决，散花。\n\n更多解决方法可以参考[hexo下mathjax的转义问题](http://shomy.top/2016/10/22/hexo-markdown-mathjax/)\n","source":"_posts/hexo-mathjax.md","raw":"---\ntitle: hexo中mathjax使用坑点\ndate: 2018-04-09 15:29:50\ncategories:\n- Messy article\ntags:\n- mathjax\n- hexo插入数学公式\n- 总结\n---\n刚刚开始自己的博客之旅，开始真是无比艰难啊，各种被坑。过程中博客需要插入数学公式，下载了mathjax插件(安装之后就可以使用Latex定义的宏写数学公式了)，结果被坑惨(也不算是mathjax的锅，markdown自己也要背)，卡了2个小时，气愤(╯‵□′)╯︵┻━┻\n这里记录一下在mathjax里踩到的坑。\nmathjax的安装配置和使用大家可以参照[Steven's space的博文](http://stevenshi.me/2017/06/26/hexo-insert-formula/)，不再赘述了。\n<!-- more -->\n## 坑点\nmarkdown本身的特殊符号和Latex中的符号会出现冲突。\n- 下划线\\_在markdown中是斜体，但是Latex中下划线是下标的意思，所以这里会冲突。\n- 双斜线\\\\\\\\在markdown中会被转义为\\，所以Latex的\\\\\\\\换行功能也会不正常。\n- 乘法符号\\*在markdown中是粗体＝＝(就是在这被卡了)，所以Latex在写两个数相乘时不能直接写\n```\n$a*b$\n```\n以上情况都会导致无法在mathjax中渲染出来。\n\n## 解决方法\n手动转义：\n比如需要在公式中写乘法*可以写成\n```\n$a\\*b$\n```\n下标写成\n```\n$a\\_1$\n```\n换行写成\n```\n$\\\\\\\\$\n```\n解决，散花。\n\n更多解决方法可以参考[hexo下mathjax的转义问题](http://shomy.top/2016/10/22/hexo-markdown-mathjax/)\n","slug":"hexo-mathjax","published":1,"updated":"2018-08-09T15:47:10.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1zm000vsxouevjay3b2","content":"<p>刚刚开始自己的博客之旅，开始真是无比艰难啊，各种被坑。过程中博客需要插入数学公式，下载了mathjax插件(安装之后就可以使用Latex定义的宏写数学公式了)，结果被坑惨(也不算是mathjax的锅，markdown自己也要背)，卡了2个小时，气愤(╯‵□′)╯︵┻━┻<br>这里记录一下在mathjax里踩到的坑。<br>mathjax的安装配置和使用大家可以参照<a href=\"http://stevenshi.me/2017/06/26/hexo-insert-formula/\" target=\"_blank\" rel=\"noopener\">Steven’s space的博文</a>，不再赘述了。<br><a id=\"more\"></a></p>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>markdown本身的特殊符号和Latex中的符号会出现冲突。</p>\n<ul>\n<li>下划线_在markdown中是斜体，但是Latex中下划线是下标的意思，所以这里会冲突。</li>\n<li>双斜线\\\\在markdown中会被转义为\\，所以Latex的\\\\换行功能也会不正常。</li>\n<li>乘法符号*在markdown中是粗体＝＝(就是在这被卡了)，所以Latex在写两个数相乘时不能直接写<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a*b$</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上情况都会导致无法在mathjax中渲染出来。</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>手动转义：<br>比如需要在公式中写乘法*可以写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a\\*b$</span><br></pre></td></tr></table></figure></p>\n<p>下标写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a\\_1$</span><br></pre></td></tr></table></figure></p>\n<p>换行写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$\\\\\\\\$</span><br></pre></td></tr></table></figure></p>\n<p>解决，散花。</p>\n<p>更多解决方法可以参考<a href=\"http://shomy.top/2016/10/22/hexo-markdown-mathjax/\" target=\"_blank\" rel=\"noopener\">hexo下mathjax的转义问题</a></p>\n","site":{"data":{}},"excerpt":"<p>刚刚开始自己的博客之旅，开始真是无比艰难啊，各种被坑。过程中博客需要插入数学公式，下载了mathjax插件(安装之后就可以使用Latex定义的宏写数学公式了)，结果被坑惨(也不算是mathjax的锅，markdown自己也要背)，卡了2个小时，气愤(╯‵□′)╯︵┻━┻<br>这里记录一下在mathjax里踩到的坑。<br>mathjax的安装配置和使用大家可以参照<a href=\"http://stevenshi.me/2017/06/26/hexo-insert-formula/\" target=\"_blank\" rel=\"noopener\">Steven’s space的博文</a>，不再赘述了。<br></p>","more":"<p></p>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>markdown本身的特殊符号和Latex中的符号会出现冲突。</p>\n<ul>\n<li>下划线_在markdown中是斜体，但是Latex中下划线是下标的意思，所以这里会冲突。</li>\n<li>双斜线\\\\在markdown中会被转义为\\，所以Latex的\\\\换行功能也会不正常。</li>\n<li>乘法符号*在markdown中是粗体＝＝(就是在这被卡了)，所以Latex在写两个数相乘时不能直接写<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a*b$</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上情况都会导致无法在mathjax中渲染出来。</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>手动转义：<br>比如需要在公式中写乘法*可以写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a\\*b$</span><br></pre></td></tr></table></figure></p>\n<p>下标写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a\\_1$</span><br></pre></td></tr></table></figure></p>\n<p>换行写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$\\\\\\\\$</span><br></pre></td></tr></table></figure></p>\n<p>解决，散花。</p>\n<p>更多解决方法可以参考<a href=\"http://shomy.top/2016/10/22/hexo-markdown-mathjax/\" target=\"_blank\" rel=\"noopener\">hexo下mathjax的转义问题</a></p>"},{"title":"新起点","date":"2018-04-08T15:12:00.000Z","_content":"搭一个自己的独立博客的想法记得从去年暑假就有了，可是当时还是小菜鸡蛋，什么都不懂＝＝，现在孵成了小菜鸡，才终于磨磨蹭蹭的搭了起来，内心还是十分激动的(〃∇〃)，其间走了很多弯路，陷进了很多坑，感谢[CrazyMilk的这篇博文](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)以及[陶司机](http://logqtainia.github.io/)的指导，感谢女票的支持，也感谢自己没有就此放弃ヽ(•̀ω•́ )ゝ。\n<!-- more -->\n### 为什么要搭建独立博客\n最近３个月左右，一直在跟着校内的ACM队进行训练，最初是想提高自己的编程能力，后来发现自己无论对这个团队还是对这项竞赛都有一种由衷的向往，虽然最后因为个人能力以及年级太高(大三下)等方面因素没能成为正式队员，但还是想至少沿这个方向走下去。从接触ACM开始后就发现，优秀的人实在太多太多，自己会的实在太少太少，都不敢以菜鸡自称，简直是菜鸡蛋2333\n所以想在这里记录自己的成长，努力成为一个优秀的人。我也十分赞同CrazyMilk博主提到的Litten（Yilia主题的制作者）说的那句话：有了一个独立博客，就有了属于自己的一片田，开始默默耕作。\n等到自己不再是小菜鸡的那一天再回头来看那个曾经的小菜鸡的成长历程，应该会别有一番滋味吧，哈哈，期待。\n\nHello, Aincrad.\n\n要去耕作了(ง •̀_•́)ง，告辞。\n\nPs:博客框架采用hexo,及其经典的next主题。\n","source":"_posts/new start point.md","raw":"---\ntitle: 新起点\ndate : 2018-04-08 23:12:00\ncategories:\n- Diary\ntags:\n- 生活\n- 总结\n---\n搭一个自己的独立博客的想法记得从去年暑假就有了，可是当时还是小菜鸡蛋，什么都不懂＝＝，现在孵成了小菜鸡，才终于磨磨蹭蹭的搭了起来，内心还是十分激动的(〃∇〃)，其间走了很多弯路，陷进了很多坑，感谢[CrazyMilk的这篇博文](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)以及[陶司机](http://logqtainia.github.io/)的指导，感谢女票的支持，也感谢自己没有就此放弃ヽ(•̀ω•́ )ゝ。\n<!-- more -->\n### 为什么要搭建独立博客\n最近３个月左右，一直在跟着校内的ACM队进行训练，最初是想提高自己的编程能力，后来发现自己无论对这个团队还是对这项竞赛都有一种由衷的向往，虽然最后因为个人能力以及年级太高(大三下)等方面因素没能成为正式队员，但还是想至少沿这个方向走下去。从接触ACM开始后就发现，优秀的人实在太多太多，自己会的实在太少太少，都不敢以菜鸡自称，简直是菜鸡蛋2333\n所以想在这里记录自己的成长，努力成为一个优秀的人。我也十分赞同CrazyMilk博主提到的Litten（Yilia主题的制作者）说的那句话：有了一个独立博客，就有了属于自己的一片田，开始默默耕作。\n等到自己不再是小菜鸡的那一天再回头来看那个曾经的小菜鸡的成长历程，应该会别有一番滋味吧，哈哈，期待。\n\nHello, Aincrad.\n\n要去耕作了(ง •̀_•́)ง，告辞。\n\nPs:博客框架采用hexo,及其经典的next主题。\n","slug":"new start point","published":1,"updated":"2018-08-09T16:01:33.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1zo000xsxou3xczcgi3","content":"<p>搭一个自己的独立博客的想法记得从去年暑假就有了，可是当时还是小菜鸡蛋，什么都不懂＝＝，现在孵成了小菜鸡，才终于磨磨蹭蹭的搭了起来，内心还是十分激动的(〃∇〃)，其间走了很多弯路，陷进了很多坑，感谢<a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"noopener\">CrazyMilk的这篇博文</a>以及<a href=\"http://logqtainia.github.io/\" target=\"_blank\" rel=\"noopener\">陶司机</a>的指导，感谢女票的支持，也感谢自己没有就此放弃ヽ(•̀ω•́ )ゝ。<br><a id=\"more\"></a></p>\n<h3 id=\"为什么要搭建独立博客\"><a href=\"#为什么要搭建独立博客\" class=\"headerlink\" title=\"为什么要搭建独立博客\"></a>为什么要搭建独立博客</h3><p>最近３个月左右，一直在跟着校内的ACM队进行训练，最初是想提高自己的编程能力，后来发现自己无论对这个团队还是对这项竞赛都有一种由衷的向往，虽然最后因为个人能力以及年级太高(大三下)等方面因素没能成为正式队员，但还是想至少沿这个方向走下去。从接触ACM开始后就发现，优秀的人实在太多太多，自己会的实在太少太少，都不敢以菜鸡自称，简直是菜鸡蛋2333<br>所以想在这里记录自己的成长，努力成为一个优秀的人。我也十分赞同CrazyMilk博主提到的Litten（Yilia主题的制作者）说的那句话：有了一个独立博客，就有了属于自己的一片田，开始默默耕作。<br>等到自己不再是小菜鸡的那一天再回头来看那个曾经的小菜鸡的成长历程，应该会别有一番滋味吧，哈哈，期待。</p>\n<p>Hello, Aincrad.</p>\n<p>要去耕作了(ง •̀_•́)ง，告辞。</p>\n<p>Ps:博客框架采用hexo,及其经典的next主题。</p>\n","site":{"data":{}},"excerpt":"<p>搭一个自己的独立博客的想法记得从去年暑假就有了，可是当时还是小菜鸡蛋，什么都不懂＝＝，现在孵成了小菜鸡，才终于磨磨蹭蹭的搭了起来，内心还是十分激动的(〃∇〃)，其间走了很多弯路，陷进了很多坑，感谢<a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"noopener\">CrazyMilk的这篇博文</a>以及<a href=\"http://logqtainia.github.io/\" target=\"_blank\" rel=\"noopener\">陶司机</a>的指导，感谢女票的支持，也感谢自己没有就此放弃ヽ(•̀ω•́ )ゝ。<br></p>","more":"<p></p>\n<h3 id=\"为什么要搭建独立博客\"><a href=\"#为什么要搭建独立博客\" class=\"headerlink\" title=\"为什么要搭建独立博客\"></a>为什么要搭建独立博客</h3><p>最近３个月左右，一直在跟着校内的ACM队进行训练，最初是想提高自己的编程能力，后来发现自己无论对这个团队还是对这项竞赛都有一种由衷的向往，虽然最后因为个人能力以及年级太高(大三下)等方面因素没能成为正式队员，但还是想至少沿这个方向走下去。从接触ACM开始后就发现，优秀的人实在太多太多，自己会的实在太少太少，都不敢以菜鸡自称，简直是菜鸡蛋2333<br>所以想在这里记录自己的成长，努力成为一个优秀的人。我也十分赞同CrazyMilk博主提到的Litten（Yilia主题的制作者）说的那句话：有了一个独立博客，就有了属于自己的一片田，开始默默耕作。<br>等到自己不再是小菜鸡的那一天再回头来看那个曾经的小菜鸡的成长历程，应该会别有一番滋味吧，哈哈，期待。</p>\n<p>Hello, Aincrad.</p>\n<p>要去耕作了(ง •̀_•́)ง，告辞。</p>\n<p>Ps:博客框架采用hexo,及其经典的next主题。</p>"},{"title":"new keyword","date":"2018-09-20T05:21:31.000Z","_content":"使用$new$关键字和不使用$new$关键字创建对象的异同及优劣对比。\n<!--more-->\n## 参考链接\n[When should I use the new keyword in C++](https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c)\n顺便安利一波[Stack Overflow](https://stackoverflow.com/) |･ω･｀)\n## 使用new关键字\n```C++\nMyClass* myClass = new Myclass();\nmyClass->MyField = \"Hello World!\";\n```\n- 为创建的对象在自由存储区分配内存\n- 之后需要使用$delete$手动释放分配的内存（否则会造成内存泄露）\n- 在使用$delete$之前被分配的内存空间持续存在（意味着用$new$关键字创建的对象可以作为指针被函数返回）\n\n## 不使用new关键字\n```C++\nMyClass myClass;\nmyClass.MyField = \"Hello World!\";\n```\n- 为创建的对象在堆栈段分配内存\n- 不需要使用$delete$来手动释放\n- 调用结束时内存空间被清除（意味着用这种方式创建的对象不能作为指针来被函数返回）\n\n## 拓展\n可执行文件由正文段、数据段、和$BSS$段组成。\n- 正文段（$Text Segment$）:用于储存指令。\n- 数据段（$Data Segment$）:用于储存已初始化的全局变量。\n- $BSS$段（$BSS Segment$）:用于储存未赋值的全局变量所需的空间\n\n调用栈不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为\\*堆栈段\\*（$Stack Segment$）。\n调用栈：调用栈描述的是函数之间的调用关系。它由多个栈帧（$Stack Frame$）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的\\*返回地址\\*和\\*局部变量\\*，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证不同函数间的局部变量互不相干－－因为不同函数对应着不同的栈帧。\n堆栈段的空间相对于自由空间十分有限（具体大小和操作系统相关，大概几十$M$）。所以建议把较大的数组放在$main$函数外，因为局部变量也是放在堆栈段的。栈溢出（$Segmentation fault$）不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。\n# 总结\n- 如果不想时刻担心要调用$delete$释放内存，那么就不要使用$new$关键字。\n- 如果需要在一个函数中返回对象的指针，那么就一定要使用$new$关键字（局部变量的方式会在函数调用结束时清除分配的空间）。","source":"_posts/new-keyword.md","raw":"---\ntitle: new keyword\ndate: 2018-09-20 13:21:31\ncategories:\n- ACM\ntags:\n- C++\n---\n使用$new$关键字和不使用$new$关键字创建对象的异同及优劣对比。\n<!--more-->\n## 参考链接\n[When should I use the new keyword in C++](https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c)\n顺便安利一波[Stack Overflow](https://stackoverflow.com/) |･ω･｀)\n## 使用new关键字\n```C++\nMyClass* myClass = new Myclass();\nmyClass->MyField = \"Hello World!\";\n```\n- 为创建的对象在自由存储区分配内存\n- 之后需要使用$delete$手动释放分配的内存（否则会造成内存泄露）\n- 在使用$delete$之前被分配的内存空间持续存在（意味着用$new$关键字创建的对象可以作为指针被函数返回）\n\n## 不使用new关键字\n```C++\nMyClass myClass;\nmyClass.MyField = \"Hello World!\";\n```\n- 为创建的对象在堆栈段分配内存\n- 不需要使用$delete$来手动释放\n- 调用结束时内存空间被清除（意味着用这种方式创建的对象不能作为指针来被函数返回）\n\n## 拓展\n可执行文件由正文段、数据段、和$BSS$段组成。\n- 正文段（$Text Segment$）:用于储存指令。\n- 数据段（$Data Segment$）:用于储存已初始化的全局变量。\n- $BSS$段（$BSS Segment$）:用于储存未赋值的全局变量所需的空间\n\n调用栈不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为\\*堆栈段\\*（$Stack Segment$）。\n调用栈：调用栈描述的是函数之间的调用关系。它由多个栈帧（$Stack Frame$）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的\\*返回地址\\*和\\*局部变量\\*，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证不同函数间的局部变量互不相干－－因为不同函数对应着不同的栈帧。\n堆栈段的空间相对于自由空间十分有限（具体大小和操作系统相关，大概几十$M$）。所以建议把较大的数组放在$main$函数外，因为局部变量也是放在堆栈段的。栈溢出（$Segmentation fault$）不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。\n# 总结\n- 如果不想时刻担心要调用$delete$释放内存，那么就不要使用$new$关键字。\n- 如果需要在一个函数中返回对象的指针，那么就一定要使用$new$关键字（局部变量的方式会在函数调用结束时清除分配的空间）。","slug":"new-keyword","published":1,"updated":"2018-09-20T06:39:53.049Z","_id":"cjma7a1zq0011sxouwi7n9561","comments":1,"layout":"post","photos":[],"link":"","content":"<p>使用$new$关键字和不使用$new$关键字创建对象的异同及优劣对比。<br><a id=\"more\"></a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c\" target=\"_blank\" rel=\"noopener\">When should I use the new keyword in C++</a><br>顺便安利一波<a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">Stack Overflow</a> |･ω･｀)</p>\n<h2 id=\"使用new关键字\"><a href=\"#使用new关键字\" class=\"headerlink\" title=\"使用new关键字\"></a>使用new关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass* myClass = <span class=\"keyword\">new</span> Myclass();</span><br><span class=\"line\">myClass-&gt;MyField = <span class=\"string\">\"Hello World!\"</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为创建的对象在自由存储区分配内存</li>\n<li>之后需要使用$delete$手动释放分配的内存（否则会造成内存泄露）</li>\n<li>在使用$delete$之前被分配的内存空间持续存在（意味着用$new$关键字创建的对象可以作为指针被函数返回）</li>\n</ul>\n<h2 id=\"不使用new关键字\"><a href=\"#不使用new关键字\" class=\"headerlink\" title=\"不使用new关键字\"></a>不使用new关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass myClass;</span><br><span class=\"line\">myClass.MyField = <span class=\"string\">\"Hello World!\"</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为创建的对象在堆栈段分配内存</li>\n<li>不需要使用$delete$来手动释放</li>\n<li>调用结束时内存空间被清除（意味着用这种方式创建的对象不能作为指针来被函数返回）</li>\n</ul>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>可执行文件由正文段、数据段、和$BSS$段组成。</p>\n<ul>\n<li>正文段（$Text Segment$）:用于储存指令。</li>\n<li>数据段（$Data Segment$）:用于储存已初始化的全局变量。</li>\n<li>$BSS$段（$BSS Segment$）:用于储存未赋值的全局变量所需的空间</li>\n</ul>\n<p>调用栈不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为*堆栈段*（$Stack Segment$）。<br>调用栈：调用栈描述的是函数之间的调用关系。它由多个栈帧（$Stack Frame$）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的*返回地址*和*局部变量*，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证不同函数间的局部变量互不相干－－因为不同函数对应着不同的栈帧。<br>堆栈段的空间相对于自由空间十分有限（具体大小和操作系统相关，大概几十$M$）。所以建议把较大的数组放在$main$函数外，因为局部变量也是放在堆栈段的。栈溢出（$Segmentation fault$）不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>如果不想时刻担心要调用$delete$释放内存，那么就不要使用$new$关键字。</li>\n<li>如果需要在一个函数中返回对象的指针，那么就一定要使用$new$关键字（局部变量的方式会在函数调用结束时清除分配的空间）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>使用$new$关键字和不使用$new$关键字创建对象的异同及优劣对比。<br></p>","more":"<p></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c\" target=\"_blank\" rel=\"noopener\">When should I use the new keyword in C++</a><br>顺便安利一波<a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">Stack Overflow</a> |･ω･｀)</p>\n<h2 id=\"使用new关键字\"><a href=\"#使用new关键字\" class=\"headerlink\" title=\"使用new关键字\"></a>使用new关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass* myClass = <span class=\"keyword\">new</span> Myclass();</span><br><span class=\"line\">myClass-&gt;MyField = <span class=\"string\">\"Hello World!\"</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为创建的对象在自由存储区分配内存</li>\n<li>之后需要使用$delete$手动释放分配的内存（否则会造成内存泄露）</li>\n<li>在使用$delete$之前被分配的内存空间持续存在（意味着用$new$关键字创建的对象可以作为指针被函数返回）</li>\n</ul>\n<h2 id=\"不使用new关键字\"><a href=\"#不使用new关键字\" class=\"headerlink\" title=\"不使用new关键字\"></a>不使用new关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass myClass;</span><br><span class=\"line\">myClass.MyField = <span class=\"string\">\"Hello World!\"</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>为创建的对象在堆栈段分配内存</li>\n<li>不需要使用$delete$来手动释放</li>\n<li>调用结束时内存空间被清除（意味着用这种方式创建的对象不能作为指针来被函数返回）</li>\n</ul>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>可执行文件由正文段、数据段、和$BSS$段组成。</p>\n<ul>\n<li>正文段（$Text Segment$）:用于储存指令。</li>\n<li>数据段（$Data Segment$）:用于储存已初始化的全局变量。</li>\n<li>$BSS$段（$BSS Segment$）:用于储存未赋值的全局变量所需的空间</li>\n</ul>\n<p>调用栈不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为*堆栈段*（$Stack Segment$）。<br>调用栈：调用栈描述的是函数之间的调用关系。它由多个栈帧（$Stack Frame$）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的*返回地址*和*局部变量*，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证不同函数间的局部变量互不相干－－因为不同函数对应着不同的栈帧。<br>堆栈段的空间相对于自由空间十分有限（具体大小和操作系统相关，大概几十$M$）。所以建议把较大的数组放在$main$函数外，因为局部变量也是放在堆栈段的。栈溢出（$Segmentation fault$）不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>如果不想时刻担心要调用$delete$释放内存，那么就不要使用$new$关键字。</li>\n<li>如果需要在一个函数中返回对象的指针，那么就一定要使用$new$关键字（局部变量的方式会在函数调用结束时清除分配的空间）。</li>\n</ul>"},{"title":"pick numbers-DFS","date":"2018-08-11T09:23:02.000Z","_content":"从$n$个整数中任选$k$个整数相加，求得到的一系列和中为素数的共有多少种．\n<!-- more -->\n## 链接\n[NOIP2002](http://acmoj.shu.edu.cn/problem/264/)\n## 题目\n已知$n$个整数$x1, x2,...,xn$，以及一个整数$k$．从$n$个整数中任选$k$个整数相加，可分别得到一系列的和．例如当$n = 4, k = 3$, $4$个整数分别为$3, 7, 12, 19$时，可得到全部的组合与它们的和为：\n$3 + 7 + 12 = 22$\n$3 + 7 + 19 = 29$\n$7 + 12 + 19 = 38$\n$3 + 12 + 19 = 34$\n现在，要求你计算和为素数共有多少种．\n## 思路\nDFS对每一种情况遍历．\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 11 Aug 16:32:41 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n, k;\nint d[maxn];\nint ans = 0;\nint sum = 0;\n\nbool is_prime(){\n    if(sum < 2)\n        return false;\n    int tmp = sqrt(sum);\n    for(int i = 2; i <= tmp; i++){\n        if(!(sum % i)) \n            return false;\n    }\n    return true;\n}\n\nvoid dfs(int now, int dep){\n    if(dep == k){\n        if(is_prime())\n            ans++;\n        return;\n    }\n    if(now == n){\n        return;\n    }\n    for(int i = now; i < n; i++){\n        sum += d[i];\n        dfs(i + 1, dep + 1);\n        sum -= d[i];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(cin >> n >> k){\n        ans = 0;\n        sum = 0;\n        //cout << n << \" \" << k << endl;\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/pick-numbers.md","raw":"---\ntitle: pick numbers-DFS\ndate: 2018-08-11 17:23:02\ncategories:\n- ACM\ntags:\n- DFS\n---\n从$n$个整数中任选$k$个整数相加，求得到的一系列和中为素数的共有多少种．\n<!-- more -->\n## 链接\n[NOIP2002](http://acmoj.shu.edu.cn/problem/264/)\n## 题目\n已知$n$个整数$x1, x2,...,xn$，以及一个整数$k$．从$n$个整数中任选$k$个整数相加，可分别得到一系列的和．例如当$n = 4, k = 3$, $4$个整数分别为$3, 7, 12, 19$时，可得到全部的组合与它们的和为：\n$3 + 7 + 12 = 22$\n$3 + 7 + 19 = 29$\n$7 + 12 + 19 = 38$\n$3 + 12 + 19 = 34$\n现在，要求你计算和为素数共有多少种．\n## 思路\nDFS对每一种情况遍历．\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 11 Aug 16:32:41 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n, k;\nint d[maxn];\nint ans = 0;\nint sum = 0;\n\nbool is_prime(){\n    if(sum < 2)\n        return false;\n    int tmp = sqrt(sum);\n    for(int i = 2; i <= tmp; i++){\n        if(!(sum % i)) \n            return false;\n    }\n    return true;\n}\n\nvoid dfs(int now, int dep){\n    if(dep == k){\n        if(is_prime())\n            ans++;\n        return;\n    }\n    if(now == n){\n        return;\n    }\n    for(int i = now; i < n; i++){\n        sum += d[i];\n        dfs(i + 1, dep + 1);\n        sum -= d[i];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(cin >> n >> k){\n        ans = 0;\n        sum = 0;\n        //cout << n << \" \" << k << endl;\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n```\n","slug":"pick-numbers","published":1,"updated":"2018-08-11T10:00:16.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1zs0013sxoucdrqsu48","content":"<p>从$n$个整数中任选$k$个整数相加，求得到的一系列和中为素数的共有多少种．<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acmoj.shu.edu.cn/problem/264/\" target=\"_blank\" rel=\"noopener\">NOIP2002</a></p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>已知$n$个整数$x1, x2,…,xn$，以及一个整数$k$．从$n$个整数中任选$k$个整数相加，可分别得到一系列的和．例如当$n = 4, k = 3$, $4$个整数分别为$3, 7, 12, 19$时，可得到全部的组合与它们的和为：<br>$3 + 7 + 12 = 22$<br>$3 + 7 + 19 = 29$<br>$7 + 12 + 19 = 38$<br>$3 + 12 + 19 = 34$<br>现在，要求你计算和为素数共有多少种．</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>DFS对每一种情况遍历．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 11 Aug 16:32:41 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, k;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_prime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sum &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"built_in\">sqrt</span>(sum);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= tmp; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(sum % i)) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> now, <span class=\"keyword\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep == k)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is_prime())</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(now == n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = now; i &lt; n; i++)&#123;</span><br><span class=\"line\">        sum += d[i];</span><br><span class=\"line\">        dfs(i + <span class=\"number\">1</span>, dep + <span class=\"number\">1</span>);</span><br><span class=\"line\">        sum -= d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k)&#123;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; k &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; d[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>从$n$个整数中任选$k$个整数相加，求得到的一系列和中为素数的共有多少种．<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acmoj.shu.edu.cn/problem/264/\" target=\"_blank\" rel=\"noopener\">NOIP2002</a></p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>已知$n$个整数$x1, x2,…,xn$，以及一个整数$k$．从$n$个整数中任选$k$个整数相加，可分别得到一系列的和．例如当$n = 4, k = 3$, $4$个整数分别为$3, 7, 12, 19$时，可得到全部的组合与它们的和为：<br>$3 + 7 + 12 = 22$<br>$3 + 7 + 19 = 29$<br>$7 + 12 + 19 = 38$<br>$3 + 12 + 19 = 34$<br>现在，要求你计算和为素数共有多少种．</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>DFS对每一种情况遍历．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 11 Aug 16:32:41 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, k;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_prime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sum &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"built_in\">sqrt</span>(sum);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= tmp; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(sum % i)) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> now, <span class=\"keyword\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep == k)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is_prime())</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(now == n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = now; i &lt; n; i++)&#123;</span><br><span class=\"line\">        sum += d[i];</span><br><span class=\"line\">        dfs(i + <span class=\"number\">1</span>, dep + <span class=\"number\">1</span>);</span><br><span class=\"line\">        sum -= d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k)&#123;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; k &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; d[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"矩阵快速幂","date":"2018-05-14T01:41:44.000Z","_content":"最近在做一道DP的题时发现数据范围竟然是1e18，这样的话只能用log(n)复杂度的算法来实现了，于是从队长那里了解到了矩阵快速幂。在这里记录一下快速幂以及其它矩阵处理的模板。\n矩阵快速幂模板参考自[eecrazy](https://github.com/eecrazy/ACM/blob/master/%E6%95%B0%E8%AE%BA/poj3233%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.cpp)\n<!-- more -->\n## 常数快速幂\n```C++\ntypedef long long ll;\nll mod_pow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res *= x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n```\n## 矩阵快速幂\n``` C++\nstruct Ma\n{\n    int m[maxn][maxn];\n};\n\nMa a,per;\nint n, mod;\n\nvoid init()//矩阵初始化\n{\n    int i,j;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n        {\n            scanf(\"%d\", &a.m[i][j]);\n            a.m[i][j] %= mod;\n            per.m[i][j] = (i == j);\n        }\n}\n\nMa add(Ma a,Ma b)//矩阵加法\n{\n    Ma c;\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n        {\n            c.m[i][j] = (a.m[i][j] + b.m[i][j]) % mod;\n        }\n    }\n    return c;\n}\n\n\nMa multi(Ma a,Ma b)//矩阵乘法\n{\n    Ma c;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n        {\n            c.m[i][j] = 0;\n            for(int k = 0; k < n; k++)\n            {\n                c.m[i][j] += a.m[i][k] * b.m[k][j];\n            }\n            c.m[i][j] %= mod;\n        }\n    return c;\n}\n\nMa quick_pow(long long x)//矩阵快速幂\n{\n    Ma res = per;\n    Ma p = a;\n    while(x)\n    {\n        if(x&1) res = multi(res,p);\n        p = multi(p,p);\n        x >>= 1;\n    }\n    return res;\n}\n```","source":"_posts/quick-matrix.md","raw":"---\ntitle: 矩阵快速幂\ndate: 2018-05-14 09:41:44\ncategories:\n- ACM\ntags:\n- math\n---\n最近在做一道DP的题时发现数据范围竟然是1e18，这样的话只能用log(n)复杂度的算法来实现了，于是从队长那里了解到了矩阵快速幂。在这里记录一下快速幂以及其它矩阵处理的模板。\n矩阵快速幂模板参考自[eecrazy](https://github.com/eecrazy/ACM/blob/master/%E6%95%B0%E8%AE%BA/poj3233%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.cpp)\n<!-- more -->\n## 常数快速幂\n```C++\ntypedef long long ll;\nll mod_pow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res *= x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n```\n## 矩阵快速幂\n``` C++\nstruct Ma\n{\n    int m[maxn][maxn];\n};\n\nMa a,per;\nint n, mod;\n\nvoid init()//矩阵初始化\n{\n    int i,j;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n        {\n            scanf(\"%d\", &a.m[i][j]);\n            a.m[i][j] %= mod;\n            per.m[i][j] = (i == j);\n        }\n}\n\nMa add(Ma a,Ma b)//矩阵加法\n{\n    Ma c;\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n        {\n            c.m[i][j] = (a.m[i][j] + b.m[i][j]) % mod;\n        }\n    }\n    return c;\n}\n\n\nMa multi(Ma a,Ma b)//矩阵乘法\n{\n    Ma c;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n        {\n            c.m[i][j] = 0;\n            for(int k = 0; k < n; k++)\n            {\n                c.m[i][j] += a.m[i][k] * b.m[k][j];\n            }\n            c.m[i][j] %= mod;\n        }\n    return c;\n}\n\nMa quick_pow(long long x)//矩阵快速幂\n{\n    Ma res = per;\n    Ma p = a;\n    while(x)\n    {\n        if(x&1) res = multi(res,p);\n        p = multi(p,p);\n        x >>= 1;\n    }\n    return res;\n}\n```","slug":"quick-matrix","published":1,"updated":"2018-08-09T15:50:59.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1zu0016sxoubiw8g7dg","content":"<p>最近在做一道DP的题时发现数据范围竟然是1e18，这样的话只能用log(n)复杂度的算法来实现了，于是从队长那里了解到了矩阵快速幂。在这里记录一下快速幂以及其它矩阵处理的模板。<br>矩阵快速幂模板参考自<a href=\"https://github.com/eecrazy/ACM/blob/master/%E6%95%B0%E8%AE%BA/poj3233%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.cpp\" target=\"_blank\" rel=\"noopener\">eecrazy</a><br><a id=\"more\"></a></p>\n<h2 id=\"常数快速幂\"><a href=\"#常数快速幂\" class=\"headerlink\" title=\"常数快速幂\"></a>常数快速幂</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mod_pow</span><span class=\"params\">(ll x, ll n, ll mod)</span></span>&#123;</span><br><span class=\"line\">    ll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &amp; <span class=\"number\">1</span>) res *= x % mod;</span><br><span class=\"line\">        x = x * x % mod;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"矩阵快速幂\"><a href=\"#矩阵快速幂\" class=\"headerlink\" title=\"矩阵快速幂\"></a>矩阵快速幂</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Ma</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m[maxn][maxn];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Ma a,per;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, mod;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span><span class=\"comment\">//矩阵初始化</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a.m[i][j]);</span><br><span class=\"line\">            a.m[i][j] %= mod;</span><br><span class=\"line\">            per.m[i][j] = (i == j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">add</span><span class=\"params\">(Ma a,Ma b)</span><span class=\"comment\">//矩阵加法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            c.m[i][j] = (a.m[i][j] + b.m[i][j]) % mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">multi</span><span class=\"params\">(Ma a,Ma b)</span><span class=\"comment\">//矩阵乘法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            c.m[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                c.m[i][j] += a.m[i][k] * b.m[k][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            c.m[i][j] %= mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">quick_pow</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x)</span><span class=\"comment\">//矩阵快速幂</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma res = per;</span><br><span class=\"line\">    Ma p = a;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&amp;<span class=\"number\">1</span>) res = multi(res,p);</span><br><span class=\"line\">        p = multi(p,p);</span><br><span class=\"line\">        x &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>最近在做一道DP的题时发现数据范围竟然是1e18，这样的话只能用log(n)复杂度的算法来实现了，于是从队长那里了解到了矩阵快速幂。在这里记录一下快速幂以及其它矩阵处理的模板。<br>矩阵快速幂模板参考自<a href=\"https://github.com/eecrazy/ACM/blob/master/%E6%95%B0%E8%AE%BA/poj3233%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.cpp\" target=\"_blank\" rel=\"noopener\">eecrazy</a><br></p>","more":"<p></p>\n<h2 id=\"常数快速幂\"><a href=\"#常数快速幂\" class=\"headerlink\" title=\"常数快速幂\"></a>常数快速幂</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mod_pow</span><span class=\"params\">(ll x, ll n, ll mod)</span></span>&#123;</span><br><span class=\"line\">    ll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &amp; <span class=\"number\">1</span>) res *= x % mod;</span><br><span class=\"line\">        x = x * x % mod;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"矩阵快速幂\"><a href=\"#矩阵快速幂\" class=\"headerlink\" title=\"矩阵快速幂\"></a>矩阵快速幂</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Ma</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m[maxn][maxn];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Ma a,per;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, mod;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span><span class=\"comment\">//矩阵初始化</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a.m[i][j]);</span><br><span class=\"line\">            a.m[i][j] %= mod;</span><br><span class=\"line\">            per.m[i][j] = (i == j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">add</span><span class=\"params\">(Ma a,Ma b)</span><span class=\"comment\">//矩阵加法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            c.m[i][j] = (a.m[i][j] + b.m[i][j]) % mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">multi</span><span class=\"params\">(Ma a,Ma b)</span><span class=\"comment\">//矩阵乘法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            c.m[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                c.m[i][j] += a.m[i][k] * b.m[k][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            c.m[i][j] %= mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">quick_pow</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x)</span><span class=\"comment\">//矩阵快速幂</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma res = per;</span><br><span class=\"line\">    Ma p = a;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&amp;<span class=\"number\">1</span>) res = multi(res,p);</span><br><span class=\"line\">        p = multi(p,p);</span><br><span class=\"line\">        x &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"线段树区间更新模板","date":"2018-05-07T16:08:11.000Z","_content":"线段树区间更新中比较重要的一个概念是延迟标记，即lazy思想，当要对某一个区间中的所有节点进行更新时，先找到包含该区间所有节点的那一个（或多个）节点，只对它（们）进行更新，同时保存更新的值lazy。当进行区间查询时，若查询的区间的大小在lazy标记区间之内则直接返回，否则将lazy值向下进行传递，直到包含查询的区间。通过这种方式，可以用更新整个区间的值来代替更新区间中的每一个节点，从而避免了很多不必要的操作，提高了效率。说起来可能比较抽象，详见代码。\n[参考链接](https://www.zybuluo.com/lychee123/note/731591)\n<!-- more -->\n## 基于区间和的线段树区间更新模板\n```C++\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;//延迟标记\n}tree[maxn << 2];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;//延迟标记初始化为0\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n//更新下层区间的值，即将lazy向下进行传递，这里是区别于单点更新的最主要的地方\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);//区间长度乘以当前标记\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;//标记传递后清空为0\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\n```\n## 例题实现\n[POJ-3468--A Simple Problem with Integers](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nint n, q;\n\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;\n}tree[maxn << 2];\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n    pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n        return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    char s[10];\n    int a, b, c;\n    scanf(\"%d%d\", &n, &q);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", d + i);\n    build(1, 1, n);\n    while(q--){\n        scanf(\"%s\", s);\n        if(s[0] == 'Q'){\n            scanf(\"%d%d\", &a, &b);\n            printf(\"%lld\\n\", query(1, a, b));\n        }\n        else if(s[0] == 'C'){\n            scanf(\"%d%d%d\", &a, &b, &c);\n            update(1, a, b, c);\n        }\n    }\n\t\n    return 0;\n}\n\n```","source":"_posts/segtree-intval.md","raw":"---\ntitle: 线段树区间更新模板\ndate: 2018-05-08 00:08:11\ncategories:\n- ACM\ntags:\n- 线段树区间更新\n---\n线段树区间更新中比较重要的一个概念是延迟标记，即lazy思想，当要对某一个区间中的所有节点进行更新时，先找到包含该区间所有节点的那一个（或多个）节点，只对它（们）进行更新，同时保存更新的值lazy。当进行区间查询时，若查询的区间的大小在lazy标记区间之内则直接返回，否则将lazy值向下进行传递，直到包含查询的区间。通过这种方式，可以用更新整个区间的值来代替更新区间中的每一个节点，从而避免了很多不必要的操作，提高了效率。说起来可能比较抽象，详见代码。\n[参考链接](https://www.zybuluo.com/lychee123/note/731591)\n<!-- more -->\n## 基于区间和的线段树区间更新模板\n```C++\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;//延迟标记\n}tree[maxn << 2];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;//延迟标记初始化为0\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n//更新下层区间的值，即将lazy向下进行传递，这里是区别于单点更新的最主要的地方\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);//区间长度乘以当前标记\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;//标记传递后清空为0\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\n```\n## 例题实现\n[POJ-3468--A Simple Problem with Integers](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nint n, q;\n\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;\n}tree[maxn << 2];\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n    pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n        return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    char s[10];\n    int a, b, c;\n    scanf(\"%d%d\", &n, &q);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", d + i);\n    build(1, 1, n);\n    while(q--){\n        scanf(\"%s\", s);\n        if(s[0] == 'Q'){\n            scanf(\"%d%d\", &a, &b);\n            printf(\"%lld\\n\", query(1, a, b));\n        }\n        else if(s[0] == 'C'){\n            scanf(\"%d%d%d\", &a, &b, &c);\n            update(1, a, b, c);\n        }\n    }\n\t\n    return 0;\n}\n\n```","slug":"segtree-intval","published":1,"updated":"2018-08-09T15:50:30.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1zv0019sxoujp6o314d","content":"<p>线段树区间更新中比较重要的一个概念是延迟标记，即lazy思想，当要对某一个区间中的所有节点进行更新时，先找到包含该区间所有节点的那一个（或多个）节点，只对它（们）进行更新，同时保存更新的值lazy。当进行区间查询时，若查询的区间的大小在lazy标记区间之内则直接返回，否则将lazy值向下进行传递，直到包含查询的区间。通过这种方式，可以用更新整个区间的值来代替更新区间中的每一个节点，从而避免了很多不必要的操作，提高了效率。说起来可能比较抽象，详见代码。<br><a href=\"https://www.zybuluo.com/lychee123/note/731591\" target=\"_blank\" rel=\"noopener\">参考链接</a><br><a id=\"more\"></a></p>\n<h2 id=\"基于区间和的线段树区间更新模板\"><a href=\"#基于区间和的线段树区间更新模板\" class=\"headerlink\" title=\"基于区间和的线段树区间更新模板\"></a>基于区间和的线段树区间更新模板</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> lazy;<span class=\"comment\">//延迟标记</span></span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;<span class=\"comment\">//延迟标记初始化为0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].sum = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//更新下层区间的值，即将lazy向下进行传递，这里是区别于单点更新的最主要的地方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);<span class=\"comment\">//区间长度乘以当前标记</span></span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;<span class=\"comment\">//标记传递后清空为0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].lazy += val;</span><br><span class=\"line\">        tree[k].sum += val * (tree[k].vr - tree[k].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy != <span class=\"number\">0</span>)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, mid, val);</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, mid) + query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例题实现\"><a href=\"#例题实现\" class=\"headerlink\" title=\"例题实现\"></a>例题实现</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1754\" target=\"_blank\" rel=\"noopener\">POJ-3468–A Simple Problem with Integers</a><br>AC代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> lazy;</span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].sum = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].lazy += val;</span><br><span class=\"line\">        tree[k].sum += val * (tree[k].vr - tree[k].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy != <span class=\"number\">0</span>)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, mid, val);</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy)</span><br><span class=\"line\">    pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, mid) + query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;q);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, d + i);</span><br><span class=\"line\">    build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(q--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;a, &amp;b);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(<span class=\"number\">1</span>, a, b));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class=\"line\">            update(<span class=\"number\">1</span>, a, b, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>线段树区间更新中比较重要的一个概念是延迟标记，即lazy思想，当要对某一个区间中的所有节点进行更新时，先找到包含该区间所有节点的那一个（或多个）节点，只对它（们）进行更新，同时保存更新的值lazy。当进行区间查询时，若查询的区间的大小在lazy标记区间之内则直接返回，否则将lazy值向下进行传递，直到包含查询的区间。通过这种方式，可以用更新整个区间的值来代替更新区间中的每一个节点，从而避免了很多不必要的操作，提高了效率。说起来可能比较抽象，详见代码。<br><a href=\"https://www.zybuluo.com/lychee123/note/731591\" target=\"_blank\" rel=\"noopener\">参考链接</a><br></p>","more":"<p></p>\n<h2 id=\"基于区间和的线段树区间更新模板\"><a href=\"#基于区间和的线段树区间更新模板\" class=\"headerlink\" title=\"基于区间和的线段树区间更新模板\"></a>基于区间和的线段树区间更新模板</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> lazy;<span class=\"comment\">//延迟标记</span></span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;<span class=\"comment\">//延迟标记初始化为0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].sum = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//更新下层区间的值，即将lazy向下进行传递，这里是区别于单点更新的最主要的地方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);<span class=\"comment\">//区间长度乘以当前标记</span></span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;<span class=\"comment\">//标记传递后清空为0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].lazy += val;</span><br><span class=\"line\">        tree[k].sum += val * (tree[k].vr - tree[k].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy != <span class=\"number\">0</span>)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, mid, val);</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, mid) + query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例题实现\"><a href=\"#例题实现\" class=\"headerlink\" title=\"例题实现\"></a>例题实现</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1754\" target=\"_blank\" rel=\"noopener\">POJ-3468–A Simple Problem with Integers</a><br>AC代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> lazy;</span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].sum = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].lazy += val;</span><br><span class=\"line\">        tree[k].sum += val * (tree[k].vr - tree[k].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy != <span class=\"number\">0</span>)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, mid, val);</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy)</span><br><span class=\"line\">    pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, mid) + query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;q);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, d + i);</span><br><span class=\"line\">    build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(q--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;a, &amp;b);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(<span class=\"number\">1</span>, a, b));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class=\"line\">            update(<span class=\"number\">1</span>, a, b, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"POJ1970-The Game-DFS","date":"2018-08-14T11:39:48.000Z","_content":"在一个$19×19$的棋盘上有一局五子棋的棋局，要求判断是白棋获胜还是黑棋获胜，并输出获胜一方获胜棋子部分的最左上一个棋子的位置．\n相比其它迷宫问题稍微变化了一点点，多了一个方向因素，通过这道题对迷宫问题和DFS有了更进一步的理解．\n<!-- more -->\n## 链接\n[POJ1970-The Game](http://poj.org/problem?id=1970)\n## 原题描述\nA game of Renju is played on a 19*19 board by two players. One player uses black stones and the other uses white stones. The game begins in an empty board and two players alternate in placing black stones and white stones. Black always goes first. There are 19 horizontal lines and 19 vertical lines in the board and the stones are placed on the intersections of the lines. \nHorizontal lines are marked 1, 2, ..., 19 from up to down and vertical lines are marked 1, 2, ..., 19 from left to right. \n![example](/Renju.png)\nThe objective of this game is to put five stones of the same color consecutively along a horizontal, vertical, or diagonal line. So, black wins in the above figure. But, a player does not win the game if more than five stones of the same color were put consecutively. \nGiven a configuration of the game, write a program to determine whether white has won or black has won or nobody has won yet. There will be no input data where the black and the white both win at the same time. Also there will be no input data where the white or the black wins in more than one place. \n## 题解\n相比于其它迷宫问题的搜索，这个问题要求每一次DFS始终沿一个方向进行搜索判断，判断出一方的某一个方向上的棋子个数等于5时该方获胜，所以在DFS函数上加上一个控制方向的参数，并把方向的选择放在DFS外部（main函数中）．还有一个需要注意的地方是连续棋子个数大于5的情况不算获胜．\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 14 Aug 17:36:47 CST 2018\n *\n */\n \n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nint d[25][25];\nint t;\n/**/\n//搜索方向为向下，向右，右斜上，右斜下（方便获得最左上的棋子坐标）\nint dx[4] = {1, 0, -1, 1};\nint dy[4] = {0, 1, 1, 1};\n/**/\nint cnt = 0;\n\n//参数k为方向参数\nvoid dfs(int x, int y, int k){\n    cnt++;\n    int nx = x + dx[k], ny = y + dy[k];\n    if(nx >= 1 && nx <= 19 && ny >= 1 && ny <= 19 && d[nx][ny] == d[x][y])\n        dfs(nx, ny, k);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        int leftx = 0, lefty = 0;\n        int win = 0;\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                cin >> d[i][j];\n                //cout << d[i][j] << \" \";\n            }\n            //cout << endl;\n        }\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                if(!d[i][j]) continue;\n                for(int k = 0; k < 4; k++){\n                    cnt = 0;\n                    dfs(i, j, k);\n                    if(cnt == 5){\n                        int xx = i - dx[k], yy = j - dy[k];\n                        //判断是否连续棋子个数大于5\n                        if(xx >= 1 && xx <= 19 && yy >= 1 && yy <= 19){\n                            if(d[xx][yy] != d[i][j]){\n                                win = d[i][j], leftx = i, lefty = j;\n                                break;\n                            }\n                        }\n                        else{\n                            win = d[i][j], leftx = i, lefty = j;\n                            break;\n                        }\n                    }\n                }\n                if(win) break;\n            }\n            if(win) break;\n        }\n        cout << win << endl;\n        if(win) cout << leftx << \" \" << lefty << endl;\n    }\n    \n    return 0;\n}\n```","source":"_posts/POJ1970-The-Game-DFS.md","raw":"---\ntitle: POJ1970-The Game-DFS\ndate: 2018-08-14 19:39:48\ncategories:\n- ACM\ntags:\n- POJ\n- DFS\n- 迷宫问题\n---\n在一个$19×19$的棋盘上有一局五子棋的棋局，要求判断是白棋获胜还是黑棋获胜，并输出获胜一方获胜棋子部分的最左上一个棋子的位置．\n相比其它迷宫问题稍微变化了一点点，多了一个方向因素，通过这道题对迷宫问题和DFS有了更进一步的理解．\n<!-- more -->\n## 链接\n[POJ1970-The Game](http://poj.org/problem?id=1970)\n## 原题描述\nA game of Renju is played on a 19*19 board by two players. One player uses black stones and the other uses white stones. The game begins in an empty board and two players alternate in placing black stones and white stones. Black always goes first. There are 19 horizontal lines and 19 vertical lines in the board and the stones are placed on the intersections of the lines. \nHorizontal lines are marked 1, 2, ..., 19 from up to down and vertical lines are marked 1, 2, ..., 19 from left to right. \n![example](/Renju.png)\nThe objective of this game is to put five stones of the same color consecutively along a horizontal, vertical, or diagonal line. So, black wins in the above figure. But, a player does not win the game if more than five stones of the same color were put consecutively. \nGiven a configuration of the game, write a program to determine whether white has won or black has won or nobody has won yet. There will be no input data where the black and the white both win at the same time. Also there will be no input data where the white or the black wins in more than one place. \n## 题解\n相比于其它迷宫问题的搜索，这个问题要求每一次DFS始终沿一个方向进行搜索判断，判断出一方的某一个方向上的棋子个数等于5时该方获胜，所以在DFS函数上加上一个控制方向的参数，并把方向的选择放在DFS外部（main函数中）．还有一个需要注意的地方是连续棋子个数大于5的情况不算获胜．\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 14 Aug 17:36:47 CST 2018\n *\n */\n \n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nint d[25][25];\nint t;\n/**/\n//搜索方向为向下，向右，右斜上，右斜下（方便获得最左上的棋子坐标）\nint dx[4] = {1, 0, -1, 1};\nint dy[4] = {0, 1, 1, 1};\n/**/\nint cnt = 0;\n\n//参数k为方向参数\nvoid dfs(int x, int y, int k){\n    cnt++;\n    int nx = x + dx[k], ny = y + dy[k];\n    if(nx >= 1 && nx <= 19 && ny >= 1 && ny <= 19 && d[nx][ny] == d[x][y])\n        dfs(nx, ny, k);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        int leftx = 0, lefty = 0;\n        int win = 0;\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                cin >> d[i][j];\n                //cout << d[i][j] << \" \";\n            }\n            //cout << endl;\n        }\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                if(!d[i][j]) continue;\n                for(int k = 0; k < 4; k++){\n                    cnt = 0;\n                    dfs(i, j, k);\n                    if(cnt == 5){\n                        int xx = i - dx[k], yy = j - dy[k];\n                        //判断是否连续棋子个数大于5\n                        if(xx >= 1 && xx <= 19 && yy >= 1 && yy <= 19){\n                            if(d[xx][yy] != d[i][j]){\n                                win = d[i][j], leftx = i, lefty = j;\n                                break;\n                            }\n                        }\n                        else{\n                            win = d[i][j], leftx = i, lefty = j;\n                            break;\n                        }\n                    }\n                }\n                if(win) break;\n            }\n            if(win) break;\n        }\n        cout << win << endl;\n        if(win) cout << leftx << \" \" << lefty << endl;\n    }\n    \n    return 0;\n}\n```","slug":"POJ1970-The-Game-DFS","published":1,"updated":"2018-08-14T12:17:49.397Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1zx001dsxouqx9h3lrk","content":"<p>在一个$19×19$的棋盘上有一局五子棋的棋局，要求判断是白棋获胜还是黑棋获胜，并输出获胜一方获胜棋子部分的最左上一个棋子的位置．<br>相比其它迷宫问题稍微变化了一点点，多了一个方向因素，通过这道题对迷宫问题和DFS有了更进一步的理解．<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://poj.org/problem?id=1970\" target=\"_blank\" rel=\"noopener\">POJ1970-The Game</a></p>\n<h2 id=\"原题描述\"><a href=\"#原题描述\" class=\"headerlink\" title=\"原题描述\"></a>原题描述</h2><p>A game of Renju is played on a 19*19 board by two players. One player uses black stones and the other uses white stones. The game begins in an empty board and two players alternate in placing black stones and white stones. Black always goes first. There are 19 horizontal lines and 19 vertical lines in the board and the stones are placed on the intersections of the lines.<br>Horizontal lines are marked 1, 2, …, 19 from up to down and vertical lines are marked 1, 2, …, 19 from left to right.<br><img src=\"/2018/08/14/POJ1970-The-Game-DFS/Renju.png\" alt=\"example\"><br>The objective of this game is to put five stones of the same color consecutively along a horizontal, vertical, or diagonal line. So, black wins in the above figure. But, a player does not win the game if more than five stones of the same color were put consecutively.<br>Given a configuration of the game, write a program to determine whether white has won or black has won or nobody has won yet. There will be no input data where the black and the white both win at the same time. Also there will be no input data where the white or the black wins in more than one place. </p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>相比于其它迷宫问题的搜索，这个问题要求每一次DFS始终沿一个方向进行搜索判断，判断出一方的某一个方向上的棋子个数等于5时该方获胜，所以在DFS函数上加上一个控制方向的参数，并把方向的选择放在DFS外部（main函数中）．还有一个需要注意的地方是连续棋子个数大于5的情况不算获胜．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 14 Aug 17:36:47 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[<span class=\"number\">25</span>][<span class=\"number\">25</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"comment\">//搜索方向为向下，向右，右斜上，右斜下（方便获得最左上的棋子坐标）</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//参数k为方向参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nx = x + dx[k], ny = y + dy[k];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">1</span> &amp;&amp; nx &lt;= <span class=\"number\">19</span> &amp;&amp; ny &gt;= <span class=\"number\">1</span> &amp;&amp; ny &lt;= <span class=\"number\">19</span> &amp;&amp; d[nx][ny] == d[x][y])</span><br><span class=\"line\">        dfs(nx, ny, k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftx = <span class=\"number\">0</span>, lefty = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> win = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">19</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">19</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cin</span> &gt;&gt; d[i][j];</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; d[i][j] &lt;&lt; \" \";</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">19</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">19</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!d[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; k++)&#123;</span><br><span class=\"line\">                    cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    dfs(i, j, k);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(cnt == <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> xx = i - dx[k], yy = j - dy[k];</span><br><span class=\"line\">                        <span class=\"comment\">//判断是否连续棋子个数大于5</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(xx &gt;= <span class=\"number\">1</span> &amp;&amp; xx &lt;= <span class=\"number\">19</span> &amp;&amp; yy &gt;= <span class=\"number\">1</span> &amp;&amp; yy &lt;= <span class=\"number\">19</span>)&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(d[xx][yy] != d[i][j])&#123;</span><br><span class=\"line\">                                win = d[i][j], leftx = i, lefty = j;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            win = d[i][j], leftx = i, lefty = j;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(win) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(win) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; win &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(win) <span class=\"built_in\">cout</span> &lt;&lt; leftx &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; lefty &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在一个$19×19$的棋盘上有一局五子棋的棋局，要求判断是白棋获胜还是黑棋获胜，并输出获胜一方获胜棋子部分的最左上一个棋子的位置．<br>相比其它迷宫问题稍微变化了一点点，多了一个方向因素，通过这道题对迷宫问题和DFS有了更进一步的理解．<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://poj.org/problem?id=1970\" target=\"_blank\" rel=\"noopener\">POJ1970-The Game</a></p>\n<h2 id=\"原题描述\"><a href=\"#原题描述\" class=\"headerlink\" title=\"原题描述\"></a>原题描述</h2><p>A game of Renju is played on a 19*19 board by two players. One player uses black stones and the other uses white stones. The game begins in an empty board and two players alternate in placing black stones and white stones. Black always goes first. There are 19 horizontal lines and 19 vertical lines in the board and the stones are placed on the intersections of the lines.<br>Horizontal lines are marked 1, 2, …, 19 from up to down and vertical lines are marked 1, 2, …, 19 from left to right.<br><img src=\"/2018/08/14/POJ1970-The-Game-DFS/Renju.png\" alt=\"example\"><br>The objective of this game is to put five stones of the same color consecutively along a horizontal, vertical, or diagonal line. So, black wins in the above figure. But, a player does not win the game if more than five stones of the same color were put consecutively.<br>Given a configuration of the game, write a program to determine whether white has won or black has won or nobody has won yet. There will be no input data where the black and the white both win at the same time. Also there will be no input data where the white or the black wins in more than one place. </p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>相比于其它迷宫问题的搜索，这个问题要求每一次DFS始终沿一个方向进行搜索判断，判断出一方的某一个方向上的棋子个数等于5时该方获胜，所以在DFS函数上加上一个控制方向的参数，并把方向的选择放在DFS外部（main函数中）．还有一个需要注意的地方是连续棋子个数大于5的情况不算获胜．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 14 Aug 17:36:47 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[<span class=\"number\">25</span>][<span class=\"number\">25</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"comment\">//搜索方向为向下，向右，右斜上，右斜下（方便获得最左上的棋子坐标）</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//参数k为方向参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nx = x + dx[k], ny = y + dy[k];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">1</span> &amp;&amp; nx &lt;= <span class=\"number\">19</span> &amp;&amp; ny &gt;= <span class=\"number\">1</span> &amp;&amp; ny &lt;= <span class=\"number\">19</span> &amp;&amp; d[nx][ny] == d[x][y])</span><br><span class=\"line\">        dfs(nx, ny, k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftx = <span class=\"number\">0</span>, lefty = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> win = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">19</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">19</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cin</span> &gt;&gt; d[i][j];</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; d[i][j] &lt;&lt; \" \";</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">19</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">19</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!d[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; k++)&#123;</span><br><span class=\"line\">                    cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    dfs(i, j, k);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(cnt == <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> xx = i - dx[k], yy = j - dy[k];</span><br><span class=\"line\">                        <span class=\"comment\">//判断是否连续棋子个数大于5</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(xx &gt;= <span class=\"number\">1</span> &amp;&amp; xx &lt;= <span class=\"number\">19</span> &amp;&amp; yy &gt;= <span class=\"number\">1</span> &amp;&amp; yy &lt;= <span class=\"number\">19</span>)&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(d[xx][yy] != d[i][j])&#123;</span><br><span class=\"line\">                                win = d[i][j], leftx = i, lefty = j;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            win = d[i][j], leftx = i, lefty = j;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(win) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(win) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; win &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(win) <span class=\"built_in\">cout</span> &lt;&lt; leftx &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; lefty &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"sscanf & sprintf","date":"2018-09-15T14:32:35.000Z","_content":"关于sscanf和sprintf用法的总结。\n<!--more-->\n## sscanf\nint sscanf（const char * str，const char * format，...）从字符串中读取格式化的输入。\n### Example\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main () {\n   int day, year;\n   char weekday[20], month[20], dtm[100];\n\n   strcpy( dtm, \"Saturday March 25 1989\" );\n   sscanf( dtm, \"%s %s %d  %d\", weekday, month, &day, &year );\n\n   printf(\"%s %d, %d = %s\\n\", month, day, year, weekday );\n    \n   return(0);\n}\n```\n### Output\n```\nMarch 25, 1989 = Saturday\n```\n## sprintf\nint sprintf（char * str，const char * format，...）将格式化的输出发送到str指向的字符串。\n### Example\n```C\n#include <stdio.h>\n#include <math.h>\n\nint main () {\n   char str[80];\n\n   sprintf(str, \"Value of Pi = %f\", M_PI);\n   puts(str);\n   \n   return(0);\n}\n```\n### Output\n```\nValue of Pi = 3.141593\n```","source":"_posts/sscanf-sprintf.md","raw":"---\ntitle: sscanf & sprintf\ndate: 2018-09-15 22:32:35\ncategories:\n- ACM\ntags:\n- 总结\n---\n关于sscanf和sprintf用法的总结。\n<!--more-->\n## sscanf\nint sscanf（const char * str，const char * format，...）从字符串中读取格式化的输入。\n### Example\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main () {\n   int day, year;\n   char weekday[20], month[20], dtm[100];\n\n   strcpy( dtm, \"Saturday March 25 1989\" );\n   sscanf( dtm, \"%s %s %d  %d\", weekday, month, &day, &year );\n\n   printf(\"%s %d, %d = %s\\n\", month, day, year, weekday );\n    \n   return(0);\n}\n```\n### Output\n```\nMarch 25, 1989 = Saturday\n```\n## sprintf\nint sprintf（char * str，const char * format，...）将格式化的输出发送到str指向的字符串。\n### Example\n```C\n#include <stdio.h>\n#include <math.h>\n\nint main () {\n   char str[80];\n\n   sprintf(str, \"Value of Pi = %f\", M_PI);\n   puts(str);\n   \n   return(0);\n}\n```\n### Output\n```\nValue of Pi = 3.141593\n```","slug":"sscanf-sprintf","published":1,"updated":"2018-09-16T09:52:57.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a1zz001fsxoudy306uln","content":"<p>关于sscanf和sprintf用法的总结。<br><a id=\"more\"></a></p>\n<h2 id=\"sscanf\"><a href=\"#sscanf\" class=\"headerlink\" title=\"sscanf\"></a>sscanf</h2><p>int sscanf（const char <em> str，const char </em> format，…）从字符串中读取格式化的输入。</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> day, year;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> weekday[<span class=\"number\">20</span>], month[<span class=\"number\">20</span>], dtm[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( dtm, <span class=\"string\">\"Saturday March 25 1989\"</span> );</span><br><span class=\"line\">   <span class=\"built_in\">sscanf</span>( dtm, <span class=\"string\">\"%s %s %d  %d\"</span>, weekday, month, &amp;day, &amp;year );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d, %d = %s\\n\"</span>, month, day, year, weekday );</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">March 25, 1989 = Saturday</span><br></pre></td></tr></table></figure>\n<h2 id=\"sprintf\"><a href=\"#sprintf\" class=\"headerlink\" title=\"sprintf\"></a>sprintf</h2><p>int sprintf（char <em> str，const char </em> format，…）将格式化的输出发送到str指向的字符串。</p>\n<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> str[<span class=\"number\">80</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">sprintf</span>(str, <span class=\"string\">\"Value of Pi = %f\"</span>, M_PI);</span><br><span class=\"line\">   <span class=\"built_in\">puts</span>(str);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output-1\"><a href=\"#Output-1\" class=\"headerlink\" title=\"Output\"></a>Output</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of Pi = 3.141593</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>关于sscanf和sprintf用法的总结。<br></p>","more":"<p></p>\n<h2 id=\"sscanf\"><a href=\"#sscanf\" class=\"headerlink\" title=\"sscanf\"></a>sscanf</h2><p>int sscanf（const char <em> str，const char </em> format，…）从字符串中读取格式化的输入。</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> day, year;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> weekday[<span class=\"number\">20</span>], month[<span class=\"number\">20</span>], dtm[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( dtm, <span class=\"string\">\"Saturday March 25 1989\"</span> );</span><br><span class=\"line\">   <span class=\"built_in\">sscanf</span>( dtm, <span class=\"string\">\"%s %s %d  %d\"</span>, weekday, month, &amp;day, &amp;year );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d, %d = %s\\n\"</span>, month, day, year, weekday );</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">March 25, 1989 = Saturday</span><br></pre></td></tr></table></figure>\n<h2 id=\"sprintf\"><a href=\"#sprintf\" class=\"headerlink\" title=\"sprintf\"></a>sprintf</h2><p>int sprintf（char <em> str，const char </em> format，…）将格式化的输出发送到str指向的字符串。</p>\n<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> str[<span class=\"number\">80</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">sprintf</span>(str, <span class=\"string\">\"Value of Pi = %f\"</span>, M_PI);</span><br><span class=\"line\">   <span class=\"built_in\">puts</span>(str);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output-1\"><a href=\"#Output-1\" class=\"headerlink\" title=\"Output\"></a>Output</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of Pi = 3.141593</span><br></pre></td></tr></table></figure>"},{"title":"stringstream-类型转换&&字符分割","date":"2018-08-08T14:07:28.000Z","_content":"继续填坑٩(•̤̀ᵕ•̤́๑)，这次是stringstream的内容，最初是看到它可以把字符串直接输出成int类型，惊了，但是一直不是很懂。在网上查了很多资料，才终于差不多理解。stringstream是C++提供的一个字符串流，和cin，cout输入输出流类似，只不过它不是从从键盘或文件输入，也不是输出到屏幕或文件中，而是接受一个对象的输入，或把缓存区的内容输出到一个对象中。具体可以用在类型转换和字符分割中。\n<!-- more -->\n## 基本方法(操作)\n```C++\nclear()－用来清空流标志(输入，输出标志)\nstr()－获得当前流中的内容\nstr(\"content\")－设置流的内容（或清空流的内容）\noperator <<－添加内容到stringstream对象\noperator >>－从stringstream流缓存区中输出内容\n```\n## 应用\n### 类型转换\n```C++\nint a;\nstring s;\nstringstream ss;\n//int型转换为字符串类型\nss << a;　//将a输入流中（输入模式）\nss >> s;　//将流中的数值输出到字符串s中（输出模式）\n\n//字符串类型转换为int型\nss << s;　//将字符串输入到流中\nss >> a;　//将流中的字符串输出到int型变量a中\n\n//注意：如果做多次数据转换须调用clear()和str(\"\")来清空输入输出标志和内容\nint a = 0, b = 0;\nstringstream ss;\nss << \"123\";\nss >> a;\nss.clear();\nss.str(\"\");\nss << \"456\";\nss >> b;\ncout << \"a:\" << a << endl;\ncout << \"b:\" << b << endl;\ncout << \"ss:\" << ss.str() << endl;\n\n//运行结果,不加clear()和str(\"\");\na:123\nb:0\nss:123\n//原因：不加clear()和str(\"\")，流处于输出模式无法接收新内容\"456\"且未被清空，所以ss仍为\"123\"，又由于缓存区的内容已输出到a中，所以b中无内容。\n\n//运行结果，加clear()但不加str(\"\");\na:123\nb:456\nss:123456\n//原因：加入clear()清空模式，可以接收新内容\"456\"，所以ss:123456。缓存区依次缓存\"123\"，\"456\"并分别输出到a, b，所以a:123, b:456\n\n//运行结果，加clear()和str(\"\");\na:123\nb:456\nss:456\n//原因：clear()清空模式，str(\"\")清空ss对象的内容。\n```\n### 支持char*的输入和输出\n```C++\nchar ch[20];\nstringstream ss;\nss << 2333;\nss >> ch; //直接将数输出到ch字符数组中\n```\n### 字符分割\n```C++\nstringstream ss(\"hello hi hey\");\nstring word;\nwhile(ss >> word){\n    cout << word << endl;\n}\n\n//运行结果\nhello\nhi\nhey\n\n```\n## 三种给stringstream对象赋初值的方式\n```C++\nstringstream ss(\"123\"); //创建的时候赋初值\nss.str(\"123\"); //str()函数赋值\nss << \"123\"; //操作符\"<<\"添加内容（需注意当前模式）\n```","source":"_posts/stringstream.md","raw":"---\ntitle: stringstream-类型转换&&字符分割\ndate: 2018-08-08 22:07:28\ncategories:\n- ACM\ntags:\n- 字符串\n---\n继续填坑٩(•̤̀ᵕ•̤́๑)，这次是stringstream的内容，最初是看到它可以把字符串直接输出成int类型，惊了，但是一直不是很懂。在网上查了很多资料，才终于差不多理解。stringstream是C++提供的一个字符串流，和cin，cout输入输出流类似，只不过它不是从从键盘或文件输入，也不是输出到屏幕或文件中，而是接受一个对象的输入，或把缓存区的内容输出到一个对象中。具体可以用在类型转换和字符分割中。\n<!-- more -->\n## 基本方法(操作)\n```C++\nclear()－用来清空流标志(输入，输出标志)\nstr()－获得当前流中的内容\nstr(\"content\")－设置流的内容（或清空流的内容）\noperator <<－添加内容到stringstream对象\noperator >>－从stringstream流缓存区中输出内容\n```\n## 应用\n### 类型转换\n```C++\nint a;\nstring s;\nstringstream ss;\n//int型转换为字符串类型\nss << a;　//将a输入流中（输入模式）\nss >> s;　//将流中的数值输出到字符串s中（输出模式）\n\n//字符串类型转换为int型\nss << s;　//将字符串输入到流中\nss >> a;　//将流中的字符串输出到int型变量a中\n\n//注意：如果做多次数据转换须调用clear()和str(\"\")来清空输入输出标志和内容\nint a = 0, b = 0;\nstringstream ss;\nss << \"123\";\nss >> a;\nss.clear();\nss.str(\"\");\nss << \"456\";\nss >> b;\ncout << \"a:\" << a << endl;\ncout << \"b:\" << b << endl;\ncout << \"ss:\" << ss.str() << endl;\n\n//运行结果,不加clear()和str(\"\");\na:123\nb:0\nss:123\n//原因：不加clear()和str(\"\")，流处于输出模式无法接收新内容\"456\"且未被清空，所以ss仍为\"123\"，又由于缓存区的内容已输出到a中，所以b中无内容。\n\n//运行结果，加clear()但不加str(\"\");\na:123\nb:456\nss:123456\n//原因：加入clear()清空模式，可以接收新内容\"456\"，所以ss:123456。缓存区依次缓存\"123\"，\"456\"并分别输出到a, b，所以a:123, b:456\n\n//运行结果，加clear()和str(\"\");\na:123\nb:456\nss:456\n//原因：clear()清空模式，str(\"\")清空ss对象的内容。\n```\n### 支持char*的输入和输出\n```C++\nchar ch[20];\nstringstream ss;\nss << 2333;\nss >> ch; //直接将数输出到ch字符数组中\n```\n### 字符分割\n```C++\nstringstream ss(\"hello hi hey\");\nstring word;\nwhile(ss >> word){\n    cout << word << endl;\n}\n\n//运行结果\nhello\nhi\nhey\n\n```\n## 三种给stringstream对象赋初值的方式\n```C++\nstringstream ss(\"123\"); //创建的时候赋初值\nss.str(\"123\"); //str()函数赋值\nss << \"123\"; //操作符\"<<\"添加内容（需注意当前模式）\n```","slug":"stringstream","published":1,"updated":"2018-08-08T15:50:27.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a200001isxoudrnpvvzi","content":"<p>继续填坑٩(•̤̀ᵕ•̤́๑)，这次是stringstream的内容，最初是看到它可以把字符串直接输出成int类型，惊了，但是一直不是很懂。在网上查了很多资料，才终于差不多理解。stringstream是C++提供的一个字符串流，和cin，cout输入输出流类似，只不过它不是从从键盘或文件输入，也不是输出到屏幕或文件中，而是接受一个对象的输入，或把缓存区的内容输出到一个对象中。具体可以用在类型转换和字符分割中。<br><a id=\"more\"></a></p>\n<h2 id=\"基本方法-操作\"><a href=\"#基本方法-操作\" class=\"headerlink\" title=\"基本方法(操作)\"></a>基本方法(操作)</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear()－用来清空流标志(输入，输出标志)</span><br><span class=\"line\">str()－获得当前流中的内容</span><br><span class=\"line\">str(<span class=\"string\">\"content\"</span>)－设置流的内容（或清空流的内容）</span><br><span class=\"line\"><span class=\"keyword\">operator</span> &lt;&lt;－添加内容到<span class=\"built_in\">stringstream</span>对象</span><br><span class=\"line\"><span class=\"keyword\">operator</span> &gt;&gt;－从<span class=\"built_in\">stringstream</span>流缓存区中输出内容</span><br></pre></td></tr></table></figure>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\"><span class=\"comment\">//int型转换为字符串类型</span></span><br><span class=\"line\">ss &lt;&lt; a;　<span class=\"comment\">//将a输入流中（输入模式）</span></span><br><span class=\"line\">ss &gt;&gt; s;　<span class=\"comment\">//将流中的数值输出到字符串s中（输出模式）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//字符串类型转换为int型</span></span><br><span class=\"line\">ss &lt;&lt; s;　<span class=\"comment\">//将字符串输入到流中</span></span><br><span class=\"line\">ss &gt;&gt; a;　<span class=\"comment\">//将流中的字符串输出到int型变量a中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意：如果做多次数据转换须调用clear()和str(\"\")来清空输入输出标志和内容</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">ss &gt;&gt; a;</span><br><span class=\"line\">ss.clear();</span><br><span class=\"line\">ss.str(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"456\"</span>;</span><br><span class=\"line\">ss &gt;&gt; b;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a:\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"b:\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ss:\"</span> &lt;&lt; ss.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果,不加clear()和str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">0</span></span><br><span class=\"line\">ss:<span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"comment\">//原因：不加clear()和str(\"\")，流处于输出模式无法接收新内容\"456\"且未被清空，所以ss仍为\"123\"，又由于缓存区的内容已输出到a中，所以b中无内容。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果，加clear()但不加str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">456</span></span><br><span class=\"line\">ss:<span class=\"number\">123456</span></span><br><span class=\"line\"><span class=\"comment\">//原因：加入clear()清空模式，可以接收新内容\"456\"，所以ss:123456。缓存区依次缓存\"123\"，\"456\"并分别输出到a, b，所以a:123, b:456</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果，加clear()和str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">456</span></span><br><span class=\"line\">ss:<span class=\"number\">456</span></span><br><span class=\"line\"><span class=\"comment\">//原因：clear()清空模式，str(\"\")清空ss对象的内容。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"支持char-的输入和输出\"><a href=\"#支持char-的输入和输出\" class=\"headerlink\" title=\"支持char*的输入和输出\"></a>支持char*的输入和输出</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> ch[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">ss &lt;&lt; <span class=\"number\">2333</span>;</span><br><span class=\"line\">ss &gt;&gt; ch; <span class=\"comment\">//直接将数输出到ch字符数组中</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符分割\"><a href=\"#字符分割\" class=\"headerlink\" title=\"字符分割\"></a>字符分割</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">\"hello hi hey\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> word;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(ss &gt;&gt; word)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; word &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果</span></span><br><span class=\"line\">hello</span><br><span class=\"line\">hi</span><br><span class=\"line\">hey</span><br></pre></td></tr></table></figure>\n<h2 id=\"三种给stringstream对象赋初值的方式\"><a href=\"#三种给stringstream对象赋初值的方式\" class=\"headerlink\" title=\"三种给stringstream对象赋初值的方式\"></a>三种给stringstream对象赋初值的方式</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">\"123\"</span>)</span></span>; <span class=\"comment\">//创建的时候赋初值</span></span><br><span class=\"line\">ss.str(<span class=\"string\">\"123\"</span>); <span class=\"comment\">//str()函数赋值</span></span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"123\"</span>; <span class=\"comment\">//操作符\"&lt;&lt;\"添加内容（需注意当前模式）</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>继续填坑٩(•̤̀ᵕ•̤́๑)，这次是stringstream的内容，最初是看到它可以把字符串直接输出成int类型，惊了，但是一直不是很懂。在网上查了很多资料，才终于差不多理解。stringstream是C++提供的一个字符串流，和cin，cout输入输出流类似，只不过它不是从从键盘或文件输入，也不是输出到屏幕或文件中，而是接受一个对象的输入，或把缓存区的内容输出到一个对象中。具体可以用在类型转换和字符分割中。<br></p>","more":"<p></p>\n<h2 id=\"基本方法-操作\"><a href=\"#基本方法-操作\" class=\"headerlink\" title=\"基本方法(操作)\"></a>基本方法(操作)</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear()－用来清空流标志(输入，输出标志)</span><br><span class=\"line\">str()－获得当前流中的内容</span><br><span class=\"line\">str(<span class=\"string\">\"content\"</span>)－设置流的内容（或清空流的内容）</span><br><span class=\"line\"><span class=\"keyword\">operator</span> &lt;&lt;－添加内容到<span class=\"built_in\">stringstream</span>对象</span><br><span class=\"line\"><span class=\"keyword\">operator</span> &gt;&gt;－从<span class=\"built_in\">stringstream</span>流缓存区中输出内容</span><br></pre></td></tr></table></figure>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\"><span class=\"comment\">//int型转换为字符串类型</span></span><br><span class=\"line\">ss &lt;&lt; a;　<span class=\"comment\">//将a输入流中（输入模式）</span></span><br><span class=\"line\">ss &gt;&gt; s;　<span class=\"comment\">//将流中的数值输出到字符串s中（输出模式）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//字符串类型转换为int型</span></span><br><span class=\"line\">ss &lt;&lt; s;　<span class=\"comment\">//将字符串输入到流中</span></span><br><span class=\"line\">ss &gt;&gt; a;　<span class=\"comment\">//将流中的字符串输出到int型变量a中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意：如果做多次数据转换须调用clear()和str(\"\")来清空输入输出标志和内容</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">ss &gt;&gt; a;</span><br><span class=\"line\">ss.clear();</span><br><span class=\"line\">ss.str(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"456\"</span>;</span><br><span class=\"line\">ss &gt;&gt; b;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a:\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"b:\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ss:\"</span> &lt;&lt; ss.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果,不加clear()和str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">0</span></span><br><span class=\"line\">ss:<span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"comment\">//原因：不加clear()和str(\"\")，流处于输出模式无法接收新内容\"456\"且未被清空，所以ss仍为\"123\"，又由于缓存区的内容已输出到a中，所以b中无内容。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果，加clear()但不加str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">456</span></span><br><span class=\"line\">ss:<span class=\"number\">123456</span></span><br><span class=\"line\"><span class=\"comment\">//原因：加入clear()清空模式，可以接收新内容\"456\"，所以ss:123456。缓存区依次缓存\"123\"，\"456\"并分别输出到a, b，所以a:123, b:456</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果，加clear()和str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">456</span></span><br><span class=\"line\">ss:<span class=\"number\">456</span></span><br><span class=\"line\"><span class=\"comment\">//原因：clear()清空模式，str(\"\")清空ss对象的内容。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"支持char-的输入和输出\"><a href=\"#支持char-的输入和输出\" class=\"headerlink\" title=\"支持char*的输入和输出\"></a>支持char*的输入和输出</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> ch[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">ss &lt;&lt; <span class=\"number\">2333</span>;</span><br><span class=\"line\">ss &gt;&gt; ch; <span class=\"comment\">//直接将数输出到ch字符数组中</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符分割\"><a href=\"#字符分割\" class=\"headerlink\" title=\"字符分割\"></a>字符分割</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">\"hello hi hey\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> word;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(ss &gt;&gt; word)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; word &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果</span></span><br><span class=\"line\">hello</span><br><span class=\"line\">hi</span><br><span class=\"line\">hey</span><br></pre></td></tr></table></figure>\n<h2 id=\"三种给stringstream对象赋初值的方式\"><a href=\"#三种给stringstream对象赋初值的方式\" class=\"headerlink\" title=\"三种给stringstream对象赋初值的方式\"></a>三种给stringstream对象赋初值的方式</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">\"123\"</span>)</span></span>; <span class=\"comment\">//创建的时候赋初值</span></span><br><span class=\"line\">ss.str(<span class=\"string\">\"123\"</span>); <span class=\"comment\">//str()函数赋值</span></span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"123\"</span>; <span class=\"comment\">//操作符\"&lt;&lt;\"添加内容（需注意当前模式）</span></span><br></pre></td></tr></table></figure>"},{"title":"python脚本-tab转空格","date":"2018-06-12T03:38:20.000Z","_content":"有一个一直比较麻烦的问题，平时写代码都是在gedit上写，然后设置了tab键是4个空格的位置，但是代码粘到博客里tab就变成了8个空格的位置，严重破坏了代码的美观！不能容忍！一直没有找到怎么在hexo里面设置，所以之前一直手动把tab换成4个空格QAQ，慢慢的觉得这样很傻，我为什么不写个程序帮我自动改＝＝，首选python！（人生苦短，我用python）。虽然对python不是很熟悉，但是边查边写应该问题不大，最终完成了，从此再也不用傻傻的手动转换了，幸福/(ㄒoㄒ)/~~代码量很小\n<!-- more -->\n## 简介\n就是把文档里的tab全部转换成4个空格，其余不变\n效果图：\n转换前\n![tab](/tab.png)\n转换后\n![space](/space.png)\n## 代码\n``` python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*- \n\ndef T2S():\n    str = raw_input(\"file name:\")\n    file_path = \"/home/aincrad/Desktop/\" + str\n    f = open(file_path, \"r\")\n    fnew = open(\"/home/aincrad/Desktop/new\", \"w\")\n    data = f.read()\n    for c in data:\n        if c == '\\t':\n            fnew.write(\"    \")\n        else:\n            fnew.write(c)\n    f.close()\n    fnew.close()\n    print \"Done\"\n\nif __name__ == \"__main__\":\n    T2S()\n```\n*说明:默认了需要转换的文件在桌面，运行程序后只需要输入文件名即可，之后会在桌面上生成名为new的转换后的文件。*\n","source":"_posts/tab-to-spaces.md","raw":"---\ntitle: python脚本-tab转空格\ndate: 2018-06-12 11:38:20\ncategories:\n- Messy article\ntags:\n- python\n---\n有一个一直比较麻烦的问题，平时写代码都是在gedit上写，然后设置了tab键是4个空格的位置，但是代码粘到博客里tab就变成了8个空格的位置，严重破坏了代码的美观！不能容忍！一直没有找到怎么在hexo里面设置，所以之前一直手动把tab换成4个空格QAQ，慢慢的觉得这样很傻，我为什么不写个程序帮我自动改＝＝，首选python！（人生苦短，我用python）。虽然对python不是很熟悉，但是边查边写应该问题不大，最终完成了，从此再也不用傻傻的手动转换了，幸福/(ㄒoㄒ)/~~代码量很小\n<!-- more -->\n## 简介\n就是把文档里的tab全部转换成4个空格，其余不变\n效果图：\n转换前\n![tab](/tab.png)\n转换后\n![space](/space.png)\n## 代码\n``` python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*- \n\ndef T2S():\n    str = raw_input(\"file name:\")\n    file_path = \"/home/aincrad/Desktop/\" + str\n    f = open(file_path, \"r\")\n    fnew = open(\"/home/aincrad/Desktop/new\", \"w\")\n    data = f.read()\n    for c in data:\n        if c == '\\t':\n            fnew.write(\"    \")\n        else:\n            fnew.write(c)\n    f.close()\n    fnew.close()\n    print \"Done\"\n\nif __name__ == \"__main__\":\n    T2S()\n```\n*说明:默认了需要转换的文件在桌面，运行程序后只需要输入文件名即可，之后会在桌面上生成名为new的转换后的文件。*\n","slug":"tab-to-spaces","published":1,"updated":"2018-08-09T15:52:30.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a202001lsxou8wpo3xsy","content":"<p>有一个一直比较麻烦的问题，平时写代码都是在gedit上写，然后设置了tab键是4个空格的位置，但是代码粘到博客里tab就变成了8个空格的位置，严重破坏了代码的美观！不能容忍！一直没有找到怎么在hexo里面设置，所以之前一直手动把tab换成4个空格QAQ，慢慢的觉得这样很傻，我为什么不写个程序帮我自动改＝＝，首选python！（人生苦短，我用python）。虽然对python不是很熟悉，但是边查边写应该问题不大，最终完成了，从此再也不用傻傻的手动转换了，幸福/(ㄒoㄒ)/~~代码量很小<br><a id=\"more\"></a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>就是把文档里的tab全部转换成4个空格，其余不变<br>效果图：<br>转换前<br><img src=\"/2018/06/12/tab-to-spaces/tab.png\" alt=\"tab\"><br>转换后<br><img src=\"/2018/06/12/tab-to-spaces/space.png\" alt=\"space\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*- </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">T2S</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    str = raw_input(<span class=\"string\">\"file name:\"</span>)</span><br><span class=\"line\">    file_path = <span class=\"string\">\"/home/aincrad/Desktop/\"</span> + str</span><br><span class=\"line\">    f = open(file_path, <span class=\"string\">\"r\"</span>)</span><br><span class=\"line\">    fnew = open(<span class=\"string\">\"/home/aincrad/Desktop/new\"</span>, <span class=\"string\">\"w\"</span>)</span><br><span class=\"line\">    data = f.read()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'\\t'</span>:</span><br><span class=\"line\">            fnew.write(<span class=\"string\">\"    \"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            fnew.write(c)</span><br><span class=\"line\">    f.close()</span><br><span class=\"line\">    fnew.close()</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Done\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    T2S()</span><br></pre></td></tr></table></figure>\n<p><em>说明:默认了需要转换的文件在桌面，运行程序后只需要输入文件名即可，之后会在桌面上生成名为new的转换后的文件。</em></p>\n","site":{"data":{}},"excerpt":"<p>有一个一直比较麻烦的问题，平时写代码都是在gedit上写，然后设置了tab键是4个空格的位置，但是代码粘到博客里tab就变成了8个空格的位置，严重破坏了代码的美观！不能容忍！一直没有找到怎么在hexo里面设置，所以之前一直手动把tab换成4个空格QAQ，慢慢的觉得这样很傻，我为什么不写个程序帮我自动改＝＝，首选python！（人生苦短，我用python）。虽然对python不是很熟悉，但是边查边写应该问题不大，最终完成了，从此再也不用傻傻的手动转换了，幸福/(ㄒoㄒ)/~~代码量很小<br></p>","more":"<p></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>就是把文档里的tab全部转换成4个空格，其余不变<br>效果图：<br>转换前<br><img src=\"/2018/06/12/tab-to-spaces/tab.png\" alt=\"tab\"><br>转换后<br><img src=\"/2018/06/12/tab-to-spaces/space.png\" alt=\"space\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*- </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">T2S</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    str = raw_input(<span class=\"string\">\"file name:\"</span>)</span><br><span class=\"line\">    file_path = <span class=\"string\">\"/home/aincrad/Desktop/\"</span> + str</span><br><span class=\"line\">    f = open(file_path, <span class=\"string\">\"r\"</span>)</span><br><span class=\"line\">    fnew = open(<span class=\"string\">\"/home/aincrad/Desktop/new\"</span>, <span class=\"string\">\"w\"</span>)</span><br><span class=\"line\">    data = f.read()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'\\t'</span>:</span><br><span class=\"line\">            fnew.write(<span class=\"string\">\"    \"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            fnew.write(c)</span><br><span class=\"line\">    f.close()</span><br><span class=\"line\">    fnew.close()</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Done\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    T2S()</span><br></pre></td></tr></table></figure>\n<p><em>说明:默认了需要转换的文件在桌面，运行程序后只需要输入文件名即可，之后会在桌面上生成名为new的转换后的文件。</em></p>"},{"title":"ubuntu下vultr服务器搭建","date":"2018-04-13T11:09:32.000Z","_content":"工欲善其事必先利其器。\n前一段时间在[陶司机学长](http://logqtainia.github.io/)的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了...，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。\n觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。\n<!-- more -->\n## 注册vultr账号\n[链接](https://www.vultr.com/)\n## 创建vultr主机\n点击右上角的蓝色加号，创建新的vultr主机\n![p1](/p1.png)\n服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)\n![p2](/p2.png)\n服务器端系统选择，选择ubuntu\n![p3](/p3.png)\n服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。\n![p4](/p4.png)\n其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)\n![p5](/p5.png)\n接下来等待主机部署完成即可。\n## 服务器端配置\n服务器端，也就是你刚刚创建的那台主机。\n点击主机右侧\"...\"展开菜单，选择\"Server Details\"可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。\n![p6](/p6.png)\n打开终端，使用ssh远程登录到主机\n```\n$ ssh root@你的主机IP地址\n```\n之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。\n登录成功后使用一键配置脚本进行配置\n```\n$ wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n```\n终端中会出现如下界面，输入１选择安装shadowsocksR\n![p7](/p7.png)\n之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择\n```\n加密方式(method):none\n协议(protocol):auth_chain_a\n混淆(obfs):plain\n```\n服务器端配置完成，终端中输入exit退出ssh登录\n```\n$ exit\n```\n## 客户端配置\n客户端，也就是你的个人电脑。\n在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。\n```\n$ wget http://www.djangoz.com/ssr\n$ sudo mv ssr /usr/local/bin\n$ sudo chmod 766 /usr/local/bin/ssr\n$ ssr install\n$ ssr config\n```\n配置和服务器端保持一直即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项\n```\n    \"server\": \"11.22.33.44\",\n    \"server_ipv6\": \"::\",\n    \"server_port\": 1234,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\": 1080,\n\n    \"password\": \"123456789\",\n    \"method\": \"none\",\n    \"protocol\": \"auth_chain_a\",\n    \"protocol_param\": \"\",\n    \"obfs\": \"plain\",\n    \"obfs_param\": \"\",\n    \"speed_limit_per_con\": 0,\n    \"speed_limit_per_user\": 0,\n\n    \"additional_ports\" : {}, // only works under multi-user mode\n    \"additional_ports_only\" : false, // only works under multi-user mode\n    \"timeout\": 120,\n    \"udp_timeout\": 60,\n    \"dns_ipv6\": false,\n    \"connect_verbose_info\": 0,\n    \"redirect\": \"\",\n\n```\n以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令\n```\nssr start\nssr stop\n```\n## 可能的问题\n检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。\n* 依次打开ubuntu系统设置->网络->网络代理，设置如下\n![p8](/p8.png)\n* 推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)\nproxy SwitchyOmega配置如下\n![p９](/p9.png)\n* 有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)\n\nps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用","source":"_posts/vultr.md","raw":"---\ntitle: ubuntu下vultr服务器搭建\ndate: 2018-04-13 19:09:32\ncategories:\n- Messy article\ntags:\n- vultr服务器搭建\n---\n工欲善其事必先利其器。\n前一段时间在[陶司机学长](http://logqtainia.github.io/)的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了...，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。\n觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。\n<!-- more -->\n## 注册vultr账号\n[链接](https://www.vultr.com/)\n## 创建vultr主机\n点击右上角的蓝色加号，创建新的vultr主机\n![p1](/p1.png)\n服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)\n![p2](/p2.png)\n服务器端系统选择，选择ubuntu\n![p3](/p3.png)\n服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。\n![p4](/p4.png)\n其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)\n![p5](/p5.png)\n接下来等待主机部署完成即可。\n## 服务器端配置\n服务器端，也就是你刚刚创建的那台主机。\n点击主机右侧\"...\"展开菜单，选择\"Server Details\"可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。\n![p6](/p6.png)\n打开终端，使用ssh远程登录到主机\n```\n$ ssh root@你的主机IP地址\n```\n之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。\n登录成功后使用一键配置脚本进行配置\n```\n$ wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n```\n终端中会出现如下界面，输入１选择安装shadowsocksR\n![p7](/p7.png)\n之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择\n```\n加密方式(method):none\n协议(protocol):auth_chain_a\n混淆(obfs):plain\n```\n服务器端配置完成，终端中输入exit退出ssh登录\n```\n$ exit\n```\n## 客户端配置\n客户端，也就是你的个人电脑。\n在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。\n```\n$ wget http://www.djangoz.com/ssr\n$ sudo mv ssr /usr/local/bin\n$ sudo chmod 766 /usr/local/bin/ssr\n$ ssr install\n$ ssr config\n```\n配置和服务器端保持一直即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项\n```\n    \"server\": \"11.22.33.44\",\n    \"server_ipv6\": \"::\",\n    \"server_port\": 1234,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\": 1080,\n\n    \"password\": \"123456789\",\n    \"method\": \"none\",\n    \"protocol\": \"auth_chain_a\",\n    \"protocol_param\": \"\",\n    \"obfs\": \"plain\",\n    \"obfs_param\": \"\",\n    \"speed_limit_per_con\": 0,\n    \"speed_limit_per_user\": 0,\n\n    \"additional_ports\" : {}, // only works under multi-user mode\n    \"additional_ports_only\" : false, // only works under multi-user mode\n    \"timeout\": 120,\n    \"udp_timeout\": 60,\n    \"dns_ipv6\": false,\n    \"connect_verbose_info\": 0,\n    \"redirect\": \"\",\n\n```\n以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令\n```\nssr start\nssr stop\n```\n## 可能的问题\n检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。\n* 依次打开ubuntu系统设置->网络->网络代理，设置如下\n![p8](/p8.png)\n* 推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)\nproxy SwitchyOmega配置如下\n![p９](/p9.png)\n* 有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)\n\nps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用","slug":"vultr","published":1,"updated":"2018-08-09T15:48:05.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a25k0035sxouap66s908","content":"<p>工欲善其事必先利其器。<br>前一段时间在<a href=\"http://logqtainia.github.io/\" target=\"_blank\" rel=\"noopener\">陶司机学长</a>的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了…，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。<br>觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。<br><a id=\"more\"></a></p>\n<h2 id=\"注册vultr账号\"><a href=\"#注册vultr账号\" class=\"headerlink\" title=\"注册vultr账号\"></a>注册vultr账号</h2><p><a href=\"https://www.vultr.com/\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"创建vultr主机\"><a href=\"#创建vultr主机\" class=\"headerlink\" title=\"创建vultr主机\"></a>创建vultr主机</h2><p>点击右上角的蓝色加号，创建新的vultr主机<br><img src=\"/2018/04/13/vultr/p1.png\" alt=\"p1\"><br>服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)<br><img src=\"/2018/04/13/vultr/p2.png\" alt=\"p2\"><br>服务器端系统选择，选择ubuntu<br><img src=\"/2018/04/13/vultr/p3.png\" alt=\"p3\"><br>服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。<br><img src=\"/2018/04/13/vultr/p4.png\" alt=\"p4\"><br>其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)<br><img src=\"/2018/04/13/vultr/p5.png\" alt=\"p5\"><br>接下来等待主机部署完成即可。</p>\n<h2 id=\"服务器端配置\"><a href=\"#服务器端配置\" class=\"headerlink\" title=\"服务器端配置\"></a>服务器端配置</h2><p>服务器端，也就是你刚刚创建的那台主机。<br>点击主机右侧”…”展开菜单，选择”Server Details”可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。<br><img src=\"/2018/04/13/vultr/p6.png\" alt=\"p6\"><br>打开终端，使用ssh远程登录到主机<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh root@你的主机IP地址</span><br></pre></td></tr></table></figure></p>\n<p>之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。<br>登录成功后使用一键配置脚本进行配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure></p>\n<p>终端中会出现如下界面，输入１选择安装shadowsocksR<br><img src=\"/2018/04/13/vultr/p7.png\" alt=\"p7\"><br>之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加密方式(method):none</span><br><span class=\"line\">协议(protocol):auth_chain_a</span><br><span class=\"line\">混淆(obfs):plain</span><br></pre></td></tr></table></figure></p>\n<p>服务器端配置完成，终端中输入exit退出ssh登录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ exit</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"客户端配置\"><a href=\"#客户端配置\" class=\"headerlink\" title=\"客户端配置\"></a>客户端配置</h2><p>客户端，也就是你的个人电脑。<br>在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget http://www.djangoz.com/ssr</span><br><span class=\"line\">$ sudo mv ssr /usr/local/bin</span><br><span class=\"line\">$ sudo chmod 766 /usr/local/bin/ssr</span><br><span class=\"line\">$ ssr install</span><br><span class=\"line\">$ ssr config</span><br></pre></td></tr></table></figure></p>\n<p>配置和服务器端保持一直即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;server&quot;: &quot;11.22.33.44&quot;,</span><br><span class=\"line\">&quot;server_ipv6&quot;: &quot;::&quot;,</span><br><span class=\"line\">&quot;server_port&quot;: 1234,</span><br><span class=\"line\">&quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">&quot;local_port&quot;: 1080,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;password&quot;: &quot;123456789&quot;,</span><br><span class=\"line\">&quot;method&quot;: &quot;none&quot;,</span><br><span class=\"line\">&quot;protocol&quot;: &quot;auth_chain_a&quot;,</span><br><span class=\"line\">&quot;protocol_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;obfs&quot;: &quot;plain&quot;,</span><br><span class=\"line\">&quot;obfs_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;speed_limit_per_con&quot;: 0,</span><br><span class=\"line\">&quot;speed_limit_per_user&quot;: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;additional_ports&quot; : &#123;&#125;, // only works under multi-user mode</span><br><span class=\"line\">&quot;additional_ports_only&quot; : false, // only works under multi-user mode</span><br><span class=\"line\">&quot;timeout&quot;: 120,</span><br><span class=\"line\">&quot;udp_timeout&quot;: 60,</span><br><span class=\"line\">&quot;dns_ipv6&quot;: false,</span><br><span class=\"line\">&quot;connect_verbose_info&quot;: 0,</span><br><span class=\"line\">&quot;redirect&quot;: &quot;&quot;,</span><br></pre></td></tr></table></figure></p>\n<p>以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssr start</span><br><span class=\"line\">ssr stop</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"可能的问题\"><a href=\"#可能的问题\" class=\"headerlink\" title=\"可能的问题\"></a>可能的问题</h2><p>检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。</p>\n<ul>\n<li>依次打开ubuntu系统设置-&gt;网络-&gt;网络代理，设置如下<br><img src=\"/2018/04/13/vultr/p8.png\" alt=\"p8\"></li>\n<li>推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)<br>proxy SwitchyOmega配置如下<br><img src=\"/2018/04/13/vultr/p9.png\" alt=\"p９\"></li>\n<li>有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)</li>\n</ul>\n<p>ps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用</p>\n","site":{"data":{}},"excerpt":"<p>工欲善其事必先利其器。<br>前一段时间在<a href=\"http://logqtainia.github.io/\" target=\"_blank\" rel=\"noopener\">陶司机学长</a>的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了…，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。<br>觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。<br></p>","more":"<p></p>\n<h2 id=\"注册vultr账号\"><a href=\"#注册vultr账号\" class=\"headerlink\" title=\"注册vultr账号\"></a>注册vultr账号</h2><p><a href=\"https://www.vultr.com/\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"创建vultr主机\"><a href=\"#创建vultr主机\" class=\"headerlink\" title=\"创建vultr主机\"></a>创建vultr主机</h2><p>点击右上角的蓝色加号，创建新的vultr主机<br><img src=\"/2018/04/13/vultr/p1.png\" alt=\"p1\"><br>服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)<br><img src=\"/2018/04/13/vultr/p2.png\" alt=\"p2\"><br>服务器端系统选择，选择ubuntu<br><img src=\"/2018/04/13/vultr/p3.png\" alt=\"p3\"><br>服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。<br><img src=\"/2018/04/13/vultr/p4.png\" alt=\"p4\"><br>其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)<br><img src=\"/2018/04/13/vultr/p5.png\" alt=\"p5\"><br>接下来等待主机部署完成即可。</p>\n<h2 id=\"服务器端配置\"><a href=\"#服务器端配置\" class=\"headerlink\" title=\"服务器端配置\"></a>服务器端配置</h2><p>服务器端，也就是你刚刚创建的那台主机。<br>点击主机右侧”…”展开菜单，选择”Server Details”可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。<br><img src=\"/2018/04/13/vultr/p6.png\" alt=\"p6\"><br>打开终端，使用ssh远程登录到主机<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh root@你的主机IP地址</span><br></pre></td></tr></table></figure></p>\n<p>之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。<br>登录成功后使用一键配置脚本进行配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure></p>\n<p>终端中会出现如下界面，输入１选择安装shadowsocksR<br><img src=\"/2018/04/13/vultr/p7.png\" alt=\"p7\"><br>之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加密方式(method):none</span><br><span class=\"line\">协议(protocol):auth_chain_a</span><br><span class=\"line\">混淆(obfs):plain</span><br></pre></td></tr></table></figure></p>\n<p>服务器端配置完成，终端中输入exit退出ssh登录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ exit</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"客户端配置\"><a href=\"#客户端配置\" class=\"headerlink\" title=\"客户端配置\"></a>客户端配置</h2><p>客户端，也就是你的个人电脑。<br>在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget http://www.djangoz.com/ssr</span><br><span class=\"line\">$ sudo mv ssr /usr/local/bin</span><br><span class=\"line\">$ sudo chmod 766 /usr/local/bin/ssr</span><br><span class=\"line\">$ ssr install</span><br><span class=\"line\">$ ssr config</span><br></pre></td></tr></table></figure></p>\n<p>配置和服务器端保持一直即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;server&quot;: &quot;11.22.33.44&quot;,</span><br><span class=\"line\">&quot;server_ipv6&quot;: &quot;::&quot;,</span><br><span class=\"line\">&quot;server_port&quot;: 1234,</span><br><span class=\"line\">&quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">&quot;local_port&quot;: 1080,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;password&quot;: &quot;123456789&quot;,</span><br><span class=\"line\">&quot;method&quot;: &quot;none&quot;,</span><br><span class=\"line\">&quot;protocol&quot;: &quot;auth_chain_a&quot;,</span><br><span class=\"line\">&quot;protocol_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;obfs&quot;: &quot;plain&quot;,</span><br><span class=\"line\">&quot;obfs_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;speed_limit_per_con&quot;: 0,</span><br><span class=\"line\">&quot;speed_limit_per_user&quot;: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;additional_ports&quot; : &#123;&#125;, // only works under multi-user mode</span><br><span class=\"line\">&quot;additional_ports_only&quot; : false, // only works under multi-user mode</span><br><span class=\"line\">&quot;timeout&quot;: 120,</span><br><span class=\"line\">&quot;udp_timeout&quot;: 60,</span><br><span class=\"line\">&quot;dns_ipv6&quot;: false,</span><br><span class=\"line\">&quot;connect_verbose_info&quot;: 0,</span><br><span class=\"line\">&quot;redirect&quot;: &quot;&quot;,</span><br></pre></td></tr></table></figure></p>\n<p>以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssr start</span><br><span class=\"line\">ssr stop</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"可能的问题\"><a href=\"#可能的问题\" class=\"headerlink\" title=\"可能的问题\"></a>可能的问题</h2><p>检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。</p>\n<ul>\n<li>依次打开ubuntu系统设置-&gt;网络-&gt;网络代理，设置如下<br><img src=\"/2018/04/13/vultr/p8.png\" alt=\"p8\"></li>\n<li>推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)<br>proxy SwitchyOmega配置如下<br><img src=\"/2018/04/13/vultr/p9.png\" alt=\"p９\"></li>\n<li>有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)</li>\n</ul>\n<p>ps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用</p>"},{"title":"POJ2481-线段树单点更新","date":"2018-04-22T08:51:50.000Z","_content":"最近刚刚开始做线段树相关的题目，很艰难...依照现在的理解其实线段树的题的暴力求解思路比较容易想到，但是暴力求解的时间复杂度一般肯会超，而线段树也正是这样一种通过区间更新来解决大量输入数据问题、降低时间复杂度的高级数据结构。线段树的关键是确定每个节点维护的是什么数据，以及以什么参数为依据进行区间的查询。\n被POJ上的这道题卡了很久，一开始是思路问题，后来是一些细节问题，总之还是熟练度不高...\n[参考博客链接](http://111qqz.com/2015/08/poj2481/)\n<!-- more -->\n## 题目链接\n[POJ2481](http://poj.org/problem?id=2481)\n## 题目描述\n共有N头牛，每头牛对应一个进食区间[$S$,$E$], 对两头牛$i$,$j$来说，假设它们对应的区间分别为[$S\\_i$,$E\\_i$]和[$S\\_j$,$E\\_j$]，如果满足$S\\_i<=S\\_j，E\\_j<=E\\_i$且$E\\_i-S\\_i>E\\_j-S\\_j$,那么我们可以说牛$i$要比牛$j$强壮。\n现对于每头牛来说计算比它强壮的牛的数量。\n## 题解\n先对区间进行排序，右端点降序为第一关键字，左端点升序为第二关键字。这样进行处理后第$i$个区间的右端点一定小于前$i-1$个区间的右端点了，那么只要进行左端点的判决就可以了，具体做法为：\n每次处理一个区间后都将该区间的左端点更新到线段树中（插入后相对应叶节点数值+1，插入前为0）。\n那么当我们查询第$i$个区间时其实也就是查询线段树中从1到$i-1$的区间内左端点的标记个数。\n**于是线段树每个节点维护的就是以该节点为根节点的子树所代表的区间中左端点的个数，而进行区间查询依据的参数也就是每个区间的左端点。**\n*需要注意的问题*:\n**两个区间重合时的情况要特殊处理，这种情况不算在内，做法可以是对排好序的每个区间进行处理前先检查它是否和上一查询区间重合，若重合则直接将上一区间的查询结果赋予该区间，并将该区间对应的左端点在线段树中再次更新（再次加1）,而后跳过该区间的查询。**详见代码：\n## 代码\n关于线段树的实现部分基于《挑战程序设计竞赛》一书中的实现模板，也可参考其它实现模板，形成自己的书写习惯。\n``` C++\n//#include <bits/stdc++.h> //POJ上大部分题不支持该头文件\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1 << 18;\ntypedef struct node{\n    int vl;\n    int vr;\n    int id;\n} nod;\nnod a[maxn];\nint d[2 * maxn];\nint n, pn;\nint ans[maxn];\n//排序部分\nbool cmp(const nod& a, const nod& b){\n    if(a.vr == b.vr) \n        return a.vl < b.vl;\n    else\n        return a.vr > b.vr;\n}\n//初始化\nvoid init(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n    for(int i = 0; i < 2 * n - 1; i++){\n        d[i] = 0;\n    }\n}\n//查询操作\nint query(int a, int b, int k, int l, int r){\n    if(a <= l && b >= r) return d[k];\n    if(b <= l) return 0;\n    else{\n        int res1 = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        int res2 = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return res1 + res2;\n    }\n}\n//更新操作\nvoid update(int k){\n    k += n - 1;\n    d[k] += 1;\n    while(k > 0){\n        k = (k - 1) / 2;\n        d[k] = d[2 *k + 1] + d[2 * k + 2];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int t1, t2;\n    while(~scanf(\"%d\", &n)){\n        memset(ans, 0, sizeof(ans));\n        memset(d, 0, sizeof(d));\n\t    if(n == 0) break;\n\t    for(int i = 0; i < n; i++){\n            scanf(\"%d%d\", &t1, &t2);\n            a[i].vl = t1;\n            a[i].vr = t2;\n            a[i].id = i;\n        }\n        sort(a, a + n, cmp);\n        pn = n;\n        init(n);\n        for(int i = 0; i < pn; i++){\n            //if内为判断重合区间部分\n            if(i >= 1 && a[i].vl == a[i - 1].vl && a[i].vr == a[i - 1].vr){\n                ans[a[i].id] = ans[a[i - 1].id];\n                update(a[i].vl);\n                continue;\n            }\n            ans[a[i].id] = query(0, a[i].vl + 1, 0, 0, n);\n            update(a[i].vl);\n\t\t\t\n        }\n        for(int i = 0; i < pn; i++){\n            printf(\"%d%c\", ans[i], i < pn - 1 ? ' ' : '\\n');\n        }\n    }\n\t\n    return 0;\n}\n```","source":"_posts/POJ2481.md","raw":"---\ntitle: POJ2481-线段树单点更新\ndate: 2018-04-22 16:51:50\ncategories: \n- ACM\ntags:\n- POJ\n- 线段树\n---\n最近刚刚开始做线段树相关的题目，很艰难...依照现在的理解其实线段树的题的暴力求解思路比较容易想到，但是暴力求解的时间复杂度一般肯会超，而线段树也正是这样一种通过区间更新来解决大量输入数据问题、降低时间复杂度的高级数据结构。线段树的关键是确定每个节点维护的是什么数据，以及以什么参数为依据进行区间的查询。\n被POJ上的这道题卡了很久，一开始是思路问题，后来是一些细节问题，总之还是熟练度不高...\n[参考博客链接](http://111qqz.com/2015/08/poj2481/)\n<!-- more -->\n## 题目链接\n[POJ2481](http://poj.org/problem?id=2481)\n## 题目描述\n共有N头牛，每头牛对应一个进食区间[$S$,$E$], 对两头牛$i$,$j$来说，假设它们对应的区间分别为[$S\\_i$,$E\\_i$]和[$S\\_j$,$E\\_j$]，如果满足$S\\_i<=S\\_j，E\\_j<=E\\_i$且$E\\_i-S\\_i>E\\_j-S\\_j$,那么我们可以说牛$i$要比牛$j$强壮。\n现对于每头牛来说计算比它强壮的牛的数量。\n## 题解\n先对区间进行排序，右端点降序为第一关键字，左端点升序为第二关键字。这样进行处理后第$i$个区间的右端点一定小于前$i-1$个区间的右端点了，那么只要进行左端点的判决就可以了，具体做法为：\n每次处理一个区间后都将该区间的左端点更新到线段树中（插入后相对应叶节点数值+1，插入前为0）。\n那么当我们查询第$i$个区间时其实也就是查询线段树中从1到$i-1$的区间内左端点的标记个数。\n**于是线段树每个节点维护的就是以该节点为根节点的子树所代表的区间中左端点的个数，而进行区间查询依据的参数也就是每个区间的左端点。**\n*需要注意的问题*:\n**两个区间重合时的情况要特殊处理，这种情况不算在内，做法可以是对排好序的每个区间进行处理前先检查它是否和上一查询区间重合，若重合则直接将上一区间的查询结果赋予该区间，并将该区间对应的左端点在线段树中再次更新（再次加1）,而后跳过该区间的查询。**详见代码：\n## 代码\n关于线段树的实现部分基于《挑战程序设计竞赛》一书中的实现模板，也可参考其它实现模板，形成自己的书写习惯。\n``` C++\n//#include <bits/stdc++.h> //POJ上大部分题不支持该头文件\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1 << 18;\ntypedef struct node{\n    int vl;\n    int vr;\n    int id;\n} nod;\nnod a[maxn];\nint d[2 * maxn];\nint n, pn;\nint ans[maxn];\n//排序部分\nbool cmp(const nod& a, const nod& b){\n    if(a.vr == b.vr) \n        return a.vl < b.vl;\n    else\n        return a.vr > b.vr;\n}\n//初始化\nvoid init(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n    for(int i = 0; i < 2 * n - 1; i++){\n        d[i] = 0;\n    }\n}\n//查询操作\nint query(int a, int b, int k, int l, int r){\n    if(a <= l && b >= r) return d[k];\n    if(b <= l) return 0;\n    else{\n        int res1 = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        int res2 = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return res1 + res2;\n    }\n}\n//更新操作\nvoid update(int k){\n    k += n - 1;\n    d[k] += 1;\n    while(k > 0){\n        k = (k - 1) / 2;\n        d[k] = d[2 *k + 1] + d[2 * k + 2];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int t1, t2;\n    while(~scanf(\"%d\", &n)){\n        memset(ans, 0, sizeof(ans));\n        memset(d, 0, sizeof(d));\n\t    if(n == 0) break;\n\t    for(int i = 0; i < n; i++){\n            scanf(\"%d%d\", &t1, &t2);\n            a[i].vl = t1;\n            a[i].vr = t2;\n            a[i].id = i;\n        }\n        sort(a, a + n, cmp);\n        pn = n;\n        init(n);\n        for(int i = 0; i < pn; i++){\n            //if内为判断重合区间部分\n            if(i >= 1 && a[i].vl == a[i - 1].vl && a[i].vr == a[i - 1].vr){\n                ans[a[i].id] = ans[a[i - 1].id];\n                update(a[i].vl);\n                continue;\n            }\n            ans[a[i].id] = query(0, a[i].vl + 1, 0, 0, n);\n            update(a[i].vl);\n\t\t\t\n        }\n        for(int i = 0; i < pn; i++){\n            printf(\"%d%c\", ans[i], i < pn - 1 ? ' ' : '\\n');\n        }\n    }\n\t\n    return 0;\n}\n```","slug":"POJ2481","published":1,"updated":"2018-08-14T12:12:45.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a25n0037sxouuo2qytww","content":"<p>最近刚刚开始做线段树相关的题目，很艰难…依照现在的理解其实线段树的题的暴力求解思路比较容易想到，但是暴力求解的时间复杂度一般肯会超，而线段树也正是这样一种通过区间更新来解决大量输入数据问题、降低时间复杂度的高级数据结构。线段树的关键是确定每个节点维护的是什么数据，以及以什么参数为依据进行区间的查询。<br>被POJ上的这道题卡了很久，一开始是思路问题，后来是一些细节问题，总之还是熟练度不高…<br><a href=\"http://111qqz.com/2015/08/poj2481/\" target=\"_blank\" rel=\"noopener\">参考博客链接</a><br><a id=\"more\"></a></p>\n<h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"http://poj.org/problem?id=2481\" target=\"_blank\" rel=\"noopener\">POJ2481</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>共有N头牛，每头牛对应一个进食区间[$S$,$E$], 对两头牛$i$,$j$来说，假设它们对应的区间分别为[$S_i$,$E_i$]和[$S_j$,$E_j$]，如果满足$S_i&lt;=S_j，E_j&lt;=E_i$且$E_i-S_i&gt;E_j-S_j$,那么我们可以说牛$i$要比牛$j$强壮。<br>现对于每头牛来说计算比它强壮的牛的数量。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>先对区间进行排序，右端点降序为第一关键字，左端点升序为第二关键字。这样进行处理后第$i$个区间的右端点一定小于前$i-1$个区间的右端点了，那么只要进行左端点的判决就可以了，具体做法为：<br>每次处理一个区间后都将该区间的左端点更新到线段树中（插入后相对应叶节点数值+1，插入前为0）。<br>那么当我们查询第$i$个区间时其实也就是查询线段树中从1到$i-1$的区间内左端点的标记个数。<br><strong>于是线段树每个节点维护的就是以该节点为根节点的子树所代表的区间中左端点的个数，而进行区间查询依据的参数也就是每个区间的左端点。</strong><br><em>需要注意的问题</em>:<br><strong>两个区间重合时的情况要特殊处理，这种情况不算在内，做法可以是对排好序的每个区间进行处理前先检查它是否和上一查询区间重合，若重合则直接将上一区间的查询结果赋予该区间，并将该区间对应的左端点在线段树中再次更新（再次加1）,而后跳过该区间的查询。</strong>详见代码：</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>关于线段树的实现部分基于《挑战程序设计竞赛》一书中的实现模板，也可参考其它实现模板，形成自己的书写习惯。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt; //POJ上大部分题不支持该头文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> vr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">&#125; nod;</span><br><span class=\"line\">nod a[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[<span class=\"number\">2</span> * maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, pn;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans[maxn];</span><br><span class=\"line\"><span class=\"comment\">//排序部分</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> nod&amp; a, <span class=\"keyword\">const</span> nod&amp; b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.vr == b.vr) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.vl &lt; b.vl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.vr &gt; b.vr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> _n)</span></span>&#123;</span><br><span class=\"line\">    n = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &lt; _n) n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span> * n - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        d[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//查询操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a &lt;= l &amp;&amp; b &gt;= r) <span class=\"keyword\">return</span> d[k];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b &lt;= l) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res1 = query(a, b, <span class=\"number\">2</span> * k + <span class=\"number\">1</span>, l, (l + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res2 = query(a, b, <span class=\"number\">2</span> * k + <span class=\"number\">2</span>, (l + r) / <span class=\"number\">2</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res1 + res2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//更新操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    k += n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    d[k] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        k = (k - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        d[k] = d[<span class=\"number\">2</span> *k + <span class=\"number\">1</span>] + d[<span class=\"number\">2</span> * k + <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t1, t2;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(ans, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(ans));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;t1, &amp;t2);</span><br><span class=\"line\">            a[i].vl = t1;</span><br><span class=\"line\">            a[i].vr = t2;</span><br><span class=\"line\">            a[i].id = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(a, a + n, cmp);</span><br><span class=\"line\">        pn = n;</span><br><span class=\"line\">        init(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pn; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//if内为判断重合区间部分</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= <span class=\"number\">1</span> &amp;&amp; a[i].vl == a[i - <span class=\"number\">1</span>].vl &amp;&amp; a[i].vr == a[i - <span class=\"number\">1</span>].vr)&#123;</span><br><span class=\"line\">                ans[a[i].id] = ans[a[i - <span class=\"number\">1</span>].id];</span><br><span class=\"line\">                update(a[i].vl);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans[a[i].id] = query(<span class=\"number\">0</span>, a[i].vl + <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n);</span><br><span class=\"line\">            update(a[i].vl);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pn; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d%c\"</span>, ans[i], i &lt; pn - <span class=\"number\">1</span> ? <span class=\"string\">' '</span> : <span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>最近刚刚开始做线段树相关的题目，很艰难…依照现在的理解其实线段树的题的暴力求解思路比较容易想到，但是暴力求解的时间复杂度一般肯会超，而线段树也正是这样一种通过区间更新来解决大量输入数据问题、降低时间复杂度的高级数据结构。线段树的关键是确定每个节点维护的是什么数据，以及以什么参数为依据进行区间的查询。<br>被POJ上的这道题卡了很久，一开始是思路问题，后来是一些细节问题，总之还是熟练度不高…<br><a href=\"http://111qqz.com/2015/08/poj2481/\" target=\"_blank\" rel=\"noopener\">参考博客链接</a><br></p>","more":"<p></p>\n<h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"http://poj.org/problem?id=2481\" target=\"_blank\" rel=\"noopener\">POJ2481</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>共有N头牛，每头牛对应一个进食区间[$S$,$E$], 对两头牛$i$,$j$来说，假设它们对应的区间分别为[$S_i$,$E_i$]和[$S_j$,$E_j$]，如果满足$S_i&lt;=S_j，E_j&lt;=E_i$且$E_i-S_i&gt;E_j-S_j$,那么我们可以说牛$i$要比牛$j$强壮。<br>现对于每头牛来说计算比它强壮的牛的数量。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>先对区间进行排序，右端点降序为第一关键字，左端点升序为第二关键字。这样进行处理后第$i$个区间的右端点一定小于前$i-1$个区间的右端点了，那么只要进行左端点的判决就可以了，具体做法为：<br>每次处理一个区间后都将该区间的左端点更新到线段树中（插入后相对应叶节点数值+1，插入前为0）。<br>那么当我们查询第$i$个区间时其实也就是查询线段树中从1到$i-1$的区间内左端点的标记个数。<br><strong>于是线段树每个节点维护的就是以该节点为根节点的子树所代表的区间中左端点的个数，而进行区间查询依据的参数也就是每个区间的左端点。</strong><br><em>需要注意的问题</em>:<br><strong>两个区间重合时的情况要特殊处理，这种情况不算在内，做法可以是对排好序的每个区间进行处理前先检查它是否和上一查询区间重合，若重合则直接将上一区间的查询结果赋予该区间，并将该区间对应的左端点在线段树中再次更新（再次加1）,而后跳过该区间的查询。</strong>详见代码：</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>关于线段树的实现部分基于《挑战程序设计竞赛》一书中的实现模板，也可参考其它实现模板，形成自己的书写习惯。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt; //POJ上大部分题不支持该头文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> vr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">&#125; nod;</span><br><span class=\"line\">nod a[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[<span class=\"number\">2</span> * maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, pn;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans[maxn];</span><br><span class=\"line\"><span class=\"comment\">//排序部分</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> nod&amp; a, <span class=\"keyword\">const</span> nod&amp; b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.vr == b.vr) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.vl &lt; b.vl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.vr &gt; b.vr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> _n)</span></span>&#123;</span><br><span class=\"line\">    n = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &lt; _n) n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span> * n - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        d[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//查询操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a &lt;= l &amp;&amp; b &gt;= r) <span class=\"keyword\">return</span> d[k];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b &lt;= l) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res1 = query(a, b, <span class=\"number\">2</span> * k + <span class=\"number\">1</span>, l, (l + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res2 = query(a, b, <span class=\"number\">2</span> * k + <span class=\"number\">2</span>, (l + r) / <span class=\"number\">2</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res1 + res2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//更新操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    k += n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    d[k] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        k = (k - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        d[k] = d[<span class=\"number\">2</span> *k + <span class=\"number\">1</span>] + d[<span class=\"number\">2</span> * k + <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t1, t2;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(ans, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(ans));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;t1, &amp;t2);</span><br><span class=\"line\">            a[i].vl = t1;</span><br><span class=\"line\">            a[i].vr = t2;</span><br><span class=\"line\">            a[i].id = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(a, a + n, cmp);</span><br><span class=\"line\">        pn = n;</span><br><span class=\"line\">        init(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pn; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//if内为判断重合区间部分</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= <span class=\"number\">1</span> &amp;&amp; a[i].vl == a[i - <span class=\"number\">1</span>].vl &amp;&amp; a[i].vr == a[i - <span class=\"number\">1</span>].vr)&#123;</span><br><span class=\"line\">                ans[a[i].id] = ans[a[i - <span class=\"number\">1</span>].id];</span><br><span class=\"line\">                update(a[i].vl);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans[a[i].id] = query(<span class=\"number\">0</span>, a[i].vl + <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n);</span><br><span class=\"line\">            update(a[i].vl);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pn; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d%c\"</span>, ans[i], i &lt; pn - <span class=\"number\">1</span> ? <span class=\"string\">' '</span> : <span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"STL中自定义比较函数和重载运算符总结","date":"2018-08-07T14:13:16.000Z","_content":"之前一直搞不太懂自定义比较函数和重载运算符的概念，只会依葫芦画瓢的实现功能，渐渐的觉得这样不太好，虽然细节是魔鬼，但有些东西还是搞明白一点比较好。部分内容转载自[Ohazyi Zone's blog](https://www.ohazyi.com/c_cmp/)\n<!-- more -->\n## sort\n### 自定义比较函数\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool cmp(const node& a, const node& b){\n    return a.x > b.x //对x降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n, cmp);\n    return 0;\n}\n```\n注：自定义比较函数的形式同样也适用于pair类型数据排序。\n### 重载运算符<\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x; //重载为降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n);\n    return 0;\n}\n```\n注：由于sort默认less(升序),所以重载'<'运算符。重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n\n## priority_queue\n### 重载运算符< (运算符重载函数放到结构体外)\n```C++\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x //less默认大顶堆，改为小顶堆\n}\n\n//bool operator >(const node& a, const node& b){\n//    return a.x < b.x //greater默认小顶堆，改为大顶堆\n//}\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同样重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n### 重载运算符< (运算符重载函数放到结构体内)\n```C++\nstruct node{\n    int x, y;\n    bool operator <(node a) const { //必须加const\n        return x > a.x;\n    }\n    //bool operator >(node a) const { //必须加const\n    //    return x < a.x;\n    //}\n};\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同上。\n### 自定义比较函数\n```C++\nstruct node{\n    int x, y;\n};\n\nstruct cmp1{\n    bool operator()(node a, node b){\n        return a.x > b.x; //小顶堆\n    }\n}\n\nstruct cmp2{\n    bool operator()(node a, node b){\n        return a.x < b.x; //大顶堆\n    }\n}\n\nint main(){\n    priority_queue<node, vector<node>, cmp1> que1; //小顶堆\n    priority_queue<node, vector<node>, cmp2> que2; //大顶堆\n    return 0;\n}\n```\n注：同样适用于pair类型数据排序。\n## 其它\n```C++\nset<int, greater<int> > st; //按照从大到小，默认是less<int>\ntypedef pair <int,int> P;\nset<P> st; //按照pair的第一个元素来排，第一个相等的话按第二个来排\nset<P, greater<P> > st;//按照从大到小的greater来排\n```\n注：set、map的自定义比较函数和重载运算符与优先队列priority_queue类似。","source":"_posts/STL-cmp.md","raw":"---\ntitle: STL中自定义比较函数和重载运算符总结\ndate: 2018-08-07 22:13:16\ncategories:\n- ACM\ntags:\n- STL\n---\n之前一直搞不太懂自定义比较函数和重载运算符的概念，只会依葫芦画瓢的实现功能，渐渐的觉得这样不太好，虽然细节是魔鬼，但有些东西还是搞明白一点比较好。部分内容转载自[Ohazyi Zone's blog](https://www.ohazyi.com/c_cmp/)\n<!-- more -->\n## sort\n### 自定义比较函数\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool cmp(const node& a, const node& b){\n    return a.x > b.x //对x降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n, cmp);\n    return 0;\n}\n```\n注：自定义比较函数的形式同样也适用于pair类型数据排序。\n### 重载运算符<\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x; //重载为降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n);\n    return 0;\n}\n```\n注：由于sort默认less(升序),所以重载'<'运算符。重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n\n## priority_queue\n### 重载运算符< (运算符重载函数放到结构体外)\n```C++\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x //less默认大顶堆，改为小顶堆\n}\n\n//bool operator >(const node& a, const node& b){\n//    return a.x < b.x //greater默认小顶堆，改为大顶堆\n//}\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同样重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n### 重载运算符< (运算符重载函数放到结构体内)\n```C++\nstruct node{\n    int x, y;\n    bool operator <(node a) const { //必须加const\n        return x > a.x;\n    }\n    //bool operator >(node a) const { //必须加const\n    //    return x < a.x;\n    //}\n};\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同上。\n### 自定义比较函数\n```C++\nstruct node{\n    int x, y;\n};\n\nstruct cmp1{\n    bool operator()(node a, node b){\n        return a.x > b.x; //小顶堆\n    }\n}\n\nstruct cmp2{\n    bool operator()(node a, node b){\n        return a.x < b.x; //大顶堆\n    }\n}\n\nint main(){\n    priority_queue<node, vector<node>, cmp1> que1; //小顶堆\n    priority_queue<node, vector<node>, cmp2> que2; //大顶堆\n    return 0;\n}\n```\n注：同样适用于pair类型数据排序。\n## 其它\n```C++\nset<int, greater<int> > st; //按照从大到小，默认是less<int>\ntypedef pair <int,int> P;\nset<P> st; //按照pair的第一个元素来排，第一个相等的话按第二个来排\nset<P, greater<P> > st;//按照从大到小的greater来排\n```\n注：set、map的自定义比较函数和重载运算符与优先队列priority_queue类似。","slug":"STL-cmp","published":1,"updated":"2018-08-07T15:38:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a25t003asxoud9192d2a","content":"<p>之前一直搞不太懂自定义比较函数和重载运算符的概念，只会依葫芦画瓢的实现功能，渐渐的觉得这样不太好，虽然细节是魔鬼，但有些东西还是搞明白一点比较好。部分内容转载自<a href=\"https://www.ohazyi.com/c_cmp/\" target=\"_blank\" rel=\"noopener\">Ohazyi Zone’s blog</a><br><a id=\"more\"></a></p>\n<h2 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h2><h3 id=\"自定义比较函数\"><a href=\"#自定义比较函数\" class=\"headerlink\" title=\"自定义比较函数\"></a>自定义比较函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x <span class=\"comment\">//对x降序排列</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sort(d, d + n, cmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：自定义比较函数的形式同样也适用于pair类型数据排序。</p>\n<h3 id=\"重载运算符-lt\"><a href=\"#重载运算符-lt\" class=\"headerlink\" title=\"重载运算符&lt;\"></a>重载运算符&lt;</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x; <span class=\"comment\">//重载为降序排列</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sort(d, d + n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：由于sort默认less(升序),所以重载’&lt;’运算符。重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。</p>\n<h2 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue\"></a>priority_queue</h2><h3 id=\"重载运算符-lt-运算符重载函数放到结构体外\"><a href=\"#重载运算符-lt-运算符重载函数放到结构体外\" class=\"headerlink\" title=\"重载运算符&lt; (运算符重载函数放到结构体外)\"></a>重载运算符&lt; (运算符重载函数放到结构体外)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x <span class=\"comment\">//less默认大顶堆，改为小顶堆</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//bool operator &gt;(const node&amp; a, const node&amp; b)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    return a.x &lt; b.x //greater默认小顶堆，改为大顶堆</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main()&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, less&lt;node&gt; &gt; que;</span><br><span class=\"line\">    <span class=\"comment\">//priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; que;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同样重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。</p>\n<h3 id=\"重载运算符-lt-运算符重载函数放到结构体内\"><a href=\"#重载运算符-lt-运算符重载函数放到结构体内\" class=\"headerlink\" title=\"重载运算符&lt; (运算符重载函数放到结构体内)\"></a>重载运算符&lt; (运算符重载函数放到结构体内)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(node a) <span class=\"keyword\">const</span> &#123; <span class=\"comment\">//必须加const</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x &gt; a.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//bool operator &gt;(node a) const &#123; //必须加const</span></span><br><span class=\"line\">    <span class=\"comment\">//    return x &lt; a.x;</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, less&lt;node&gt; &gt; que;</span><br><span class=\"line\">    <span class=\"comment\">//priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; que;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同上。</p>\n<h3 id=\"自定义比较函数-1\"><a href=\"#自定义比较函数-1\" class=\"headerlink\" title=\"自定义比较函数\"></a>自定义比较函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp1</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(node a, node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.x &gt; b.x; <span class=\"comment\">//小顶堆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp2</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(node a, node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.x &lt; b.x; <span class=\"comment\">//大顶堆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, cmp1&gt; que1; <span class=\"comment\">//小顶堆</span></span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, cmp2&gt; que2; <span class=\"comment\">//大顶堆</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同样适用于pair类型数据排序。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>, greater&lt;<span class=\"keyword\">int</span>&gt; &gt; st; <span class=\"comment\">//按照从大到小，默认是less&lt;int&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;P&gt; st; <span class=\"comment\">//按照pair的第一个元素来排，第一个相等的话按第二个来排</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;P, greater&lt;P&gt; &gt; st;<span class=\"comment\">//按照从大到小的greater来排</span></span><br></pre></td></tr></table></figure>\n<p>注：set、map的自定义比较函数和重载运算符与优先队列priority_queue类似。</p>\n","site":{"data":{}},"excerpt":"<p>之前一直搞不太懂自定义比较函数和重载运算符的概念，只会依葫芦画瓢的实现功能，渐渐的觉得这样不太好，虽然细节是魔鬼，但有些东西还是搞明白一点比较好。部分内容转载自<a href=\"https://www.ohazyi.com/c_cmp/\" target=\"_blank\" rel=\"noopener\">Ohazyi Zone’s blog</a><br></p>","more":"<p></p>\n<h2 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h2><h3 id=\"自定义比较函数\"><a href=\"#自定义比较函数\" class=\"headerlink\" title=\"自定义比较函数\"></a>自定义比较函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x <span class=\"comment\">//对x降序排列</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sort(d, d + n, cmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：自定义比较函数的形式同样也适用于pair类型数据排序。</p>\n<h3 id=\"重载运算符-lt\"><a href=\"#重载运算符-lt\" class=\"headerlink\" title=\"重载运算符&lt;\"></a>重载运算符&lt;</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x; <span class=\"comment\">//重载为降序排列</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sort(d, d + n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：由于sort默认less(升序),所以重载’&lt;’运算符。重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。</p>\n<h2 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue\"></a>priority_queue</h2><h3 id=\"重载运算符-lt-运算符重载函数放到结构体外\"><a href=\"#重载运算符-lt-运算符重载函数放到结构体外\" class=\"headerlink\" title=\"重载运算符&lt; (运算符重载函数放到结构体外)\"></a>重载运算符&lt; (运算符重载函数放到结构体外)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x <span class=\"comment\">//less默认大顶堆，改为小顶堆</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//bool operator &gt;(const node&amp; a, const node&amp; b)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    return a.x &lt; b.x //greater默认小顶堆，改为大顶堆</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main()&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, less&lt;node&gt; &gt; que;</span><br><span class=\"line\">    <span class=\"comment\">//priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; que;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同样重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。</p>\n<h3 id=\"重载运算符-lt-运算符重载函数放到结构体内\"><a href=\"#重载运算符-lt-运算符重载函数放到结构体内\" class=\"headerlink\" title=\"重载运算符&lt; (运算符重载函数放到结构体内)\"></a>重载运算符&lt; (运算符重载函数放到结构体内)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(node a) <span class=\"keyword\">const</span> &#123; <span class=\"comment\">//必须加const</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x &gt; a.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//bool operator &gt;(node a) const &#123; //必须加const</span></span><br><span class=\"line\">    <span class=\"comment\">//    return x &lt; a.x;</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, less&lt;node&gt; &gt; que;</span><br><span class=\"line\">    <span class=\"comment\">//priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; que;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同上。</p>\n<h3 id=\"自定义比较函数-1\"><a href=\"#自定义比较函数-1\" class=\"headerlink\" title=\"自定义比较函数\"></a>自定义比较函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp1</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(node a, node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.x &gt; b.x; <span class=\"comment\">//小顶堆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp2</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(node a, node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.x &lt; b.x; <span class=\"comment\">//大顶堆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, cmp1&gt; que1; <span class=\"comment\">//小顶堆</span></span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, cmp2&gt; que2; <span class=\"comment\">//大顶堆</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同样适用于pair类型数据排序。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>, greater&lt;<span class=\"keyword\">int</span>&gt; &gt; st; <span class=\"comment\">//按照从大到小，默认是less&lt;int&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;P&gt; st; <span class=\"comment\">//按照pair的第一个元素来排，第一个相等的话按第二个来排</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;P, greater&lt;P&gt; &gt; st;<span class=\"comment\">//按照从大到小的greater来排</span></span><br></pre></td></tr></table></figure>\n<p>注：set、map的自定义比较函数和重载运算符与优先队列priority_queue类似。</p>"},{"title":"线段树单点更新模板","date":"2018-05-06T13:47:10.000Z","_content":"之前一直在用大白上的线段树单点更新模板，最近渐渐发现有一些不太舒服的地方，一方面是大白上的模板会强行把线段树建成一个满二叉树，这样虽然比较好理解一些，但同时也会因为要考虑多出来的那些点的影响而相对麻烦。另一方面是因为大家貌似都不用大白上的线段树模板= =||，这样搜题解以及和队友交流的时候会存在一些障碍（其实这一方面是主要原因），所以最后通过权衡还是选择了一个自己觉得通用性比较好也比较好实现的模板。[参考博客链接](http://www.hysonn.com/2017/01/26/segtree/)\nPs:关于线段树区间更新目前正在学习中，之后再补上关于区间更新的模板。\n<!-- more -->\n## 基于最大值查询的线段树模板\n```C++\n//首先定义线段树的结构体\nstruct SegTree{\n    int vl, vr;         //每个tree[k]对应一个节点，其中vl, vr是节点对应的区间\n    int mv;             //表示节点维护的数据，视情况而定，以维护区间最大值为例\n}tree[maxn << 2];       //绝对安全的情况是建议开四倍数据量的大小\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\n```\n## 例题实现\n[HDU-1754--I Hate It(线段树单点更新入门题)](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint n, m;\nstruct SegTree{\n    int vl, vr;\n    int mv;\n}tree[maxn << 2];\n\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)//doubt\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\t\n    while(~scanf(\"%d%d\", &n, &m)){\n        char c[10];\n        int a, b;\n        for(int i = 1; i <= n; i++){\n            scanf(\"%d\", &d[i]);\n        }\n        build(1, 1, n);\n        for(int i = 1; i <= m; i++){\n            scanf(\"%s%d%d\", c, &a, &b);\n            if(c[0] == 'Q')\n                printf(\"%d\\n\", query(1, a, b));\n            else if(c[0] == 'U')\n            update(1, a, b);\n        }\n\t\t\n\t}\n\t\n    return 0;\n}\n```\n\n","source":"_posts/segtree-template.md","raw":"---\ntitle: 线段树单点更新模板\ndate: 2018-05-06 21:47:10\ncategories:\n- ACM\ntags:\n- 线段树单点更新\n---\n之前一直在用大白上的线段树单点更新模板，最近渐渐发现有一些不太舒服的地方，一方面是大白上的模板会强行把线段树建成一个满二叉树，这样虽然比较好理解一些，但同时也会因为要考虑多出来的那些点的影响而相对麻烦。另一方面是因为大家貌似都不用大白上的线段树模板= =||，这样搜题解以及和队友交流的时候会存在一些障碍（其实这一方面是主要原因），所以最后通过权衡还是选择了一个自己觉得通用性比较好也比较好实现的模板。[参考博客链接](http://www.hysonn.com/2017/01/26/segtree/)\nPs:关于线段树区间更新目前正在学习中，之后再补上关于区间更新的模板。\n<!-- more -->\n## 基于最大值查询的线段树模板\n```C++\n//首先定义线段树的结构体\nstruct SegTree{\n    int vl, vr;         //每个tree[k]对应一个节点，其中vl, vr是节点对应的区间\n    int mv;             //表示节点维护的数据，视情况而定，以维护区间最大值为例\n}tree[maxn << 2];       //绝对安全的情况是建议开四倍数据量的大小\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\n```\n## 例题实现\n[HDU-1754--I Hate It(线段树单点更新入门题)](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint n, m;\nstruct SegTree{\n    int vl, vr;\n    int mv;\n}tree[maxn << 2];\n\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)//doubt\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\t\n    while(~scanf(\"%d%d\", &n, &m)){\n        char c[10];\n        int a, b;\n        for(int i = 1; i <= n; i++){\n            scanf(\"%d\", &d[i]);\n        }\n        build(1, 1, n);\n        for(int i = 1; i <= m; i++){\n            scanf(\"%s%d%d\", c, &a, &b);\n            if(c[0] == 'Q')\n                printf(\"%d\\n\", query(1, a, b));\n            else if(c[0] == 'U')\n            update(1, a, b);\n        }\n\t\t\n\t}\n\t\n    return 0;\n}\n```\n\n","slug":"segtree-template","published":1,"updated":"2018-08-09T15:50:22.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjma7a28y003msxou8ut6vo2a","content":"<p>之前一直在用大白上的线段树单点更新模板，最近渐渐发现有一些不太舒服的地方，一方面是大白上的模板会强行把线段树建成一个满二叉树，这样虽然比较好理解一些，但同时也会因为要考虑多出来的那些点的影响而相对麻烦。另一方面是因为大家貌似都不用大白上的线段树模板= =||，这样搜题解以及和队友交流的时候会存在一些障碍（其实这一方面是主要原因），所以最后通过权衡还是选择了一个自己觉得通用性比较好也比较好实现的模板。<a href=\"http://www.hysonn.com/2017/01/26/segtree/\" target=\"_blank\" rel=\"noopener\">参考博客链接</a><br>Ps:关于线段树区间更新目前正在学习中，之后再补上关于区间更新的模板。<br><a id=\"more\"></a></p>\n<h2 id=\"基于最大值查询的线段树模板\"><a href=\"#基于最大值查询的线段树模板\" class=\"headerlink\" title=\"基于最大值查询的线段树模板\"></a>基于最大值查询的线段树模板</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先定义线段树的结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;         <span class=\"comment\">//每个tree[k]对应一个节点，其中vl, vr是节点对应的区间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mv;             <span class=\"comment\">//表示节点维护的数据，视情况而定，以维护区间最大值为例</span></span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];       <span class=\"comment\">//绝对安全的情况是建议开四倍数据量的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].mv = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].vl == tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].mv = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].mv;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(query(k &lt;&lt; <span class=\"number\">1</span>, l, mid), query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r));</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例题实现\"><a href=\"#例题实现\" class=\"headerlink\" title=\"例题实现\"></a>例题实现</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1754\" target=\"_blank\" rel=\"noopener\">HDU-1754–I Hate It(线段树单点更新入门题)</a><br>AC代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">2e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mv;</span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].mv = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].vl == tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].mv = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= mid)<span class=\"comment\">//doubt</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].mv;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(query(k &lt;&lt; <span class=\"number\">1</span>, l, mid), query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r));</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;d[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%d%d\"</span>, c, &amp;a, &amp;b);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, query(<span class=\"number\">1</span>, a, b));</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'U'</span>)</span><br><span class=\"line\">            update(<span class=\"number\">1</span>, a, b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>之前一直在用大白上的线段树单点更新模板，最近渐渐发现有一些不太舒服的地方，一方面是大白上的模板会强行把线段树建成一个满二叉树，这样虽然比较好理解一些，但同时也会因为要考虑多出来的那些点的影响而相对麻烦。另一方面是因为大家貌似都不用大白上的线段树模板= =||，这样搜题解以及和队友交流的时候会存在一些障碍（其实这一方面是主要原因），所以最后通过权衡还是选择了一个自己觉得通用性比较好也比较好实现的模板。<a href=\"http://www.hysonn.com/2017/01/26/segtree/\" target=\"_blank\" rel=\"noopener\">参考博客链接</a><br>Ps:关于线段树区间更新目前正在学习中，之后再补上关于区间更新的模板。<br></p>","more":"<p></p>\n<h2 id=\"基于最大值查询的线段树模板\"><a href=\"#基于最大值查询的线段树模板\" class=\"headerlink\" title=\"基于最大值查询的线段树模板\"></a>基于最大值查询的线段树模板</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先定义线段树的结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;         <span class=\"comment\">//每个tree[k]对应一个节点，其中vl, vr是节点对应的区间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mv;             <span class=\"comment\">//表示节点维护的数据，视情况而定，以维护区间最大值为例</span></span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];       <span class=\"comment\">//绝对安全的情况是建议开四倍数据量的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].mv = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].vl == tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].mv = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].mv;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(query(k &lt;&lt; <span class=\"number\">1</span>, l, mid), query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r));</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例题实现\"><a href=\"#例题实现\" class=\"headerlink\" title=\"例题实现\"></a>例题实现</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1754\" target=\"_blank\" rel=\"noopener\">HDU-1754–I Hate It(线段树单点更新入门题)</a><br>AC代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">2e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mv;</span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].mv = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].vl == tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].mv = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= mid)<span class=\"comment\">//doubt</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].mv;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(query(k &lt;&lt; <span class=\"number\">1</span>, l, mid), query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r));</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;d[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%d%d\"</span>, c, &amp;a, &amp;b);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, query(<span class=\"number\">1</span>, a, b));</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'U'</span>)</span><br><span class=\"line\">            update(<span class=\"number\">1</span>, a, b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[{"_id":"source/_posts/HDU1016-Prime-Ring-Problem-DFS/dfs.png","slug":"dfs.png","post":"cjma7a1ys0001sxoulcf2w6vp","modified":0,"renderable":0},{"_id":"source/_posts/POJ1970-The-Game-DFS/Renju.png","slug":"Renju.png","post":"cjma7a1zx001dsxouqx9h3lrk","modified":0,"renderable":0},{"_id":"source/_posts/Graph-Theory-The-shortest-path/gra.png","slug":"gra.png","post":"cjma7a1yx0004sxouik4mb6vw","modified":0,"renderable":0},{"_id":"source/_posts/Graph-Theory-The-shortest-path/path.png","slug":"path.png","post":"cjma7a1yx0004sxouik4mb6vw","modified":0,"renderable":0},{"_id":"source/_posts/HDU2050/line.jpg","slug":"line.jpg","post":"cjma7a1yy0005sxou4sv4tbrv","modified":0,"renderable":0},{"_id":"source/_posts/HDU2050/res.gif","slug":"res.gif","post":"cjma7a1yy0005sxou4sv4tbrv","modified":0,"renderable":0},{"_id":"source/_posts/tab-to-spaces/space.png","slug":"space.png","post":"cjma7a202001lsxou8wpo3xsy","modified":0,"renderable":0},{"_id":"source/_posts/tab-to-spaces/tab.png","slug":"tab.png","post":"cjma7a202001lsxou8wpo3xsy","modified":0,"renderable":0},{"_id":"source/_posts/My-little-angel/moon1.jpg","slug":"moon1.jpg","post":"cjma7a1z5000asxouz1zbogam","modified":0,"renderable":0},{"_id":"source/_posts/My-little-angel/qxy1.jpg","slug":"qxy1.jpg","post":"cjma7a1z5000asxouz1zbogam","modified":0,"renderable":0},{"_id":"source/_posts/My-little-angel/together1.jpg","slug":"together1.jpg","post":"cjma7a1z5000asxouz1zbogam","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p1.png","slug":"p1.png","post":"cjma7a25k0035sxouap66s908","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p2.png","slug":"p2.png","post":"cjma7a25k0035sxouap66s908","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p3.png","slug":"p3.png","post":"cjma7a25k0035sxouap66s908","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p4.png","slug":"p4.png","post":"cjma7a25k0035sxouap66s908","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p5.png","slug":"p5.png","post":"cjma7a25k0035sxouap66s908","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p6.png","slug":"p6.png","post":"cjma7a25k0035sxouap66s908","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p7.png","slug":"p7.png","post":"cjma7a25k0035sxouap66s908","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p8.png","slug":"p8.png","post":"cjma7a25k0035sxouap66s908","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p9.png","slug":"p9.png","post":"cjma7a25k0035sxouap66s908","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjma7a1yy0005sxou4sv4tbrv","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1z6000bsxou3ahql3zn"},{"post_id":"cjma7a1ym0000sxou6j4r9uib","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1z9000fsxoucskvnkok"},{"post_id":"cjma7a1z00006sxougvacjtnm","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1zd000isxouy28gonnu"},{"post_id":"cjma7a1z30009sxour2zlutx6","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1zh000nsxou6mfpcrd9"},{"post_id":"cjma7a1ys0001sxoulcf2w6vp","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1zk000qsxou0lzvv1f0"},{"post_id":"cjma7a1z8000esxoulcf5s8yn","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1zm000tsxou8unb2oky"},{"post_id":"cjma7a1yx0004sxouik4mb6vw","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1zn000wsxouq7uhvwuh"},{"post_id":"cjma7a1za000hsxoux4opd8cb","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1zp000ysxou90msyk0e"},{"post_id":"cjma7a1z5000asxouz1zbogam","category_id":"cjma7a1zd000jsxouhtygteui","_id":"cjma7a1zr0012sxouz34z74b0"},{"post_id":"cjma7a1zj000psxou5i4q7048","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1zt0014sxouzibky2yw"},{"post_id":"cjma7a1zl000ssxouba7d0cgm","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1zv0017sxoujbdzlxx3"},{"post_id":"cjma7a1zo000xsxou3xczcgi3","category_id":"cjma7a1zd000jsxouhtygteui","_id":"cjma7a1zw001asxouofaneq4v"},{"post_id":"cjma7a1zq0011sxouwi7n9561","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a1zy001esxoutjciluaw"},{"post_id":"cjma7a1zs0013sxoucdrqsu48","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a200001gsxouz2r0vk1z"},{"post_id":"cjma7a1zm000vsxouevjay3b2","category_id":"cjma7a1zq0010sxoudlqre6dr","_id":"cjma7a201001jsxou8j47w8h3"},{"post_id":"cjma7a1zu0016sxoubiw8g7dg","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a203001msxouse5ne4ic"},{"post_id":"cjma7a1zv0019sxoujp6o314d","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a204001psxou2lr8xun2"},{"post_id":"cjma7a1zx001dsxouqx9h3lrk","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a205001rsxou666cswd8"},{"post_id":"cjma7a1zz001fsxoudy306uln","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a205001tsxou889z9obb"},{"post_id":"cjma7a200001isxoudrnpvvzi","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a206001vsxouksm5df6q"},{"post_id":"cjma7a202001lsxou8wpo3xsy","category_id":"cjma7a1zq0010sxoudlqre6dr","_id":"cjma7a206001wsxoueth1gwln"},{"post_id":"cjma7a25k0035sxouap66s908","category_id":"cjma7a1zq0010sxoudlqre6dr","_id":"cjma7a25v003csxouylwwwpep"},{"post_id":"cjma7a25n0037sxouuo2qytww","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a25x003fsxouol6r21er"},{"post_id":"cjma7a25t003asxoud9192d2a","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a25y003jsxou4w9w8erj"},{"post_id":"cjma7a28y003msxou8ut6vo2a","category_id":"cjma7a1yu0002sxou2twu1gcv","_id":"cjma7a295003psxouy90364ub"}],"PostTag":[{"post_id":"cjma7a1ym0000sxou6j4r9uib","tag_id":"cjma7a1yw0003sxouvr293ii5","_id":"cjma7a1za000gsxou03cka3v5"},{"post_id":"cjma7a1ym0000sxou6j4r9uib","tag_id":"cjma7a1z10008sxoupst9w5xl","_id":"cjma7a1ze000ksxoug6u0p3qg"},{"post_id":"cjma7a1ys0001sxoulcf2w6vp","tag_id":"cjma7a1z7000dsxou5qspkgct","_id":"cjma7a1zi000osxou4jze4h3o"},{"post_id":"cjma7a1yx0004sxouik4mb6vw","tag_id":"cjma7a1ze000lsxouoo4qi4kq","_id":"cjma7a1zm000usxouctn09jim"},{"post_id":"cjma7a1zs0013sxoucdrqsu48","tag_id":"cjma7a1z7000dsxou5qspkgct","_id":"cjma7a1zv0018sxoubu62em0x"},{"post_id":"cjma7a1zu0016sxoubiw8g7dg","tag_id":"cjma7a1zt0015sxou3c0y7poo","_id":"cjma7a1zx001csxoufej4l022"},{"post_id":"cjma7a1yy0005sxou4sv4tbrv","tag_id":"cjma7a1zk000rsxou09kbfvfx","_id":"cjma7a202001ksxouueyfef9m"},{"post_id":"cjma7a1yy0005sxou4sv4tbrv","tag_id":"cjma7a1zp000zsxoum7yb6m1r","_id":"cjma7a204001nsxoufbeefq8x"},{"post_id":"cjma7a1yy0005sxou4sv4tbrv","tag_id":"cjma7a1zt0015sxou3c0y7poo","_id":"cjma7a205001qsxou7m4j7ib7"},{"post_id":"cjma7a1yy0005sxou4sv4tbrv","tag_id":"cjma7a1zx001bsxouye1f1ldp","_id":"cjma7a205001ssxou7jaljic5"},{"post_id":"cjma7a1z00006sxougvacjtnm","tag_id":"cjma7a1zk000rsxou09kbfvfx","_id":"cjma7a207001ysxourihyavog"},{"post_id":"cjma7a1z00006sxougvacjtnm","tag_id":"cjma7a204001osxouzjw4itau","_id":"cjma7a207001zsxour20u94ys"},{"post_id":"cjma7a1z00006sxougvacjtnm","tag_id":"cjma7a205001usxoupvhm8vq1","_id":"cjma7a2080021sxou2e9im8b4"},{"post_id":"cjma7a1z30009sxour2zlutx6","tag_id":"cjma7a1zx001bsxouye1f1ldp","_id":"cjma7a2080022sxouobx9tyc9"},{"post_id":"cjma7a1z5000asxouz1zbogam","tag_id":"cjma7a2070020sxou3xzevbu2","_id":"cjma7a2090024sxou6pun797u"},{"post_id":"cjma7a1z8000esxoulcf5s8yn","tag_id":"cjma7a1zx001bsxouye1f1ldp","_id":"cjma7a20a0026sxou1k36jxuj"},{"post_id":"cjma7a1za000hsxoux4opd8cb","tag_id":"cjma7a20a0025sxouov0pk3lg","_id":"cjma7a20b0029sxouqefpuajx"},{"post_id":"cjma7a1za000hsxoux4opd8cb","tag_id":"cjma7a20a0027sxou8fiswcx6","_id":"cjma7a20b002asxouhv0bvppq"},{"post_id":"cjma7a1zj000psxou5i4q7048","tag_id":"cjma7a20b0028sxoudy8u6pau","_id":"cjma7a20c002csxoufa0ds21k"},{"post_id":"cjma7a1zl000ssxouba7d0cgm","tag_id":"cjma7a20b002bsxouyy38460b","_id":"cjma7a20c002fsxouoimuo8le"},{"post_id":"cjma7a1zl000ssxouba7d0cgm","tag_id":"cjma7a20c002dsxoupv3hrz1c","_id":"cjma7a20c002gsxoumufw7b3u"},{"post_id":"cjma7a1zm000vsxouevjay3b2","tag_id":"cjma7a20c002esxou7yb8jwvh","_id":"cjma7a20d002ksxous47va0vc"},{"post_id":"cjma7a1zm000vsxouevjay3b2","tag_id":"cjma7a20c002hsxoud9lkwom2","_id":"cjma7a20d002lsxouhj03hr0x"},{"post_id":"cjma7a1zm000vsxouevjay3b2","tag_id":"cjma7a20d002isxouxhx7x209","_id":"cjma7a20e002nsxoul54u3bwf"},{"post_id":"cjma7a1zo000xsxou3xczcgi3","tag_id":"cjma7a20d002jsxounx2tnapy","_id":"cjma7a20e002psxourwviz96m"},{"post_id":"cjma7a1zo000xsxou3xczcgi3","tag_id":"cjma7a20d002isxouxhx7x209","_id":"cjma7a20e002qsxounpmu8bmm"},{"post_id":"cjma7a1zq0011sxouwi7n9561","tag_id":"cjma7a20e002osxoua149erft","_id":"cjma7a20f002ssxoujgrlyvwx"},{"post_id":"cjma7a1zv0019sxoujp6o314d","tag_id":"cjma7a20e002rsxounnhl870c","_id":"cjma7a20f002usxouo7qve2vr"},{"post_id":"cjma7a1zx001dsxouqx9h3lrk","tag_id":"cjma7a20f002tsxousne5tdv1","_id":"cjma7a20g002xsxouyxv4eo4s"},{"post_id":"cjma7a1zx001dsxouqx9h3lrk","tag_id":"cjma7a1z7000dsxou5qspkgct","_id":"cjma7a20g002ysxou0yrtto0d"},{"post_id":"cjma7a1zx001dsxouqx9h3lrk","tag_id":"cjma7a20f002vsxouf89g0gle","_id":"cjma7a20g0030sxouj2b9sdet"},{"post_id":"cjma7a1zz001fsxoudy306uln","tag_id":"cjma7a20d002isxouxhx7x209","_id":"cjma7a20g0031sxou8y1kyy7e"},{"post_id":"cjma7a200001isxoudrnpvvzi","tag_id":"cjma7a20g002zsxouesgro9iz","_id":"cjma7a20h0033sxou5rrnw2l2"},{"post_id":"cjma7a202001lsxou8wpo3xsy","tag_id":"cjma7a20h0032sxouxh3e2j06","_id":"cjma7a20h0034sxouoih99h4o"},{"post_id":"cjma7a25t003asxoud9192d2a","tag_id":"cjma7a20c002dsxoupv3hrz1c","_id":"cjma7a25x003esxou2dejg1df"},{"post_id":"cjma7a25k0035sxouap66s908","tag_id":"cjma7a25s0039sxou2zh8o2yr","_id":"cjma7a25y003isxougpko91zu"},{"post_id":"cjma7a25n0037sxouuo2qytww","tag_id":"cjma7a20f002tsxousne5tdv1","_id":"cjma7a25z003ksxouwce5oz2w"},{"post_id":"cjma7a25n0037sxouuo2qytww","tag_id":"cjma7a25x003gsxou7iqmv7sx","_id":"cjma7a25z003lsxouqfnodvpy"},{"post_id":"cjma7a28y003msxou8ut6vo2a","tag_id":"cjma7a293003osxouiil59wtw","_id":"cjma7a297003qsxou4t6slmsy"}],"Tag":[{"name":"前缀和","_id":"cjma7a1yw0003sxouvr293ii5"},{"name":"后缀和","_id":"cjma7a1z10008sxoupst9w5xl"},{"name":"DFS","_id":"cjma7a1z7000dsxou5qspkgct"},{"name":"图论","_id":"cjma7a1ze000lsxouoo4qi4kq"},{"name":"HDU","_id":"cjma7a1zk000rsxou09kbfvfx"},{"name":"线切割平面","_id":"cjma7a1zp000zsxoum7yb6m1r"},{"name":"math","_id":"cjma7a1zt0015sxou3c0y7poo"},{"name":"思维","_id":"cjma7a1zx001bsxouye1f1ldp"},{"name":"状态压缩DP","_id":"cjma7a204001osxouzjw4itau"},{"name":"BFS","_id":"cjma7a205001usxoupvhm8vq1"},{"name":"Lover","_id":"cjma7a2070020sxou3xzevbu2"},{"name":"DP","_id":"cjma7a20a0025sxouov0pk3lg"},{"name":"01背包","_id":"cjma7a20a0027sxou8fiswcx6"},{"name":"逆向思维","_id":"cjma7a20b0028sxoudy8u6pau"},{"name":"stack","_id":"cjma7a20b002bsxouyy38460b"},{"name":"STL","_id":"cjma7a20c002dsxoupv3hrz1c"},{"name":"mathjax","_id":"cjma7a20c002esxou7yb8jwvh"},{"name":"hexo插入数学公式","_id":"cjma7a20c002hsxoud9lkwom2"},{"name":"总结","_id":"cjma7a20d002isxouxhx7x209"},{"name":"生活","_id":"cjma7a20d002jsxounx2tnapy"},{"name":"C++","_id":"cjma7a20e002osxoua149erft"},{"name":"线段树区间更新","_id":"cjma7a20e002rsxounnhl870c"},{"name":"POJ","_id":"cjma7a20f002tsxousne5tdv1"},{"name":"迷宫问题","_id":"cjma7a20f002vsxouf89g0gle"},{"name":"字符串","_id":"cjma7a20g002zsxouesgro9iz"},{"name":"python","_id":"cjma7a20h0032sxouxh3e2j06"},{"name":"vultr服务器搭建","_id":"cjma7a25s0039sxou2zh8o2yr"},{"name":"线段树","_id":"cjma7a25x003gsxou7iqmv7sx"},{"name":"线段树单点更新","_id":"cjma7a293003osxouiil59wtw"}]}}