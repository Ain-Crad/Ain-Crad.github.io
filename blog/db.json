{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/images.jpeg","path":"images/images.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/user2.jpg","path":"images/user2.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar2.png","path":"images/avatar2.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1618975814810},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1618975814810},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1618975814810},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1618975814810},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1618975814810},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1618975814810},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1618975814810},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1618975814810},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1618975814810},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1618975814810},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1618975814810},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1618975814810},{"_id":"themes/next/_config.yml","hash":"51d09191147bfc9330cbe687cc3cbc8dc25fdd19","modified":1618975814810},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1618975814810},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1618975814810},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1618975814810},{"_id":"source/about/index.md","hash":"3ebd04672d0a84fa7380f3ae3a7aea48f08c07cc","modified":1618975814800},{"_id":"source/commonweal/index.md","hash":"423894f3e9d10b9bbfae31c42cb31f5c3cec81a2","modified":1618975814800},{"_id":"source/categories/index.md","hash":"76f4447e0e8f274e0255fa038aa97656425eae07","modified":1618975814800},{"_id":"source/schedule/index.md","hash":"73d7ca6fb2a4d82bc89a489befdb0b066599178b","modified":1618975814800},{"_id":"source/links/index.md","hash":"c702b6d1bde8020ae93198b29f1833ef39f549bf","modified":1618975814800},{"_id":"source/_posts/CodeForces-469D-Two-Sets.md","hash":"32b808fafbea518e69192f6a0bfd8940c5b1c904","modified":1618975814750},{"_id":"source/_posts/CodeForces-569A.md","hash":"3f8302038fe63b829dc9e4ff028162812ccda11d","modified":1618975814750},{"_id":"source/_posts/CodeForces-478C.md","hash":"66d6ce10772fbc916bdf743414b13965406c5d63","modified":1618975814750},{"_id":"source/_posts/Codeforces-498Div3-C.md","hash":"2730707a986311e5a9da502806efb59170f20549","modified":1618975814750},{"_id":"source/_posts/Covariance-协方差.md","hash":"c72841f1de004e0071f6fcc2048b528f8b584d27","modified":1618975814750},{"_id":"source/_posts/C语言编译连接过程以及-h和-c文件解析.md","hash":"db4d29f11a75334caa2b8053d3fb0cfdc3284120","modified":1618975814750},{"_id":"source/_posts/Graph-Theory-The-shortest-path.md","hash":"951f3d7742d35811d5fce27bb70c8ad46a902b7a","modified":1618975814750},{"_id":"source/_posts/HDU1016-Prime-Ring-Problem-DFS.md","hash":"a41ac3c1942701c96805558bdd34c3db9425e9b8","modified":1618975814750},{"_id":"source/_posts/Good-Bye-2018.md","hash":"2bea57bbaf1e8c8c3b709904db1d7d2e85ca4589","modified":1618975814750},{"_id":"source/_posts/HDU2050.md","hash":"7cb7a0e9d3a8a0b571e3cd628ea85bcba4f25dad","modified":1618975814750},{"_id":"source/_posts/HDU5092.md","hash":"51ba3808c7917621d95edbbd6090a5a1af11a383","modified":1618975814750},{"_id":"source/_posts/HDU4856-Tunnels.md","hash":"62495b34681e4818cfe8451f225da3267c713944","modified":1618975814750},{"_id":"source/_posts/Learn-CMake-2-多文件-目录.md","hash":"55e281b708811ef1787e1b1b0bc85e529116937e","modified":1618975814750},{"_id":"source/_posts/Learn-CMake-1-HelloWorld.md","hash":"58ebf4756d54a77e1f227f30ba96d06ec1a27fba","modified":1618975814750},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器.md","hash":"950ba7d1859c7d1b4ce5848d5459cb857ab2fd5d","modified":1618975814750},{"_id":"source/_posts/Learn-CMake-4-链接库文件.md","hash":"821d2b3a2ef8e0918932b66383c1c2d545075f17","modified":1618975814750},{"_id":"source/_posts/Learn-CMake-3-创建库文件.md","hash":"8c9b50d66cbba6490ccfd2bf8435938d62ced186","modified":1618975814750},{"_id":"source/_posts/Maze.md","hash":"2c79fdddaea2b77d0768e7bd5fd2de009f774d37","modified":1618975814760},{"_id":"source/_posts/Nowcoder-Fourth-G.md","hash":"27585328ffd5e96c5817f98d9c61d2160b18c2f2","modified":1618975814760},{"_id":"source/_posts/Linear algebra-Dot product.md","hash":"6868d5a738f267ffaefa55f5e66464d25a2236fa","modified":1618975814750},{"_id":"source/_posts/PCA-主成分分析.md","hash":"0f57fdc4425d8ec4117cf2daafc7ca5325715d9e","modified":1618975814760},{"_id":"source/_posts/Nowcoder-Third-A.md","hash":"64bdfc1c278597937a77462551849d9a6538ad19","modified":1618975814760},{"_id":"source/_posts/My-little-angel.md","hash":"8833b6485727ea75be760eac8f393e8aca78ec4b","modified":1618975814760},{"_id":"source/_posts/POJ2481.md","hash":"7b0c27492aabfefa174d12dfc4dcd26d522fffbf","modified":1618975814760},{"_id":"source/_posts/POJ1970-The-Game-DFS.md","hash":"f06ac95b1a2d14be4c307abb8b1a1199a69bb907","modified":1618975814760},{"_id":"source/_posts/Rand-C-随机数.md","hash":"2cdeb521c1d4b8717d455e27848378464e490848","modified":1618975814760},{"_id":"source/_posts/Super-Mario.md","hash":"d55024523c466eca345e5b3ed3b6467ab5fd8c51","modified":1618975814760},{"_id":"source/_posts/STL-cmp.md","hash":"bb545679b1bca697500b86d01a422642796a5585","modified":1618975814760},{"_id":"source/_posts/Uva10129-Play-on-Words.md","hash":"118f36c8e0a45c6cc3be871732f3d7cce0dc960f","modified":1618975814760},{"_id":"source/_posts/Uva10410-Tree-Reconstruction.md","hash":"5e3b2725198cc4e40eb7751d19cff9e86ac1e4ee","modified":1618975814760},{"_id":"source/_posts/Uva10305-Ordering-Tasks.md","hash":"859f52dca1b65b0aa72f64847bfb6b23dba28a91","modified":1618975814760},{"_id":"source/_posts/Uva10562-Undraw the trees.md","hash":"150dae8c8c85e9bc04d2b6b0ea698a5db501a796","modified":1618975814760},{"_id":"source/_posts/Uva1103-Ancient-Messages.md","hash":"55a70ada513b08a9266e46255b3bc56093a5b005","modified":1618975814760},{"_id":"source/_posts/Uva11059-Maximum-Product.md","hash":"c50b30136d449cfa8e6449e18d0e1289c77d7640","modified":1618975814770},{"_id":"source/_posts/Uva11212-Editing-a-Book.md","hash":"48a5c77c1fa360310c1fa2914aac43a10388b87a","modified":1618975814770},{"_id":"source/_posts/Uva12118-Inspetor-s-Dilemma.md","hash":"840bee83819d9bc2a18d1a4e6a2cb3e1f9695f81","modified":1618975814770},{"_id":"source/_posts/Uva11853-Painball.md","hash":"14c9dd73cf4d95d6fb8b32d9aee44a3477ca50f2","modified":1618975814770},{"_id":"source/_posts/Uva12096-The-SetStack-Computer-STL.md","hash":"6bfdf7be05c9f776bea98b1ac71d35dd3bdf60b3","modified":1618975814770},{"_id":"source/_posts/Uva122-二叉树构建与层次遍历.md","hash":"43a359c298542fdc957a68d96d7b9cdb005bda67","modified":1618975814770},{"_id":"source/_posts/Uva1343-The-Rotation-Game.md","hash":"fea5e62ce01fc697e6bc73c144b8b99aa5d81b3b","modified":1618975814770},{"_id":"source/_posts/Uva127-Accordian-Patience.md","hash":"36f0ca26038ce4de86f59bd93b5564c2e19dbea3","modified":1618975814770},{"_id":"source/_posts/Uva12166-Equilibrium-Mobile.md","hash":"31e9b672880594e35200eab5fa893cb7710d4fa1","modified":1618975814770},{"_id":"source/_posts/Uva1374-Power-Calculus.md","hash":"b34367edf229d633ebac37cf69394240e7bbeb2a","modified":1618975814770},{"_id":"source/_posts/Uva1600-Patrol-Robot.md","hash":"e12369ba0658d42210ca08b026e14c57d9982c0e","modified":1618975814770},{"_id":"source/_posts/Uva1602-Lattice-Animals.md","hash":"793d82ab47ac1bb997cf5f72eca9bdca865238be","modified":1618975814770},{"_id":"source/_posts/Uva221-Urban-Elevations.md","hash":"18101dbf1759662de2be80fff70e55bed0b425e9","modified":1618975814770},{"_id":"source/_posts/Uva1599-Ideal-Path.md","hash":"eeea283323504cba404e51374fb3a31b49c7561b","modified":1618975814770},{"_id":"source/_posts/Uva673-Parentheses-Balance.md","hash":"c68c067ba722ec94c53a72a7433a68069befbd95","modified":1618975814770},{"_id":"source/_posts/Uva1601-The-Morning-after-Halloween.md","hash":"c77bb378d0e5112c8aeede266152aa2c80882e03","modified":1618975814770},{"_id":"source/_posts/Uva548-二叉树构建-DFS.md","hash":"a8cc1c551c134732c61054322f921b93129de10a","modified":1618975814770},{"_id":"source/_posts/Uva806-Spatial-Structures.md","hash":"f7e3007c64f6840d99d8808e438f91fa075af74d","modified":1618975814770},{"_id":"source/_posts/Uva816-Abbott-s-Revenge-BFS.md","hash":"91c146529898082f5a0a6d873c7c958c39b534fc","modified":1618975814770},{"_id":"source/_posts/Uva839-二叉树的递归处理.md","hash":"4084700b7cc4ecbcde80d4656693a129ecf5a44d","modified":1618975814770},{"_id":"source/_posts/Uva725-Division.md","hash":"9f4f2a4b936c62f52ca2293fc7730b20ca9d17ea","modified":1618975814770},{"_id":"source/_posts/hexo-mathjax.md","hash":"ec70dd336ab7be00e60968dac5bf49be1d42c206","modified":1618975814770},{"_id":"source/_posts/buildBinaryTree.md","hash":"a6af540028ec7b77ad198c06f12dd4650d61a796","modified":1618975814770},{"_id":"source/_posts/new start point.md","hash":"8d61e5773ee56de7b45545a01f00f4b01bc363aa","modified":1618975814770},{"_id":"source/_posts/extern-外部变量.md","hash":"8e4b47f7a9dafc04522e38d219d3a3b4a83811ec","modified":1618975814770},{"_id":"source/_posts/pick-numbers.md","hash":"ee1b5b08461fa315f97e3f555e7053fa1f547d38","modified":1618975814770},{"_id":"source/_posts/next-permutation解析.md","hash":"2f2ccd0c1abe547a23c949e25a13b40c32406a32","modified":1618975814770},{"_id":"source/_posts/new-keyword.md","hash":"a6ea511919eb7eaab2e547fd7fa119040b501f93","modified":1618975814770},{"_id":"source/_posts/quick-matrix.md","hash":"32c997c9dabf06339ae0750830bc606a4eb2759f","modified":1618975814770},{"_id":"source/_posts/segtree-intval.md","hash":"a1743df73ec83cf05a60e4de003167e122aaf140","modified":1618975814770},{"_id":"source/_posts/segtree-template.md","hash":"d050c345bb8dd5a78dacacb7df02d36b4566ce6f","modified":1618975814770},{"_id":"source/_posts/kickstart-2019D-X-or-What.md","hash":"e0082db05881cbc05c277b69e760121dab5a91bd","modified":1618975814770},{"_id":"source/_posts/stringstream.md","hash":"ff776073104c58ced0cd2a13c8fd25f602fa3398","modified":1618975814770},{"_id":"source/_posts/tab-to-spaces.md","hash":"f105f396aad832474e07110cf1ca7b6791e1373d","modified":1618975814770},{"_id":"source/_posts/sscanf-sprintf.md","hash":"bd65a74ee57fee95d67e0840e18501d97c0aa7de","modified":1618975814770},{"_id":"source/_posts/vultr.md","hash":"118cfebf0060fc2c56dc36c7a1a7394d85425410","modified":1567328484917},{"_id":"source/_posts/光栅化渲染-2-透视投影.md","hash":"a8397b6ffb24171c027857f778769e647434e034","modified":1618975814780},{"_id":"source/_posts/光栅化渲染-1-算法总述.md","hash":"17656d7f80825b2cbfc3ad977727163d9e30aaa6","modified":1618975814780},{"_id":"source/_posts/二叉树中序和后序遍历-层序和先序遍历.md","hash":"210e6e926d2bc89ae183a4dc8d2317ddf2a429ab","modified":1618975814780},{"_id":"source/_posts/倒水问题.md","hash":"aeefc3f9f32dad89f8c98dc2b755c7e9922a88b5","modified":1618975814780},{"_id":"source/_posts/二分查找以及lower-bound-upper-bound实现.md","hash":"a6a90142de984213d29d452774a5cc5ec15f82f7","modified":1618975814780},{"_id":"source/_posts/光栅化渲染-3-光栅化.md","hash":"cb1330d4c84bc4cc4505c3779ab10665c0ee714d","modified":1618975814780},{"_id":"source/_posts/光栅化渲染-5-透视矫正.md","hash":"ba684a2c50e199ff886551fdb8cb033d02bb2657","modified":1569038058545},{"_id":"source/_posts/光栅化渲染-7-渲染管线.md","hash":"bbaf6b258e96a8b54978bf342edc00b4b46a643b","modified":1569126794898},{"_id":"source/_posts/光栅化渲染-8-正交投影矩阵.md","hash":"bbb8bd168eebae7408435177cc15828386ff227f","modified":1569126787002},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵.md","hash":"eb8676f7f9bba6ff5bd9e031210925e7c7932e65","modified":1569126805995},{"_id":"source/_posts/八皇后问题.md","hash":"e5ae8dbac2bc95455cd11487e777376b96f2de96","modified":1618975814790},{"_id":"source/_posts/光栅化渲染-4-深度检测.md","hash":"b0584de16b28b17abdfcf65905eee6d14fce38f6","modified":1618975814780},{"_id":"source/_posts/哈希表.md","hash":"9d984a0b81ef67b0847c45875accaa2785294a9d","modified":1618975814790},{"_id":"source/_posts/八数码问题.md","hash":"edea52cea6a883dd3a49088c33562be3909e7bb6","modified":1618975814790},{"_id":"source/_posts/静态链接库-STATIC-和动态链接库-SHARED.md","hash":"76fa9c4b933fb2b237bdcbd2abffbe1bddd9b8bb","modified":1618975814790},{"_id":"source/_posts/循环小数化为分数的方法.md","hash":"66b7773c7edefa5f1c074e077ddc483f20524245","modified":1618975814790},{"_id":"source/sitemap/index.md","hash":"f18cfe801086a113dff7f6862d85c7e2d6727e46","modified":1618975814800},{"_id":"source/tags/index.md","hash":"b23dc9c86fb565af015f51a741bf0c9f890a87fc","modified":1618975814800},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1618975814810},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1618975814810},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1618975814810},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1566306323393},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1618975814810},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1618975814810},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1618975814810},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1618975814810},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1618975814810},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1618975814810},{"_id":"source/_posts/欧拉回路.md","hash":"20575092429014b7ef8373a47ccaa8e8bed60d8a","modified":1618975814790},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1618975814810},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1618975814810},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1618975814810},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1618975814810},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1618975814810},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1618975814810},{"_id":"themes/next/languages/zh-Hans.yml","hash":"b1570210fd580f456685ffcb1c6452c69e1463bb","modified":1618975814810},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1618975814810},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1618975814810},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1618975814810},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1618975814810},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1618975814810},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1618975814810},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1618975814810},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1618975814810},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1618975814810},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1618975814810},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1618975814810},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1618975814810},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1618975814840},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1618975814810},{"_id":"source/_posts/埃及分数-迭代加深搜索.md","hash":"8482d12c5dfdc519dec1fa66df0e8fd7f98be604","modified":1618975814790},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1618975814840},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1618975814840},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566306324190},{"_id":"source/_posts/HDU1016-Prime-Ring-Problem-DFS/dfs.png","hash":"bfaf09def97b165527bb22bad63dfe38109bdd64","modified":1566306323315},{"_id":"source/_posts/Graph-Theory-The-shortest-path/gra.png","hash":"c2a7946e9e78ad6264a4a6d6b581d06160604bfe","modified":1566306323315},{"_id":"source/_posts/Graph-Theory-The-shortest-path/path.png","hash":"b20559aca988d5aaefc0931e513b4fc808c5be21","modified":1566306323315},{"_id":"source/_posts/HDU2050/line.jpg","hash":"0b614039e05df58510f6979466289f7ac7190b5f","modified":1566306323315},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/Rudolf_Kalman.jpg","hash":"d9fc75dcf49e0051bfdcc7756e2b63ddfe7b8260","modified":1566306323315},{"_id":"source/_posts/HDU2050/res.gif","hash":"163a87523482ba25a73787e59a0b13ecfb736053","modified":1566306323315},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/g1.jpg","hash":"37434d3f18bd047d74a955400bff7e0405cfa8b9","modified":1566306323315},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/afterFilter.png","hash":"bf96d602e8c3f2030946ea7c0ce66c3b712f6374","modified":1566306323315},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/g2.jpg","hash":"7e24f2f2110a8d055e59fd2504c97aa40150515a","modified":1566306323315},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/g4.jpg","hash":"2003c2200792d6795a15d1aaef0fd7bf4e0b89da","modified":1566306323315},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/gauss.jpg","hash":"1857b243d0f0dc7cdc0e7640783f02faa9e3710f","modified":1566306323315},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/g5.jpg","hash":"44ba09420e7fbfc1dc583c071f0f248d91c16b8e","modified":1566306323315},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/g3.jpg","hash":"addfbb4a223035d1ff4c146db85266d1c2b25adb","modified":1566306323315},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/origin.png","hash":"9c830d9b7f7d255ba74fe3900ac0e5b271c9f211","modified":1566306323315},{"_id":"source/_posts/Learn-CMake-4-链接库文件/lena_color.png","hash":"5c2c81b0f5095fd2787700a7549d0b61e7bc7998","modified":1566306323315},{"_id":"source/_posts/My-little-angel/moon1.jpg","hash":"c57a51bb30e1ec204f4fb3c01783b8f2e87a1bbd","modified":1566306323331},{"_id":"source/_posts/Maze/maze.png","hash":"26050035faeb5026419d4fe0076622b2f6dc821a","modified":1566306323331},{"_id":"source/_posts/My-little-angel/together1.jpg","hash":"1783fb05e6a210c1c2de23c413b9fb466c44c03a","modified":1566306323331},{"_id":"source/_posts/PCA-主成分分析/pca.jpeg","hash":"29edc63a8409f691aeb4c74bea6f2014bff9681a","modified":1566306323331},{"_id":"source/_posts/POJ1970-The-Game-DFS/Renju.png","hash":"e478edf969416be8f2fda647b3336271dbb13b6a","modified":1566306323331},{"_id":"source/_posts/Rand-C-随机数/random.jpg","hash":"e6cfaf454b76a04cc8c38273c89e9a2c9b2265a5","modified":1566306323331},{"_id":"source/_posts/Super-Mario/SuperMario.png","hash":"b063b297ce5044d523ae0c3d2ea4c408cefe5848","modified":1566306323331},{"_id":"source/_posts/Uva10562-Undraw the trees/tree.png","hash":"51cf513829497a8d98dc1e0f7ade6d8dc407adfd","modified":1566306323331},{"_id":"source/_posts/Uva1103-Ancient-Messages/1.png","hash":"49e92896091c97e432582ca738cdd415dfbaef3a","modified":1566306323331},{"_id":"source/_posts/Uva1103-Ancient-Messages/2.png","hash":"66e6e3e8aa6456456ff9794274edf1dacb72219c","modified":1566306323331},{"_id":"source/_posts/Uva12166-Equilibrium-Mobile/balance.png","hash":"f4529422d6cf9010363875a87318e6ec8cb45083","modified":1566306323346},{"_id":"source/_posts/Uva11212-Editing-a-Book/prune.png","hash":"c73f3744915ded4e3872dcb821e19743dd5669eb","modified":1566306323346},{"_id":"source/_posts/Uva221-Urban-Elevations/building.png","hash":"5be5290e6f5974f919f3525d5d85f215d2b2dcd9","modified":1566306323346},{"_id":"source/_posts/Uva1602-Lattice-Animals/pic.png","hash":"7d7efe55681e5d9619164d67d023e8322cad366d","modified":1566306323346},{"_id":"source/_posts/Uva806-Spatial-Structures/2.png","hash":"ad1edffc72af5cec0649f0b5e93a48a19d9d9acf","modified":1566306323346},{"_id":"source/_posts/Uva806-Spatial-Structures/1.png","hash":"3374b72597b7048bb95a6af65ba72f10699f86a8","modified":1566306323346},{"_id":"source/_posts/buildBinaryTree/BinaryTree.png","hash":"f5a67b09376f01bfe9459e5dbd066ef290510d5a","modified":1566306323346},{"_id":"source/_posts/tab-to-spaces/space.png","hash":"e1202e8eb89c5c09f5e3eb1e4a72be772c4790b6","modified":1566306323346},{"_id":"source/_posts/tab-to-spaces/tab.png","hash":"30312fc2dabd01c3540693ea57af6ea0a11c9fe2","modified":1566306323346},{"_id":"source/_posts/Uva839-二叉树的递归处理/tree.png","hash":"ccee240e1b924dd7cca49828c69e0cf78742a7e3","modified":1566306323346},{"_id":"source/_posts/vultr/p1.png","hash":"595bda0f3e72f314db02d09c378298daf0840657","modified":1566306323346},{"_id":"source/_posts/vultr/p2.png","hash":"c797e71775de0c707e10ec8f765a154b37f27197","modified":1566306323346},{"_id":"source/_posts/vultr/p5.png","hash":"a7c6230253b7b12375ea294a6386473479cd7d26","modified":1566306323346},{"_id":"source/_posts/vultr/p3.png","hash":"67dbd2c65a2c47e6ae09f22051629da1a6c5fdd1","modified":1566306323346},{"_id":"source/_posts/vultr/p8.png","hash":"2f5ce1e7aa48769570589a1a15948f1364753a67","modified":1566306323362},{"_id":"source/_posts/二分查找以及lower-bound-upper-bound实现/BinarySearch.jpeg","hash":"0ba27593f39f67249e26ef7183c23a7f87513bcf","modified":1566306323362},{"_id":"source/_posts/vultr/p7.png","hash":"da388ae09f2db520f71e2348bf8a4883adb2666a","modified":1566306323362},{"_id":"source/_posts/倒水问题/fill.png","hash":"e52c036e123deee8ba888f4751544fee2873f38a","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-1-算法总述/figure1.png","hash":"af649c9b70f42ecfa0edad5a481f5ffd4d197b82","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-1-算法总述/figure2.jpg","hash":"2c36c6012a7c504c74cb3dca3a3d01995a6c27e7","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-1-算法总述/figure4.png","hash":"726703b49d439506bedae760c6fa738b95151e6f","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-2-透视投影/figure1.png","hash":"912adafd5db1b41e1998984b3be9772ca857d2cb","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-2-透视投影/figure3.png","hash":"aac0c865e4baf9b3a90312a55bb1c4523807c33c","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-2-透视投影/figure5.png","hash":"f2ee13c644b516eb37867babd53db9ba1a3f8760","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-2-透视投影/figure2.png","hash":"649cae0f0af4c126256c4f299b92d4ed48fbf696","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-2-透视投影/figure4.png","hash":"4fe94351ba51f9d8f087951002fb05f3532284ab","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-2-透视投影/visible.png","hash":"1f0d35a1d683fd482fa1aa95141569a5338e75f4","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure1.png","hash":"b290b99658bc7c84af7720c3ba79fdd4aef05454","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure2.png","hash":"a8fe68eafaf8652d2124c42c5de5ec5b6ec99904","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure3.gif","hash":"b0a9b36f91e92ca2a42b8336352976420793cf5d","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure5.png","hash":"416f024d8f45031d1f8c8eaea530173c29f3f88b","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure6.png","hash":"279d015a4c7800ef29633a3413aa94d1c24f605d","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-3-光栅化/result.png","hash":"b564c4c7db1f03b08ee9a8c0f53f72506f285886","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure7.png","hash":"a356d3e49e4627eadc7ff1cdb7d6393431c1c7fc","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-3-光栅化/rasterization.png","hash":"cb9323db41b2889a3ca9609100eff4202ee77b9a","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-4-深度检测/equation4.png","hash":"22f9f9893087b2cc5c91a6341301454e7204ed61","modified":1567424024497},{"_id":"source/_posts/光栅化渲染-4-深度检测/equation6.png","hash":"627278d2ffcb2f33ac784d879389618746bd6fc4","modified":1567424466455},{"_id":"source/_posts/光栅化渲染-4-深度检测/equation2.png","hash":"2249a28cf6d96d6ab25f8eba1e0a5539521b23d4","modified":1567424006272},{"_id":"source/_posts/光栅化渲染-4-深度检测/depth.png","hash":"2cf502ead52ade69c9aa9ddac8ebc2df3f8892dc","modified":1566907910392},{"_id":"source/_posts/光栅化渲染-4-深度检测/equation8.png","hash":"ace1f7711d24f9d2da9e485c8f674cda8b77279a","modified":1567425098657},{"_id":"source/_posts/光栅化渲染-4-深度检测/simplify.png","hash":"c823a43fd2492e2817a75cd2f7a2e5eb68cf9a29","modified":1567426540699},{"_id":"source/_posts/光栅化渲染-4-深度检测/equation7.png","hash":"1380cc7d0390cd3f0701af4d55e677336d5ae792","modified":1567425030822},{"_id":"source/_posts/光栅化渲染-5-透视矫正/figure1.png","hash":"1e135db59da481a49accdc278d49bf1b767f0213","modified":1566909929227},{"_id":"source/_posts/光栅化渲染-5-透视矫正/formula1.png","hash":"d046a0bda94273c8281ec1d75b84627fd78a8be3","modified":1567480366814},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/equation1.png","hash":"bbf573035e02bc8ad9f472c18cbd4f6d1d8554bc","modified":1569058626074},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/equation2.png","hash":"1ed03c9b87e6f8bce71c88796c83cbb9fc9a7fb8","modified":1569059845964},{"_id":"source/_posts/光栅化渲染-5-透视矫正/formula2.png","hash":"bba56568d3bb3abe3cc9d788df4f19762eb61dfd","modified":1567480948923},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure2.png","hash":"5807e7ae70533828fb60ab73b194349e8a9d7a56","modified":1569038212589},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure3.png","hash":"5f36ec78896a0961945b213d57d78f1c7f31b093","modified":1569038097303},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure5.png","hash":"2d6cfd588280b48cea274b3a1447c97c6103bc86","modified":1569060876827},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure4.png","hash":"6c3f74cafbf43860cd5cebce07ee6a305c5afdca","modified":1569060460547},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure6.png","hash":"1b51ae2a5b2207a9e4ccc88ebf387929dab290b7","modified":1569065709540},{"_id":"source/_posts/光栅化渲染-8-正交投影矩阵/figure1.png","hash":"bda81d3009985253e265adf9d5832120779f1889","modified":1569123004889},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure7.png","hash":"25486fad882745c4da95844b94fa4401f28b77c5","modified":1569066422750},{"_id":"source/_posts/八数码问题/EightDigital.png","hash":"0de9048bd4284853f514126f2664ba19e7ed4b10","modified":1566306323362},{"_id":"source/_posts/八皇后问题/queen.png","hash":"6ab1bc094e22cb34ec02d3dcd9f3c70efe233479","modified":1566306323362},{"_id":"source/_posts/循环小数化为分数的方法/wiki.png","hash":"1b5ec94305a72471f51e90d9bd1d71e44983a983","modified":1566306323377},{"_id":"source/_posts/静态链接库-STATIC-和动态链接库-SHARED/shared.png","hash":"30958cd8a546d25f90a9320630be02d8b39dc16d","modified":1566306323377},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1618975814810},{"_id":"source/_posts/静态链接库-STATIC-和动态链接库-SHARED/static.png","hash":"2a49d01e43487344cba9c57f6b1d47a4f1489052","modified":1566306323377},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1618975814810},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1618975814810},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1618975814810},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1618975814810},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1618975814810},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1618975814810},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1618975814810},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1618975814810},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1618975814810},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1618975814810},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1618975814810},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1618975814810},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure4.png","hash":"bff74759418d9700c5efda10e288c4bc9788d604","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-4-深度检测/figure1.png","hash":"1e135db59da481a49accdc278d49bf1b767f0213","modified":1566909929227},{"_id":"themes/next/layout/_third-party/comments.swig","hash":"01f548c83370793dc91e905a12d693687b423a3e","modified":1618975814810},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1618975814810},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1618975814810},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1618975814810},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1618975814810},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1618975814810},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1618975814810},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1618975814810},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1618975814810},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1618975814810},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1618975814810},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1618975814810},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1618975814810},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1618975814810},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1618975814810},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1618975814810},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1618975814810},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1618975814810},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1618975814810},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1618975814810},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1618975814810},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1618975814810},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1618975814820},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1618975814820},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1566306324190},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1566306324190},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1618975814820},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1618975814820},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1618975814820},{"_id":"source/_posts/光栅化渲染-5-透视矫正/figure2.png","hash":"86ca1b83f05cf6fe1a539e79de910c8acbe774d2","modified":1567479671681},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1618975814820},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1618975814820},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1618975814820},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1566306324190},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1566306324190},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1618975814820},{"_id":"themes/next/source/images/images.jpeg","hash":"c3f38a8f5c4b6afca08f655cdaa2daf9c7804b5f","modified":1566306324190},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1618975814820},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1566306324190},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1566306324190},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1566306324190},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1618975814820},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1618975814820},{"_id":"themes/next/source/images/user2.jpg","hash":"16b0e60948516954e1f9834e2d593c1deb0ffec4","modified":1566306324190},{"_id":"source/_posts/My-little-angel/qxy1.jpg","hash":"29c0b85aa8bd9e32c8b239b78ae5f571e8375bd9","modified":1566306323331},{"_id":"source/_posts/Uva1103-Ancient-Messages/hier.png","hash":"9fc1f550a328d3a0f44bec5cd4655935db1fe9d0","modified":1566306323346},{"_id":"source/_posts/光栅化渲染-5-透视矫正/formula3.png","hash":"686b72ecfe10c313d8e062e9c4612d054f6b3f4d","modified":1567481029115},{"_id":"source/_posts/vultr/p4.png","hash":"2ee46cf520c7d0585db4245c9586829f5173e680","modified":1566306323346},{"_id":"source/_posts/vultr/p6.png","hash":"47f4048062363375bb49809ceb19a67b5c659bf3","modified":1566306323362},{"_id":"source/_posts/vultr/p9.png","hash":"7a099d33cc7ac17bc5e233121d135e46af0549b5","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-1-算法总述/discrete.png","hash":"b4b6f31ff7984722ea989da3021d191fc2806c77","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-1-算法总述/figure3.png","hash":"70c2465005d5eec54389370fafa997d62224ff54","modified":1566306323362},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure1.png","hash":"6dd6f1c04d661b7665eac613aac347366a694da5","modified":1569038206755},{"_id":"source/_posts/八皇后问题/diagonal.png","hash":"4963cc964d96d85438ef74780aafd357f2c198f4","modified":1566306323362},{"_id":"source/_posts/欧拉回路/Elur.png","hash":"ddc21e3cbc1ffa51606a7a521fad01c798d6ad47","modified":1566306323377},{"_id":"source/_posts/光栅化渲染-4-深度检测/figure2.png","hash":"55a78a8a6e5ff37e3af5f3dfdf2f920dec96584c","modified":1566986184771},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566306323409},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566306324175},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566306323409},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566306324175},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566306324175},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566306324190},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566306324190},{"_id":"themes/next/source/images/avatar2.png","hash":"5a825078a61886e5bf8f40244b0c0d3acef801ee","modified":1566306324190},{"_id":"themes/next/source/images/avatar.jpg","hash":"a2940e550cbd26df2e3561074910cc38f54edd15","modified":1566306324190},{"_id":"source/_posts/光栅化渲染-8-正交投影矩阵/projectionsexample.png","hash":"48166b3bed17e8a7138eb9718db8eb198e1c033c","modified":1569121677522},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1618975814810},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1618975814810},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1618975814810},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1618975814810},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1618975814810},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1618975814810},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1618975814810},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1618975814810},{"_id":"source/_posts/Uva1343-The-Rotation-Game/game.png","hash":"aaa5af49a4c3ecab97010f616c8cced728f60c1f","modified":1566306323346},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1618975814810},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1618975814810},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1618975814810},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1618975814810},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1618975814810},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1618975814810},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1618975814810},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1618975814810},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1618975814810},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1618975814810},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1618975814810},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1618975814810},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1618975814810},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1618975814810},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1618975814810},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1618975814820},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1618975814810},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1618975814820},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1618975814810},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1618975814810},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1618975814820},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1618975814820},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1618975814820},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1618975814820},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1618975814820},{"_id":"themes/next/source/css/_variables/base.styl","hash":"52021fd91328788f5e1477a6518d0b713e1c92ce","modified":1618975814820},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1566306324206},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1566306324206},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1618975814830},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1618975814830},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1618975814830},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1618975814830},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1618975814830},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1618975814830},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1618975814830},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1618975814830},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1618975814830},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1618975814830},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1618975814830},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1618975814830},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1618975814830},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1618975814830},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1618975814830},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1618975814830},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1618975814830},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1618975814830},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1618975814830},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1566306324221},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1618975814840},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1566306324221},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1618975814840},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1618975814840},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1618975814840},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1618975814840},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1618975814840},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1618975814820},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1618975814820},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1618975814820},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1618975814820},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1618975814820},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1618975814820},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1618975814820},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1618975814820},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1618975814820},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1618975814820},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1618975814820},{"_id":"source/_posts/光栅化渲染-2-透视投影/perspective.png","hash":"dd94afdc53034d3284cacc982d9124c2f596475a","modified":1566306323362},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1618975814840},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1618975814840},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1618975814840},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1618975814840},{"_id":"source/_posts/光栅化渲染-7-渲染管线/figure1.png","hash":"938e056da84f53ea11716159c9d62b93e9ca11bc","modified":1568978806758},{"_id":"source/_posts/哈希表/hash.png","hash":"29a902ee92685689f3c4b52320ed65dab3c442e1","modified":1566306323362},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1618975814810},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1618975814820},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1618975814820},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1618975814820},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1618975814820},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1618975814820},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1618975814820},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1618975814820},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1618975814820},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1618975814820},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1618975814820},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1618975814820},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1566306324206},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1566306324206},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1566306324206},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1566306324206},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1566306324206},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1566306324206},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1618975814830},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1618975814830},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1618975814830},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1618975814830},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1618975814830},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1618975814830},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1618975814830},{"_id":"source/_posts/Linear algebra-Dot product/1.gif","hash":"a037ce119aca35cd7188ef70334ba9b06dc81d31","modified":1566306323315},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1618975814820},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1618975814840},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1618975814840},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1618975814820},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1566306324206},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1566306324221},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1618975814810},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1618975814820},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1618975814820},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1618975814820},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1566306324190},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1566306324190},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1566306324190},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1566306324190},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1566306324206},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1618975814830},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1618975814830},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1618975814830},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1618975814830},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1566306324206},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1566306324221},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1566306324190},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1618975814830},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1618975814830},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1566306324221},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1618975814840},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1566306324221},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1618975814830},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1618975814840},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1618975814830},{"_id":"source/_posts/Linear algebra-Dot product/3.gif","hash":"fc991a2c97761dcc611775a0ed1bd3bcf31c6435","modified":1566306323331},{"_id":"source/_posts/Linear algebra-Dot product/2.gif","hash":"bb118b39f653f5c4b63c9947450608f8049641d4","modified":1566306323331},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1569126140163},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1569126140163},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1569126140163},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1569126140163},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1569126140163},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1569126140163},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1569126140163},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1569126140163},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1569126140163},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1569126140163},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1569126140163},{"_id":"public/images/images.jpeg","hash":"c3f38a8f5c4b6afca08f655cdaa2daf9c7804b5f","modified":1569126140163},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1569126140163},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1569126140163},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1569126140163},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1569126140163},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1569126140163},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1569126140163},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1569126140163},{"_id":"public/images/user2.jpg","hash":"16b0e60948516954e1f9834e2d593c1deb0ffec4","modified":1569126140163},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1569126140163},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1569126140163},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1569126140163},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1569126140163},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1569126140163},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1569126140163},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1569126140163},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1569126140163},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1569126140164},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1569126140164},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1569126140164},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1569126140164},{"_id":"public/2018/08/12/HDU1016-Prime-Ring-Problem-DFS/dfs.png","hash":"bfaf09def97b165527bb22bad63dfe38109bdd64","modified":1569126140164},{"_id":"public/2019/03/26/Maze/maze.png","hash":"26050035faeb5026419d4fe0076622b2f6dc821a","modified":1569126140164},{"_id":"public/2019/04/03/Learn-CMake-4-链接库文件/lena_color.png","hash":"5c2c81b0f5095fd2787700a7549d0b61e7bc7998","modified":1569126140164},{"_id":"public/about/index.html","hash":"f52186b6f8841aaaaea76a39e7a2141b66ecda8a","modified":1569126141468},{"_id":"public/commonweal/index.html","hash":"8786796119d6ee81f3bb0e9835aa0a2fa39ae3b9","modified":1569126141468},{"_id":"public/categories/index.html","hash":"9d93e3e09ce01930396b5789e2284e039bab0e84","modified":1569126141468},{"_id":"public/schedule/index.html","hash":"620ffdf961fba2709d4bc23af8c3f9bf0c327f64","modified":1569126141468},{"_id":"public/links/index.html","hash":"1ad8adec6519084578aac9960e76bc031f652c39","modified":1569126141468},{"_id":"public/sitemap/index.html","hash":"fbdab78c2aae2dc856222206f334eaa2b175c4cf","modified":1569126141468},{"_id":"public/tags/index.html","hash":"67eeb72d3230f88ff9e2f56e146a4eca98f38ee2","modified":1569126141468},{"_id":"public/2019/09/22/光栅化渲染-8-正交投影矩阵/index.html","hash":"99abd2c42c594f07cfc7fe823d3828b9fdb69d1b","modified":1569126863442},{"_id":"public/2019/09/21/光栅化渲染-7-渲染管线/index.html","hash":"8d7753627ac99e65b79256cc19324b3394240666","modified":1569126863442},{"_id":"public/2019/09/20/光栅化渲染-6-透视投影矩阵/index.html","hash":"ced220b071e37a28d04342b4b73d9fd8038fc294","modified":1569126863443},{"_id":"public/2019/09/02/光栅化渲染-5-透视矫正/index.html","hash":"85ffa187689fcf933c7af8087b0982e09cdcbcd9","modified":1569126141468},{"_id":"public/2019/08/27/光栅化渲染-4-深度检测/index.html","hash":"2c9a18e846b79fed37d579ce39428e0690012e31","modified":1569126141468},{"_id":"public/2019/08/15/光栅化渲染-3-光栅化/index.html","hash":"12d5bdd98456084f7dfe3634af475fe4f8ade63f","modified":1569126141468},{"_id":"public/2019/08/11/光栅化渲染-2-透视投影/index.html","hash":"2458b2fbd65dec3f34898017dcf6af7b0eefc613","modified":1569126141468},{"_id":"public/2019/08/10/光栅化渲染-1-算法总述/index.html","hash":"8833c1402c9cc9dac349852626a4eba9723776a6","modified":1569126141468},{"_id":"public/2019/08/02/kickstart-2019D-X-or-What/index.html","hash":"e1c5d22eefe5958d291e51bcfb0ec3d6723bf525","modified":1569126141468},{"_id":"public/2019/07/27/CodeForces-469D-Two-Sets/index.html","hash":"8f750e2c8e90ca0b3d308d81fea0281bad1af032","modified":1569126141468},{"_id":"public/2019/07/27/二分查找以及lower-bound-upper-bound实现/index.html","hash":"a780e4192d8aaa55e0134ce2581eaa153c6e0e47","modified":1569126141468},{"_id":"public/2019/04/28/Rand-C-随机数/index.html","hash":"b24828fc4197647c2a683bef69d154771a931387","modified":1574235827376},{"_id":"public/2019/04/17/Kalman-filter-卡尔曼滤波器/index.html","hash":"b1119d184a4f04e4decbf6105da3c9ab070c76c6","modified":1569126141468},{"_id":"public/2019/04/03/静态链接库-STATIC-和动态链接库-SHARED/index.html","hash":"2f75afa737444bfb26b6338feb08e5bcb316eaeb","modified":1569126141468},{"_id":"public/2019/04/03/Learn-CMake-4-链接库文件/index.html","hash":"ef6a0f2585677befcd5ed020dbbdcddc81568d0c","modified":1569126141468},{"_id":"public/2019/04/03/Learn-CMake-3-创建库文件/index.html","hash":"0be52610b211103cdcf5ddbed91f724052a40413","modified":1569126141468},{"_id":"public/2019/04/03/Learn-CMake-2-多文件-目录/index.html","hash":"7782fb629654f1f2544ab2f3c4cff3c08c835ca8","modified":1569126141468},{"_id":"public/2019/04/02/Learn-CMake-1-HelloWorld/index.html","hash":"d53c28c62fcf097b9337ff9fdb8faf72f1d0858c","modified":1569126141468},{"_id":"public/2019/03/27/PCA-主成分分析/index.html","hash":"7c400867dcb6cd68cae19fa3827bc7fa2166618d","modified":1569126141468},{"_id":"public/2019/03/27/Covariance-协方差/index.html","hash":"cf00fbf18e12b4861bb27ecec64ef20a2335d9ec","modified":1569126141468},{"_id":"public/2019/03/26/Maze/index.html","hash":"16fa6e57bee653f692499e271840ad25000c6207","modified":1569126141468},{"_id":"public/2019/03/04/buildBinaryTree/index.html","hash":"347a2ca71f3dd76b96232848bb5829b5653601bd","modified":1569126141469},{"_id":"public/2019/02/12/Uva1602-Lattice-Animals/index.html","hash":"c62ee5aeef5559a3f45a6ec038ac7af6a562f7f8","modified":1569126141469},{"_id":"public/2019/02/08/Uva1374-Power-Calculus/index.html","hash":"4c2dac7d4cfffb19d060b327130af813b382d71c","modified":1569126141469},{"_id":"public/2019/01/13/Uva1343-The-Rotation-Game/index.html","hash":"42394dddac2d47a6f68bada919f53d1768ce0744","modified":1569126141469},{"_id":"public/2019/01/12/Uva11212-Editing-a-Book/index.html","hash":"af5eb355fbd64399db5d13e014d2648fecde2264","modified":1569126141469},{"_id":"public/2019/01/03/埃及分数-迭代加深搜索/index.html","hash":"1829c58bf19dd547804311d637fe0c71fbca0be2","modified":1569126141469},{"_id":"public/2019/01/02/Uva1601-The-Morning-after-Halloween/index.html","hash":"d5159ad18adfa1bc6be8260c9b14ea55f364a615","modified":1569126141469},{"_id":"public/2018/12/31/Good-Bye-2018/index.html","hash":"0b9dbd30b68688b1377ad0c4391d199d5f76cfd4","modified":1569126141469},{"_id":"public/2018/12/31/倒水问题/index.html","hash":"6c1d3d3bc754018b8cd2a1aca338de22b53f292d","modified":1569126141469},{"_id":"public/2018/12/26/八数码问题/index.html","hash":"e35e03f26b256076e8e36455bc3c2da44cef1ce0","modified":1569126141469},{"_id":"public/2018/12/25/哈希表/index.html","hash":"b3d650deb35b3b715eba18912d745cd8318c88e5","modified":1569126141469},{"_id":"public/2018/12/20/八皇后问题/index.html","hash":"48b2a28a8a87837ab08a3114e98a80da43ade64f","modified":1569126141469},{"_id":"public/2018/12/18/next-permutation解析/index.html","hash":"69b88c5087a01a364ad1514c7333669e4e1e2f00","modified":1569126141469},{"_id":"public/2018/12/17/Uva11059-Maximum-Product/index.html","hash":"81a0c1701ecd9975b97a4bca76c00ba3129b4583","modified":1569126141469},{"_id":"public/2018/12/17/Uva725-Division/index.html","hash":"1b7aa69561baa9f96658942c8d8a37e0cbfb15b4","modified":1569126141469},{"_id":"public/2018/12/17/Uva12118-Inspetor-s-Dilemma/index.html","hash":"0382a44f910e869cf4b097be9fa42ca8dc8fcbca","modified":1569126141469},{"_id":"public/2018/12/14/Uva10410-Tree-Reconstruction/index.html","hash":"6bdffa070ce1d0a96abbbee7b5183cf2dc9b9852","modified":1569126141469},{"_id":"public/2018/12/12/Uva127-Accordian-Patience/index.html","hash":"1a44b00d6186ffd41abe0ad8507b2d189eed2d20","modified":1569126141469},{"_id":"public/2018/12/09/循环小数化为分数的方法/index.html","hash":"ddf09e44189b69dc9f54902c2c6a72ba3a0723b0","modified":1569126141469},{"_id":"public/2018/12/04/Uva806-Spatial-Structures/index.html","hash":"3e58b61d1bde39ffcbb6ef3c46fba619d35dfe6b","modified":1569126141469},{"_id":"public/2018/12/04/Uva12166-Equilibrium-Mobile/index.html","hash":"bccc4fee135ddbb68e0b36a470de4e5e323a164d","modified":1569126141469},{"_id":"public/2018/12/03/Uva1600-Patrol-Robot/index.html","hash":"66ec87f77ed190c89aacba65cfc366dff706f434","modified":1569126141469},{"_id":"public/2018/12/03/extern-外部变量/index.html","hash":"332626cfff377fcf8936fb8bdbf783588878d13c","modified":1569126141469},{"_id":"public/2018/12/03/Super-Mario/index.html","hash":"d3fe47e5e914f1eb8dd8bb19ce872ca39fd10062","modified":1569126141469},{"_id":"public/2018/12/02/C语言编译连接过程以及-h和-c文件解析/index.html","hash":"4f648a02982cc3ecbad8c76ff01498230149e037","modified":1569126141470},{"_id":"public/2018/11/27/Uva673-Parentheses-Balance/index.html","hash":"b23447eda3fc8aca87e65edafd6aa5f6a3934c1b","modified":1569126141470},{"_id":"public/2018/11/20/Uva11853-Painball/index.html","hash":"7dcc04002c4c45affbba01f1e9735228ecbf0480","modified":1569126141470},{"_id":"public/2018/11/18/Uva1599-Ideal-Path/index.html","hash":"5bf2ce98fabd749430195f43ec6de04ff56f198d","modified":1569126141470},{"_id":"public/2018/11/14/Uva221-Urban-Elevations/index.html","hash":"be3dd8d766eea685589f426ff748c04828975491","modified":1569126141470},{"_id":"public/2018/11/13/Uva10562-Undraw the trees/index.html","hash":"4d3ab15a2bb9ca4cf5220c77a4ceb5e1f51d36b9","modified":1569126141470},{"_id":"public/2018/11/12/Uva10129-Play-on-Words/index.html","hash":"313bf36a4f236918e12d4855defd2c424788af2d","modified":1569126141470},{"_id":"public/2018/11/04/欧拉回路/index.html","hash":"1a34c90099a7d3e0d190d9fc3a827a08c38fa403","modified":1569126141470},{"_id":"public/2018/11/04/Uva10305-Ordering-Tasks/index.html","hash":"041c85dc7809e8692aaaa27faa73c8510bd9241f","modified":1569126141470},{"_id":"public/2018/11/01/Uva816-Abbott-s-Revenge-BFS/index.html","hash":"e6c12acfe72a6cf48a652007ec6bdb21e2046647","modified":1569126141470},{"_id":"public/2018/10/28/Uva1103-Ancient-Messages/index.html","hash":"2586ef0ea08419d3a994d51c1a600187a150b4ea","modified":1569126141470},{"_id":"public/2018/10/24/Linear algebra-Dot product/index.html","hash":"0f57bea41f625708363593f1285a377f9c653b19","modified":1569126141470},{"_id":"public/2018/09/22/Uva839-二叉树的递归处理/index.html","hash":"7ea97fbcf09bc74a1ad643cf3859a36be04a3046","modified":1569126141470},{"_id":"public/2018/09/22/Uva548-二叉树构建-DFS/index.html","hash":"c6604d40a5d195912c440502fe62c4d188939f1b","modified":1569126141470},{"_id":"public/2018/09/22/二叉树中序和后序遍历-层序和先序遍历/index.html","hash":"e722466b21d771c2a76276e375864d57af3590c9","modified":1569126141470},{"_id":"public/2018/09/21/Uva122-二叉树构建与层次遍历/index.html","hash":"0e9e793ed7ddeb93440e36713a5e87c645f5362e","modified":1569126141470},{"_id":"public/2018/09/20/new-keyword/index.html","hash":"8628c2fd75386324bba17a13a50429df21c3d508","modified":1569126141470},{"_id":"public/2018/09/15/sscanf-sprintf/index.html","hash":"4893f763e05a992532f84948e9eccaec5be12a55","modified":1569227147278},{"_id":"public/2018/09/07/Graph-Theory-The-shortest-path/index.html","hash":"840302f655b63730b44bde82d0ff54697382872e","modified":1569126141470},{"_id":"public/2018/08/28/CodeForces-569A/index.html","hash":"2a4701e9dbd22855dabb0953552dace036dbf932","modified":1569126141470},{"_id":"public/2018/08/28/CodeForces-478C/index.html","hash":"e3f9d5d86c68e7f82be3b414560a9479a1a97d9b","modified":1569126141470},{"_id":"public/2018/08/14/POJ1970-The-Game-DFS/index.html","hash":"293d3985d2689cf3ec8ee8c7a076ae4c7a494861","modified":1569126141470},{"_id":"public/2018/08/12/HDU1016-Prime-Ring-Problem-DFS/index.html","hash":"f433fa7eb6d7a483081ee9b537b589c9b490cdd6","modified":1569126141470},{"_id":"public/2018/08/11/pick-numbers/index.html","hash":"32cc8f2c475a5bd7e79726c9c8964d156decaad6","modified":1569126141471},{"_id":"public/2018/08/09/Uva12096-The-SetStack-Computer-STL/index.html","hash":"8f9d625893c65b7e46bca25c4d123146866f9cfd","modified":1569126141471},{"_id":"public/2018/08/08/stringstream/index.html","hash":"69467448fe51ce24fa122d65f1383a58b1482e15","modified":1569126141471},{"_id":"public/2018/08/07/STL-cmp/index.html","hash":"cd07c9989e40a088546fa1883f0125dbf0c45460","modified":1569126141471},{"_id":"public/2018/07/31/Codeforces-498Div3-C/index.html","hash":"9eb3d92f42a2c96d716d7fdfea49f38ba318a712","modified":1569126141471},{"_id":"public/2018/07/29/Nowcoder-Fourth-G/index.html","hash":"b880d1961e6e3f805ccd87c18dac56c13ecc978e","modified":1569126141471},{"_id":"public/2018/07/26/Nowcoder-Third-A/index.html","hash":"631fc879b16e909ff598e45a266cf76d1057a2ae","modified":1569126141471},{"_id":"public/2018/06/12/tab-to-spaces/index.html","hash":"072dd08d55b6c73c7fdd5d5ba40fab38fa0f11b7","modified":1569126141471},{"_id":"public/2018/06/10/My-little-angel/index.html","hash":"a3b1d967847e6916089d55dbb52b61a6ad561d07","modified":1569126141471},{"_id":"public/2018/06/05/HDU5092/index.html","hash":"07c95b2b0d31149d5aa9deaeb05615809667a8da","modified":1569126141471},{"_id":"public/2018/05/16/HDU4856-Tunnels/index.html","hash":"c569dce67a77b1f9661aded3cedc4ae1ef0bafed","modified":1569126141471},{"_id":"public/2018/05/14/quick-matrix/index.html","hash":"315152520c263ee47fd5637fbe7de766f6688d6a","modified":1569126141471},{"_id":"public/2018/05/08/segtree-intval/index.html","hash":"970b484e97eaa89fa12b3c362b1a283b4dbf6296","modified":1569126141471},{"_id":"public/2018/05/06/segtree-template/index.html","hash":"594d441e7075f66fc566cce9331bc0f60165ce77","modified":1569126141471},{"_id":"public/2018/04/22/POJ2481/index.html","hash":"62e651560321b5513439f82a78ae7e959b1e211a","modified":1569126141471},{"_id":"public/2018/04/13/vultr/index.html","hash":"858cdcfe26f2fb33477c0d98a8bd2d840fca90a0","modified":1569126141471},{"_id":"public/2018/04/09/hexo-mathjax/index.html","hash":"2b1ba2aa187328e3053319475bae8672efc8c77d","modified":1569126141471},{"_id":"public/2018/04/09/HDU2050/index.html","hash":"4990fd67b7a143463a89e1858432527acc8f6927","modified":1569126141471},{"_id":"public/2018/04/08/new start point/index.html","hash":"747307251ffdd1113eb383ffa6e4fab1ec5f42ea","modified":1569126141471},{"_id":"public/archives/page/2/index.html","hash":"21b53976d442eb3b3c940374ed7f519cf561cd21","modified":1569126141471},{"_id":"public/archives/index.html","hash":"310a3bc95ed5f3ced4713aa9152a9e40aaf06dae","modified":1569126141471},{"_id":"public/archives/page/4/index.html","hash":"9ec74502af32e400300c682638276c1751255772","modified":1569126141471},{"_id":"public/archives/page/3/index.html","hash":"4b7f4bc8153775f6a057207ee581250e35700624","modified":1569126141471},{"_id":"public/archives/page/5/index.html","hash":"350372bc2d394928be260c1fe04eef187138d6f4","modified":1569126141472},{"_id":"public/archives/page/6/index.html","hash":"b4160aa26e60e55bb460a7c8c3bf8a5ef1d20860","modified":1569126141472},{"_id":"public/archives/page/7/index.html","hash":"6234b463342ed08f5ee277c4dc02ec742c64f612","modified":1569126141472},{"_id":"public/archives/page/9/index.html","hash":"71826971972c2d233f2898c70d61b2f6ac514291","modified":1569126141472},{"_id":"public/archives/2018/index.html","hash":"4e68a40a573fe0946c5d197b94282ead6c51348e","modified":1569126141472},{"_id":"public/archives/page/8/index.html","hash":"b80e9719e98936310e0b4721b2fba52f3769f269","modified":1569126141472},{"_id":"public/archives/2018/page/2/index.html","hash":"434110a8557e9e01d1631d0802aa4930070f2ca2","modified":1569126141472},{"_id":"public/archives/2018/page/3/index.html","hash":"94ad81a49501cdbd5214b996f233c7e4c4f310f7","modified":1569126141472},{"_id":"public/archives/2018/page/4/index.html","hash":"747390e66ffa3d8d97a704b399d64fafc93b212c","modified":1569126141472},{"_id":"public/archives/2018/page/6/index.html","hash":"41b7e893daced1253d7396e25e1cb151803a7ad5","modified":1569126141472},{"_id":"public/archives/2018/page/5/index.html","hash":"a1681eda7a92c902069cbf7061ff6a67ed6baf56","modified":1569126141472},{"_id":"public/archives/2018/04/index.html","hash":"01a29df87770d9d923b2d159e400e1e8123d833a","modified":1569126141472},{"_id":"public/archives/2018/05/index.html","hash":"3ec4bd9201fd63fc7a62f56e80ab38ad585638ee","modified":1569126141472},{"_id":"public/archives/2018/06/index.html","hash":"d5592cd2811dc8fdb56f541dd628c59d81612a16","modified":1569126141472},{"_id":"public/archives/2018/08/index.html","hash":"7d945e9336900dd10ecd952c81ab9194b854a17d","modified":1569126141472},{"_id":"public/archives/2018/09/index.html","hash":"1ae4d0ea4c318893970c4d230f4515cde5e5401f","modified":1569126141472},{"_id":"public/archives/2018/07/index.html","hash":"518a82ef7cb2f2bd6b03403d5adead8c112de906","modified":1569126141472},{"_id":"public/archives/2018/10/index.html","hash":"b8cb40fc2a27f30536e242ef9f036503a40c0e21","modified":1569126141472},{"_id":"public/archives/2018/11/index.html","hash":"e17a7d9c8175d90acfd8789146a39d6f3dd9c820","modified":1569126141472},{"_id":"public/archives/2018/12/index.html","hash":"7fcf133d54e6ce771ad893366237138eb40f452b","modified":1569126141472},{"_id":"public/archives/2018/12/page/2/index.html","hash":"77ae58066e23c2da3f3a39e588fc732bd841c280","modified":1569126141472},{"_id":"public/archives/2019/index.html","hash":"df42b2e17ae4019e6f86dc91beb105a7b801c217","modified":1569126141472},{"_id":"public/archives/2019/page/2/index.html","hash":"d2d94091ac7378e14b79f264e5b36ff485e66041","modified":1569126141472},{"_id":"public/archives/2019/01/index.html","hash":"3ab43607ab3bfa119db172a40328d0182aaf6916","modified":1569126141472},{"_id":"public/archives/2019/page/3/index.html","hash":"364d3f4d9b3fda38313cc7cd54f49f988bc87bca","modified":1569126141472},{"_id":"public/archives/2019/02/index.html","hash":"48444fc78350278a21a2f08ddaf1fb7567dc4499","modified":1569126141472},{"_id":"public/archives/2019/03/index.html","hash":"dddfbef19f7bbf25dc45178995c47595031f44db","modified":1569126141473},{"_id":"public/archives/2019/04/index.html","hash":"2db9651c3fe3a604fe933075fa2c87f3e4bd6fe3","modified":1569126141473},{"_id":"public/archives/2019/07/index.html","hash":"d4dcd741a4767229b87c2a83a902a6764b73d32b","modified":1569126141473},{"_id":"public/index.html","hash":"e7b174ecaba5ca4937c1f94ee94a9fcbd5d2bf98","modified":1569126863443},{"_id":"public/archives/2019/08/index.html","hash":"abed8829ec74d271933a322fc9932351a44704a9","modified":1569126141473},{"_id":"public/archives/2019/09/index.html","hash":"7b5dd2692233ddb9790d18ab2eb84690cf821dc5","modified":1569126141473},{"_id":"public/page/3/index.html","hash":"63aebdf4943edf172d61729d99d0ffc31d1f35cb","modified":1569126141473},{"_id":"public/page/2/index.html","hash":"133060c3d8eb587f23d3564b6def9ee59f022028","modified":1574235827376},{"_id":"public/page/4/index.html","hash":"6eb630065556bcb0135fcdbeb7c7c98b9fac8ac8","modified":1569126141473},{"_id":"public/page/5/index.html","hash":"0db1df39a87e7dae4a86327a0838e44474e1c32d","modified":1569126141473},{"_id":"public/page/6/index.html","hash":"808c416982e53315c772ddcf860fd58679fb88dd","modified":1569126141473},{"_id":"public/page/7/index.html","hash":"128eabc95b8afdbf2933d7fc508575ae11b9d7ec","modified":1569227147279},{"_id":"public/page/8/index.html","hash":"23f3b25b4f389182a6d9b9d81beb9aaaaaed28a7","modified":1569126141473},{"_id":"public/page/9/index.html","hash":"31710c17a172719383a02dcbc272c24e5c6f79c4","modified":1569126141473},{"_id":"public/categories/ACM/index.html","hash":"c93106701d94a98a00f56fd5a79c2e93d7fe8916","modified":1569126141473},{"_id":"public/categories/ACM/page/3/index.html","hash":"7a0d3e7c4fdd7963158a23a3e567d78175457e13","modified":1569126141473},{"_id":"public/categories/ACM/page/4/index.html","hash":"afc87ae32a73ef04abd501b9cafe626570fd10fa","modified":1569126141473},{"_id":"public/categories/ACM/page/2/index.html","hash":"a8b84ab4497f1443d449b460bf311eb7a08c8ba0","modified":1569126141473},{"_id":"public/categories/Math/index.html","hash":"80f3c61f4e2855d2cf7696979c838114cdfb8907","modified":1569126141473},{"_id":"public/categories/C/index.html","hash":"866da2e6bbb344f47269f3c83359d37a2b97fa3f","modified":1569126141473},{"_id":"public/categories/Summary/index.html","hash":"468f57525aa3e086b872222bdb4173dd87b2258f","modified":1569126141473},{"_id":"public/categories/Diary/index.html","hash":"0d600b6f2831f01c5c57101cbd98dafa04b463c6","modified":1569126141473},{"_id":"public/categories/Summary/page/2/index.html","hash":"5006282547ddd15c8698e40236a5b46995202f09","modified":1569126141473},{"_id":"public/categories/Messy-article/index.html","hash":"4905456b27a01c5b1e97bd3675056e822d830a94","modified":1569126141473},{"_id":"public/categories/Template/index.html","hash":"3c603d6a87c6cf2d81b84f7d355b3a35cb8b0703","modified":1569126141474},{"_id":"public/categories/Google-Kick-Start/index.html","hash":"1b85f6ce80f40024c046f4b109bede76e728a2df","modified":1569126141474},{"_id":"public/categories/ACM/贪心/index.html","hash":"2f14ced2ebc47a5f1d5cc445a3208e3a12b6d6f4","modified":1569126141474},{"_id":"public/categories/ACM/思维/index.html","hash":"119defdab423168f73a5136d35ee0cdd51b6e1a3","modified":1569126141474},{"_id":"public/categories/Computer-Graphics/index.html","hash":"067c791f7f397fccb256576d48180fdef4aef818","modified":1569126141474},{"_id":"public/categories/ACM/前缀和/index.html","hash":"444f57cdeb71a2e71e3277991e0a5933866342a3","modified":1569126141474},{"_id":"public/categories/ACM/DFS/index.html","hash":"7abeaa8d99a121341a04f757219fb17463accc8d","modified":1569126141474},{"_id":"public/categories/ACM/动态规划/index.html","hash":"27fa9dfc1610d51fc65bb07f323e0fbc68fa2b60","modified":1569126141474},{"_id":"public/categories/ACM/欧拉路/index.html","hash":"7ce81bd43267940e8a94841ca1593e9dd302741d","modified":1569126141474},{"_id":"public/categories/ACM/线段树/index.html","hash":"7fbdd0529619ec18cd03da6751b8a51681eff7df","modified":1569126141474},{"_id":"public/categories/ACM/背包/index.html","hash":"6cfb493d503444f0c364d3c92e5977044346b1c4","modified":1569126141474},{"_id":"public/categories/ACM/树/index.html","hash":"7b0560faa25900903a90e99b6575fd4f0fc21389","modified":1569126141474},{"_id":"public/categories/ACM/拓扑排序/index.html","hash":"9138020f727e44782b97882fc1a11c5be15c7ed2","modified":1569126141474},{"_id":"public/categories/ACM/暴力枚举/index.html","hash":"75027394c23b1ee6999b54c5d650e9b6ecc029bd","modified":1569126141474},{"_id":"public/categories/ACM/map/index.html","hash":"a75408524492fb5923f641ab652317d4b922e7e0","modified":1569126141474},{"_id":"public/categories/ACM/链表/index.html","hash":"478aa08b9ffd066a0b5a0b7f207daacd18deaae3","modified":1569126141474},{"_id":"public/categories/ACM/IDA/index.html","hash":"e358940ea5c7571b8ec39e7485de7e18b01d66e0","modified":1569126141474},{"_id":"public/categories/ACM/BFS/index.html","hash":"c56b04a95fc0ca7132a32485ae7972da1cf81dfd","modified":1569126141474},{"_id":"public/categories/ACM/离散化/index.html","hash":"2db219a2514d413df62383125be4160e509ab20b","modified":1569126141474},{"_id":"public/categories/ACM/栈/index.html","hash":"4bd5212678e12971c6a7e43700f0032804879315","modified":1569126141474},{"_id":"public/tags/思维/index.html","hash":"651ecb09b543d668ccb4c887fad4e4bf46367eba","modified":1569126141474},{"_id":"public/tags/贪心/index.html","hash":"bf3916c0bbd68772ff4c7061c08e2f9e4c10fb68","modified":1569126141474},{"_id":"public/categories/Computer-Graphics/光栅化渲染/index.html","hash":"23dc825a23c5ae373189fa2c21c8c7b657ab3a13","modified":1569126141474},{"_id":"public/tags/Covariance/index.html","hash":"3a769a293d9b19afcb8f55b62b3e4a2d06cc724b","modified":1569126141474},{"_id":"public/tags/前缀和/index.html","hash":"e2f54e69ac22e6de8323567dc349ae2ce8e1c700","modified":1569126141474},{"_id":"public/tags/后缀和/index.html","hash":"333756cacabfb7b4358ed3c2b6374899467213bf","modified":1569126141474},{"_id":"public/tags/图论/index.html","hash":"10366914bc4c10da319ae777da6691457ea84f1f","modified":1569126141475},{"_id":"public/tags/DFS/index.html","hash":"d1753c841769e1c234e8241bed969448201c1539","modified":1569126141475},{"_id":"public/tags/C语言/index.html","hash":"f9cbff80231a999a41fee77dcaf11c5ec4e23dfd","modified":1569126141475},{"_id":"public/tags/HDU/index.html","hash":"0de3a1c0c010351df23ec7b1b1f37b89e0c30c0a","modified":1569126141475},{"_id":"public/tags/线切割平面/index.html","hash":"b62c587a0c9ca60e96ac0e054b78e4161f0dc7cf","modified":1569126141475},{"_id":"public/tags/math/index.html","hash":"37f99736597ebaed3c2aa7ab11fb086ceb4eca22","modified":1569126141475},{"_id":"public/tags/状态压缩DP/index.html","hash":"0ad6ee20b5974b13680415f5c423849e867fbac4","modified":1569126141475},{"_id":"public/tags/BFS/index.html","hash":"b45f8cedf647de8c28b9ba00baa666c92787e05f","modified":1569126141475},{"_id":"public/tags/CMake/index.html","hash":"998e9144f2ba7e67dba1f374ffee2a0964936584","modified":1569126141475},{"_id":"public/tags/逆向思维/index.html","hash":"2525dd06cca60f2089ebd367f62abad9d04dab75","modified":1569126141475},{"_id":"public/tags/PCA/index.html","hash":"422f13fc43330d9706e3d85386e9a932e046e3db","modified":1569126141475},{"_id":"public/tags/总结/index.html","hash":"58b51c8ba99ac902ddb66c7a6e729d8db2b2e2be","modified":1569126141475},{"_id":"public/tags/Liner-algebra/index.html","hash":"216e1340fc8c53b72b67ae99d17ea7fe7adab77a","modified":1569126141475},{"_id":"public/tags/DP/index.html","hash":"5c751248b618ea66800f892bf4d413d3a2a67e30","modified":1569126141475},{"_id":"public/tags/01背包/index.html","hash":"f890891d689f645b6318bbca04e2aa4a07135320","modified":1569126141475},{"_id":"public/tags/Lover/index.html","hash":"13b0743316ca6f8910ba0c1358116d9d670b0530","modified":1569126141475},{"_id":"public/tags/POJ/index.html","hash":"27f64a6ef8e3ebb34557bcf63993a622206cca3a","modified":1569126141475},{"_id":"public/tags/线段树/index.html","hash":"de28d39a5da71536bf6d60d5e27784ea66a01a6a","modified":1569126141475},{"_id":"public/tags/迷宫问题/index.html","hash":"831380cb92efd11b310aef7f921e94d0c34c4bfd","modified":1569126141475},{"_id":"public/tags/Game/index.html","hash":"8c243f323236f0a366ad2160696ea9483e573b11","modified":1569126141475},{"_id":"public/tags/STL/index.html","hash":"e4121da6e34b793906dfb822e55f9c8cfe669a14","modified":1569126141475},{"_id":"public/tags/欧拉路/index.html","hash":"f1b333e742fce6f7c1d2bce21b0a1921a135c80a","modified":1569126141475},{"_id":"public/tags/树/index.html","hash":"45acd2c6932727167eb4b0539715360af27286f6","modified":1569126141475},{"_id":"public/tags/拓扑排序/index.html","hash":"16a7ff8e9636d4feef7c20bece713782f435a008","modified":1569126141475},{"_id":"public/tags/二叉树/index.html","hash":"308b9387319091cf40e5d49f93dc3f10ba0e3aba","modified":1569126141475},{"_id":"public/tags/Random/index.html","hash":"988c7f5b034bf746b20d8d9bdf85d33b5795e67e","modified":1569126141475},{"_id":"public/tags/全局思维/index.html","hash":"2791ede08ee434cb20371cd7d208ede0547050e3","modified":1569126141475},{"_id":"public/tags/暴力枚举/index.html","hash":"7e2b8860a6daaa6a2bea931aaabf046526cfe554","modified":1569126141476},{"_id":"public/tags/迭代加深/index.html","hash":"75f84ade0d1e14adb2f35ed3b413e4e750e73542","modified":1569126141476},{"_id":"public/tags/全局思想/index.html","hash":"02794862c66c03ba11d05f1642410673f320a31d","modified":1569126141476},{"_id":"public/tags/stack/index.html","hash":"56bee1b2ad1c6e3a50bc5345bdee22a25ceca512","modified":1569126141476},{"_id":"public/tags/链表/index.html","hash":"f29f259e08ab37d21ae124b15daaed5e52bddf80","modified":1569126141476},{"_id":"public/tags/栈/index.html","hash":"1d55757684becf02d13191e6339944b840fb8fbe","modified":1569126141476},{"_id":"public/tags/搜索/index.html","hash":"3c3230861293a40d99a96d45795b5053ba1e9c8d","modified":1569126141476},{"_id":"public/tags/仿射变换/index.html","hash":"20133294fb8aea87a20d4ba5320b72dc532fd155","modified":1569126141476},{"_id":"public/tags/离散化/index.html","hash":"daf9d6db5279b9dc611ea7920d6a5183503dc140","modified":1569126141476},{"_id":"public/tags/Stack/index.html","hash":"0fc689aac75197d3a30f3045827bff00846efcd7","modified":1569126141476},{"_id":"public/tags/IDA/index.html","hash":"9aedb5aba341ea791224de1a399d2db8c92a6dd0","modified":1569126141476},{"_id":"public/tags/四分树/index.html","hash":"db3f2e0c82c7bcbea8fe73383f39a84786ad69bb","modified":1569126141476},{"_id":"public/tags/Binary-Tree/index.html","hash":"65af6f853e9a5504d712d997adaab1e0db2fc8ce","modified":1569126141476},{"_id":"public/tags/mathjax/index.html","hash":"786d08ba89d7eccb48b5c372555b79864df18865","modified":1569126141476},{"_id":"public/tags/hexo插入数学公式/index.html","hash":"6de33ab4d626705389a4280a257b71e18650ed6a","modified":1569126141476},{"_id":"public/tags/生活/index.html","hash":"da472dbaa129d568c7ca76d925f869ca25c6d70f","modified":1569126141476},{"_id":"public/tags/排列/index.html","hash":"2f1565521480f49f46879ed8fc429412d46b3104","modified":1569126141476},{"_id":"public/tags/C/index.html","hash":"27b831656ca09630d7d538dc7c9b26331c616880","modified":1569126141476},{"_id":"public/tags/线段树单点更新/index.html","hash":"f0285e4f8e4794e845ba8937f669244598e65712","modified":1569126141476},{"_id":"public/tags/字符串/index.html","hash":"34662c3ada6562ead62dfb96d917a6a90a6c83b0","modified":1569126141476},{"_id":"public/tags/python/index.html","hash":"0a70f9064ee50c2cabd514c2382275c4a0155f22","modified":1569126141476},{"_id":"public/tags/vultr服务器搭建/index.html","hash":"a3b8c8d7294996806f5306648ee474e291b3710a","modified":1569126141476},{"_id":"public/tags/rasterization/index.html","hash":"01976a2ba16cd50d9c18e6619f91bc9f14a36ab8","modified":1569126141476},{"_id":"public/tags/Rasterization/index.html","hash":"4e625bb1cd95efec100346516ba783577cdf7dd0","modified":1569126141476},{"_id":"public/tags/线段树区间更新/index.html","hash":"3c6dc36627a3a76dae767d7badede225942c549b","modified":1569126141476},{"_id":"public/tags/状态转移/index.html","hash":"f70a1fd0776deff20d5f82d552abd82165626b61","modified":1569126141476},{"_id":"public/tags/Binary-Search/index.html","hash":"4f0d17ba13751ef5460bf3d89ac041a33efe9606","modified":1569126141477},{"_id":"public/tags/Hash/index.html","hash":"5dcdfd4af7a1dee9ecbf46d82556920a944ad239","modified":1569126141477},{"_id":"public/tags/Link-Library/index.html","hash":"6db0f1416b37976ad2d27e90afc2e2459789fb27","modified":1569126141477},{"_id":"public/tags/Math/index.html","hash":"c8b78a31ffa1b3187c4c5b909a172d9c6f78e7de","modified":1569126141477},{"_id":"public/tags/Kalman-filter/index.html","hash":"71a2def543ad347f3dfedc030afabc61ae4e5ac7","modified":1569126141477},{"_id":"public/tags/迭代加深搜索/index.html","hash":"9f7f6f6e92db5227c33a1e4a17edde0c18bcd376","modified":1569126141477},{"_id":"public/tags/建图/index.html","hash":"c4ac514447f26408395c86aeff90cd6fb492ea34","modified":1569126141477},{"_id":"public/tags/双向BFS/index.html","hash":"42e23a4dff8b2c95b7c76fbef8b8bb2fbb6bb7ea","modified":1569126141477},{"_id":"public/2019/03/27/PCA-主成分分析/pca.jpeg","hash":"29edc63a8409f691aeb4c74bea6f2014bff9681a","modified":1569126141477},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1569126141477},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1569126141477},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1569126141477},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1569126141477},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1569126141477},{"_id":"public/2018/08/14/POJ1970-The-Game-DFS/Renju.png","hash":"e478edf969416be8f2fda647b3336271dbb13b6a","modified":1569126141477},{"_id":"public/2018/12/03/Super-Mario/SuperMario.png","hash":"b063b297ce5044d523ae0c3d2ea4c408cefe5848","modified":1569126141477},{"_id":"public/2018/11/13/Uva10562-Undraw the trees/tree.png","hash":"51cf513829497a8d98dc1e0f7ade6d8dc407adfd","modified":1569126141477},{"_id":"public/2019/01/12/Uva11212-Editing-a-Book/prune.png","hash":"c73f3744915ded4e3872dcb821e19743dd5669eb","modified":1569126141477},{"_id":"public/2019/04/28/Rand-C-随机数/random.jpg","hash":"e6cfaf454b76a04cc8c38273c89e9a2c9b2265a5","modified":1569126141477},{"_id":"public/2018/12/04/Uva12166-Equilibrium-Mobile/balance.png","hash":"f4529422d6cf9010363875a87318e6ec8cb45083","modified":1569126141477},{"_id":"public/2019/02/12/Uva1602-Lattice-Animals/pic.png","hash":"7d7efe55681e5d9619164d67d023e8322cad366d","modified":1569126141479},{"_id":"public/2018/09/22/Uva839-二叉树的递归处理/tree.png","hash":"ccee240e1b924dd7cca49828c69e0cf78742a7e3","modified":1569126141479},{"_id":"public/2019/03/04/buildBinaryTree/BinaryTree.png","hash":"f5a67b09376f01bfe9459e5dbd066ef290510d5a","modified":1569126141479},{"_id":"public/2018/11/14/Uva221-Urban-Elevations/building.png","hash":"5be5290e6f5974f919f3525d5d85f215d2b2dcd9","modified":1569126141479},{"_id":"public/2018/12/31/倒水问题/fill.png","hash":"e52c036e123deee8ba888f4751544fee2873f38a","modified":1569126141479},{"_id":"public/2018/12/09/循环小数化为分数的方法/wiki.png","hash":"1b5ec94305a72471f51e90d9bd1d71e44983a983","modified":1569126141479},{"_id":"public/2019/07/27/二分查找以及lower-bound-upper-bound实现/BinarySearch.jpeg","hash":"0ba27593f39f67249e26ef7183c23a7f87513bcf","modified":1569126141479},{"_id":"public/2018/12/26/八数码问题/EightDigital.png","hash":"0de9048bd4284853f514126f2664ba19e7ed4b10","modified":1569126141479},{"_id":"public/2018/09/07/Graph-Theory-The-shortest-path/gra.png","hash":"c2a7946e9e78ad6264a4a6d6b581d06160604bfe","modified":1569126141479},{"_id":"public/2018/09/07/Graph-Theory-The-shortest-path/path.png","hash":"b20559aca988d5aaefc0931e513b4fc808c5be21","modified":1569126141479},{"_id":"public/2018/04/09/HDU2050/line.jpg","hash":"0b614039e05df58510f6979466289f7ac7190b5f","modified":1569126141479},{"_id":"public/2018/04/09/HDU2050/res.gif","hash":"163a87523482ba25a73787e59a0b13ecfb736053","modified":1569126141479},{"_id":"public/2018/12/04/Uva806-Spatial-Structures/1.png","hash":"3374b72597b7048bb95a6af65ba72f10699f86a8","modified":1569126141480},{"_id":"public/2018/06/12/tab-to-spaces/space.png","hash":"e1202e8eb89c5c09f5e3eb1e4a72be772c4790b6","modified":1569126141480},{"_id":"public/2018/12/04/Uva806-Spatial-Structures/2.png","hash":"ad1edffc72af5cec0649f0b5e93a48a19d9d9acf","modified":1569126141480},{"_id":"public/2018/06/12/tab-to-spaces/tab.png","hash":"30312fc2dabd01c3540693ea57af6ea0a11c9fe2","modified":1569126141480},{"_id":"public/2019/09/22/光栅化渲染-8-正交投影矩阵/figure1.png","hash":"bda81d3009985253e265adf9d5832120779f1889","modified":1569126141480},{"_id":"public/2018/12/20/八皇后问题/queen.png","hash":"6ab1bc094e22cb34ec02d3dcd9f3c70efe233479","modified":1569126141480},{"_id":"public/2019/04/03/静态链接库-STATIC-和动态链接库-SHARED/shared.png","hash":"30958cd8a546d25f90a9320630be02d8b39dc16d","modified":1569126141480},{"_id":"public/2018/06/10/My-little-angel/moon1.jpg","hash":"c57a51bb30e1ec204f4fb3c01783b8f2e87a1bbd","modified":1569126141480},{"_id":"public/2018/06/10/My-little-angel/together1.jpg","hash":"1783fb05e6a210c1c2de23c413b9fb466c44c03a","modified":1569126141480},{"_id":"public/2019/04/03/静态链接库-STATIC-和动态链接库-SHARED/static.png","hash":"2a49d01e43487344cba9c57f6b1d47a4f1489052","modified":1569126141480},{"_id":"public/2018/10/28/Uva1103-Ancient-Messages/1.png","hash":"49e92896091c97e432582ca738cdd415dfbaef3a","modified":1569126141480},{"_id":"public/2018/10/28/Uva1103-Ancient-Messages/2.png","hash":"66e6e3e8aa6456456ff9794274edf1dacb72219c","modified":1569126141480},{"_id":"public/2019/08/10/光栅化渲染-1-算法总述/discrete.png","hash":"b4b6f31ff7984722ea989da3021d191fc2806c77","modified":1569126141480},{"_id":"public/2019/08/10/光栅化渲染-1-算法总述/figure1.png","hash":"af649c9b70f42ecfa0edad5a481f5ffd4d197b82","modified":1569126141480},{"_id":"public/2019/08/10/光栅化渲染-1-算法总述/figure2.jpg","hash":"2c36c6012a7c504c74cb3dca3a3d01995a6c27e7","modified":1569126141480},{"_id":"public/2019/08/10/光栅化渲染-1-算法总述/figure3.png","hash":"70c2465005d5eec54389370fafa997d62224ff54","modified":1569126141480},{"_id":"public/2019/08/10/光栅化渲染-1-算法总述/figure4.png","hash":"726703b49d439506bedae760c6fa738b95151e6f","modified":1569126141480},{"_id":"public/2019/09/02/光栅化渲染-5-透视矫正/figure2.png","hash":"86ca1b83f05cf6fe1a539e79de910c8acbe774d2","modified":1569126141480},{"_id":"public/2019/09/02/光栅化渲染-5-透视矫正/figure1.png","hash":"1e135db59da481a49accdc278d49bf1b767f0213","modified":1569126141480},{"_id":"public/2019/09/02/光栅化渲染-5-透视矫正/formula1.png","hash":"d046a0bda94273c8281ec1d75b84627fd78a8be3","modified":1569126141480},{"_id":"public/2019/09/02/光栅化渲染-5-透视矫正/formula3.png","hash":"686b72ecfe10c313d8e062e9c4612d054f6b3f4d","modified":1569126141480},{"_id":"public/2019/09/02/光栅化渲染-5-透视矫正/formula2.png","hash":"bba56568d3bb3abe3cc9d788df4f19762eb61dfd","modified":1569126141481},{"_id":"public/2019/08/11/光栅化渲染-2-透视投影/figure1.png","hash":"912adafd5db1b41e1998984b3be9772ca857d2cb","modified":1569126141481},{"_id":"public/2019/08/11/光栅化渲染-2-透视投影/figure3.png","hash":"aac0c865e4baf9b3a90312a55bb1c4523807c33c","modified":1569126141481},{"_id":"public/2019/08/11/光栅化渲染-2-透视投影/figure2.png","hash":"649cae0f0af4c126256c4f299b92d4ed48fbf696","modified":1569126141481},{"_id":"public/2019/08/11/光栅化渲染-2-透视投影/figure4.png","hash":"4fe94351ba51f9d8f087951002fb05f3532284ab","modified":1569126141481},{"_id":"public/2019/08/11/光栅化渲染-2-透视投影/visible.png","hash":"1f0d35a1d683fd482fa1aa95141569a5338e75f4","modified":1569126141481},{"_id":"public/2019/08/11/光栅化渲染-2-透视投影/figure5.png","hash":"f2ee13c644b516eb37867babd53db9ba1a3f8760","modified":1569126141481},{"_id":"public/2018/04/13/vultr/p1.png","hash":"595bda0f3e72f314db02d09c378298daf0840657","modified":1569126141482},{"_id":"public/2018/04/13/vultr/p2.png","hash":"c797e71775de0c707e10ec8f765a154b37f27197","modified":1569126141482},{"_id":"public/2018/04/13/vultr/p3.png","hash":"67dbd2c65a2c47e6ae09f22051629da1a6c5fdd1","modified":1569126141482},{"_id":"public/2018/04/13/vultr/p5.png","hash":"a7c6230253b7b12375ea294a6386473479cd7d26","modified":1569126141482},{"_id":"public/2018/04/13/vultr/p8.png","hash":"2f5ce1e7aa48769570589a1a15948f1364753a67","modified":1569126141482},{"_id":"public/2019/09/20/光栅化渲染-6-透视投影矩阵/equation1.png","hash":"bbf573035e02bc8ad9f472c18cbd4f6d1d8554bc","modified":1569126141482},{"_id":"public/2018/04/13/vultr/p7.png","hash":"da388ae09f2db520f71e2348bf8a4883adb2666a","modified":1569126141482},{"_id":"public/2019/09/20/光栅化渲染-6-透视投影矩阵/equation2.png","hash":"1ed03c9b87e6f8bce71c88796c83cbb9fc9a7fb8","modified":1569126141482},{"_id":"public/2019/09/20/光栅化渲染-6-透视投影矩阵/figure2.png","hash":"5807e7ae70533828fb60ab73b194349e8a9d7a56","modified":1569126141482},{"_id":"public/2019/09/20/光栅化渲染-6-透视投影矩阵/figure3.png","hash":"5f36ec78896a0961945b213d57d78f1c7f31b093","modified":1569126141482},{"_id":"public/2019/09/20/光栅化渲染-6-透视投影矩阵/figure4.png","hash":"6c3f74cafbf43860cd5cebce07ee6a305c5afdca","modified":1569126141482},{"_id":"public/2019/09/20/光栅化渲染-6-透视投影矩阵/figure5.png","hash":"2d6cfd588280b48cea274b3a1447c97c6103bc86","modified":1569126141482},{"_id":"public/2019/09/20/光栅化渲染-6-透视投影矩阵/figure7.png","hash":"25486fad882745c4da95844b94fa4401f28b77c5","modified":1569126141482},{"_id":"public/2019/08/27/光栅化渲染-4-深度检测/depth.png","hash":"2cf502ead52ade69c9aa9ddac8ebc2df3f8892dc","modified":1569126141482},{"_id":"public/2019/08/27/光栅化渲染-4-深度检测/equation2.png","hash":"2249a28cf6d96d6ab25f8eba1e0a5539521b23d4","modified":1569126141482},{"_id":"public/2019/09/20/光栅化渲染-6-透视投影矩阵/figure6.png","hash":"1b51ae2a5b2207a9e4ccc88ebf387929dab290b7","modified":1569126141482},{"_id":"public/2019/08/27/光栅化渲染-4-深度检测/equation4.png","hash":"22f9f9893087b2cc5c91a6341301454e7204ed61","modified":1569126141483},{"_id":"public/2019/08/27/光栅化渲染-4-深度检测/equation6.png","hash":"627278d2ffcb2f33ac784d879389618746bd6fc4","modified":1569126141483},{"_id":"public/2019/08/27/光栅化渲染-4-深度检测/equation7.png","hash":"1380cc7d0390cd3f0701af4d55e677336d5ae792","modified":1569126141483},{"_id":"public/2019/08/27/光栅化渲染-4-深度检测/equation8.png","hash":"ace1f7711d24f9d2da9e485c8f674cda8b77279a","modified":1569126141483},{"_id":"public/2019/08/27/光栅化渲染-4-深度检测/figure1.png","hash":"1e135db59da481a49accdc278d49bf1b767f0213","modified":1569126141483},{"_id":"public/2019/08/27/光栅化渲染-4-深度检测/simplify.png","hash":"c823a43fd2492e2817a75cd2f7a2e5eb68cf9a29","modified":1569126141483},{"_id":"public/2019/08/27/光栅化渲染-4-深度检测/figure2.png","hash":"55a78a8a6e5ff37e3af5f3dfdf2f920dec96584c","modified":1569126141483},{"_id":"public/2019/04/17/Kalman-filter-卡尔曼滤波器/Rudolf_Kalman.jpg","hash":"d9fc75dcf49e0051bfdcc7756e2b63ddfe7b8260","modified":1569126141483},{"_id":"public/2019/04/17/Kalman-filter-卡尔曼滤波器/afterFilter.png","hash":"bf96d602e8c3f2030946ea7c0ce66c3b712f6374","modified":1569126141483},{"_id":"public/2019/04/17/Kalman-filter-卡尔曼滤波器/g1.jpg","hash":"37434d3f18bd047d74a955400bff7e0405cfa8b9","modified":1569126141483},{"_id":"public/2019/04/17/Kalman-filter-卡尔曼滤波器/g2.jpg","hash":"7e24f2f2110a8d055e59fd2504c97aa40150515a","modified":1569126141483},{"_id":"public/2019/04/17/Kalman-filter-卡尔曼滤波器/g3.jpg","hash":"addfbb4a223035d1ff4c146db85266d1c2b25adb","modified":1569126141483},{"_id":"public/2019/04/17/Kalman-filter-卡尔曼滤波器/origin.png","hash":"9c830d9b7f7d255ba74fe3900ac0e5b271c9f211","modified":1569126141483},{"_id":"public/2019/08/15/光栅化渲染-3-光栅化/figure1.png","hash":"b290b99658bc7c84af7720c3ba79fdd4aef05454","modified":1569126141483},{"_id":"public/2019/08/15/光栅化渲染-3-光栅化/figure2.png","hash":"a8fe68eafaf8652d2124c42c5de5ec5b6ec99904","modified":1569126141483},{"_id":"public/2019/08/15/光栅化渲染-3-光栅化/figure3.gif","hash":"b0a9b36f91e92ca2a42b8336352976420793cf5d","modified":1569126141483},{"_id":"public/2019/04/17/Kalman-filter-卡尔曼滤波器/gauss.jpg","hash":"1857b243d0f0dc7cdc0e7640783f02faa9e3710f","modified":1569126141483},{"_id":"public/2019/08/15/光栅化渲染-3-光栅化/figure4.png","hash":"bff74759418d9700c5efda10e288c4bc9788d604","modified":1569126141483},{"_id":"public/2019/08/15/光栅化渲染-3-光栅化/figure5.png","hash":"416f024d8f45031d1f8c8eaea530173c29f3f88b","modified":1569126141483},{"_id":"public/2019/08/15/光栅化渲染-3-光栅化/figure6.png","hash":"279d015a4c7800ef29633a3413aa94d1c24f605d","modified":1569126141483},{"_id":"public/2019/08/15/光栅化渲染-3-光栅化/figure7.png","hash":"a356d3e49e4627eadc7ff1cdb7d6393431c1c7fc","modified":1569126141483},{"_id":"public/2019/08/15/光栅化渲染-3-光栅化/rasterization.png","hash":"cb9323db41b2889a3ca9609100eff4202ee77b9a","modified":1569126141483},{"_id":"public/2019/08/15/光栅化渲染-3-光栅化/result.png","hash":"b564c4c7db1f03b08ee9a8c0f53f72506f285886","modified":1569126141483},{"_id":"public/2019/04/17/Kalman-filter-卡尔曼滤波器/g4.jpg","hash":"2003c2200792d6795a15d1aaef0fd7bf4e0b89da","modified":1569126141483},{"_id":"public/2019/04/17/Kalman-filter-卡尔曼滤波器/g5.jpg","hash":"44ba09420e7fbfc1dc583c071f0f248d91c16b8e","modified":1569126141483},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1569126141490},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1569126141490},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1569126141490},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1569126141490},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1569126141490},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1569126141490},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1569126141490},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1569126141490},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1569126141490},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1569126141490},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1569126141490},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1569126141490},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1569126141490},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1569126141490},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1569126141490},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1569126141490},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1569126141491},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1569126141491},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1569126141491},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1569126141491},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1569126141491},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1569126141491},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1569126141491},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1569126141491},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1569126141491},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1569126141491},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1569126141491},{"_id":"public/lib/fastclick/README.html","hash":"e25da2e29e6947b704b43611b325e8ad65134e42","modified":1569126141491},{"_id":"public/lib/jquery_lazyload/README.html","hash":"14c63ba441fb49b26032e72e9cb67c67c8df19f1","modified":1569126141491},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"81057e5b518b8ab60474e1ad027e868b558f15b7","modified":1569126141491},{"_id":"public/css/main.css","hash":"0c6d51b1fbb59507fcf84fcca562ca33177ff00b","modified":1569126141491},{"_id":"public/images/avatar.jpg","hash":"a2940e550cbd26df2e3561074910cc38f54edd15","modified":1569126141491},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1569126141491},{"_id":"public/2019/09/22/光栅化渲染-8-正交投影矩阵/projectionsexample.png","hash":"48166b3bed17e8a7138eb9718db8eb198e1c033c","modified":1569126141491},{"_id":"public/2019/01/13/Uva1343-The-Rotation-Game/game.png","hash":"aaa5af49a4c3ecab97010f616c8cced728f60c1f","modified":1569126141491},{"_id":"public/2018/11/04/欧拉回路/Elur.png","hash":"ddc21e3cbc1ffa51606a7a521fad01c798d6ad47","modified":1569126141491},{"_id":"public/2018/12/20/八皇后问题/diagonal.png","hash":"4963cc964d96d85438ef74780aafd357f2c198f4","modified":1569126141491},{"_id":"public/2018/06/10/My-little-angel/qxy1.jpg","hash":"29c0b85aa8bd9e32c8b239b78ae5f571e8375bd9","modified":1569126141491},{"_id":"public/2018/10/28/Uva1103-Ancient-Messages/hier.png","hash":"9fc1f550a328d3a0f44bec5cd4655935db1fe9d0","modified":1569126141491},{"_id":"public/2018/04/13/vultr/p4.png","hash":"2ee46cf520c7d0585db4245c9586829f5173e680","modified":1569126141491},{"_id":"public/2018/04/13/vultr/p6.png","hash":"47f4048062363375bb49809ceb19a67b5c659bf3","modified":1569126141491},{"_id":"public/2018/04/13/vultr/p9.png","hash":"7a099d33cc7ac17bc5e233121d135e46af0549b5","modified":1569126141491},{"_id":"public/2019/09/20/光栅化渲染-6-透视投影矩阵/figure1.png","hash":"6dd6f1c04d661b7665eac613aac347366a694da5","modified":1569126141491},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1569126141498},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1569126141498},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1569126141498},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1569126141498},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1569126141498},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1569126141498},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1569126141498},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1569126141498},{"_id":"public/images/avatar2.png","hash":"5a825078a61886e5bf8f40244b0c0d3acef801ee","modified":1569126141498},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1569126141498},{"_id":"public/2019/08/11/光栅化渲染-2-透视投影/perspective.png","hash":"dd94afdc53034d3284cacc982d9124c2f596475a","modified":1569126141498},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1569126141502},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1569126141502},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1569126141502},{"_id":"public/2019/09/21/光栅化渲染-7-渲染管线/figure1.png","hash":"938e056da84f53ea11716159c9d62b93e9ca11bc","modified":1569126141502},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1569126141503},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1569126141503},{"_id":"public/2018/12/25/哈希表/hash.png","hash":"29a902ee92685689f3c4b52320ed65dab3c442e1","modified":1569126141503},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1569126141503},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1569126141503},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1569126141503},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1569126141503},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1569126141503},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1569126141503},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1569126141503},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1569126141512},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1569126141513},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1569126141525},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1569126141525},{"_id":"public/2018/10/24/Linear algebra-Dot product/1.gif","hash":"a037ce119aca35cd7188ef70334ba9b06dc81d31","modified":1569126141586},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1569126141692},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1569126141692},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1569126141722},{"_id":"public/2018/10/24/Linear algebra-Dot product/3.gif","hash":"fc991a2c97761dcc611775a0ed1bd3bcf31c6435","modified":1569126141886},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1569126141888},{"_id":"public/2018/10/24/Linear algebra-Dot product/2.gif","hash":"bb118b39f653f5c4b63c9947450608f8049641d4","modified":1569126141888},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1569126141892},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1569126141894}],"Category":[{"name":"ACM","_id":"ck0uh6nof002ih8vn13n83wir"},{"name":"Math","_id":"ck0uh6nos002oh8vnd8mr03qi"},{"name":"C++","_id":"ck0uh6nou002sh8vnhjiddn8h"},{"name":"Summary","_id":"ck0uh6nou002uh8vnmlbfam9j"},{"name":"Diary","_id":"ck0uh6now002yh8vnvgp9nn5u"},{"name":"Messy article","_id":"ck0uh6np6003rh8vn8xk4kpfm"},{"name":"Template","_id":"ck0uh6npl0059h8vnr9kuggoe"},{"name":"Google Kick Start","_id":"ck0uh6npr005rh8vnfn6dzun2"},{"name":"Computer Graphics","_id":"ck0uh6npt0060h8vnsizr3zwp"},{"name":"贪心","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nrv007ih8vng07nunsl"},{"name":"思维","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nrz007sh8vn3p7yj7qs"},{"name":"前缀和","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6ns10083h8vnka6jk5xt"},{"name":"DFS","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6ns20088h8vn9kfaicgp"},{"name":"动态规划","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6ns3008ih8vnlpzo025k"},{"name":"背包","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6ns5008uh8vnseja906x"},{"name":"线段树","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6ns6008zh8vn9o0cpycg"},{"name":"欧拉路","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6ns70099h8vnv9p6u7ps"},{"name":"树","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6ns7009eh8vnbbpbcq9k"},{"name":"拓扑排序","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6ns8009lh8vnmdcrxec1"},{"name":"暴力枚举","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsa00a0h8vnuo60rt8q"},{"name":"IDA*","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsb00a9h8vnvyhljy18"},{"name":"map","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsc00afh8vnrafzkr73"},{"name":"链表","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsd00aph8vnbc01cfu7"},{"name":"BFS","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nse00avh8vnri0v22mz"},{"name":"离散化","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsf00b1h8vnomg6z4is"},{"name":"栈","parent":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsf00b4h8vnbaj1g61v"},{"name":"光栅化渲染","parent":"ck0uh6npt0060h8vnsizr3zwp","_id":"ck0uh6nsk00bwh8vnfaw8vhw7"}],"Data":[],"Page":[{"title":"about","date":"2018-04-08T08:12:48.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-04-08 16:12:48\ntype: \"about\"\n---\n","updated":"2021-04-21T03:30:14.800Z","path":"about/index.html","_id":"ck0uh6nkx0000h8vngmhlorft","comments":1,"layout":"page"},{"title":"commonweal","date":"2018-04-08T09:18:33.000Z","type":"commonweal","_content":"","source":"commonweal/index.md","raw":"---\ntitle: commonweal\ndate: 2018-04-08 17:18:33\ntype: \"commonweal\"\n---\n","updated":"2021-04-21T03:30:14.800Z","path":"commonweal/index.html","_id":"ck0uh6nl20002h8vn3tnl94jh","comments":1,"layout":"page"},{"title":"categories","date":"2018-04-08T08:14:39.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-04-08 16:14:39\ntype: \"categories\"\n---\n","updated":"2021-04-21T03:30:14.800Z","path":"categories/index.html","_id":"ck0uh6nl40004h8vna6cw4gry","comments":1,"layout":"page"},{"title":"schedule","date":"2018-04-08T09:15:03.000Z","type":"schedule","_content":"","source":"schedule/index.md","raw":"---\ntitle: schedule\ndate: 2018-04-08 17:15:03\ntype: \"schedule\"\n---\n","updated":"2021-04-21T03:30:14.800Z","path":"schedule/index.html","_id":"ck0uh6nl50006h8vnqckkgi80","comments":1,"layout":"page"},{"title":"Friends","date":"2018-10-13T02:47:36.000Z","_content":"| Links    | Notes    |\n| :------: | :------: |\n| [Bowen's Blog](http://www.bowen-blog.com/) | 徐阿卞大佬 |\n","source":"links/index.md","raw":"---\ntitle: Friends\ndate: 2018-10-13 10:47:36\n---\n| Links    | Notes    |\n| :------: | :------: |\n| [Bowen's Blog](http://www.bowen-blog.com/) | 徐阿卞大佬 |\n","updated":"2021-04-21T03:30:14.800Z","path":"links/index.html","_id":"ck0uh6nl60008h8vneyt27z1n","comments":1,"layout":"page"},{"title":"sitemap","date":"2018-04-08T09:18:19.000Z","type":"sitemap","_content":"","source":"sitemap/index.md","raw":"---\ntitle: sitemap\ndate: 2018-04-08 17:18:19\ntype: \"sitemap\"\n---\n","updated":"2021-04-21T03:30:14.800Z","path":"sitemap/index.html","_id":"ck0uh6nl7000ah8vnaix4a9e1","comments":1,"layout":"page"},{"title":"tags","date":"2018-04-07T17:23:59.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-04-08 01:23:59\ntype: \"tags\"\n---\n","updated":"2021-04-21T03:30:14.800Z","path":"tags/index.html","_id":"ck0uh6nl8000ch8vn9gzgzc9a","comments":1,"layout":"page"}],"Post":[{"title":"CodeForces-469D-Two Sets","date":"2019-07-27T10:46:03.000Z","_content":"CodeForces-469D-Two Sets 贪心求解\n<!--more-->\n# 题目链接\n[CodeForces-496D-Two Sets](http://codeforces.com/problemset/problem/469/D)\n\n# 题意\n有 $n$ 个不同的整数，要把它们分到 $A$ 和 $B$ 两个集合中。要求满足以下两个条件：\n- 如果 $x$ 属于集合 $A$，那么 $a-x$ 也必须属于集合$A$。\n- 如果 $x$ 属于集合 $B$，那么 $b-x$ 也必须属于集合$B$。\n\n# 题解\n贪心法。首先对这 $n$ 个不同的整数进行排序，顺序进行判断，假设 $b > a$，那么对于 $x$ 来说，先判断 $b-x$ 是否存在，之后再判断 $a-x$ 是否存在。因为 $b > a$，所以 $b-x>a-x$，应该优先将较大的一方也就是 $b-x$　与 $x$ 配对，因为由于序列递增若先将 $a-x$ 与 $x$，配对，那么 $b-x$ 此后将没有机会再次配对。\n查找 $b-x$ 和 $a-x$ 时使用二分搜索，这也是将数列进行排序的意义。\n\n# 代码\n```C++\n#include <iostream>\n#include <map>\n#include <algorithm>\n\n#include <cstdio>\n#include <cstring>\n\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nint n, a, b;\nint d[maxn];\nint dd[maxn];\nbool res[maxn];\nmap<int, bool> mp;\nbool flag = 0;\nbool vis[maxn];\n\nint bSearch(int x, int y, int v){\n    int m;\n    while(x < y){\n        m = x + (y - x) / 2;\n        if(dd[m] == v) return m;\n        else if(dd[m] > v) y = m;\n        else x = m + 1;\n    }\n    return -1;\n}\n\nint main(){\n    //freopen(\"in.txt\", \"r\", stdin);\n    cin >> n >> a >> b;\n    for(int i = 0; i < n; i++){\n        cin >> d[i];\n    }\n    memset(vis, 0, sizeof(vis));\n    memcpy(dd, d, sizeof(dd));\n    sort(dd, dd + n);\n\n    if(a > b){\n        swap(a, b);\n        flag = 1;\n    }\n\n    for(int i = 0; i < n; i++){\n        if((b - dd[i] >= 0) && !vis[i]){\n            int index = bSearch(0, n, b - dd[i]);\n            if(index >= 0 && !vis[index]){\n                mp[dd[i]] = 1;\n                mp[b - dd[i]] = 1;\n                vis[i] = 1;\n                vis[index] = 1;\n            }\n        }\n        if((a - dd[i] >= 0) && !vis[i]){\n            int index = bSearch(0, n, a - dd[i]);\n            if(index >= 0 && !vis[index]){\n                mp[dd[i]] = 0;\n                mp[a - dd[i]] = 0;\n                vis[i] = 1;\n                vis[index] = 1;\n            }\n        }\n\n        if(!vis[i]){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n\n    for(int i = 0; i < n; i++){\n        if(flag) res[i] = !mp[d[i]];\n        else res[i] = mp[d[i]];\n    }\n\n    cout << \"YES\" << endl;\n    for(int i = 0; i < n; i++){\n        if(i == 0) cout << res[i];\n        else cout << \" \" << res[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n```\n\n# 参考链接\n[Two Sets My greedy solution~~](http://codeforces.com/blog/entry/13880)","source":"_posts/CodeForces-469D-Two-Sets.md","raw":"---\ntitle: CodeForces-469D-Two Sets\ndate: 2019-07-27 18:46:03\ncategories:\n- ACM\n- 贪心\ntags:\n- 思维\n- 贪心\n---\nCodeForces-469D-Two Sets 贪心求解\n<!--more-->\n# 题目链接\n[CodeForces-496D-Two Sets](http://codeforces.com/problemset/problem/469/D)\n\n# 题意\n有 $n$ 个不同的整数，要把它们分到 $A$ 和 $B$ 两个集合中。要求满足以下两个条件：\n- 如果 $x$ 属于集合 $A$，那么 $a-x$ 也必须属于集合$A$。\n- 如果 $x$ 属于集合 $B$，那么 $b-x$ 也必须属于集合$B$。\n\n# 题解\n贪心法。首先对这 $n$ 个不同的整数进行排序，顺序进行判断，假设 $b > a$，那么对于 $x$ 来说，先判断 $b-x$ 是否存在，之后再判断 $a-x$ 是否存在。因为 $b > a$，所以 $b-x>a-x$，应该优先将较大的一方也就是 $b-x$　与 $x$ 配对，因为由于序列递增若先将 $a-x$ 与 $x$，配对，那么 $b-x$ 此后将没有机会再次配对。\n查找 $b-x$ 和 $a-x$ 时使用二分搜索，这也是将数列进行排序的意义。\n\n# 代码\n```C++\n#include <iostream>\n#include <map>\n#include <algorithm>\n\n#include <cstdio>\n#include <cstring>\n\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nint n, a, b;\nint d[maxn];\nint dd[maxn];\nbool res[maxn];\nmap<int, bool> mp;\nbool flag = 0;\nbool vis[maxn];\n\nint bSearch(int x, int y, int v){\n    int m;\n    while(x < y){\n        m = x + (y - x) / 2;\n        if(dd[m] == v) return m;\n        else if(dd[m] > v) y = m;\n        else x = m + 1;\n    }\n    return -1;\n}\n\nint main(){\n    //freopen(\"in.txt\", \"r\", stdin);\n    cin >> n >> a >> b;\n    for(int i = 0; i < n; i++){\n        cin >> d[i];\n    }\n    memset(vis, 0, sizeof(vis));\n    memcpy(dd, d, sizeof(dd));\n    sort(dd, dd + n);\n\n    if(a > b){\n        swap(a, b);\n        flag = 1;\n    }\n\n    for(int i = 0; i < n; i++){\n        if((b - dd[i] >= 0) && !vis[i]){\n            int index = bSearch(0, n, b - dd[i]);\n            if(index >= 0 && !vis[index]){\n                mp[dd[i]] = 1;\n                mp[b - dd[i]] = 1;\n                vis[i] = 1;\n                vis[index] = 1;\n            }\n        }\n        if((a - dd[i] >= 0) && !vis[i]){\n            int index = bSearch(0, n, a - dd[i]);\n            if(index >= 0 && !vis[index]){\n                mp[dd[i]] = 0;\n                mp[a - dd[i]] = 0;\n                vis[i] = 1;\n                vis[index] = 1;\n            }\n        }\n\n        if(!vis[i]){\n            cout << \"NO\" << endl;\n            return 0;\n        }\n    }\n\n    for(int i = 0; i < n; i++){\n        if(flag) res[i] = !mp[d[i]];\n        else res[i] = mp[d[i]];\n    }\n\n    cout << \"YES\" << endl;\n    for(int i = 0; i < n; i++){\n        if(i == 0) cout << res[i];\n        else cout << \" \" << res[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n```\n\n# 参考链接\n[Two Sets My greedy solution~~](http://codeforces.com/blog/entry/13880)","slug":"CodeForces-469D-Two-Sets","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nky0001h8vnc9jr32e3","comments":1,"layout":"post","photos":[],"link":""},{"title":"CodeForces-569A-Music","date":"2018-08-28T07:15:59.000Z","_content":"也是一道思维题，理解了题意就很简单，但是自己理解题意费了好长时间，，还好最后AC了，背景故事蛮有意思的2333.\n<!--more-->\n# 链接\n[CodeForces-569A-Music](http://codeforces.com/problemset/problem/569/A)\n## 题意\n下载一首时长为$T$的歌，首先下载$S$秒，然后边下载边播放，播放到还未下载的位置就立即返回歌的开头重新播放，求需要返回几次才能最终完整听完这首歌。歌的下载速率为每经过$q$秒下载$q - 1$秒的歌。\n# 题解\n一开始没有理解歌的下载速率的问题，是每经过$q$秒直接得到$q - 1$秒的歌，还是在$q$秒内一直在下载，最后累计得到$q-1$秒的歌，看了样例后发现是第二种，（好像也第二种也更符合实际）。平均每秒的下载速率是$(q-1)/q$，这不是一个整数，甚至很可能是无理数，那结果很可能就不精确了，尤其是最后刚好下载完也刚刚听完的那种情况，会多算或者少算一次，所以不能求出平均下载速率然后来模拟计算。\n然后想到了一种思路，因为听的速率是大于下载的速率的，所以考虑最开始下载的$S$秒，求出这$S$秒被消耗完的时间$t$，$$t = \\frac{S}{1 - \\frac{q - 1}{q}}$$化简得$$t = S * q$$同时$t$也表示在这一时刻，听歌的进度正好赶上了下载的速度，此时判断$t$是否大于等于$T$，若大于等于则表示歌已下载完成，否则需返回歌的开头重新播放（此时的$S$更新为$t$，因为已下载的进度现在是$t$）。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 27 Aug 13:48:09 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long T, S, q;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    cin >> T >> S >> q;\n    while(1){\n        if(S * q >= T) break;\n        else{\n            S = S * q;\n            cnt++;\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}\n```","source":"_posts/CodeForces-569A.md","raw":"---\ntitle: 'CodeForces-569A-Music'\ndate: 2018-08-28 15:15:59\ncategories:\n- ACM\n- 思维\ntags:\n- 思维\n---\n也是一道思维题，理解了题意就很简单，但是自己理解题意费了好长时间，，还好最后AC了，背景故事蛮有意思的2333.\n<!--more-->\n# 链接\n[CodeForces-569A-Music](http://codeforces.com/problemset/problem/569/A)\n## 题意\n下载一首时长为$T$的歌，首先下载$S$秒，然后边下载边播放，播放到还未下载的位置就立即返回歌的开头重新播放，求需要返回几次才能最终完整听完这首歌。歌的下载速率为每经过$q$秒下载$q - 1$秒的歌。\n# 题解\n一开始没有理解歌的下载速率的问题，是每经过$q$秒直接得到$q - 1$秒的歌，还是在$q$秒内一直在下载，最后累计得到$q-1$秒的歌，看了样例后发现是第二种，（好像也第二种也更符合实际）。平均每秒的下载速率是$(q-1)/q$，这不是一个整数，甚至很可能是无理数，那结果很可能就不精确了，尤其是最后刚好下载完也刚刚听完的那种情况，会多算或者少算一次，所以不能求出平均下载速率然后来模拟计算。\n然后想到了一种思路，因为听的速率是大于下载的速率的，所以考虑最开始下载的$S$秒，求出这$S$秒被消耗完的时间$t$，$$t = \\frac{S}{1 - \\frac{q - 1}{q}}$$化简得$$t = S * q$$同时$t$也表示在这一时刻，听歌的进度正好赶上了下载的速度，此时判断$t$是否大于等于$T$，若大于等于则表示歌已下载完成，否则需返回歌的开头重新播放（此时的$S$更新为$t$，因为已下载的进度现在是$t$）。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 27 Aug 13:48:09 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long T, S, q;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    cin >> T >> S >> q;\n    while(1){\n        if(S * q >= T) break;\n        else{\n            S = S * q;\n            cnt++;\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}\n```","slug":"CodeForces-569A","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nl30003h8vn4us8x1om","comments":1,"layout":"post","photos":[],"link":""},{"title":"CodeForces-478C-Table Decorations","date":"2018-08-28T06:21:27.000Z","_content":"水题，然而自己WA了orz，看到了一种很有意思的解法。\n[参考连接](http://codeforces.com/blog/entry/18619)\n<!--more-->\n# 链接\n[CodeForces-478C-Table Decorations](http://codeforces.com/problemset/problem/478/C)\n# 题目描述\n给定红黄蓝三种气球的数量，要求每个桌子上放三个气球，且三个气球的颜色不能完全相同，求这些气球最多可以装饰几张桌子。\n# 题解\n假定三种气球的数量分别为``a[0]，a[1]，a[2]``，且已按大小排好序，``a[0] <= a[1] <= a[2]``。\n有两种情况:\n+ ``2 * (a[0] + a[1]) <=  a[2]``。这种情况下可以每取一个``a[0]``取两个``a[2]``组成三气球或者每取一个``a[1]``取两个``a[2]``组成三气球，即取球集合为``(1，0，2)``和``(0，1，2)``。答案为``a[0] + a[1]``。\n+ ``2*(a[0] + a[1]) > a[2]``。这种情况下我们从``a[2]``中取两个气球同时从``max(a[0]，a[1])``中取一个气球，直到``a[2] <= max(a[0]，a[1])``。这时满足``max(a[0]，a[1]) - a[2] <= 1``和``max(a[0]，a[1]) - min(a[0]，a[1]) <= 1``。接下来的按集合``(1，1，1)``继续取球。**可以发现这种取法最后剩余球的数量一定是** ``(a[0]+a[1]+a[2]) mod 3``，**除去剩余的这些球(数量小于3)，其它球每三个装饰一张桌子，所以针对这种情况我们直接可以用** ``(a[0]+a[1]+a[2]) div 3`` **来得到最终结果。**\n\n真是神解orz。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 28 Aug 14:12:13 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long d[5];\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    for(int i = 0; i < 3; i++)\n        cin >> d[i];\n    sort(d, d + 3);\n    long long ans;\n    if(2 * (d[0] + d[1]) <= d[2])\n        ans = d[0] + d[1];\n    else \n        ans = (d[0] + d[1] + d[2]) / 3;\n    cout << ans << endl;\n    \n    return 0;\n}\n```\n","source":"_posts/CodeForces-478C.md","raw":"---\ntitle: CodeForces-478C-Table Decorations\ndate: 2018-08-28 14:21:27\ncategories:\n- ACM\n- 思维\ntags:\n- 思维\n---\n水题，然而自己WA了orz，看到了一种很有意思的解法。\n[参考连接](http://codeforces.com/blog/entry/18619)\n<!--more-->\n# 链接\n[CodeForces-478C-Table Decorations](http://codeforces.com/problemset/problem/478/C)\n# 题目描述\n给定红黄蓝三种气球的数量，要求每个桌子上放三个气球，且三个气球的颜色不能完全相同，求这些气球最多可以装饰几张桌子。\n# 题解\n假定三种气球的数量分别为``a[0]，a[1]，a[2]``，且已按大小排好序，``a[0] <= a[1] <= a[2]``。\n有两种情况:\n+ ``2 * (a[0] + a[1]) <=  a[2]``。这种情况下可以每取一个``a[0]``取两个``a[2]``组成三气球或者每取一个``a[1]``取两个``a[2]``组成三气球，即取球集合为``(1，0，2)``和``(0，1，2)``。答案为``a[0] + a[1]``。\n+ ``2*(a[0] + a[1]) > a[2]``。这种情况下我们从``a[2]``中取两个气球同时从``max(a[0]，a[1])``中取一个气球，直到``a[2] <= max(a[0]，a[1])``。这时满足``max(a[0]，a[1]) - a[2] <= 1``和``max(a[0]，a[1]) - min(a[0]，a[1]) <= 1``。接下来的按集合``(1，1，1)``继续取球。**可以发现这种取法最后剩余球的数量一定是** ``(a[0]+a[1]+a[2]) mod 3``，**除去剩余的这些球(数量小于3)，其它球每三个装饰一张桌子，所以针对这种情况我们直接可以用** ``(a[0]+a[1]+a[2]) div 3`` **来得到最终结果。**\n\n真是神解orz。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 28 Aug 14:12:13 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long d[5];\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    for(int i = 0; i < 3; i++)\n        cin >> d[i];\n    sort(d, d + 3);\n    long long ans;\n    if(2 * (d[0] + d[1]) <= d[2])\n        ans = d[0] + d[1];\n    else \n        ans = (d[0] + d[1] + d[2]) / 3;\n    cout << ans << endl;\n    \n    return 0;\n}\n```\n","slug":"CodeForces-478C","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nl40005h8vnzpt4u3wv","comments":1,"layout":"post","photos":[],"link":""},{"title":"Covariance-协方差","date":"2019-03-27T02:26:57.000Z","_content":"*填坑数学系列*\n总结协方差的意义，它可以表示物体间的什么属性，它和相关系数之间的关系，以及协方差矩阵的作用。\n<!--more-->\n\n# 概念\n协方差用在概率论和统计学中于衡量两个变量的总体误差([Wikiwand](https://www.wikiwand.com/zh-hans/%E5%8D%8F%E6%96%B9%E5%B7%AE))。\n简单来说协方差用来描述两个随机变量之间具有什么样的关系。\n\n# 数学定义\n和方差的数学定义类似：$$Var(X)=\\frac{\\sum_{i=1}^n(x_i-\\overline{x})(x_i-\\overline{x})}{n-1}$$\n协方差的数学定义：$$Cov(X,Y)=\\frac{\\sum_{i=1}^n(x_i-\\overline{x})(y_i-\\overline{y})}{n-1}$$\n通过向量表示为：$$Cov(X,Y)=\\frac{\\vec{x}\\cdot\\vec{y}}{n-1}$$\n\n可以发现协方差看起来很像**点积**。\n\n*除以n-1表示无偏估计,一般我们可以直接除以样本数量n(有偏估计)*\n\n# 相关系数\n协方差可以理解为通过**点积**来计算关系。举一个实际应用的例子。\n假设有A，B，C，D，E，F六本书，甲、乙两个人对它们的评分(满分5分)如下：\n\n```\n　    A  B  C  D  E  F\n甲    4  3  3  0  5  3\n乙    4  2  4  0  4  4\n```\n\n甲的信息可以用向量$\\vec{x} = (4,3,3,0,5,3)^T$来表示。\n乙的信息可以用向量$\\vec{y} = (4,2,4,0,4,4)^T$来表示。\n甲和乙的协方差经过计算可得(有偏计算)：$$Cov(X,Y)=2.4$$\n这个值可以表示甲、乙之间的关系，但是由于点积结果受到向量长度的影响，所以我们最好把**协方差进行归一化**，具体的做法是将得到的协方差(未除以样本总数n均值化之前)除以变量各自的标准差。\n$$r=\\frac{\\sum_{i=1}^n(x_i-\\overline{x})(y_i-\\overline{y})}{\\sqrt{\\sum_{i=1}^n(x_i-\\overline{x})^2}\\sqrt{\\sum_{i=1}^n(y_i-\\overline{y})^2}}$$\n这被称作两个变量样本的**相关系数**，其实就是两向量夹角的**余弦**：$$\\cos\\theta=\\frac{\\vec{x}\\cdot\\vec{y}}{\\|\\|\\vec{x}\\|\\|\\|\\|\\vec{y}\\|\\|}$$\n上面的例子通过计算相关系数得到：$$r=\\cos\\theta\\approx0.86$$\n余弦范围为[-1，1]，所以结果表明两者之间应该挺有正向关系的，可以考虑把甲喜欢的书推荐给乙。\n\n# 协方差矩阵\n协方差反映的是两个变量之间的相关性，协方差矩阵反映的是所有变量两两之间的关系。具体来说，包含两个特征变量的矩阵：\n\n$$\nZ=\n \\begin{bmatrix}\n   1 & 2 \\\\\\\\\n   3 & 6 \\\\\\\\\n   4 & 5 \\\\\\\\\n   5 & 2 \\\\\\\\\n  \\end{bmatrix}\n$$\n\n其中两个特征X，Y分别为：\n\n$$\nX=\n \\begin{bmatrix}\n   1 \\\\\\\\\n   3 \\\\\\\\\n   4 \\\\\\\\\n   5 \\\\\\\\\n  \\end{bmatrix}\n，\nY=\n \\begin{bmatrix}\n   2 \\\\\\\\\n   6 \\\\\\\\\n   2 \\\\\\\\\n   2 \\\\\\\\\n  \\end{bmatrix}\n$$\n\n此时协方差矩阵为：\n\n$$\nCov(Z)=\n \\begin{bmatrix}\n   Cov(X,X) & Cov(X,Y) \\\\\\\\\n   Cov(Y,X) & Cov(Y,Y) \\\\\\\\\n \\end{bmatrix}\n$$\n\n*注：自己和自己的协方差等于自己的方差*\n\n# 协方差矩阵的作用\n协方差矩阵经常被用来计算特征之间的某种联系，机器学习中的用于降维的主成分分析(PCA)就用到了协方差矩阵。\n\n# 参考\n\n[如何通俗易懂地解释协方差和相关系数的概念](https://www.zhihu.com/question/20852004/answer/287792087)\n[协方差矩阵-Jermmy's Lazy Blog](http://jermmy.xyz/2017/03/19/2017-3-19-covariance-matrix/)","source":"_posts/Covariance-协方差.md","raw":"---\ntitle: Covariance-协方差\ndate: 2019-03-27 10:26:57\ncategories:\n- Math\ntags:\n- Covariance\n---\n*填坑数学系列*\n总结协方差的意义，它可以表示物体间的什么属性，它和相关系数之间的关系，以及协方差矩阵的作用。\n<!--more-->\n\n# 概念\n协方差用在概率论和统计学中于衡量两个变量的总体误差([Wikiwand](https://www.wikiwand.com/zh-hans/%E5%8D%8F%E6%96%B9%E5%B7%AE))。\n简单来说协方差用来描述两个随机变量之间具有什么样的关系。\n\n# 数学定义\n和方差的数学定义类似：$$Var(X)=\\frac{\\sum_{i=1}^n(x_i-\\overline{x})(x_i-\\overline{x})}{n-1}$$\n协方差的数学定义：$$Cov(X,Y)=\\frac{\\sum_{i=1}^n(x_i-\\overline{x})(y_i-\\overline{y})}{n-1}$$\n通过向量表示为：$$Cov(X,Y)=\\frac{\\vec{x}\\cdot\\vec{y}}{n-1}$$\n\n可以发现协方差看起来很像**点积**。\n\n*除以n-1表示无偏估计,一般我们可以直接除以样本数量n(有偏估计)*\n\n# 相关系数\n协方差可以理解为通过**点积**来计算关系。举一个实际应用的例子。\n假设有A，B，C，D，E，F六本书，甲、乙两个人对它们的评分(满分5分)如下：\n\n```\n　    A  B  C  D  E  F\n甲    4  3  3  0  5  3\n乙    4  2  4  0  4  4\n```\n\n甲的信息可以用向量$\\vec{x} = (4,3,3,0,5,3)^T$来表示。\n乙的信息可以用向量$\\vec{y} = (4,2,4,0,4,4)^T$来表示。\n甲和乙的协方差经过计算可得(有偏计算)：$$Cov(X,Y)=2.4$$\n这个值可以表示甲、乙之间的关系，但是由于点积结果受到向量长度的影响，所以我们最好把**协方差进行归一化**，具体的做法是将得到的协方差(未除以样本总数n均值化之前)除以变量各自的标准差。\n$$r=\\frac{\\sum_{i=1}^n(x_i-\\overline{x})(y_i-\\overline{y})}{\\sqrt{\\sum_{i=1}^n(x_i-\\overline{x})^2}\\sqrt{\\sum_{i=1}^n(y_i-\\overline{y})^2}}$$\n这被称作两个变量样本的**相关系数**，其实就是两向量夹角的**余弦**：$$\\cos\\theta=\\frac{\\vec{x}\\cdot\\vec{y}}{\\|\\|\\vec{x}\\|\\|\\|\\|\\vec{y}\\|\\|}$$\n上面的例子通过计算相关系数得到：$$r=\\cos\\theta\\approx0.86$$\n余弦范围为[-1，1]，所以结果表明两者之间应该挺有正向关系的，可以考虑把甲喜欢的书推荐给乙。\n\n# 协方差矩阵\n协方差反映的是两个变量之间的相关性，协方差矩阵反映的是所有变量两两之间的关系。具体来说，包含两个特征变量的矩阵：\n\n$$\nZ=\n \\begin{bmatrix}\n   1 & 2 \\\\\\\\\n   3 & 6 \\\\\\\\\n   4 & 5 \\\\\\\\\n   5 & 2 \\\\\\\\\n  \\end{bmatrix}\n$$\n\n其中两个特征X，Y分别为：\n\n$$\nX=\n \\begin{bmatrix}\n   1 \\\\\\\\\n   3 \\\\\\\\\n   4 \\\\\\\\\n   5 \\\\\\\\\n  \\end{bmatrix}\n，\nY=\n \\begin{bmatrix}\n   2 \\\\\\\\\n   6 \\\\\\\\\n   2 \\\\\\\\\n   2 \\\\\\\\\n  \\end{bmatrix}\n$$\n\n此时协方差矩阵为：\n\n$$\nCov(Z)=\n \\begin{bmatrix}\n   Cov(X,X) & Cov(X,Y) \\\\\\\\\n   Cov(Y,X) & Cov(Y,Y) \\\\\\\\\n \\end{bmatrix}\n$$\n\n*注：自己和自己的协方差等于自己的方差*\n\n# 协方差矩阵的作用\n协方差矩阵经常被用来计算特征之间的某种联系，机器学习中的用于降维的主成分分析(PCA)就用到了协方差矩阵。\n\n# 参考\n\n[如何通俗易懂地解释协方差和相关系数的概念](https://www.zhihu.com/question/20852004/answer/287792087)\n[协方差矩阵-Jermmy's Lazy Blog](http://jermmy.xyz/2017/03/19/2017-3-19-covariance-matrix/)","slug":"Covariance-协方差","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nl50007h8vnrxjrnlmg","comments":1,"layout":"post","photos":[],"link":""},{"title":"Codeforces-#498Div3-C-前&&后缀和","date":"2018-07-31T15:08:57.000Z","_content":"好题，虽然比较简单，但是觉得这道题的解题思路挺棒的，用到了前缀和，后缀和以及思路的转换．解出来之后还是很开心的，嚯嚯嚯（一个只能做做Div3的小菜鸡|･ω･｀)）\n<!-- more -->\n# 链接\n[Codeforces-#498Div3-C](http://codeforces.com/contest/1006/problem/C)\n# 题解\n题目大意：给定n个整数（范围1-1e9）,要求把这n个整数划分为连续的三段，使得第一段的数的总和与第三段的数的总和相等且要求这个总和尽量大．\n思路：\n因为n的范围是1-2e5，而且又涉及求和，所以应该可以比较自然的想到前缀和，题目又要求是前后两段的总和相等所以后缀和也要统计一下．接下来就要考虑什么时候两端的和相等且最大了，因为第一段和第三段长度不定，所以相当于是两个变量，想到它们的长度变化其实可以归一到第二段数据的长度变化，这样的话复杂度变为O(n)，就可以通过了．具体做法是对于[1, n]这n个数据，初始化第二段数据区间为[2, n - 1], 然后判断此时第一段和第三段数据和的大小关系，因为已经统计了前缀和和后缀和，所以这部分复杂度是O(1)．如果第一段数据和等于第三段数据和则记录这个数据和同时缩小第二段数据的区间，变为[3, n - 2]，继续判断，看是否还有更大的数据和满足条件；如果第一段数据和大于第三段数据和则保持第二段区间左端点不变收缩右端点，即变为[2, n - 2];同样的如果第一段数据和小于第三段数据和则保持第二段区间右端点不变，左端点收缩，即变为[3, n - 2];以此类推，直到第二段区间消失，此时最后一次记录的数据和即为结果．\n# 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint d[maxn];\nint n;\nlong long psum[maxn], bsum[maxn];\nvector<long long> vec;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", d + i);\n        if(i == 0) psum[i] = d[i];\n        else psum[i] = psum[i - 1] + d[i];\n    }\n    for(int i = n - 1; i >= 0; i--){\n        if(i == n - 1) bsum[i] = d[i];\n        else bsum[i] = bsum[i + 1] + d[i];\n    }\n\n    int i, j;\n    for(i = 0, j = n - 1; i < n;){\n        if(i >= j) break;\n        if(psum[i] == bsum[j]){\n            vec.push_back(psum[i]);\n            i++;\n            j--;\n        }\n        else if(psum[i] < bsum[j]) i++;\n        else if(psum[i] > bsum[j]) j--;\n    }\n    if(vec.size() != 0) printf(\"%lld\\n\", vec[vec.size() - 1]);\n    else printf(\"0\\n\");\n    return 0;\n}\n```","source":"_posts/Codeforces-498Div3-C.md","raw":"---\ntitle: 'Codeforces-#498Div3-C-前&&后缀和'\ndate: 2018-07-31 23:08:57\ncategories:\n- ACM\n- 前缀和\ntags:\n- 前缀和\n- 后缀和\n---\n好题，虽然比较简单，但是觉得这道题的解题思路挺棒的，用到了前缀和，后缀和以及思路的转换．解出来之后还是很开心的，嚯嚯嚯（一个只能做做Div3的小菜鸡|･ω･｀)）\n<!-- more -->\n# 链接\n[Codeforces-#498Div3-C](http://codeforces.com/contest/1006/problem/C)\n# 题解\n题目大意：给定n个整数（范围1-1e9）,要求把这n个整数划分为连续的三段，使得第一段的数的总和与第三段的数的总和相等且要求这个总和尽量大．\n思路：\n因为n的范围是1-2e5，而且又涉及求和，所以应该可以比较自然的想到前缀和，题目又要求是前后两段的总和相等所以后缀和也要统计一下．接下来就要考虑什么时候两端的和相等且最大了，因为第一段和第三段长度不定，所以相当于是两个变量，想到它们的长度变化其实可以归一到第二段数据的长度变化，这样的话复杂度变为O(n)，就可以通过了．具体做法是对于[1, n]这n个数据，初始化第二段数据区间为[2, n - 1], 然后判断此时第一段和第三段数据和的大小关系，因为已经统计了前缀和和后缀和，所以这部分复杂度是O(1)．如果第一段数据和等于第三段数据和则记录这个数据和同时缩小第二段数据的区间，变为[3, n - 2]，继续判断，看是否还有更大的数据和满足条件；如果第一段数据和大于第三段数据和则保持第二段区间左端点不变收缩右端点，即变为[2, n - 2];同样的如果第一段数据和小于第三段数据和则保持第二段区间右端点不变，左端点收缩，即变为[3, n - 2];以此类推，直到第二段区间消失，此时最后一次记录的数据和即为结果．\n# 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint d[maxn];\nint n;\nlong long psum[maxn], bsum[maxn];\nvector<long long> vec;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", d + i);\n        if(i == 0) psum[i] = d[i];\n        else psum[i] = psum[i - 1] + d[i];\n    }\n    for(int i = n - 1; i >= 0; i--){\n        if(i == n - 1) bsum[i] = d[i];\n        else bsum[i] = bsum[i + 1] + d[i];\n    }\n\n    int i, j;\n    for(i = 0, j = n - 1; i < n;){\n        if(i >= j) break;\n        if(psum[i] == bsum[j]){\n            vec.push_back(psum[i]);\n            i++;\n            j--;\n        }\n        else if(psum[i] < bsum[j]) i++;\n        else if(psum[i] > bsum[j]) j--;\n    }\n    if(vec.size() != 0) printf(\"%lld\\n\", vec[vec.size() - 1]);\n    else printf(\"0\\n\");\n    return 0;\n}\n```","slug":"Codeforces-498Div3-C","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nl70009h8vn789jza64","comments":1,"layout":"post","photos":[],"link":""},{"title":"C语言编译器工作原理以及.h和.c文件解析","date":"2018-12-02T04:41:00.000Z","_content":"　　在进行多文件编程的时候，虽然很多IDE都可以帮我们完成预处理、编译、链接等过程，但深入理解编译器的这几个过程可以避免很多\"undefined\"，\"undeclared\"以及\"redefined\"的问题。而比较好的实践方式是自己写Makefile（IDE实际上完成的就是帮我们弄清文件依赖关系，然后生成一个Makefile，调用编译器去编译链接生成可执行文件）。\n<!--more-->\n# 编译器工作原理\n1.预处理阶段：\n　　实际上是处理的是\"define\"，\"include\"等宏命令，进行宏替换。例如``#include \"xx.h\"``实际意思是把当前这一行删掉，把xx.h中的内容原封不动的插入在当前行位置。\n2.编译阶段：\n　　**以.c文件为基本单位进行**，也就是说如果项目中一个.c文件都没有，那么项目无法编译。这一阶段为所有.c文件中的变量、函数分配空间，并将各个全局变量、函数进行符号描述，编译、汇编成二进制码从而生成.o目标文件。\n　　**需要注意的是这个过程并不关心变量的具体定义和函数的具体实现，只要存在变量和函数的相关声明就可以使得编译通过。**因为只要知道了变量/函数的类型和名字，编译器就知道了该如何使用这个变量/函数。\n3.链接阶段:\n　　**以.o文件为基本单位进行**，主要的工作是重定位各个目标文件的函数、变量。这个过程主要是为上一个编译过程中变量和函数的声明找到他们具体的定义和实现。\n\n*下面是一个具体的解释例子：*\n\nadd.h文件\n```C\n#ifndef _ADD_H\n#define _ADD_H\n\nint add(int a, int b);\n\n#endif\n```\n\nadd.c文件\n```C\n#include \"add.h\"\n\nint add(int a, int b){\n    return a + b;\n}\n```\n\nmain.c文件\n```C\n#include <stdio.h>\n#include \"add.h\"\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n\n1.预处理阶段：\n　　编译器会把main.c和add.c中的``#include \"add.h\"``替换成add.h中的全部内容。\n2.编译阶段：\n　　为main.c和add.c中的各变量和函数分配内存空间并汇编成目标文件。可以发现在main.c中并没有关于add函数的实现只有由``#include \"add.h\"``替换成的这个函数的声明，但这并不影响编译过程的进行。\n3.链接阶段：\n　　经过编译后生成了main.o和add.o文件。因为main.o中用到了add函数但没有它的具体实现，所以编译器会去其它.o文件中寻找该函数的具体实现。在这个例子中add.o提供了add函数的具体实现，链接过程顺利进行，生成可执行文件。\n\n**Ps.关于add.h中#ifndef、#define和#endif的解释：**它们的作用是防止头文件在一个.c文件中被重复包含。\n\n*一个具体的例子：*\n\na.h文件\n```C\nstruct Node{\n    int a;\n    int b;\n};\n```\n\nb.h文件\n```C\n#include \"a.h\"\n```\n\nc.h文件\n```C\n#include \"a.h\"\n```\n\nmain.c文件\n```C\n#include <stdio.h>\n#include \"b.h\"\n#include \"c.h\"\n\nint main(){\n    print(\"hello\\n\");\n    return 0;\n}\n```\n　　a.h中有结构体struct Node的定义，b.h和c.h都包含了a.h，main.c中又包含了b.h和c.h这两个头文件。这会导致a.h中的内容被两次复制到main.c中，产生struct Node的重复重复定义错误，而如果a.h遵循下面的格式：\n```C\n#ifndef _A_H\n#define _A_H\n\nstruct Node{\n    int a;\n    int b;\n};\n\n#endif\n```\n　　那么a.h在main.c中只会被替换一次，这样就避免了头文件的重复包含。\n\n# .h和.c文件解析\n　　**一般情况下我们在.h文件中进行变量、函数和宏的声明，在.c文件中进行变量和函数的具体实现。**\n　　但这只是我们默认的一种规范的做法，实际上我们舍弃.h文件，在.c文件中包含变量、函数的声明以及实现也没有问题，但如果在其它.c文件中用#include去包含这个.c文件就会出现问题。\n\n*具体例子：*\n\nadd.c文件\n```C\nint add(int a, int b);\n\nint add(int a, int b){\n    return a + b;\n}\n```\n\nmain.c文件\n```C\n#include \"add.c\"\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n　　链接过程会出现add函数重复定义的错误，因为编译后生成的main.o和add.o中都含有add函数的具体实现。这种情况下可以对main.c做如下修改:\n```C\nint add(int a, int b);\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n　　这样编译后生成的main.o文件中便不再包含add函数的实现，而只包含声明。但是如果add.c中的函数很多，以及调用这些函数的.c文件也很多，这样在每个.c文件中手动挨个添加这些函数的声明会十分不方便，**而可以理解为.h文件就是为了声明函数和变量方便而创建的**，因为这样把所有的变量、函数声明都写在.h中，其它.c文件只需要#include相应的.h文件就好。\n\n# 问答专区\n```\nQ：ifndef后面的标识必须是_ADD_H这种头文件名大写加下划线的形式吗？\nA：不必，你可以自定义，这只是一种习惯性写法，因为一个工程中头文件名是不会重复的，所以这样定义的话标识也不会重复。\n\nQ：工程中可以没有.h文件吗？\nA：可以，只是如上所说这样会有很多不方便。\n\nQ：.h文件必须和相应的.c文件同名吗？\nA：不必，但是通常我们都这样做，因为比较这样比较清晰。\n\nQ：头文件必须是.h后缀吗？\nA：不必，因为头文件只是其中的内容被#include宏命令替换，所以.txt、.doc等作为头文件的后缀都可以，但我们习惯用.h作为头文件后缀。\n\nQ：.c文件必须包含自己的.h文件吗？\nA：不一定，在最初解释编译器工作原理的例子中add.c就可以不包含add.h文件，因为add.h中只是对add函数的声明，而add.c不需要这个声明也可以编译通过。\n```\n\n# 参考链接\n\n[C语言中.h和.c文件解析（很精彩）](https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html)\n[Purpose of #ifndef and #define](https://community.arduboy.com/t/purpose-of-ifndef-and-define/3592/2)\n","source":"_posts/C语言编译连接过程以及-h和-c文件解析.md","raw":"---\ntitle: C语言编译器工作原理以及.h和.c文件解析\ndate: 2018-12-02 12:41:00\ncategories:\n- C++\ntags:\n- C语言\n---\n　　在进行多文件编程的时候，虽然很多IDE都可以帮我们完成预处理、编译、链接等过程，但深入理解编译器的这几个过程可以避免很多\"undefined\"，\"undeclared\"以及\"redefined\"的问题。而比较好的实践方式是自己写Makefile（IDE实际上完成的就是帮我们弄清文件依赖关系，然后生成一个Makefile，调用编译器去编译链接生成可执行文件）。\n<!--more-->\n# 编译器工作原理\n1.预处理阶段：\n　　实际上是处理的是\"define\"，\"include\"等宏命令，进行宏替换。例如``#include \"xx.h\"``实际意思是把当前这一行删掉，把xx.h中的内容原封不动的插入在当前行位置。\n2.编译阶段：\n　　**以.c文件为基本单位进行**，也就是说如果项目中一个.c文件都没有，那么项目无法编译。这一阶段为所有.c文件中的变量、函数分配空间，并将各个全局变量、函数进行符号描述，编译、汇编成二进制码从而生成.o目标文件。\n　　**需要注意的是这个过程并不关心变量的具体定义和函数的具体实现，只要存在变量和函数的相关声明就可以使得编译通过。**因为只要知道了变量/函数的类型和名字，编译器就知道了该如何使用这个变量/函数。\n3.链接阶段:\n　　**以.o文件为基本单位进行**，主要的工作是重定位各个目标文件的函数、变量。这个过程主要是为上一个编译过程中变量和函数的声明找到他们具体的定义和实现。\n\n*下面是一个具体的解释例子：*\n\nadd.h文件\n```C\n#ifndef _ADD_H\n#define _ADD_H\n\nint add(int a, int b);\n\n#endif\n```\n\nadd.c文件\n```C\n#include \"add.h\"\n\nint add(int a, int b){\n    return a + b;\n}\n```\n\nmain.c文件\n```C\n#include <stdio.h>\n#include \"add.h\"\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n\n1.预处理阶段：\n　　编译器会把main.c和add.c中的``#include \"add.h\"``替换成add.h中的全部内容。\n2.编译阶段：\n　　为main.c和add.c中的各变量和函数分配内存空间并汇编成目标文件。可以发现在main.c中并没有关于add函数的实现只有由``#include \"add.h\"``替换成的这个函数的声明，但这并不影响编译过程的进行。\n3.链接阶段：\n　　经过编译后生成了main.o和add.o文件。因为main.o中用到了add函数但没有它的具体实现，所以编译器会去其它.o文件中寻找该函数的具体实现。在这个例子中add.o提供了add函数的具体实现，链接过程顺利进行，生成可执行文件。\n\n**Ps.关于add.h中#ifndef、#define和#endif的解释：**它们的作用是防止头文件在一个.c文件中被重复包含。\n\n*一个具体的例子：*\n\na.h文件\n```C\nstruct Node{\n    int a;\n    int b;\n};\n```\n\nb.h文件\n```C\n#include \"a.h\"\n```\n\nc.h文件\n```C\n#include \"a.h\"\n```\n\nmain.c文件\n```C\n#include <stdio.h>\n#include \"b.h\"\n#include \"c.h\"\n\nint main(){\n    print(\"hello\\n\");\n    return 0;\n}\n```\n　　a.h中有结构体struct Node的定义，b.h和c.h都包含了a.h，main.c中又包含了b.h和c.h这两个头文件。这会导致a.h中的内容被两次复制到main.c中，产生struct Node的重复重复定义错误，而如果a.h遵循下面的格式：\n```C\n#ifndef _A_H\n#define _A_H\n\nstruct Node{\n    int a;\n    int b;\n};\n\n#endif\n```\n　　那么a.h在main.c中只会被替换一次，这样就避免了头文件的重复包含。\n\n# .h和.c文件解析\n　　**一般情况下我们在.h文件中进行变量、函数和宏的声明，在.c文件中进行变量和函数的具体实现。**\n　　但这只是我们默认的一种规范的做法，实际上我们舍弃.h文件，在.c文件中包含变量、函数的声明以及实现也没有问题，但如果在其它.c文件中用#include去包含这个.c文件就会出现问题。\n\n*具体例子：*\n\nadd.c文件\n```C\nint add(int a, int b);\n\nint add(int a, int b){\n    return a + b;\n}\n```\n\nmain.c文件\n```C\n#include \"add.c\"\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n　　链接过程会出现add函数重复定义的错误，因为编译后生成的main.o和add.o中都含有add函数的具体实现。这种情况下可以对main.c做如下修改:\n```C\nint add(int a, int b);\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n　　这样编译后生成的main.o文件中便不再包含add函数的实现，而只包含声明。但是如果add.c中的函数很多，以及调用这些函数的.c文件也很多，这样在每个.c文件中手动挨个添加这些函数的声明会十分不方便，**而可以理解为.h文件就是为了声明函数和变量方便而创建的**，因为这样把所有的变量、函数声明都写在.h中，其它.c文件只需要#include相应的.h文件就好。\n\n# 问答专区\n```\nQ：ifndef后面的标识必须是_ADD_H这种头文件名大写加下划线的形式吗？\nA：不必，你可以自定义，这只是一种习惯性写法，因为一个工程中头文件名是不会重复的，所以这样定义的话标识也不会重复。\n\nQ：工程中可以没有.h文件吗？\nA：可以，只是如上所说这样会有很多不方便。\n\nQ：.h文件必须和相应的.c文件同名吗？\nA：不必，但是通常我们都这样做，因为比较这样比较清晰。\n\nQ：头文件必须是.h后缀吗？\nA：不必，因为头文件只是其中的内容被#include宏命令替换，所以.txt、.doc等作为头文件的后缀都可以，但我们习惯用.h作为头文件后缀。\n\nQ：.c文件必须包含自己的.h文件吗？\nA：不一定，在最初解释编译器工作原理的例子中add.c就可以不包含add.h文件，因为add.h中只是对add函数的声明，而add.c不需要这个声明也可以编译通过。\n```\n\n# 参考链接\n\n[C语言中.h和.c文件解析（很精彩）](https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html)\n[Purpose of #ifndef and #define](https://community.arduboy.com/t/purpose-of-ifndef-and-define/3592/2)\n","slug":"C语言编译连接过程以及-h和-c文件解析","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nl8000bh8vn7cd0bcu1","comments":1,"layout":"post","photos":[],"link":""},{"title":"Graph Theory-The shortest path","date":"2018-09-07T11:57:58.000Z","_content":"　　$Bellman-Ford、SPFA、Dijkstra$这些单源最短路算法自己一直都在用，但有时候只是需要的时候拿出来当板子敲上去，没有什么深刻的理解，今天花了一下午把这些算法的原理和一些细节基本搞通了，总结一下。\n<!--more-->\n　　$PS：Floyd-Warshall$多源最短路算法受限于自己对DP的理解，还没有完全搞明白= =，之后再来填坑。\n　　*Bellman-Ford代码、Dijkstra理解和代码部分参考自《挑战程序设计竞赛》。*\n\n# 限制和复杂度\n　　$Bellman-Ford$：不含负圈（可判断出）。运行时间：$O(|V|\\*|E|)$。\n　　$SPFA$：不含负圈（可判断出）。运行时间：$O(k\\*|E|)$，一般情况下$(k <<|V|)$，可以认为近似线性。\n　　$Dijkstra$：不含负权边。运行时间：$O(|E|\\*|log|V|)$（优先队列实现）\n# Bellman-Ford\n　　$Bellman-Ford$算法思想是更新所有的边，每条边都更新$|V|-1$次，由于多余的更新操作是无害的，所有算法可以求得最短路，但同时不可避免的有复杂度冗余的问题。\n　　先说一下为什么是更新$|V|-1$次：\n　　首先每一个节点$v$都有一条相对于起点$s$的最短路，因为最短路是简单路径不包含环（如果是负环，最短路不存在；如果是正环，去掉后变短；如果是零环，去掉后不变），所以节点总数为$|V|$的情况下最长的那条最短路的长度不会超过$|V|-1$，又因为每更新一次都必然会确定最短路径上的一条线段，所以最多只需要更新$|V|-1$次，反之，如果更新次数超过$|V|-1$次则说明图中有负环最短路不存在，可以利用这一点来判断图中是否有负环。\n关于“每更新一次都必然会确定最短路径上的一条线段“的进一步解释：\n\n![graph](/gra.png)\n\n　　以上图为例，假设上图中的最长的一条最短路为$A->F$的最短路\n\n![path](/path.png)\n\n　　从原点$A$开始出发，每次进行所有边的更新，第一次更新结束后$A->B$的最短路确定，第二次更新结束后$A->C$的最短路确定，以此类推四次后这条最长的最短路确定。因为这条最短路是最长的，所以在它确定时其它较短的最短路也肯定已经确定。所以在至多$|V|-1$次更新后$Bellman-Ford$算法可以找到任意一条最短路。\n\n$Bellman-Ford$代码：\n```C++\n//从顶点from指向顶点to的权值为cost的边\nstruct edge{\n    int from;\n    int to;\n    int cost;\n};\n\nedge es[MAX_E]; //边\n\nint d[MAX_V];   //最短距离\nint V, E;       //顶点数和边数\n\n//求解从顶点s出发到所有点的最短距离\nvoid short_path(int s){\n    fill(d, d + V, INF);\n    d[s] = 0;\n    while(true){\n        bool update = false;\n        for(int i = 0; i < E; i++){\n            edge e = es[i];\n            if(d[e.from] != INF && d[e.to] > d[e.from] + e.cost){\n                d[e.to] = d[e.from] + e.cost;\n                update = true;\n            }\n        }\n        if(!update) break;\n    }\n}\n```\n# SPFA\n　　$SPFA$算法可以用一句话概括：”只有被更新了的节点才有资格更新其它节点“。因为如果一个节点自身没有被更新的话，那用它更新与它相邻的其它节点也不会产生新的结果。它用队列来维护那些被更新了节点。值得注意的是虽然一般情况来说$SPFA$的复杂度接近线性，但它不稳定，可以构造出特殊的图使得SPFA的复杂度变为和$Bellman-Ford$一样。\n\n$SPFA$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\n\nvector<edge> G[MAX_V];  //邻接表\n\nint d[MAX_V];\nbool vis[MAX_V];\n\nvoid spfa(int s) \n{\n    queue<int> q;\n    memset(vis, 0, sizeof(vis));\n    fill(d, d + V, INF);\n    d[s] = 0;\n    q.push(s);\n    vis[s] = true;\n    while (!q.empty()) \n    {\n        int v = q.front(); \n        q.pop(); \n        vis[v] = false;\n        for(int i = 0; i < G[v].size(); i++)\n        {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) \n            {\n                d[e.to] = d[v] + e.cost;\n                if (!vis[e.to])\n                {\n                    vis[e.to] = true;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n}\n```\n# Dijkstra\n　　考虑没有负边的情况。在$Bellman-Ford$算法中，如果$d[i]$还不是最短距离的话，那么即使进行$d[j]=d[i]+l(i, j)$的更新，$d[j]$也不会变成最短距离。而且，即使$d[i]$没有变化，每一次循环也要检查一遍从$i$出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改：\n1. 找到最短距离已经确定的顶点，从它出发更新相邻的顶点的最短距离。\n2. 此后不需要再关心$1$中的”最短距离已经确定的顶点“。\n\n　　在$1$和$2$中提到的”最短距离已经确定的顶点“要怎么得到是问题的关键。在最开始时，只有起点的最短距离是确定的。而在尚未使用过的顶点中，距离$d[i]$最小的顶点就是已经确定的顶点。这是因为由于不存在负边，所以$d[i]$不会在之后的更新中变小。\n\n$Dijkstra$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s){\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d, d + V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;    //v点的距离已被更新为更小的值，队列中的值丢弃\n        for(int i = 0; i < G[v].size(); i++){\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost){\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n```\n","source":"_posts/Graph-Theory-The-shortest-path.md","raw":"---\ntitle: Graph Theory-The shortest path\ndate: 2018-09-07 19:57:58\ncategories:\n- Summary\ntags:\n- 图论\n---\n　　$Bellman-Ford、SPFA、Dijkstra$这些单源最短路算法自己一直都在用，但有时候只是需要的时候拿出来当板子敲上去，没有什么深刻的理解，今天花了一下午把这些算法的原理和一些细节基本搞通了，总结一下。\n<!--more-->\n　　$PS：Floyd-Warshall$多源最短路算法受限于自己对DP的理解，还没有完全搞明白= =，之后再来填坑。\n　　*Bellman-Ford代码、Dijkstra理解和代码部分参考自《挑战程序设计竞赛》。*\n\n# 限制和复杂度\n　　$Bellman-Ford$：不含负圈（可判断出）。运行时间：$O(|V|\\*|E|)$。\n　　$SPFA$：不含负圈（可判断出）。运行时间：$O(k\\*|E|)$，一般情况下$(k <<|V|)$，可以认为近似线性。\n　　$Dijkstra$：不含负权边。运行时间：$O(|E|\\*|log|V|)$（优先队列实现）\n# Bellman-Ford\n　　$Bellman-Ford$算法思想是更新所有的边，每条边都更新$|V|-1$次，由于多余的更新操作是无害的，所有算法可以求得最短路，但同时不可避免的有复杂度冗余的问题。\n　　先说一下为什么是更新$|V|-1$次：\n　　首先每一个节点$v$都有一条相对于起点$s$的最短路，因为最短路是简单路径不包含环（如果是负环，最短路不存在；如果是正环，去掉后变短；如果是零环，去掉后不变），所以节点总数为$|V|$的情况下最长的那条最短路的长度不会超过$|V|-1$，又因为每更新一次都必然会确定最短路径上的一条线段，所以最多只需要更新$|V|-1$次，反之，如果更新次数超过$|V|-1$次则说明图中有负环最短路不存在，可以利用这一点来判断图中是否有负环。\n关于“每更新一次都必然会确定最短路径上的一条线段“的进一步解释：\n\n![graph](/gra.png)\n\n　　以上图为例，假设上图中的最长的一条最短路为$A->F$的最短路\n\n![path](/path.png)\n\n　　从原点$A$开始出发，每次进行所有边的更新，第一次更新结束后$A->B$的最短路确定，第二次更新结束后$A->C$的最短路确定，以此类推四次后这条最长的最短路确定。因为这条最短路是最长的，所以在它确定时其它较短的最短路也肯定已经确定。所以在至多$|V|-1$次更新后$Bellman-Ford$算法可以找到任意一条最短路。\n\n$Bellman-Ford$代码：\n```C++\n//从顶点from指向顶点to的权值为cost的边\nstruct edge{\n    int from;\n    int to;\n    int cost;\n};\n\nedge es[MAX_E]; //边\n\nint d[MAX_V];   //最短距离\nint V, E;       //顶点数和边数\n\n//求解从顶点s出发到所有点的最短距离\nvoid short_path(int s){\n    fill(d, d + V, INF);\n    d[s] = 0;\n    while(true){\n        bool update = false;\n        for(int i = 0; i < E; i++){\n            edge e = es[i];\n            if(d[e.from] != INF && d[e.to] > d[e.from] + e.cost){\n                d[e.to] = d[e.from] + e.cost;\n                update = true;\n            }\n        }\n        if(!update) break;\n    }\n}\n```\n# SPFA\n　　$SPFA$算法可以用一句话概括：”只有被更新了的节点才有资格更新其它节点“。因为如果一个节点自身没有被更新的话，那用它更新与它相邻的其它节点也不会产生新的结果。它用队列来维护那些被更新了节点。值得注意的是虽然一般情况来说$SPFA$的复杂度接近线性，但它不稳定，可以构造出特殊的图使得SPFA的复杂度变为和$Bellman-Ford$一样。\n\n$SPFA$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\n\nvector<edge> G[MAX_V];  //邻接表\n\nint d[MAX_V];\nbool vis[MAX_V];\n\nvoid spfa(int s) \n{\n    queue<int> q;\n    memset(vis, 0, sizeof(vis));\n    fill(d, d + V, INF);\n    d[s] = 0;\n    q.push(s);\n    vis[s] = true;\n    while (!q.empty()) \n    {\n        int v = q.front(); \n        q.pop(); \n        vis[v] = false;\n        for(int i = 0; i < G[v].size(); i++)\n        {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) \n            {\n                d[e.to] = d[v] + e.cost;\n                if (!vis[e.to])\n                {\n                    vis[e.to] = true;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n}\n```\n# Dijkstra\n　　考虑没有负边的情况。在$Bellman-Ford$算法中，如果$d[i]$还不是最短距离的话，那么即使进行$d[j]=d[i]+l(i, j)$的更新，$d[j]$也不会变成最短距离。而且，即使$d[i]$没有变化，每一次循环也要检查一遍从$i$出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改：\n1. 找到最短距离已经确定的顶点，从它出发更新相邻的顶点的最短距离。\n2. 此后不需要再关心$1$中的”最短距离已经确定的顶点“。\n\n　　在$1$和$2$中提到的”最短距离已经确定的顶点“要怎么得到是问题的关键。在最开始时，只有起点的最短距离是确定的。而在尚未使用过的顶点中，距离$d[i]$最小的顶点就是已经确定的顶点。这是因为由于不存在负边，所以$d[i]$不会在之后的更新中变小。\n\n$Dijkstra$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s){\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d, d + V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;    //v点的距离已被更新为更小的值，队列中的值丢弃\n        for(int i = 0; i < G[v].size(); i++){\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost){\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n```\n","slug":"Graph-Theory-The-shortest-path","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nl9000dh8vndniv2gcc","comments":1,"layout":"post","photos":[],"link":""},{"title":"HDU1016-Prime Ring Problem-DFS","date":"2018-08-12T15:16:27.000Z","_content":"渐渐对深搜类的题有了自信, 虽然还只能做一些简单的题, 但是感觉还不错٩('ω')و .\n题目描述：由$1-n$这$n$个自然数组成一个环,要求任意相邻两数之和为素数, 按顺序输出这些数.\n<!-- more -->\n# 链接\n[HDU1016-Prime Ring Problem](http://acm.hdu.edu.cn/showproblem.php?pid=1016)\n# 原题\nA ring is compose of $n$ circles as shown in diagram. Put natural number $1, 2,...,n$ into each circle separately, and the sum of numbers in two adjacent circles should be a prime.\nNote: the number of first circle should always be 1.\n![example](/dfs.png)\n# 题解\nDFS遍历每一种情况.\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 12 Aug 22:10:25 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n;\nvector<int> vec;\nbool vis[maxn];\n\nvoid ans_print(){\n    int cnt = 1;\n    for(auto x : vec){\n        if(cnt == 1) cout << x;\n        else cout << \" \" << x;\n        cnt++;\n    }\n    cout << endl;\n}\n\nbool is_prime(int x){\n    if(x < 2) return false;\n    int tmp = sqrt(x);\n    for(int i = 2; i <= tmp; i++){\n        if(!(x % i)) return false;\n    }\n    return true;\n}\n\nvoid dfs(int dep){\n    if(dep == n - 1){\n        for(int i = 2; i <= n; i++){\n            if(!vis[i] && is_prime(i + vec[dep - 1]) && is_prime(i + 1)){\n                vec.push_back(i);\n                ans_print();\n                vec.pop_back();\n            }\n        }\n        return;\n    }\n    for(int i = 2; i <= n; i++){\n        if(!vis[i] && is_prime(i + vec[dep - 1])){\n            vec.push_back(i);\n            vis[i] = 1;\n            dfs(dep + 1);\n            vec.pop_back();\n            vis[i] = 0;\n        }\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    while(cin >> n){\n        vec.clear();\n        memset(vis, 0, sizeof(0));\n        printf(\"Case %d:\\n\", cnt++);\n        vec.push_back(1);\n        vis[1] = 1;\n        dfs(1);\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/HDU1016-Prime-Ring-Problem-DFS.md","raw":"---\ntitle: HDU1016-Prime Ring Problem-DFS\ndate: 2018-08-12 23:16:27\ncategories:\n- ACM\n- DFS\ntags:\n- DFS\n---\n渐渐对深搜类的题有了自信, 虽然还只能做一些简单的题, 但是感觉还不错٩('ω')و .\n题目描述：由$1-n$这$n$个自然数组成一个环,要求任意相邻两数之和为素数, 按顺序输出这些数.\n<!-- more -->\n# 链接\n[HDU1016-Prime Ring Problem](http://acm.hdu.edu.cn/showproblem.php?pid=1016)\n# 原题\nA ring is compose of $n$ circles as shown in diagram. Put natural number $1, 2,...,n$ into each circle separately, and the sum of numbers in two adjacent circles should be a prime.\nNote: the number of first circle should always be 1.\n![example](/dfs.png)\n# 题解\nDFS遍历每一种情况.\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 12 Aug 22:10:25 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n;\nvector<int> vec;\nbool vis[maxn];\n\nvoid ans_print(){\n    int cnt = 1;\n    for(auto x : vec){\n        if(cnt == 1) cout << x;\n        else cout << \" \" << x;\n        cnt++;\n    }\n    cout << endl;\n}\n\nbool is_prime(int x){\n    if(x < 2) return false;\n    int tmp = sqrt(x);\n    for(int i = 2; i <= tmp; i++){\n        if(!(x % i)) return false;\n    }\n    return true;\n}\n\nvoid dfs(int dep){\n    if(dep == n - 1){\n        for(int i = 2; i <= n; i++){\n            if(!vis[i] && is_prime(i + vec[dep - 1]) && is_prime(i + 1)){\n                vec.push_back(i);\n                ans_print();\n                vec.pop_back();\n            }\n        }\n        return;\n    }\n    for(int i = 2; i <= n; i++){\n        if(!vis[i] && is_prime(i + vec[dep - 1])){\n            vec.push_back(i);\n            vis[i] = 1;\n            dfs(dep + 1);\n            vec.pop_back();\n            vis[i] = 0;\n        }\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    while(cin >> n){\n        vec.clear();\n        memset(vis, 0, sizeof(0));\n        printf(\"Case %d:\\n\", cnt++);\n        vec.push_back(1);\n        vis[1] = 1;\n        dfs(1);\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n","slug":"HDU1016-Prime-Ring-Problem-DFS","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nl9000eh8vnhnu1jkv3","comments":1,"layout":"post","photos":[],"link":""},{"title":"Good Bye 2018","date":"2018-12-31T02:54:31.000Z","_content":"　　2018要结束了，做一个总结吧。\n　　2018这一年真的发生了很多事，1月份和女票在一起，5月份到西安参加ACM-ICPC邀请赛，9月份保研北航成功。2018年可以说是我目前为止最不迷茫的一年，因为我找到了目标，真正喜欢想去实现的目标，很多事情也因为它而改变了。\n<!--more-->\n　　很喜欢网易云上看到的一个评论，\n{% centerquote %}\n黄色的树林里分出两条路\n我选择了人迹更少的一条\n从此决定了我一生的道路\n{% endcenterquote %}\n　　ACM之于我大概就是这种感觉吧，从一开始的锻炼编程能力为目的，到现在喜欢上它带给我的愉悦。我想这才是我真正的“进步”吧。昨天参加了Codeforces2018年的最后一场比赛[Good Bye 2018](https://codeforces.com/contest/1091)，才突然意识到原来自己接触ACM已经将近一年了，感谢这一年的陪伴。我希望自己能够继续坚持下去，享受它带给我的快乐，获得由此而带来的进步，并继续在这片田地默默耕耘下去。","source":"_posts/Good-Bye-2018.md","raw":"---\ntitle: Good Bye 2018\ndate: 2018-12-31 10:54:31\ncategories:\n- Diary\ntags:\n---\n　　2018要结束了，做一个总结吧。\n　　2018这一年真的发生了很多事，1月份和女票在一起，5月份到西安参加ACM-ICPC邀请赛，9月份保研北航成功。2018年可以说是我目前为止最不迷茫的一年，因为我找到了目标，真正喜欢想去实现的目标，很多事情也因为它而改变了。\n<!--more-->\n　　很喜欢网易云上看到的一个评论，\n{% centerquote %}\n黄色的树林里分出两条路\n我选择了人迹更少的一条\n从此决定了我一生的道路\n{% endcenterquote %}\n　　ACM之于我大概就是这种感觉吧，从一开始的锻炼编程能力为目的，到现在喜欢上它带给我的愉悦。我想这才是我真正的“进步”吧。昨天参加了Codeforces2018年的最后一场比赛[Good Bye 2018](https://codeforces.com/contest/1091)，才突然意识到原来自己接触ACM已经将近一年了，感谢这一年的陪伴。我希望自己能够继续坚持下去，享受它带给我的快乐，获得由此而带来的进步，并继续在这片田地默默耕耘下去。","slug":"Good-Bye-2018","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nla000fh8vncm8ql3q1","comments":1,"layout":"post","photos":[],"link":""},{"title":"HDU2050-线切割平面问题-思维+简单dp","date":"2018-04-09T02:42:54.000Z","_content":"和队友一块做这道题，队友们几乎秒杀，而自己想了很久也没有推导出一个清晰的规律...看了[vinacky的线切割平面问题](https://blog.csdn.net/vinacky/article/details/8958326)这篇博客后才豁然开朗,个人感觉一道很好的思维题。\n题目描述就是求n条折线可以分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成七部分。\n![example](/line.jpg)\n<!-- more -->\n# 链接\n[HDU2050](http://acm.hdu.edu.cn/showproblem.php?pid=2050)\n# 题解\n## 直线切割平面\n首先考虑向平面添加直线(简化思维)后的平面分割情况：\n(下面假设新添加的直线与已有直线均相交)\n当平面上没有直线时，有一个平面；\n有１条直线时，没有节点，多出１部分，共２个平面；\n有２条直线时，多了１个节点，多出２部分，共４个平面；\n有３条直线时，多了２个节点，多出３部分，共７个平面；\n...\n至此我们便可以直观的思考一下是什么导致了平面的分割，当添加第i条直线时，因为我们总可以使它和前i-1条直线都相交，所以共有i-1个交点，也即第i条直线被分割成了i段，对每一段来说，它都将自己所在的平面重新分割为两部分。所以添加了第i条直线后，最多可以重新多分割出i个平面。\n所以原始的１个平面,\n添加１条直线后平面数为1+1;\n添加２条直线后平面数为1+1+2;\n添加３条直线后平面数为1+1+2+3；\n...\n得到添加n条直线后的平面数公式：$res = 1 + 1 + 2 + 3 + ... + n = \\frac{n(n+1)}{2} + 1$\n## V型折线切割平面\nV型折线切割平面可以看做同时添加了两条相交直线，但是稍有不同的是，这两条直线的交点有一侧平面合并了,因此而产生的影响是减少了两个平面。\n\n我们仍然可以保证添加的折线与其他折线均有交点，所以添加第i条V型折线时，增加的平面数为：$2\\*i - 1 + 2\\*i - 2$\n得到添加n条折线后的平面数公式：$$res = 1 + (1 + 2) + (3 + 4) + ... + (2n - 1 + 2n) = \\frac{2n(2n + 1)}{2} + 1 - 2n$$\n于是可以公式直接求解，也可以dp求解\n# 代码\n下面给出dp求解代码\n``` C++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nconst int maxn = 1e4 + 7;\nint n;\nlong long dp[maxn] = {1, 2, 7};\n\nint main(){\n    int c;\n    scanf(\"%d\", &c);\n    while(c--){\n    scanf(\"%d\", &n);\n        for(int i = 3; i <= n; i++){\n            dp[i] = dp[i - 1] + ２ * i - 1 + 2 * i - 2;\n        }\n        printf(\"%lld\\n\", dp[n]);\n        \n    }\n    return 0;\n\n}\n```","source":"_posts/HDU2050.md","raw":"---\ntitle: HDU2050-线切割平面问题-思维+简单dp\ndate: 2018-04-09 10:42:54\ncategories:\n- ACM\n- 思维\ntags:\n- HDU\n- 线切割平面\n- math\n- 思维\n---\n和队友一块做这道题，队友们几乎秒杀，而自己想了很久也没有推导出一个清晰的规律...看了[vinacky的线切割平面问题](https://blog.csdn.net/vinacky/article/details/8958326)这篇博客后才豁然开朗,个人感觉一道很好的思维题。\n题目描述就是求n条折线可以分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成七部分。\n![example](/line.jpg)\n<!-- more -->\n# 链接\n[HDU2050](http://acm.hdu.edu.cn/showproblem.php?pid=2050)\n# 题解\n## 直线切割平面\n首先考虑向平面添加直线(简化思维)后的平面分割情况：\n(下面假设新添加的直线与已有直线均相交)\n当平面上没有直线时，有一个平面；\n有１条直线时，没有节点，多出１部分，共２个平面；\n有２条直线时，多了１个节点，多出２部分，共４个平面；\n有３条直线时，多了２个节点，多出３部分，共７个平面；\n...\n至此我们便可以直观的思考一下是什么导致了平面的分割，当添加第i条直线时，因为我们总可以使它和前i-1条直线都相交，所以共有i-1个交点，也即第i条直线被分割成了i段，对每一段来说，它都将自己所在的平面重新分割为两部分。所以添加了第i条直线后，最多可以重新多分割出i个平面。\n所以原始的１个平面,\n添加１条直线后平面数为1+1;\n添加２条直线后平面数为1+1+2;\n添加３条直线后平面数为1+1+2+3；\n...\n得到添加n条直线后的平面数公式：$res = 1 + 1 + 2 + 3 + ... + n = \\frac{n(n+1)}{2} + 1$\n## V型折线切割平面\nV型折线切割平面可以看做同时添加了两条相交直线，但是稍有不同的是，这两条直线的交点有一侧平面合并了,因此而产生的影响是减少了两个平面。\n\n我们仍然可以保证添加的折线与其他折线均有交点，所以添加第i条V型折线时，增加的平面数为：$2\\*i - 1 + 2\\*i - 2$\n得到添加n条折线后的平面数公式：$$res = 1 + (1 + 2) + (3 + 4) + ... + (2n - 1 + 2n) = \\frac{2n(2n + 1)}{2} + 1 - 2n$$\n于是可以公式直接求解，也可以dp求解\n# 代码\n下面给出dp求解代码\n``` C++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nconst int maxn = 1e4 + 7;\nint n;\nlong long dp[maxn] = {1, 2, 7};\n\nint main(){\n    int c;\n    scanf(\"%d\", &c);\n    while(c--){\n    scanf(\"%d\", &n);\n        for(int i = 3; i <= n; i++){\n            dp[i] = dp[i - 1] + ２ * i - 1 + 2 * i - 2;\n        }\n        printf(\"%lld\\n\", dp[n]);\n        \n    }\n    return 0;\n\n}\n```","slug":"HDU2050","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nlb000gh8vniktfm60z","comments":1,"layout":"post","photos":[],"link":""},{"title":"hdu-5092","date":"2018-06-05T12:28:06.000Z","_content":"","source":"_posts/HDU5092.md","raw":"---\ntitle: hdu-5092\ndate: 2018-06-05 20:28:06\ncategories:\ntags:\n---\n","slug":"HDU5092","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nlb000hh8vnlpp8hr4l","comments":1,"layout":"post","photos":[],"link":""},{"title":"HDU4856-Tunnels-BFS+状态压缩DP","date":"2018-05-16T06:03:19.000Z","_content":"最近的几场训练赛做题的时候发现自己对搜索类、动态规划类的题有些恐惧，导致这些类型的题比赛时基本做不出来。仔细想了一下，是自己的递归部分理解的就不够透彻，导致搜索写不出来，动态规划就更无从下手。之前也找了很多递归理解的文章去看，也做了一些递归的题，但是效果不佳。意识到网上的资料对于递归的理解一般会拿经典的斐波那契数列或汉诺塔来举例，这对于递归的理解确实是有帮助的，但是对于锻炼搜索思维的效果不是太有效，于是决定先恶补一部分搜索类的题。\n这道题是准备西安邀请赛时打的模拟赛做到的题，知识点主要用到了BFS和状态压缩DP，可以当做旅行商问题来做，但是最后不返回起点。由于自己DP比较差，所以搞懂这道题还是花了挺长时间。状态压缩DP部分的实现代码参考大白。\n\nPs：在最后会贴几个自己觉得看到的对递归和动态规划理解比较有帮助的文章链接。\n<!-- more -->\n# 题目链接\n[HDU4856-Tunnels](http://acm.hdu.edu.cn/showproblem.php?pid=4856)\n# 题目描述\n一张城市网格图，城市中有m条快速通道，可以从图中任意位置出发，求访问完所有快速通道所用的最少时间，忽略在快速通道内的时间。\n# 题解\n因为在快速通道内的时间是不计的所以只要到达了一个快速通道的入口就相当于访问完了这一条通道，所以可以构造一张$m×m$的邻接表，其中$d[i][j]$表示从第$i$个通道的出口到第$j$个通道的入口的距离，这一部分直接用BFS就能实现，接下来就可以用旅行商问题的解法求解不重复的访问完所有通道所用的时间。\n有两个与旅行商问题不同需要注意的地方：\n**最后不返回起点**\n**起点位置任意，也就是可以将任意一个通道的入口作为起点**\n解决方法详见代码。\n#代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 18;\nconst int maxm = 18;\nconst int inf = 0x3f3f3f3f;\nchar mp[maxn][maxn];\ntypedef pair<int, int> P;\nP in[maxm];\nP out[maxm];\nint n, m;\nint d[maxn][maxn];\nint sx, sy;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint dis[maxm][maxm];\nint dp[1 <<  maxm][maxm];\n\n//状态压缩DP\nvoid dpsolve(){\n    for(int S = 0; S < 1 << m; S++){\n        fill(dp[S], dp[S] + m, inf);\n    }\n    for(int i = 0; i < m; i++){\n        dp[(1 << m) - 1][i] = 0;//因为起点未定，所以终点在任意一个通道都可以\n    }\n    for(int S = (1 << m) - 2; S >= 0; S--){\n        for(int v = 0; v < m; v++){\n            for(int u = 0; u < m; u++){\n                if(!(S >> u & 1)){\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + dis[v][u]);\n                }\n            }\n        }\n    }\n    int res = inf;\n    for(int i = 0; i < m; i++){\n        res = min(res, dp[1 << i][i]);//判断以不同通道为起点的情况下，哪种用时最短\n    }\n    if(res == inf) printf(\"%d\\n\", -1);\n    else printf(\"%d\\n\", res);\n}\n\n//bfs搜索确定两两通道之间最小距离\nvoid bfs(int sx, int sy){\n    queue<P> que;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            d[i][j] = inf;\n        }\n    }\n    d[sx][sy] = 0;\n    que.push(P(sx, sy));\n\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < n && mp[nx][ny] != '#' && d[nx][ny] == inf){\n\n                d[nx][ny] = d[p.first][p.second] + 1;\n                que.push(P(nx, ny));\n            }\n        }\n\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif // ONLINE_JUDGE\n    while(~scanf(\"%d%d\", &n, &m)){\n        for(int i = 0; i < n; i++){\n            scanf(\"%s\", mp[i]);\n        }\n        for(int i = 0; i < m; i++){\n            scanf(\"%d%d%d%d\", &in[i].first, &in[i].second, &out[i].first, &out[i].second);\n        }\n        //构建邻接表\n        for(int i = 0; i < m; i++){\n            bfs(out[i].first - 1, out[i].second - 1);\n            for(int j = 0; j < m; j++){\n                if(i == j) dis[i][j] = 0;\n                else dis[i][j] = d[in[j].first - 1][in[j].second - 1];\n            }\n        }\n\n        dpsolve();\n    }\n    return 0;\n}\n```\n# 关于递归、动态规划理解的文章链接\n[写递归函数的正确思维方法](https://blog.csdn.net/vagrxie/article/details/8470798)\n[递归算法详解](https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/)\n[怎么更好地终极理解递归算法](https://blog.csdn.net/StruggleShu/article/details/51051140)\n[如何有效地理解程序中的递归](https://blog.csdn.net/qq_34773981/article/details/79225588)\n\n[一道题看清动态规划的前世今生（一）](http://www.importnew.com/27323.html)\n[一道题看清动态规划的前世今生（二）](http://www.importnew.com/27444.html)\n\n最后对这些文章的博主表示感谢！\n","source":"_posts/HDU4856-Tunnels.md","raw":"---\ntitle: HDU4856-Tunnels-BFS+状态压缩DP\ndate: 2018-05-16 14:03:19\ncategories:\n- ACM\n- 动态规划\ntags:\n- HDU\n- 状态压缩DP\n- BFS\n---\n最近的几场训练赛做题的时候发现自己对搜索类、动态规划类的题有些恐惧，导致这些类型的题比赛时基本做不出来。仔细想了一下，是自己的递归部分理解的就不够透彻，导致搜索写不出来，动态规划就更无从下手。之前也找了很多递归理解的文章去看，也做了一些递归的题，但是效果不佳。意识到网上的资料对于递归的理解一般会拿经典的斐波那契数列或汉诺塔来举例，这对于递归的理解确实是有帮助的，但是对于锻炼搜索思维的效果不是太有效，于是决定先恶补一部分搜索类的题。\n这道题是准备西安邀请赛时打的模拟赛做到的题，知识点主要用到了BFS和状态压缩DP，可以当做旅行商问题来做，但是最后不返回起点。由于自己DP比较差，所以搞懂这道题还是花了挺长时间。状态压缩DP部分的实现代码参考大白。\n\nPs：在最后会贴几个自己觉得看到的对递归和动态规划理解比较有帮助的文章链接。\n<!-- more -->\n# 题目链接\n[HDU4856-Tunnels](http://acm.hdu.edu.cn/showproblem.php?pid=4856)\n# 题目描述\n一张城市网格图，城市中有m条快速通道，可以从图中任意位置出发，求访问完所有快速通道所用的最少时间，忽略在快速通道内的时间。\n# 题解\n因为在快速通道内的时间是不计的所以只要到达了一个快速通道的入口就相当于访问完了这一条通道，所以可以构造一张$m×m$的邻接表，其中$d[i][j]$表示从第$i$个通道的出口到第$j$个通道的入口的距离，这一部分直接用BFS就能实现，接下来就可以用旅行商问题的解法求解不重复的访问完所有通道所用的时间。\n有两个与旅行商问题不同需要注意的地方：\n**最后不返回起点**\n**起点位置任意，也就是可以将任意一个通道的入口作为起点**\n解决方法详见代码。\n#代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 18;\nconst int maxm = 18;\nconst int inf = 0x3f3f3f3f;\nchar mp[maxn][maxn];\ntypedef pair<int, int> P;\nP in[maxm];\nP out[maxm];\nint n, m;\nint d[maxn][maxn];\nint sx, sy;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint dis[maxm][maxm];\nint dp[1 <<  maxm][maxm];\n\n//状态压缩DP\nvoid dpsolve(){\n    for(int S = 0; S < 1 << m; S++){\n        fill(dp[S], dp[S] + m, inf);\n    }\n    for(int i = 0; i < m; i++){\n        dp[(1 << m) - 1][i] = 0;//因为起点未定，所以终点在任意一个通道都可以\n    }\n    for(int S = (1 << m) - 2; S >= 0; S--){\n        for(int v = 0; v < m; v++){\n            for(int u = 0; u < m; u++){\n                if(!(S >> u & 1)){\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + dis[v][u]);\n                }\n            }\n        }\n    }\n    int res = inf;\n    for(int i = 0; i < m; i++){\n        res = min(res, dp[1 << i][i]);//判断以不同通道为起点的情况下，哪种用时最短\n    }\n    if(res == inf) printf(\"%d\\n\", -1);\n    else printf(\"%d\\n\", res);\n}\n\n//bfs搜索确定两两通道之间最小距离\nvoid bfs(int sx, int sy){\n    queue<P> que;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            d[i][j] = inf;\n        }\n    }\n    d[sx][sy] = 0;\n    que.push(P(sx, sy));\n\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < n && mp[nx][ny] != '#' && d[nx][ny] == inf){\n\n                d[nx][ny] = d[p.first][p.second] + 1;\n                que.push(P(nx, ny));\n            }\n        }\n\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif // ONLINE_JUDGE\n    while(~scanf(\"%d%d\", &n, &m)){\n        for(int i = 0; i < n; i++){\n            scanf(\"%s\", mp[i]);\n        }\n        for(int i = 0; i < m; i++){\n            scanf(\"%d%d%d%d\", &in[i].first, &in[i].second, &out[i].first, &out[i].second);\n        }\n        //构建邻接表\n        for(int i = 0; i < m; i++){\n            bfs(out[i].first - 1, out[i].second - 1);\n            for(int j = 0; j < m; j++){\n                if(i == j) dis[i][j] = 0;\n                else dis[i][j] = d[in[j].first - 1][in[j].second - 1];\n            }\n        }\n\n        dpsolve();\n    }\n    return 0;\n}\n```\n# 关于递归、动态规划理解的文章链接\n[写递归函数的正确思维方法](https://blog.csdn.net/vagrxie/article/details/8470798)\n[递归算法详解](https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/)\n[怎么更好地终极理解递归算法](https://blog.csdn.net/StruggleShu/article/details/51051140)\n[如何有效地理解程序中的递归](https://blog.csdn.net/qq_34773981/article/details/79225588)\n\n[一道题看清动态规划的前世今生（一）](http://www.importnew.com/27323.html)\n[一道题看清动态规划的前世今生（二）](http://www.importnew.com/27444.html)\n\n最后对这些文章的博主表示感谢！\n","slug":"HDU4856-Tunnels","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nlc000ih8vn42edf6vm","comments":1,"layout":"post","photos":[],"link":""},{"title":"Learn CMake(1)--HelloWorld","date":"2019-04-02T08:38:14.000Z","_content":"之前的博客[C语言编译器工作原理以及.h和.c文件解析](https://ain-crad.github.io/2018/12/02/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A-h%E5%92%8C-c%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/)中比较详细的介绍了编译器的编译过程，以及它是如何处理多文件编译问题的。但是在工程项目比较庞大以及需要链接外部库的时候，手动编写Makefile往往比较繁琐，一个比较好的解决方式是使用CMake工具自动生成工程项目的Makefile。\n<!--more-->\n# CMake介绍\nCMake是一个开源的跨平台自动化构建系统。它可以产生不同系统平台的构建文件(e.g., 类Unix系统的Makefile，Window系统的.vcproj)。可以方便的用于工程项目的管理。\n\n*大部分内容来自[Introduction to CMake by Example](http://derekmolloy.ie/hello-world-introductions-to-cmake/)*\n\n# CMake 安装(Ubuntu)\n```bash\n$ sudo apt-get install cmake    //install CMake\n$ cmake -version    //check version of CMake\n```\n\n# The Hello World Example\n首先创建一个HelloWorld.cpp文件，包含以下代码:\n```c++\n#include <iostream>\n\nint main(int argc, char *argv[]){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n```\n在相同目录下创建一个CMakeLists.txt文件(存放CMake命令的标准文件)，包含一下内容:\n```cmake\ncmake_minimum_required(VERSION 3.5.1)\nproject(HelloWorld)\nadd_executable(hello HelloWorld.cpp)\n```\nCMakeLists.txt中包含三行：\n- 第一行的``cmake_minimum_required()``命令指定了该工程的最小CMake版本，设置为自己系统中的CMake版本即可。\n- 第二行的``project()``命令设置了工程的名字。\n- 第三行的``add_executable()``命令，第一个参数为生成的可执行文件的名字，第二个参数指定需要编译的源文件。两个参数之间用空格隔开。\n\n接下来在CMakeLists.txt同一目录下执行以下命令：\n```bash\n$ cmake .\n```\n\".\"表示当前目录。\n\n执行完毕后，在同一目录下会生成一些文件，最重要的是生成了Makefile文件，接下来用make命令来编译链接以生成可执行文件：\n```bash\n$ make\n```\n之后会在同一目录下生成``hello``可执行文件，运行：\n```bash\n$ ./hello\n```\n会在终端中打印出以下信息：\n```\nHello World!\n```\n\n# 补充\n执行``cmake .``命令后我们发现多出的一些文件会使得整个工程看起来比较混乱，而我们只需要用到其中的Makefile文件。所以比较推荐的做法是，在同一目录下新建一个``build``文件夹用来存放cmake命令之后产生的文件，而当我们不需要这些文件的时候只需要将build文件夹下的文件删除。下面是具体的命令：\n```bash\n$ mkdir build\n$ cd build\n$ cmake ..\n$ make\n```\n清除cmake文件\n```bash\n$ sudo rm -rf build/*\n```\n\n# 总结\n虽然只编译一个HelloWorld.cpp我们完全没有必要使用CMake，但我们通过这个例子解释了CMake的一些基本操作，可以用于后面更复杂的例子。\n\n# 参考链接\n[Introduction to CMake by Example](http://derekmolloy.ie/hello-world-introductions-to-cmake/)\n[Jermmy's Lazy Blog--cmake学习笔记](http://jermmy.xyz/2017/04/25/2017-4-25-learn-cmake-1/)","source":"_posts/Learn-CMake-1-HelloWorld.md","raw":"---\ntitle: Learn CMake(1)--HelloWorld\ndate: 2019-04-02 16:38:14\ncategories:\n- Summary\ntags:\n- CMake\n---\n之前的博客[C语言编译器工作原理以及.h和.c文件解析](https://ain-crad.github.io/2018/12/02/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A-h%E5%92%8C-c%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/)中比较详细的介绍了编译器的编译过程，以及它是如何处理多文件编译问题的。但是在工程项目比较庞大以及需要链接外部库的时候，手动编写Makefile往往比较繁琐，一个比较好的解决方式是使用CMake工具自动生成工程项目的Makefile。\n<!--more-->\n# CMake介绍\nCMake是一个开源的跨平台自动化构建系统。它可以产生不同系统平台的构建文件(e.g., 类Unix系统的Makefile，Window系统的.vcproj)。可以方便的用于工程项目的管理。\n\n*大部分内容来自[Introduction to CMake by Example](http://derekmolloy.ie/hello-world-introductions-to-cmake/)*\n\n# CMake 安装(Ubuntu)\n```bash\n$ sudo apt-get install cmake    //install CMake\n$ cmake -version    //check version of CMake\n```\n\n# The Hello World Example\n首先创建一个HelloWorld.cpp文件，包含以下代码:\n```c++\n#include <iostream>\n\nint main(int argc, char *argv[]){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n```\n在相同目录下创建一个CMakeLists.txt文件(存放CMake命令的标准文件)，包含一下内容:\n```cmake\ncmake_minimum_required(VERSION 3.5.1)\nproject(HelloWorld)\nadd_executable(hello HelloWorld.cpp)\n```\nCMakeLists.txt中包含三行：\n- 第一行的``cmake_minimum_required()``命令指定了该工程的最小CMake版本，设置为自己系统中的CMake版本即可。\n- 第二行的``project()``命令设置了工程的名字。\n- 第三行的``add_executable()``命令，第一个参数为生成的可执行文件的名字，第二个参数指定需要编译的源文件。两个参数之间用空格隔开。\n\n接下来在CMakeLists.txt同一目录下执行以下命令：\n```bash\n$ cmake .\n```\n\".\"表示当前目录。\n\n执行完毕后，在同一目录下会生成一些文件，最重要的是生成了Makefile文件，接下来用make命令来编译链接以生成可执行文件：\n```bash\n$ make\n```\n之后会在同一目录下生成``hello``可执行文件，运行：\n```bash\n$ ./hello\n```\n会在终端中打印出以下信息：\n```\nHello World!\n```\n\n# 补充\n执行``cmake .``命令后我们发现多出的一些文件会使得整个工程看起来比较混乱，而我们只需要用到其中的Makefile文件。所以比较推荐的做法是，在同一目录下新建一个``build``文件夹用来存放cmake命令之后产生的文件，而当我们不需要这些文件的时候只需要将build文件夹下的文件删除。下面是具体的命令：\n```bash\n$ mkdir build\n$ cd build\n$ cmake ..\n$ make\n```\n清除cmake文件\n```bash\n$ sudo rm -rf build/*\n```\n\n# 总结\n虽然只编译一个HelloWorld.cpp我们完全没有必要使用CMake，但我们通过这个例子解释了CMake的一些基本操作，可以用于后面更复杂的例子。\n\n# 参考链接\n[Introduction to CMake by Example](http://derekmolloy.ie/hello-world-introductions-to-cmake/)\n[Jermmy's Lazy Blog--cmake学习笔记](http://jermmy.xyz/2017/04/25/2017-4-25-learn-cmake-1/)","slug":"Learn-CMake-1-HelloWorld","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nld000jh8vnogprhvu1","comments":1,"layout":"post","photos":[],"link":""},{"title":"Learn CMake(2)--多文件/目录","date":"2019-04-03T02:16:23.000Z","_content":"随着工程的不断扩大，我们会将工程分成不同的子模块，每个子模块用一个子文件夹管理。传统的编译方法是在每一个子目录下创建一个Makefile，然后这些Makefile由父目录中的Makefile调用。使用CMake可以有效的简化这种情况。\n<!--more-->\n# A Project with Directories\n我们把HelloWorld封装成一个类，头文件``HelloWorld.h``放在``include``文件夹里，源文件``HelloWorld.cpp``和``main.cpp``放在``src``文件夹里。(文件中具体代码在最后给出)。目录结构如下：\n```bash\naincrad@Inspiron:~/Desktop/HelloWorld$ tree\n.\n├── CMakeLists.txt\n├── include\n│   └── HelloWorld.h\n└── src\n    ├── HelloWorld.cpp\n    └── main.cpp\n\n2 directories, 4 files\n```\n这时候CMakeLists.txt中的内容如下：\n```cmake\ncmake_minimum_required(VERSION 3.5.1)\nproject(HelloWorld)\n\n#Bring the headers, such as HelloWorld.h into the project\ninclude_directories(include)\n\n#Can manually add the sources using the set command as follows:\n#set(SOURCES src/main.cpp src/HelloWorld.cpp)\n\n#However, the file(GLOB ...) allows for wildcard additions:\nfile(GLOB SOURCES \"src/*.cpp\")\n\nadd_executable(hello ${SOURCES})\n```\n解释一下CMakeLists.txt中新出现的内容：\n- ``include_directories()``命令用来把头文件加入环境中，它的参数是包含头文件的目录。另外还有一个``target_include_directories()``可以在添加头文件目录的同时指定头文件作用的目标(target)。\n- ``set()``命令可以用来设置变量，这里我们把``SOURCES``变量设置为``main.cpp``和``HelloWorld.cpp``，表示包含这两个源文件。但是因为需要手动添加所有的源文件，比较繁琐，所以这条命令被注释了，用下一行的命令代替。\n- ``file()``命令将所有的源文件添加到工程中。``GLOB``用来创建一个文件列表，读取了``src/*.cpp``中的所有源文件，并将它们赋值给``SOURCES``变量。\n- ``add_executable()``和上一个例子中直接显式使用源文件不同的是使用了``SOURCES``变量作为参数，来生成``hello``可执行文件。\n\n下面是用CMake进行编译的命令：\n```bash\n$ mkdir build\n$ cd build\n$ cmake ..\n$ make\n$ ./hello \n```\n成功编译、运行后终端打印出结果：\n```\nHello World!\n```\n\n# 文件中代码\n**HelloWorld.h**\n```c++\n#ifndef _HelloWorld_H\n#define _HelloWorld_H\n\n#include <iostream>\n\nclass HelloWorld{\npublic:\n    void sayHello(void);\n};\n\n#endif\n```\n\n**HelloWorld.cpp**\n```c++\n#include \"HelloWorld.h\"\n\nvoid HelloWorld::sayHello(){\n    std::cout << \"Hello World!\" << std::endl;\n}\n```\n\n**main.cpp**\n```c++\n#include \"../include/HelloWorld.h\"\n\nint main(int argc, char* argv[]){\n    HelloWorld hi;\n    hi.sayHello();\n    return 0;\n}\n```\n\n# 参考链接\n[Introduction to CMake by Example](http://derekmolloy.ie/hello-world-introductions-to-cmake/)\n[Jermmy's Lazy Blog--cmake学习笔记](http://jermmy.xyz/2017/04/26/2017-4-26-learn-cmake-2/)","source":"_posts/Learn-CMake-2-多文件-目录.md","raw":"---\ntitle: Learn CMake(2)--多文件/目录\ndate: 2019-04-03 10:16:23\ncategories:\n- Summary\ntags:\n- CMake\n---\n随着工程的不断扩大，我们会将工程分成不同的子模块，每个子模块用一个子文件夹管理。传统的编译方法是在每一个子目录下创建一个Makefile，然后这些Makefile由父目录中的Makefile调用。使用CMake可以有效的简化这种情况。\n<!--more-->\n# A Project with Directories\n我们把HelloWorld封装成一个类，头文件``HelloWorld.h``放在``include``文件夹里，源文件``HelloWorld.cpp``和``main.cpp``放在``src``文件夹里。(文件中具体代码在最后给出)。目录结构如下：\n```bash\naincrad@Inspiron:~/Desktop/HelloWorld$ tree\n.\n├── CMakeLists.txt\n├── include\n│   └── HelloWorld.h\n└── src\n    ├── HelloWorld.cpp\n    └── main.cpp\n\n2 directories, 4 files\n```\n这时候CMakeLists.txt中的内容如下：\n```cmake\ncmake_minimum_required(VERSION 3.5.1)\nproject(HelloWorld)\n\n#Bring the headers, such as HelloWorld.h into the project\ninclude_directories(include)\n\n#Can manually add the sources using the set command as follows:\n#set(SOURCES src/main.cpp src/HelloWorld.cpp)\n\n#However, the file(GLOB ...) allows for wildcard additions:\nfile(GLOB SOURCES \"src/*.cpp\")\n\nadd_executable(hello ${SOURCES})\n```\n解释一下CMakeLists.txt中新出现的内容：\n- ``include_directories()``命令用来把头文件加入环境中，它的参数是包含头文件的目录。另外还有一个``target_include_directories()``可以在添加头文件目录的同时指定头文件作用的目标(target)。\n- ``set()``命令可以用来设置变量，这里我们把``SOURCES``变量设置为``main.cpp``和``HelloWorld.cpp``，表示包含这两个源文件。但是因为需要手动添加所有的源文件，比较繁琐，所以这条命令被注释了，用下一行的命令代替。\n- ``file()``命令将所有的源文件添加到工程中。``GLOB``用来创建一个文件列表，读取了``src/*.cpp``中的所有源文件，并将它们赋值给``SOURCES``变量。\n- ``add_executable()``和上一个例子中直接显式使用源文件不同的是使用了``SOURCES``变量作为参数，来生成``hello``可执行文件。\n\n下面是用CMake进行编译的命令：\n```bash\n$ mkdir build\n$ cd build\n$ cmake ..\n$ make\n$ ./hello \n```\n成功编译、运行后终端打印出结果：\n```\nHello World!\n```\n\n# 文件中代码\n**HelloWorld.h**\n```c++\n#ifndef _HelloWorld_H\n#define _HelloWorld_H\n\n#include <iostream>\n\nclass HelloWorld{\npublic:\n    void sayHello(void);\n};\n\n#endif\n```\n\n**HelloWorld.cpp**\n```c++\n#include \"HelloWorld.h\"\n\nvoid HelloWorld::sayHello(){\n    std::cout << \"Hello World!\" << std::endl;\n}\n```\n\n**main.cpp**\n```c++\n#include \"../include/HelloWorld.h\"\n\nint main(int argc, char* argv[]){\n    HelloWorld hi;\n    hi.sayHello();\n    return 0;\n}\n```\n\n# 参考链接\n[Introduction to CMake by Example](http://derekmolloy.ie/hello-world-introductions-to-cmake/)\n[Jermmy's Lazy Blog--cmake学习笔记](http://jermmy.xyz/2017/04/26/2017-4-26-learn-cmake-2/)","slug":"Learn-CMake-2-多文件-目录","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nld000kh8vnzhbg0b05","comments":1,"layout":"post","photos":[],"link":""},{"title":"Learn CMake(4)--链接库文件","date":"2019-04-03T09:38:42.000Z","_content":"很多时候我们都要在程序中链接外部库文件，不论是我们自己创建的，还是第三方的（例如OpenCV）。这里介绍如何使用CMake来方便的在项目中链接库文件。\n<!--more-->\n# 链接自己的创建的库文件\n沿用上一个示例中创建的库文件，文件目录：\n```bash\naincrad@Inspiron:~/Desktop/HelloWorld$ tree\n.\n├── CMakeLists.txt\n├── include\n│   └── HelloWorld.h\n├── lib\n│   ├── libHelloWorld.a\n│   └── libHelloWorld.so\n└── src\n    └── main.cpp\n\n3 directories, 5 files\n```\n将库文件放在了lib文件夹中，因为有了库文件所以我们不再需要HelloWorld.cpp。\n\nCMakeLists.txt中的内容：\n```cmake\ncmake_minimum_required(VERSION 3.5.1)\nproject(HelloWorld_lib)\n\n#For the shared library:\nset(PROJECT_LINK_LIBS libHelloWorld.so)\nlink_directories(lib)\n\n#For the static library:\n#set(PROJECT_LINK_LIBS libHelloWorld.a)\n#link_directories(lib)\n\ninclude_directories(include)\n\nadd_executable(hello src/main.cpp)\ntarget_link_libraries(hello ${PROJECT_LINK_LIBS})\n```\n源文件main.cpp中的内容：\n```c++\n#include \"../include/HelloWorld.h\"\n\nint main(int argc, char* argv[]){\n    HelloWorld hi;\n    hi.sayHello();\n    return 0;\n}\n```\n\n# 链接第三方库文件\nCMake提供了一个``find_package()``命令来搜寻这些依赖库。比如，如果我们需要链接OpenCV库文件，可以加入以下几条命令：\n```cmake\nfind_package(OpenCV REQUIRED)\ninclude_directories(${OpenCV_INCLUDE_DIRS})\n```\n然后在``add_executable()``之后链接库文件：\n```cmake\ntarget_link_libraries(hello ${OpenCV_LIBS})\n```\n``<NAME>_FOUND``，``<NAME>_INCLUDE_DIRS``和``<NAME>_LIBS``是相应库的.cmake文件中定义好的。\n\n``find_package()``并不能保证一定可以找到相应的库，如果找不到，就需要我们手动添加路径了，类Unix系统一般都在``/usr/local/include``和``/usr/local/lib``路径下。在CMakeLists.txt文件中添加以下路径。\n```cmake\ninclude_directories(/usr/local/include)\nlink_directories(/usr/local/lib)\n```\n或者如果我们知道库源文件的具体位置(以OpenCV为例)，但其没有安装到系统目录中，添加以下命令：\n```cmake\nset(OpenCV_DIR /home/aincrad/opencv/_build)\n```\n其中第二个参数是对应库在自己计算机上的路径。\n\n# OpenCV示例\n文件目录：\n```bash\naincrad@Inspiron:~/Desktop/opencv$ tree\n.\n├── CMakeLists.txt\n├── lena_color.png\n└── main.cpp\n\n0 directories, 3 files\n```\nCMakeLists.txt中的内容：\n```cmake\ncmake_minimum_required(VERSION 3.5.1)\nproject(HelloWorld_lib)\n\nfind_package(OpenCV REQUIRED)\ninclude_directories(${OpenCV_INCLUDE_DIRS})\n\nadd_executable(img main.cpp)\ntarget_link_libraries(img ${OpenCV_LIBS})\n```\nmain.cpp中的内容：\n```c++\n#include <stdio.h>\n#include <opencv2/opencv.hpp>\n\nusing namespace cv;\n\nint main(int argc, char** argv ){\n    if ( argc != 2 )\n    {\n        printf(\"usage: DisplayImage.out <Image_Path>\\n\");\n        return -1;\n    }\n    Mat image;\n    image = imread(argv[1], 1);\n    if ( !image.data )\n    {\n        printf(\"No image data \\n\");\n        return -1;\n    }\n    namedWindow(\"Display Image\", WINDOW_AUTOSIZE );\n    imshow(\"Display Image\", image);\n    waitKey(0);\n    return 0;\n}\n```\n终端中执行以下命令后：\n```bash\n$ mkdir build\n$ cd build\n$ cmake ..\n$ make\n$ ./img ../lena_color.png\n```\n显示出lena的图片：\n![lena](/lena_color.png)\n\n# 参考链接\n[Introduction to CMake by Example](http://derekmolloy.ie/hello-world-introductions-to-cmake/)\n[Jermmy's Lazy Blog--cmake学习笔记](http://jermmy.xyz/2017/04/26/2017-4-26-learn-cmake-3/)\n[Using OpenCV with gcc and CMake](https://docs.opencv.org/3.3.0/db/df5/tutorial_linux_gcc_cmake.html)\n[CMake如何查找链接库---find_package的使用方法](https://blog.csdn.net/u011092188/article/details/61425924)\n[CMake之find_package](https://www.jianshu.com/p/46e9b8a6cb6a)","source":"_posts/Learn-CMake-4-链接库文件.md","raw":"---\ntitle: Learn CMake(4)--链接库文件\ndate: 2019-04-03 17:38:42\ncategories:\n- Summary\ntags:\n- CMake\n---\n很多时候我们都要在程序中链接外部库文件，不论是我们自己创建的，还是第三方的（例如OpenCV）。这里介绍如何使用CMake来方便的在项目中链接库文件。\n<!--more-->\n# 链接自己的创建的库文件\n沿用上一个示例中创建的库文件，文件目录：\n```bash\naincrad@Inspiron:~/Desktop/HelloWorld$ tree\n.\n├── CMakeLists.txt\n├── include\n│   └── HelloWorld.h\n├── lib\n│   ├── libHelloWorld.a\n│   └── libHelloWorld.so\n└── src\n    └── main.cpp\n\n3 directories, 5 files\n```\n将库文件放在了lib文件夹中，因为有了库文件所以我们不再需要HelloWorld.cpp。\n\nCMakeLists.txt中的内容：\n```cmake\ncmake_minimum_required(VERSION 3.5.1)\nproject(HelloWorld_lib)\n\n#For the shared library:\nset(PROJECT_LINK_LIBS libHelloWorld.so)\nlink_directories(lib)\n\n#For the static library:\n#set(PROJECT_LINK_LIBS libHelloWorld.a)\n#link_directories(lib)\n\ninclude_directories(include)\n\nadd_executable(hello src/main.cpp)\ntarget_link_libraries(hello ${PROJECT_LINK_LIBS})\n```\n源文件main.cpp中的内容：\n```c++\n#include \"../include/HelloWorld.h\"\n\nint main(int argc, char* argv[]){\n    HelloWorld hi;\n    hi.sayHello();\n    return 0;\n}\n```\n\n# 链接第三方库文件\nCMake提供了一个``find_package()``命令来搜寻这些依赖库。比如，如果我们需要链接OpenCV库文件，可以加入以下几条命令：\n```cmake\nfind_package(OpenCV REQUIRED)\ninclude_directories(${OpenCV_INCLUDE_DIRS})\n```\n然后在``add_executable()``之后链接库文件：\n```cmake\ntarget_link_libraries(hello ${OpenCV_LIBS})\n```\n``<NAME>_FOUND``，``<NAME>_INCLUDE_DIRS``和``<NAME>_LIBS``是相应库的.cmake文件中定义好的。\n\n``find_package()``并不能保证一定可以找到相应的库，如果找不到，就需要我们手动添加路径了，类Unix系统一般都在``/usr/local/include``和``/usr/local/lib``路径下。在CMakeLists.txt文件中添加以下路径。\n```cmake\ninclude_directories(/usr/local/include)\nlink_directories(/usr/local/lib)\n```\n或者如果我们知道库源文件的具体位置(以OpenCV为例)，但其没有安装到系统目录中，添加以下命令：\n```cmake\nset(OpenCV_DIR /home/aincrad/opencv/_build)\n```\n其中第二个参数是对应库在自己计算机上的路径。\n\n# OpenCV示例\n文件目录：\n```bash\naincrad@Inspiron:~/Desktop/opencv$ tree\n.\n├── CMakeLists.txt\n├── lena_color.png\n└── main.cpp\n\n0 directories, 3 files\n```\nCMakeLists.txt中的内容：\n```cmake\ncmake_minimum_required(VERSION 3.5.1)\nproject(HelloWorld_lib)\n\nfind_package(OpenCV REQUIRED)\ninclude_directories(${OpenCV_INCLUDE_DIRS})\n\nadd_executable(img main.cpp)\ntarget_link_libraries(img ${OpenCV_LIBS})\n```\nmain.cpp中的内容：\n```c++\n#include <stdio.h>\n#include <opencv2/opencv.hpp>\n\nusing namespace cv;\n\nint main(int argc, char** argv ){\n    if ( argc != 2 )\n    {\n        printf(\"usage: DisplayImage.out <Image_Path>\\n\");\n        return -1;\n    }\n    Mat image;\n    image = imread(argv[1], 1);\n    if ( !image.data )\n    {\n        printf(\"No image data \\n\");\n        return -1;\n    }\n    namedWindow(\"Display Image\", WINDOW_AUTOSIZE );\n    imshow(\"Display Image\", image);\n    waitKey(0);\n    return 0;\n}\n```\n终端中执行以下命令后：\n```bash\n$ mkdir build\n$ cd build\n$ cmake ..\n$ make\n$ ./img ../lena_color.png\n```\n显示出lena的图片：\n![lena](/lena_color.png)\n\n# 参考链接\n[Introduction to CMake by Example](http://derekmolloy.ie/hello-world-introductions-to-cmake/)\n[Jermmy's Lazy Blog--cmake学习笔记](http://jermmy.xyz/2017/04/26/2017-4-26-learn-cmake-3/)\n[Using OpenCV with gcc and CMake](https://docs.opencv.org/3.3.0/db/df5/tutorial_linux_gcc_cmake.html)\n[CMake如何查找链接库---find_package的使用方法](https://blog.csdn.net/u011092188/article/details/61425924)\n[CMake之find_package](https://www.jianshu.com/p/46e9b8a6cb6a)","slug":"Learn-CMake-4-链接库文件","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nld000lh8vnvczi8hin","comments":1,"layout":"post","photos":[],"link":""},{"title":"Learn CMake(3)--创建库文件","date":"2019-04-03T07:45:26.000Z","_content":"介绍如何用CMake编译生成动态链接库和静态链接库。\n<!--more-->\n# 静态库和动态库的区别\n[静态链接库(STATIC)和动态链接库(SHARED)](https://ain-crad.github.io/2019/04/03/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93-STATIC-%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93-SHARED/)\n\n# 建立动态链接库(.so/.dll)\n我们把上一个示例中的HelloWorld类编译成动态链接库。\n文件目录如下：\n```bash\naincrad@Inspiron:~/Desktop/HelloWorld$ tree\n.\n├── CMakeLists.txt\n├── include\n│   └── HelloWorld.h\n└── src\n    └── HelloWorld.cpp\n\n2 directories, 3 files\n```\n由于目标是建立库，而不是生成可执行文件，所以我们不需要``main.cpp``。\n\n下面是CMakeLists.txt中的内容：\n```cmake\ncmake_minimum_required(VERSION 3.5.1)\nproject(HelloWorld_lib)\nset(CMAKE_BUILD_TYPE Release)\n\n#Bring the headers, such as HelloWorld.h into the project\ninclude_directories(include)\n\n#However, the file(GLOB ...) allows for wildcard additions:\nfile(GLOB SOURCES \"src/*.cpp\")\n\n#Generate the shared library from the sources\nadd_library(HelloWorld SHARED ${SOURCES})\n\n#Set the location for library installation -- i.e., /usr/lib in this case\n# not really necessary in this example. Use \"sudo make install \" to apply\ninstall(TARGETS HelloWorld DESTINATION /usr/lib)\n```\n解释CMakeLists.txt中新出现的内容：\n- ``set(CMAKE_BUILD_TYPE Release)``表示此次编译为正式发布版本。另外还有``Debug``等模式。这个参数决定了在编译时进不进行优化或者包不包含debug信息。详细参见[Build types in CMake](https://codeyarns.com/2015/05/14/build-types-in-cmake/)\n- ``add_library()``和之前的``add_executable()``类似。不过是用来创建库文件的，``SHARED``参数表明这是一个动态库（其它选项：STATIC or MODULE）。\n- ``install()``指定了库的安装位置。使用``sudo make install``来激发，用来把链接库安装到系统中。\n\n下面是具体的编译命令：\n```cmake\n$ mkdir build\n$ cd build\n$ cmake ..\n$ make\n$ sudo make install\n```\n成功编译后会在build文件夹里生成库文件libHelloWorld.so，使用``sudo make install``安装成功后的信息：\n```bash\naincrad@Inspiron:~/Desktop/HelloWorld/build$ sudo make install\n[100%] Built target HelloWorld\nInstall the project...\n-- Install configuration: \"Release\"\n-- Installing: /usr/lib/libHelloWorld.so\n```\n\n# 建立静态链接库(.a/.lib)\n编译静态库和编译动态库的方式几乎完全一样，唯一的区别就是把``add_library()``中的``SHARED``参数改成``STATIC``。\n\n# 参考链接\n[Introduction to CMake by Example](http://derekmolloy.ie/hello-world-introductions-to-cmake/)\n[Jermmy's Lazy Blog--cmake学习笔记](http://jermmy.xyz/2017/04/26/2017-4-26-learn-cmake-3/)","source":"_posts/Learn-CMake-3-创建库文件.md","raw":"---\ntitle: Learn CMake(3)--创建库文件\ndate: 2019-04-03 15:45:26\ncategories:\n- Summary\ntags:\n- CMake\n---\n介绍如何用CMake编译生成动态链接库和静态链接库。\n<!--more-->\n# 静态库和动态库的区别\n[静态链接库(STATIC)和动态链接库(SHARED)](https://ain-crad.github.io/2019/04/03/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93-STATIC-%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93-SHARED/)\n\n# 建立动态链接库(.so/.dll)\n我们把上一个示例中的HelloWorld类编译成动态链接库。\n文件目录如下：\n```bash\naincrad@Inspiron:~/Desktop/HelloWorld$ tree\n.\n├── CMakeLists.txt\n├── include\n│   └── HelloWorld.h\n└── src\n    └── HelloWorld.cpp\n\n2 directories, 3 files\n```\n由于目标是建立库，而不是生成可执行文件，所以我们不需要``main.cpp``。\n\n下面是CMakeLists.txt中的内容：\n```cmake\ncmake_minimum_required(VERSION 3.5.1)\nproject(HelloWorld_lib)\nset(CMAKE_BUILD_TYPE Release)\n\n#Bring the headers, such as HelloWorld.h into the project\ninclude_directories(include)\n\n#However, the file(GLOB ...) allows for wildcard additions:\nfile(GLOB SOURCES \"src/*.cpp\")\n\n#Generate the shared library from the sources\nadd_library(HelloWorld SHARED ${SOURCES})\n\n#Set the location for library installation -- i.e., /usr/lib in this case\n# not really necessary in this example. Use \"sudo make install \" to apply\ninstall(TARGETS HelloWorld DESTINATION /usr/lib)\n```\n解释CMakeLists.txt中新出现的内容：\n- ``set(CMAKE_BUILD_TYPE Release)``表示此次编译为正式发布版本。另外还有``Debug``等模式。这个参数决定了在编译时进不进行优化或者包不包含debug信息。详细参见[Build types in CMake](https://codeyarns.com/2015/05/14/build-types-in-cmake/)\n- ``add_library()``和之前的``add_executable()``类似。不过是用来创建库文件的，``SHARED``参数表明这是一个动态库（其它选项：STATIC or MODULE）。\n- ``install()``指定了库的安装位置。使用``sudo make install``来激发，用来把链接库安装到系统中。\n\n下面是具体的编译命令：\n```cmake\n$ mkdir build\n$ cd build\n$ cmake ..\n$ make\n$ sudo make install\n```\n成功编译后会在build文件夹里生成库文件libHelloWorld.so，使用``sudo make install``安装成功后的信息：\n```bash\naincrad@Inspiron:~/Desktop/HelloWorld/build$ sudo make install\n[100%] Built target HelloWorld\nInstall the project...\n-- Install configuration: \"Release\"\n-- Installing: /usr/lib/libHelloWorld.so\n```\n\n# 建立静态链接库(.a/.lib)\n编译静态库和编译动态库的方式几乎完全一样，唯一的区别就是把``add_library()``中的``SHARED``参数改成``STATIC``。\n\n# 参考链接\n[Introduction to CMake by Example](http://derekmolloy.ie/hello-world-introductions-to-cmake/)\n[Jermmy's Lazy Blog--cmake学习笔记](http://jermmy.xyz/2017/04/26/2017-4-26-learn-cmake-3/)","slug":"Learn-CMake-3-创建库文件","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nle000mh8vniggb599t","comments":1,"layout":"post","photos":[],"link":""},{"title":"Maze","date":"2019-03-26T05:23:44.000Z","_content":"第十届蓝桥杯省赛D题，迷宫求从(0，0)－>(n，m)的最短路径。\n本来如果只是求最短路的话倒没什么，一遍BFS就可以解决。但是要求如果存在多条最短路，取路径字典序最小的那条。其中路径由``U D L R``四种字符组成，分别表示``上 下 左 右``。\n譬如，下面这个迷宫的最短路为``DRRURRDDDR``。\n![maze](/maze.png)\n<!--more-->\n# 题解\n*这道题和之前整理过的[Uva1599](https://ain-crad.github.io/2018/11/18/Uva1599-Ideal-Path/)有点类似。*\n一种策略是和Uva1599的做法一样，先从终点开始反向求一遍BFS，再根据距离信息从起点出发选择方向字典序小的走直到终点。\n和Uva1599不同的是，这道题中每个位置相邻的四个可走方向优先级固定，且不存在优先级相同的情况，所以另一种策略是直接从起点BFS每次优先把方向字典序小的位置加入队列中，并记录路径。\n\n# 代码\n*题目中给定了一个maze.txt，代码是根据文件中的迷宫来写的。*\n*[maze.txt以及原题pdf链接](https://github.com/Ain-Crad/ACM/tree/master/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF/Problems)*\n## 策略1\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 26 Mar 13:55:33 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100;\nchar maze[maxn][maxn];\nint dis[maxn][maxn];\nbool vis[maxn][maxn];\nint n = 30, m = 50;\nint dx[] = {1, 0, 0, -1};\nint dy[] = {0, -1, 1, 0};\nchar dir[] = {'D', 'L', 'R', 'U'};\nstruct Node{\n    int x, y;\n    Node(int x = 0, int y = 0):x(x), y(y){}\n};\n\nvoid back_bfs(){\n    queue<Node> que;\n    que.push(Node(n - 1, m - 1));\n    dis[n - 1][m - 1] = 0;\n    vis[n - 1][m - 1] = 1;\n\n    while(!que.empty()){\n        Node node = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = node.x + dx[i], ny = node.y + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny] && maze[nx][ny] == '0'){\n                que.push(Node(nx, ny));\n                dis[nx][ny] = dis[node.x][node.y] + 1;\n                vis[nx][ny] = 1;\n            }\n        }\n    }\n}\n\nvoid bfs(){\n    vector<char> vec;\n    queue<Node> que;\n    que.push(Node(0, 0));\n    int len = dis[0][0];\n    for(int k = 0; k < len; k++){\n        Node node = que.front();\n        que.pop();\n        if(node.x == n - 1 && node.y == m - 1) break;\n        for(int i = 0; i < 4; i++){\n            int nx = node.x + dx[i], ny = node.y + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < m && dis[nx][ny] == dis[node.x][node.y] - 1){\n                vec.push_back(dir[i]);\n                que.push(Node(nx, ny));\n                break;\n            }\n        }\n    }\n\n    for(auto x : vec){\n        cout << x;\n    }\n    cout << endl;\n}\n\nint main(){\n    freopen(\"maze.txt\", \"r\", stdin);\n    memset(dis, -1, sizeof(dis));\n    memset(vis, 0, sizeof(vis));\n    for(int i = 0; i < n; i++){\n        gets(maze[i]);\n    }\n    back_bfs();\n    bfs();\n\n    return 0;\n}\n```\n## 策略2\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 26 Mar 20:02:33 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100;\nint n = 30, m = 50;\nchar maze[maxn][maxn];\nbool vis[maxn][maxn];\nint dis[maxn][maxn];\nint dx[] = {1, 0, 0, -1};\nint dy[] = {0, -1, 1, 0};\n\nstruct Node{\n    int x, y;\n    Node(int x = 0, int y = 0):x(x), y(y){}\n};\nNode pre[maxn][maxn];\n\nvoid bfs(){\n    queue<Node> que;\n    que.push(Node(0, 0));\n    vis[0][0] = 1;\n    dis[0][0] = 0;\n\n    while(!que.empty()){\n        Node node = que.front();\n        que.pop();\n        if(node.x == n - 1 && node.y == m - 1) break;\n        for(int i = 0; i < 4; i++){\n            int nx = node.x + dx[i], ny = node.y + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny] && maze[nx][ny] == '0'){\n                dis[nx][ny] = dis[node.x][node.y] + 1;\n                vis[nx][ny] = 1;\n                pre[nx][ny] = node;\n                que.push(Node(nx, ny));\n            }\n        }\n    }\n}\n\nvoid printPath(){\n    vector<char> vec;\n    int len = dis[n - 1][m - 1];\n    int x = n - 1, y = m - 1;\n    for(int i = 0; i < len; i++){\n        if(pre[x][y].x - x == -1 && pre[x][y].y - y == 0)\n            vec.push_back('D');\n        else if(pre[x][y].x - x == 0 && pre[x][y].y - y == 1)\n            vec.push_back('L');\n        else if(pre[x][y].x - x == 0 && pre[x][y].y - y == -1)\n            vec.push_back('R');\n        else if(pre[x][y].x - x == 1 && pre[x][y].y - y == 0)\n            vec.push_back('U');\n\n        //坑点，卡了好久，一开始直接另x = pre[x][y].x, y = pre[x][y].y, 这样就在赋值过程中改变了原始值。\n        int x_tmp = pre[x][y].x, y_tmp = pre[x][y].y; \n        x = x_tmp, y = y_tmp;\n    }\n\n    reverse(vec.begin(), vec.end());\n\n    for(auto x : vec){\n        cout << x;\n    }\n    cout << endl;\n}\n\nint main(){\n    freopen(\"maze.txt\", \"r\", stdin);\n    freopen(\"c1out.txt\", \"w\", stdout);\n    memset(vis, 0, sizeof(vis));\n    memset(dis, -1, sizeof(dis));\n    for(int i = 0; i < n; i++){\n        fgets(maze[i], sizeof(maze[i]), stdin);\n    }\n\n    bfs();\n    printPath();\n\n    return 0;\n}\n```\n","source":"_posts/Maze.md","raw":"---\ntitle: Maze\ndate: 2019-03-26 13:23:44\ncategories:\n- ACM\ntags:\n- BFS\n---\n第十届蓝桥杯省赛D题，迷宫求从(0，0)－>(n，m)的最短路径。\n本来如果只是求最短路的话倒没什么，一遍BFS就可以解决。但是要求如果存在多条最短路，取路径字典序最小的那条。其中路径由``U D L R``四种字符组成，分别表示``上 下 左 右``。\n譬如，下面这个迷宫的最短路为``DRRURRDDDR``。\n![maze](/maze.png)\n<!--more-->\n# 题解\n*这道题和之前整理过的[Uva1599](https://ain-crad.github.io/2018/11/18/Uva1599-Ideal-Path/)有点类似。*\n一种策略是和Uva1599的做法一样，先从终点开始反向求一遍BFS，再根据距离信息从起点出发选择方向字典序小的走直到终点。\n和Uva1599不同的是，这道题中每个位置相邻的四个可走方向优先级固定，且不存在优先级相同的情况，所以另一种策略是直接从起点BFS每次优先把方向字典序小的位置加入队列中，并记录路径。\n\n# 代码\n*题目中给定了一个maze.txt，代码是根据文件中的迷宫来写的。*\n*[maze.txt以及原题pdf链接](https://github.com/Ain-Crad/ACM/tree/master/%E7%AC%AC%E5%8D%81%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF/Problems)*\n## 策略1\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 26 Mar 13:55:33 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100;\nchar maze[maxn][maxn];\nint dis[maxn][maxn];\nbool vis[maxn][maxn];\nint n = 30, m = 50;\nint dx[] = {1, 0, 0, -1};\nint dy[] = {0, -1, 1, 0};\nchar dir[] = {'D', 'L', 'R', 'U'};\nstruct Node{\n    int x, y;\n    Node(int x = 0, int y = 0):x(x), y(y){}\n};\n\nvoid back_bfs(){\n    queue<Node> que;\n    que.push(Node(n - 1, m - 1));\n    dis[n - 1][m - 1] = 0;\n    vis[n - 1][m - 1] = 1;\n\n    while(!que.empty()){\n        Node node = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = node.x + dx[i], ny = node.y + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny] && maze[nx][ny] == '0'){\n                que.push(Node(nx, ny));\n                dis[nx][ny] = dis[node.x][node.y] + 1;\n                vis[nx][ny] = 1;\n            }\n        }\n    }\n}\n\nvoid bfs(){\n    vector<char> vec;\n    queue<Node> que;\n    que.push(Node(0, 0));\n    int len = dis[0][0];\n    for(int k = 0; k < len; k++){\n        Node node = que.front();\n        que.pop();\n        if(node.x == n - 1 && node.y == m - 1) break;\n        for(int i = 0; i < 4; i++){\n            int nx = node.x + dx[i], ny = node.y + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < m && dis[nx][ny] == dis[node.x][node.y] - 1){\n                vec.push_back(dir[i]);\n                que.push(Node(nx, ny));\n                break;\n            }\n        }\n    }\n\n    for(auto x : vec){\n        cout << x;\n    }\n    cout << endl;\n}\n\nint main(){\n    freopen(\"maze.txt\", \"r\", stdin);\n    memset(dis, -1, sizeof(dis));\n    memset(vis, 0, sizeof(vis));\n    for(int i = 0; i < n; i++){\n        gets(maze[i]);\n    }\n    back_bfs();\n    bfs();\n\n    return 0;\n}\n```\n## 策略2\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 26 Mar 20:02:33 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100;\nint n = 30, m = 50;\nchar maze[maxn][maxn];\nbool vis[maxn][maxn];\nint dis[maxn][maxn];\nint dx[] = {1, 0, 0, -1};\nint dy[] = {0, -1, 1, 0};\n\nstruct Node{\n    int x, y;\n    Node(int x = 0, int y = 0):x(x), y(y){}\n};\nNode pre[maxn][maxn];\n\nvoid bfs(){\n    queue<Node> que;\n    que.push(Node(0, 0));\n    vis[0][0] = 1;\n    dis[0][0] = 0;\n\n    while(!que.empty()){\n        Node node = que.front();\n        que.pop();\n        if(node.x == n - 1 && node.y == m - 1) break;\n        for(int i = 0; i < 4; i++){\n            int nx = node.x + dx[i], ny = node.y + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny] && maze[nx][ny] == '0'){\n                dis[nx][ny] = dis[node.x][node.y] + 1;\n                vis[nx][ny] = 1;\n                pre[nx][ny] = node;\n                que.push(Node(nx, ny));\n            }\n        }\n    }\n}\n\nvoid printPath(){\n    vector<char> vec;\n    int len = dis[n - 1][m - 1];\n    int x = n - 1, y = m - 1;\n    for(int i = 0; i < len; i++){\n        if(pre[x][y].x - x == -1 && pre[x][y].y - y == 0)\n            vec.push_back('D');\n        else if(pre[x][y].x - x == 0 && pre[x][y].y - y == 1)\n            vec.push_back('L');\n        else if(pre[x][y].x - x == 0 && pre[x][y].y - y == -1)\n            vec.push_back('R');\n        else if(pre[x][y].x - x == 1 && pre[x][y].y - y == 0)\n            vec.push_back('U');\n\n        //坑点，卡了好久，一开始直接另x = pre[x][y].x, y = pre[x][y].y, 这样就在赋值过程中改变了原始值。\n        int x_tmp = pre[x][y].x, y_tmp = pre[x][y].y; \n        x = x_tmp, y = y_tmp;\n    }\n\n    reverse(vec.begin(), vec.end());\n\n    for(auto x : vec){\n        cout << x;\n    }\n    cout << endl;\n}\n\nint main(){\n    freopen(\"maze.txt\", \"r\", stdin);\n    freopen(\"c1out.txt\", \"w\", stdout);\n    memset(vis, 0, sizeof(vis));\n    memset(dis, -1, sizeof(dis));\n    for(int i = 0; i < n; i++){\n        fgets(maze[i], sizeof(maze[i]), stdin);\n    }\n\n    bfs();\n    printPath();\n\n    return 0;\n}\n```\n","slug":"Maze","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nle000nh8vnxeoxx93g","comments":1,"layout":"post","photos":[],"link":""},{"title":"牛客暑期ACM多校训练营(第四场)G题-Maxinum Mode-思维+map","date":"2018-07-29T12:06:46.000Z","_content":"一道逆向思维的好题,比赛的时候没有做出来,赛后补题的时候按原来的思路写出来了,然而代码超时了= =,阅读了别人的代码后发现自己想复杂了,从逆向来考虑感觉非常巧妙,思路也很顺畅.从正向考虑反而要顾及很多情况,可能就是因为考虑的太多代码冗余就TLE了.\n<!-- more -->\n# 链接\n[Nowcoder-Fourth-G](https://www.nowcoder.com/acm/contest/142/G)\n# 题目描述\nThe mode of an integer sequence is the value that appears most often. Chiaki has n integers a1,a2,...,an. She woud like to delete exactly m of them such that: the rest integers have only one mode and the mode is maximum.\n输入描述:\nThere are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:\nThe first line contains two integers n and m (1 ≤ n ≤ 105, 0 ≤ m < n) -- the length of the sequence and the number of integers to delete.\nThe second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) denoting the sequence.\nIt is guaranteed that the sum of all n does not exceed 106.\n输出描述:\nFor each test case, output an integer denoting the only maximum mode, or -1 if Chiaki cannot achieve it.\n输入:\n5\n5 0\n2 2 3 3 4\n5 1\n2 2 3 3 4\n5 2\n2 2 3 3 4\n5 3\n2 2 3 3 4\n5 4\n2 2 3 3 4\n输出:\n-1\n3\n3\n3\n4\n# 题解\n题目大意是给定n个数,从这n个数中删掉m个数,使得出现次数最多的数只有一个且要求尽量大.求解这个出现次数最多的数.\n思路:\nmap存数据及数据个数, 按键值从大到小排(实际上map会按键值从小到大自动排列,那么就从后往前判断就好了).然后不考虑删除数的情况而是考虑剩余数(逆向思维)的情况,首先判断剩余数的个数是否小于等于最大值的个数,若满足则最终的结果就是最大值;若不满足则把剩余的数进行分配,看是否可以在满足min(d[max] - 1,d[i])的分配条件下将剩余的数分配完(其中d[i]表示第i个数的个数,用d[max]表示了最大的数的个数),如果可以分配完则最终结果就是最大值.若最大值不能满足上述情况则考虑次大值,以此类推,若全都不满足则无解,输出-1.\n\n# 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\ntypedef pair<int, int> P;\nP d[maxn];\nint t;\nint n, m;\nmap<int, int> mp;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &t);\n    while(t--){\n        mp.clear();\n        scanf(\"%d%d\", &n, &m);\n        int tmp;\n        for(int i = 0; i < n; i++){\n            scanf(\"%d\", &tmp);\n            mp[tmp]++;\n        }\n        \n        int cnt = 0;\n        for(auto x : mp){\n            d[cnt].first = x.first;\n            d[cnt].second = x.second;\n            cnt++;\n        }\n        \n        int flag = 0;\n        int rem = n - m;//剩余数的个数\n        int i;\n        for(i = cnt - 1; i >= 0; i--){\n            int res = rem - d[i].second;\n            if(res <= 0){\n                flag = 1;\n                break;\n            }\n            for(int j = 0; j < cnt; j++){\n                if(j == i) continue;\n                res -= min(d[i].second - 1, d[j].second);\n                if(res <= 0){\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag) break;\n        }\n        \n        if(flag) printf(\"%d\\n\", d[i].first);\n        else printf(\"-1\\n\");\n    }\n    \n    return 0;\n}\n```","source":"_posts/Nowcoder-Fourth-G.md","raw":"---\ntitle: 牛客暑期ACM多校训练营(第四场)G题-Maxinum Mode-思维+map\ndate: 2018-07-29 20:06:46\ncategories:\n- ACM\n- 思维\ntags:\n- 逆向思维\n---\n一道逆向思维的好题,比赛的时候没有做出来,赛后补题的时候按原来的思路写出来了,然而代码超时了= =,阅读了别人的代码后发现自己想复杂了,从逆向来考虑感觉非常巧妙,思路也很顺畅.从正向考虑反而要顾及很多情况,可能就是因为考虑的太多代码冗余就TLE了.\n<!-- more -->\n# 链接\n[Nowcoder-Fourth-G](https://www.nowcoder.com/acm/contest/142/G)\n# 题目描述\nThe mode of an integer sequence is the value that appears most often. Chiaki has n integers a1,a2,...,an. She woud like to delete exactly m of them such that: the rest integers have only one mode and the mode is maximum.\n输入描述:\nThere are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:\nThe first line contains two integers n and m (1 ≤ n ≤ 105, 0 ≤ m < n) -- the length of the sequence and the number of integers to delete.\nThe second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) denoting the sequence.\nIt is guaranteed that the sum of all n does not exceed 106.\n输出描述:\nFor each test case, output an integer denoting the only maximum mode, or -1 if Chiaki cannot achieve it.\n输入:\n5\n5 0\n2 2 3 3 4\n5 1\n2 2 3 3 4\n5 2\n2 2 3 3 4\n5 3\n2 2 3 3 4\n5 4\n2 2 3 3 4\n输出:\n-1\n3\n3\n3\n4\n# 题解\n题目大意是给定n个数,从这n个数中删掉m个数,使得出现次数最多的数只有一个且要求尽量大.求解这个出现次数最多的数.\n思路:\nmap存数据及数据个数, 按键值从大到小排(实际上map会按键值从小到大自动排列,那么就从后往前判断就好了).然后不考虑删除数的情况而是考虑剩余数(逆向思维)的情况,首先判断剩余数的个数是否小于等于最大值的个数,若满足则最终的结果就是最大值;若不满足则把剩余的数进行分配,看是否可以在满足min(d[max] - 1,d[i])的分配条件下将剩余的数分配完(其中d[i]表示第i个数的个数,用d[max]表示了最大的数的个数),如果可以分配完则最终结果就是最大值.若最大值不能满足上述情况则考虑次大值,以此类推,若全都不满足则无解,输出-1.\n\n# 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\ntypedef pair<int, int> P;\nP d[maxn];\nint t;\nint n, m;\nmap<int, int> mp;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &t);\n    while(t--){\n        mp.clear();\n        scanf(\"%d%d\", &n, &m);\n        int tmp;\n        for(int i = 0; i < n; i++){\n            scanf(\"%d\", &tmp);\n            mp[tmp]++;\n        }\n        \n        int cnt = 0;\n        for(auto x : mp){\n            d[cnt].first = x.first;\n            d[cnt].second = x.second;\n            cnt++;\n        }\n        \n        int flag = 0;\n        int rem = n - m;//剩余数的个数\n        int i;\n        for(i = cnt - 1; i >= 0; i--){\n            int res = rem - d[i].second;\n            if(res <= 0){\n                flag = 1;\n                break;\n            }\n            for(int j = 0; j < cnt; j++){\n                if(j == i) continue;\n                res -= min(d[i].second - 1, d[j].second);\n                if(res <= 0){\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag) break;\n        }\n        \n        if(flag) printf(\"%d\\n\", d[i].first);\n        else printf(\"-1\\n\");\n    }\n    \n    return 0;\n}\n```","slug":"Nowcoder-Fourth-G","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nlf000oh8vnbuefy5nk","comments":1,"layout":"post","photos":[],"link":""},{"title":"PCA-主成分分析","date":"2019-03-27T08:20:45.000Z","_content":"重温了线性代数基变换、特征值、特征向量和协方差矩阵。趁热打铁，记录一下它们在PCA中的应用。\n![pca](/pca.jpeg)\n*图片来源[Jermmy's Lazy Blog-PCA，到底在做什么](http://jermmy.xyz/2017/12/14/2017-12-15-PCA-another-view/)*\n<!--more-->\n# 概念\n[Wikiwand](https://www.wikiwand.com/zh-hans/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90)：主成分分析(PCA)是一种分析、简化数据集的技术。经常用于减少数据集的维数，同时保持数据集中的对方差贡献最大的特征。\n简单来说，PCA可以将数据进行压缩，并且是在尽量少的丢失信息的情况下进行压缩，方便加速对数据的处理速度。\n\n# 算法流程\n```\n    样本数据中心化、标准化 //变量减去均值，再除以标准差\n\n    计算样本数据的协方差矩阵Cov\n\n    计算Cov的特征向量，构造特征向量矩阵A\n\n    把Cov变换到以A中各特征向量为基向量的空间中 //已A的视角来看Cov\n\n    根据变换的Cov，提取特征值最大的前k个特征向量，组成新的变换矩阵B\n\n    将样本数据进行矩阵B表示的变换，得到新的降维后样本数据\n```\n*数据中心化和标准化是为了使得不同的特征数据具有相同的尺度*\n\n假设数据样本矩阵$D(n\\times{m})$表示m个样本n维特征，则协方差矩阵$Cov(n\\times{n})$，其特征向量矩阵$A(n\\times{n})$，取前k维特征向量$B(n\\times{k})$，那么降维后的数据：\n$$\nD_{PCA}(k\\times{m})=B^T(k\\times{n})\\cdot{D(n\\times{m})}\n$$\n\n# PCA的意义\nPCA的意义要从协方差矩阵说起，协方差矩阵表示各个变量之间的关系，包括各自变量之间的方差。将Cov在以其特征向量为基向量构成的空间中的来观察：\n$$\nA^{-1}CovA=\n    \\begin{bmatrix}\n    \\lambda_{1} & \\quad & \\quad & 0 \\\\\\\\\n    \\quad & \\lambda_{2} & \\quad & \\quad \\\\\\\\\n    \\quad & \\quad & \\ddots & \\quad \\\\\\\\\n    0 & \\quad & \\quad & \\lambda_{n}\n    \\end{bmatrix}\n$$\n\n关于为什么矩阵在以其特征向量为基向量的空间中来看是一个**对角阵**，且对角元素为各个**特征值**，可以参考3Blue1Brown的线性代数教程的[9-基变换](https://www.bilibili.com/video/av6500834/?spm_id_from=333.788.videocard.2)和[10-特征向量和特征值](https://www.bilibili.com/video/av6540378/?spm_id_from=333.788.videocard.1)。看完后会对这个变换过程有一个非常直观的理解。\n上面说到协方差矩阵表示了各个变量之间和自身的关系，现在变换后的协方差矩阵除了对角线元素外，其它位置都变成0了，也就是说**各个变量之间被去相关性了！**在这空间下各个变量是**独立的**，去除了数据之间的冗余。\n接下来我们选取特征值最大的前k个特征向量，由其组成新的变换矩阵B。之所以选择特征值大的，是因为**特征值**所在的对角位置是协方差矩阵表示**方差**的位置，方差越大，说明该特征变量越分散，信息量越大，压缩后越不容易恢复，所以我们保留它们而舍弃那些包含信息量小的特征变量。\n最后我们只需要把样本数据投影到以提取出的k个特征向量为基向量的空间中。\n\n*如最开始的图中，在三维数据中找到两个独立的主特征，并将三维数据投影降维到了二维平面上实现数据降维。*\n\n# 参考\n[Jermmy's Lazy Blog-PCA，到底在做什么](http://jermmy.xyz/2017/12/14/2017-12-15-PCA-another-view/)\n[3Blue1Brown线性代数的本质-9-基变换](https://www.bilibili.com/video/av6500834/?spm_id_from=333.788.videocard.2)\n[3Blue1Brown线性代数的本质-10-特征向量和特征值](https://www.bilibili.com/video/av6540378/?spm_id_from=333.788.videocard.1)","source":"_posts/PCA-主成分分析.md","raw":"---\ntitle: PCA-主成分分析\ndate: 2019-03-27 16:20:45\ncategories:\n- Math\ntags:\n- PCA\n---\n重温了线性代数基变换、特征值、特征向量和协方差矩阵。趁热打铁，记录一下它们在PCA中的应用。\n![pca](/pca.jpeg)\n*图片来源[Jermmy's Lazy Blog-PCA，到底在做什么](http://jermmy.xyz/2017/12/14/2017-12-15-PCA-another-view/)*\n<!--more-->\n# 概念\n[Wikiwand](https://www.wikiwand.com/zh-hans/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90)：主成分分析(PCA)是一种分析、简化数据集的技术。经常用于减少数据集的维数，同时保持数据集中的对方差贡献最大的特征。\n简单来说，PCA可以将数据进行压缩，并且是在尽量少的丢失信息的情况下进行压缩，方便加速对数据的处理速度。\n\n# 算法流程\n```\n    样本数据中心化、标准化 //变量减去均值，再除以标准差\n\n    计算样本数据的协方差矩阵Cov\n\n    计算Cov的特征向量，构造特征向量矩阵A\n\n    把Cov变换到以A中各特征向量为基向量的空间中 //已A的视角来看Cov\n\n    根据变换的Cov，提取特征值最大的前k个特征向量，组成新的变换矩阵B\n\n    将样本数据进行矩阵B表示的变换，得到新的降维后样本数据\n```\n*数据中心化和标准化是为了使得不同的特征数据具有相同的尺度*\n\n假设数据样本矩阵$D(n\\times{m})$表示m个样本n维特征，则协方差矩阵$Cov(n\\times{n})$，其特征向量矩阵$A(n\\times{n})$，取前k维特征向量$B(n\\times{k})$，那么降维后的数据：\n$$\nD_{PCA}(k\\times{m})=B^T(k\\times{n})\\cdot{D(n\\times{m})}\n$$\n\n# PCA的意义\nPCA的意义要从协方差矩阵说起，协方差矩阵表示各个变量之间的关系，包括各自变量之间的方差。将Cov在以其特征向量为基向量构成的空间中的来观察：\n$$\nA^{-1}CovA=\n    \\begin{bmatrix}\n    \\lambda_{1} & \\quad & \\quad & 0 \\\\\\\\\n    \\quad & \\lambda_{2} & \\quad & \\quad \\\\\\\\\n    \\quad & \\quad & \\ddots & \\quad \\\\\\\\\n    0 & \\quad & \\quad & \\lambda_{n}\n    \\end{bmatrix}\n$$\n\n关于为什么矩阵在以其特征向量为基向量的空间中来看是一个**对角阵**，且对角元素为各个**特征值**，可以参考3Blue1Brown的线性代数教程的[9-基变换](https://www.bilibili.com/video/av6500834/?spm_id_from=333.788.videocard.2)和[10-特征向量和特征值](https://www.bilibili.com/video/av6540378/?spm_id_from=333.788.videocard.1)。看完后会对这个变换过程有一个非常直观的理解。\n上面说到协方差矩阵表示了各个变量之间和自身的关系，现在变换后的协方差矩阵除了对角线元素外，其它位置都变成0了，也就是说**各个变量之间被去相关性了！**在这空间下各个变量是**独立的**，去除了数据之间的冗余。\n接下来我们选取特征值最大的前k个特征向量，由其组成新的变换矩阵B。之所以选择特征值大的，是因为**特征值**所在的对角位置是协方差矩阵表示**方差**的位置，方差越大，说明该特征变量越分散，信息量越大，压缩后越不容易恢复，所以我们保留它们而舍弃那些包含信息量小的特征变量。\n最后我们只需要把样本数据投影到以提取出的k个特征向量为基向量的空间中。\n\n*如最开始的图中，在三维数据中找到两个独立的主特征，并将三维数据投影降维到了二维平面上实现数据降维。*\n\n# 参考\n[Jermmy's Lazy Blog-PCA，到底在做什么](http://jermmy.xyz/2017/12/14/2017-12-15-PCA-another-view/)\n[3Blue1Brown线性代数的本质-9-基变换](https://www.bilibili.com/video/av6500834/?spm_id_from=333.788.videocard.2)\n[3Blue1Brown线性代数的本质-10-特征向量和特征值](https://www.bilibili.com/video/av6540378/?spm_id_from=333.788.videocard.1)","slug":"PCA-主成分分析","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nlf000ph8vnp0w1bpjh","comments":1,"layout":"post","photos":[],"link":""},{"title":"直观理解线性代数-点积","date":"2018-10-24T13:56:50.000Z","_content":"我们都知道两个向量 $\\vec{a}$，$\\vec{b}$ 的点积可以想象为 $\\vec{a}$ 朝 $\\vec{b}$ 方向上的投影长度乘以 $\\vec{b}$ 的长度。其中结果的正负代表方向，两个向量成锐角则大于$0$，成钝角则小于$0$。\n\n可是为什么可以这样做呢，这要从线性代数的本质说起。致敬[3Blue1Brown](http://www.3blue1brown.com/)，一个热爱数学，并教你如何从直观上去理解数学的团队，将只停留在数值运算和公式的线性代数推进到可视化几何直观的领悟上，在B站上可以找到搬运的系列视频[线性代数的本质](https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8)。\n<!-- more -->\n```\n卡尔文：你知道吗，我觉得数学不是一门科学，而是一种宗教\n霍布斯：一种宗教？\n卡尔文：是啊。这些公式就像奇迹一般。你取出两个数，把它们相加时，它们神奇地成为了一个全新\n的数！没人能说清这到底是怎么发生的。你要么完全相信，要么完全不信。\n```\n# 点积与投影\n视频里关于点积和投影对应的那一部分个人觉得不太好理解，自己也花了挺久才理解，在这里记录一下，并提供一种理解方式。\n\n***以下图片均来自3Blue1Brown发布的线性代数的本质系列视频，直接来源为[Go Further的博客](https://charlesliuyx.github.io/2017/10/06/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/#%E7%82%B9%E7%A7%AF%E4%B8%8E%E5%AF%B9%E5%81%B6%E6%80%A7)***\n\n**首先来看点积的运算：**\n\n两个维数相同的向量做点积，就是把他们对应坐标相乘再相加。\n\n<div style=\"width: 300px; margin: auto\">\n    ![1.gif](/1.gif)\n</div>\n\n我们假设图中的两个向量分别为 $\\vec{a}$ 和 $\\vec{b}$， 我们可以发现点积的运算和将向量 $\\vec{a}$ 转置为 $1*4$ 的矩阵再和 $\\vec{b}$ 做相乘的结果是一样的。从这里入手我们来分析一下矩阵相乘和投影的关系。\n\n**投影：**\n\n任取坐标系中的一条直线作为投影直线，同时在这条直线上取一个单位向量 $\\vec{u}$，设它的坐标为$(u_x，u_y)$。\n\n<div style=\"width: 500px; margin: auto\">\n    ![2.gif](/2.gif)\n</div>\n\n投影是一种线性变换，矩阵的意义就是表示线性变换，所以这个二维空间中的任意一个向量在这条直线上的投影变换都可以用一个矩阵表示出来，至于这个矩阵是什么，我们只需要考虑基向量的变换。(***至于为什么矩阵的意义是线性变换以及为什么用矩阵描述一个变换只需要考虑基向量的变换请移步[线性代数的本质](https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8)***)\n\n<div style=\"width: 500px; margin: auto\">\n    ![3.gif](/3.gif)\n</div>\n\n上图运用对称性得到基向量 $\\vec{i}$ 和 $\\vec{j}$ 在直线上的投影分别为$u_x$ 和 $u_y$，所以这个投影变换的矩阵也就是\n\n$$\n \\begin{bmatrix}\n   u_x & u_y\n  \\end{bmatrix}\n$$\n\n所以二维空间中任一向量 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 在单位向量 $\\vec{u}$ 所在直线上的投影值为\n\n$$\n \\left[\n \\begin{matrix}\n   u_x & u_y\n  \\end{matrix}\n  \\right]\n  \\left[\n  \\begin{matrix}\n   x \\\\\\\\\n   y\n  \\end{matrix}\n  \\right]\n$$\n\n**把矩阵$\\begin{bmatrix} u_x & u_y \\end{bmatrix}$转置一下，就变成了点积的定义，这也就是为什么向量的点积可以和几何投影对应起来。**\n\n上面是以单位向量 $\\vec{u}$ 为例，如果 $\\vec{u}$ 不是单位向量怎么理解呢？\n\n其实也很简单，把 $\\vec{u}$ 归一化成单位向量 $\\vec{u_0}$，前面提取出一个系数 $c$，这个系数也就是 $\\vec{u}$ 的长度。那么空间中任意向量 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 和 $\\vec{u}$ 的点积可以先看做 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 和 $\\vec{u_0}$ 的点积，也就是上面的投影过程，最后再乘以 $c$，也就是 $\\vec{u}$ 的长度。\n\n完美对应。\n","source":"_posts/Linear algebra-Dot product.md","raw":"---\ntitle: 直观理解线性代数-点积\ndate: 2018-10-24 21:56:50\ncategories:\n- Math\ntags:\n- 总结\n- Liner algebra\n---\n我们都知道两个向量 $\\vec{a}$，$\\vec{b}$ 的点积可以想象为 $\\vec{a}$ 朝 $\\vec{b}$ 方向上的投影长度乘以 $\\vec{b}$ 的长度。其中结果的正负代表方向，两个向量成锐角则大于$0$，成钝角则小于$0$。\n\n可是为什么可以这样做呢，这要从线性代数的本质说起。致敬[3Blue1Brown](http://www.3blue1brown.com/)，一个热爱数学，并教你如何从直观上去理解数学的团队，将只停留在数值运算和公式的线性代数推进到可视化几何直观的领悟上，在B站上可以找到搬运的系列视频[线性代数的本质](https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8)。\n<!-- more -->\n```\n卡尔文：你知道吗，我觉得数学不是一门科学，而是一种宗教\n霍布斯：一种宗教？\n卡尔文：是啊。这些公式就像奇迹一般。你取出两个数，把它们相加时，它们神奇地成为了一个全新\n的数！没人能说清这到底是怎么发生的。你要么完全相信，要么完全不信。\n```\n# 点积与投影\n视频里关于点积和投影对应的那一部分个人觉得不太好理解，自己也花了挺久才理解，在这里记录一下，并提供一种理解方式。\n\n***以下图片均来自3Blue1Brown发布的线性代数的本质系列视频，直接来源为[Go Further的博客](https://charlesliuyx.github.io/2017/10/06/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/#%E7%82%B9%E7%A7%AF%E4%B8%8E%E5%AF%B9%E5%81%B6%E6%80%A7)***\n\n**首先来看点积的运算：**\n\n两个维数相同的向量做点积，就是把他们对应坐标相乘再相加。\n\n<div style=\"width: 300px; margin: auto\">\n    ![1.gif](/1.gif)\n</div>\n\n我们假设图中的两个向量分别为 $\\vec{a}$ 和 $\\vec{b}$， 我们可以发现点积的运算和将向量 $\\vec{a}$ 转置为 $1*4$ 的矩阵再和 $\\vec{b}$ 做相乘的结果是一样的。从这里入手我们来分析一下矩阵相乘和投影的关系。\n\n**投影：**\n\n任取坐标系中的一条直线作为投影直线，同时在这条直线上取一个单位向量 $\\vec{u}$，设它的坐标为$(u_x，u_y)$。\n\n<div style=\"width: 500px; margin: auto\">\n    ![2.gif](/2.gif)\n</div>\n\n投影是一种线性变换，矩阵的意义就是表示线性变换，所以这个二维空间中的任意一个向量在这条直线上的投影变换都可以用一个矩阵表示出来，至于这个矩阵是什么，我们只需要考虑基向量的变换。(***至于为什么矩阵的意义是线性变换以及为什么用矩阵描述一个变换只需要考虑基向量的变换请移步[线性代数的本质](https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8)***)\n\n<div style=\"width: 500px; margin: auto\">\n    ![3.gif](/3.gif)\n</div>\n\n上图运用对称性得到基向量 $\\vec{i}$ 和 $\\vec{j}$ 在直线上的投影分别为$u_x$ 和 $u_y$，所以这个投影变换的矩阵也就是\n\n$$\n \\begin{bmatrix}\n   u_x & u_y\n  \\end{bmatrix}\n$$\n\n所以二维空间中任一向量 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 在单位向量 $\\vec{u}$ 所在直线上的投影值为\n\n$$\n \\left[\n \\begin{matrix}\n   u_x & u_y\n  \\end{matrix}\n  \\right]\n  \\left[\n  \\begin{matrix}\n   x \\\\\\\\\n   y\n  \\end{matrix}\n  \\right]\n$$\n\n**把矩阵$\\begin{bmatrix} u_x & u_y \\end{bmatrix}$转置一下，就变成了点积的定义，这也就是为什么向量的点积可以和几何投影对应起来。**\n\n上面是以单位向量 $\\vec{u}$ 为例，如果 $\\vec{u}$ 不是单位向量怎么理解呢？\n\n其实也很简单，把 $\\vec{u}$ 归一化成单位向量 $\\vec{u_0}$，前面提取出一个系数 $c$，这个系数也就是 $\\vec{u}$ 的长度。那么空间中任意向量 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 和 $\\vec{u}$ 的点积可以先看做 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 和 $\\vec{u_0}$ 的点积，也就是上面的投影过程，最后再乘以 $c$，也就是 $\\vec{u}$ 的长度。\n\n完美对应。\n","slug":"Linear algebra-Dot product","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nlf000qh8vnq32qs9xc","comments":1,"layout":"post","photos":[],"link":""},{"title":"牛客暑期ACM多校训练营(第三场)A题-PACM Team-多维01背包+记录路径","date":"2018-07-26T15:16:37.000Z","_content":"DP果然是最弱的，记录路径更是十分懵，在多校训练营里被虐的抬不起头，，，算了，只要不死，就会更强(赛亚人的特性其实也就是人的特性)\n<!-- more -->\n# 题目描述\nEddy was a contestant participating in ACM ICPC contests. ACM is short for Algorithm, Coding, Math. Since in the ACM contest, the most important knowledge is about algorithm, followed by coding(implementation ability), then math. However, in the ACM ICPC World Finals 2018, Eddy failed to solve a physics equation, which pushed him away from a potential medal.\n\nSince then on, Eddy found that physics is actually the most important thing in the contest. Thus, he wants to form a team to guide the following contestants to conquer the PACM contests(PACM is short for Physics, Algorithm, Coding, Math). \n\nThere are N candidate groups each composed of pi physics experts, ai algorithm experts, ci coding experts, mi math experts. For each group, Eddy can either invite all of them or none of them. If i-th team is invited, they will bring gi knowledge points which is calculated by Eddy's magic formula. Eddy believes that the higher the total knowledge points is, the better a team could place in a contest. But, Eddy doesn't want too many experts in the same area in the invited groups. Thus, the number of invited physics experts should not exceed P, and A for algorithm experts, C for coding experts, M for math experts.\n\nEddy is still busy in studying Physics. You come to help him to figure out which groups should be invited such that they doesn't exceed the constraint and will bring the most knowledge points in total.\n\n输入描述:\nThe first line contains a positive integer N indicating the number of candidate groups.\nEach of following N lines contains five space-separated integer pi, ai, ci, mi, gi indicating that i-th team consists of pi physics experts, ai algorithm experts, ci coding experts, mi math experts, and will bring gi knowledge points.\nThe last line contains four space-separated integer P, A, C, M indicating the maximum possible number of physics experts, algorithm experts, coding experts, and math experts, respectively.\n\n 1 ≤ N ≤ 36\n 0 ≤ pi,ai,ci,mi,gi ≤ 36\n 0 ≤ P, A, C, M ≤ 36\n输出描述:\n\nThe first line should contain a non-negative integer K indicating the number of invited groups.\nThe second line should contain K space-separated integer indicating the index of invited groups(groups are indexed from 0).\n\nYou can output index in any order as long as each index appears at most once. If there are multiple way to reach the most total knowledge points, you can output any one of them. If none of the groups will be invited, you could either output one line or output a blank line in the second line.\n示例1:\n\n输入:\n2\n1 0 2 1 10\n1 0 2 1 21\n1 0 2 1\n输出:\n1\n1\n\n示例2:\n\n输入:\n1\n2 1 1 0 31\n1 0 2 1\n输出：\n0\n\n# 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 40;\nint p[maxn], a[maxn], c[maxn], m[maxn];\nint v[maxn];\nshort d[maxn][maxn][maxn][maxn][maxn];\nint n;\nint Pm, Am, Cm, Mm;\nint used[maxn];//记录路径\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    memset(used, 0, sizeof(used));\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d%d%d%d%d\", p + i, a + i, c + i, m + i, v + i);\n    }\n\n    scanf(\"%d%d%d%d\", &Pm, &Am, &Cm, &Mm);\n    for(int i = 0; i <= Pm; i++){\n        for(int j = 0; j <= Am; j++){\n            for(int k = 0; k <= Cm; k++){\n                for(int l = 0; l <= Mm; l++){\n                    d[0][i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= Pm; j++){\n            for(int k = 0; k <= Am; k++){\n                for(int l = 0; l <= Cm; l++){\n                    for(int q = 0; q <= Mm; q++){\n                        d[i + 1][j][k][l][q] = d[i][j][k][l][q];\n                        if(j >= p[i] && k >= a[i] && l >= c[i] && q >= m[i]){\n                            int tmp = v[i] + d[i][j - p[i]][k - a[i]][l - c[i]][q - m[i]];\n                            if(tmp > d[i + 1][j][k][l][q]) {\n                                d[i + 1][j][k][l][q] = tmp;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //记录路径部分\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][Pm][Am][Cm][Mm] != d[i][Pm][Am][Cm][Mm]){\n            used[i] = 1;\n            Pm -= p[i];\n            Am -= a[i];\n            Cm -= c[i];\n            Mm -= m[i];\n        }\n    }\n    int cnt = 0;\n    for(int i = 0; i < n; i++){\n        if(used[i] == 1){\n            cnt++;\n        }\n    }\n    printf(\"%d\\n\", cnt);\n    if(cnt){\n        for(int i = 0; i < n; i++){\n            if(used[i]) printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n# 坑点\n数据d的类型要是short类型，int类型会爆内存，char类型会数据溢出．\n\n# 背包记录路径问题总结\n## 方法一核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            if(j < w[i]){\n                d[i + 1][j] = d[i][j];\n            }\n            else{\n                d[i + 1][j] = max(d[i][j], d[i][j - w[i]] + v[i]);\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][W] != d[i][W]){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n## 方法二核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            d[i + 1][j] = d[i][j];\n            if(j >= w[i]){\n                int tmp = d[i][j - w[i]] + v[i];\n                if(tmp > d[i + 1][j]){\n                    d[i + 1][j] = tmp;\n                    path[i][j] = 1;\n                }\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(path[i][W] == 1){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n","source":"_posts/Nowcoder-Third-A.md","raw":"---\ntitle: 牛客暑期ACM多校训练营(第三场)A题-PACM Team-多维01背包+记录路径\ndate: 2018-07-26 23:16:37\ncategories:\n- ACM\n- 背包\ntags:\n- DP\n- 01背包\n---\nDP果然是最弱的，记录路径更是十分懵，在多校训练营里被虐的抬不起头，，，算了，只要不死，就会更强(赛亚人的特性其实也就是人的特性)\n<!-- more -->\n# 题目描述\nEddy was a contestant participating in ACM ICPC contests. ACM is short for Algorithm, Coding, Math. Since in the ACM contest, the most important knowledge is about algorithm, followed by coding(implementation ability), then math. However, in the ACM ICPC World Finals 2018, Eddy failed to solve a physics equation, which pushed him away from a potential medal.\n\nSince then on, Eddy found that physics is actually the most important thing in the contest. Thus, he wants to form a team to guide the following contestants to conquer the PACM contests(PACM is short for Physics, Algorithm, Coding, Math). \n\nThere are N candidate groups each composed of pi physics experts, ai algorithm experts, ci coding experts, mi math experts. For each group, Eddy can either invite all of them or none of them. If i-th team is invited, they will bring gi knowledge points which is calculated by Eddy's magic formula. Eddy believes that the higher the total knowledge points is, the better a team could place in a contest. But, Eddy doesn't want too many experts in the same area in the invited groups. Thus, the number of invited physics experts should not exceed P, and A for algorithm experts, C for coding experts, M for math experts.\n\nEddy is still busy in studying Physics. You come to help him to figure out which groups should be invited such that they doesn't exceed the constraint and will bring the most knowledge points in total.\n\n输入描述:\nThe first line contains a positive integer N indicating the number of candidate groups.\nEach of following N lines contains five space-separated integer pi, ai, ci, mi, gi indicating that i-th team consists of pi physics experts, ai algorithm experts, ci coding experts, mi math experts, and will bring gi knowledge points.\nThe last line contains four space-separated integer P, A, C, M indicating the maximum possible number of physics experts, algorithm experts, coding experts, and math experts, respectively.\n\n 1 ≤ N ≤ 36\n 0 ≤ pi,ai,ci,mi,gi ≤ 36\n 0 ≤ P, A, C, M ≤ 36\n输出描述:\n\nThe first line should contain a non-negative integer K indicating the number of invited groups.\nThe second line should contain K space-separated integer indicating the index of invited groups(groups are indexed from 0).\n\nYou can output index in any order as long as each index appears at most once. If there are multiple way to reach the most total knowledge points, you can output any one of them. If none of the groups will be invited, you could either output one line or output a blank line in the second line.\n示例1:\n\n输入:\n2\n1 0 2 1 10\n1 0 2 1 21\n1 0 2 1\n输出:\n1\n1\n\n示例2:\n\n输入:\n1\n2 1 1 0 31\n1 0 2 1\n输出：\n0\n\n# 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 40;\nint p[maxn], a[maxn], c[maxn], m[maxn];\nint v[maxn];\nshort d[maxn][maxn][maxn][maxn][maxn];\nint n;\nint Pm, Am, Cm, Mm;\nint used[maxn];//记录路径\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    memset(used, 0, sizeof(used));\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d%d%d%d%d\", p + i, a + i, c + i, m + i, v + i);\n    }\n\n    scanf(\"%d%d%d%d\", &Pm, &Am, &Cm, &Mm);\n    for(int i = 0; i <= Pm; i++){\n        for(int j = 0; j <= Am; j++){\n            for(int k = 0; k <= Cm; k++){\n                for(int l = 0; l <= Mm; l++){\n                    d[0][i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= Pm; j++){\n            for(int k = 0; k <= Am; k++){\n                for(int l = 0; l <= Cm; l++){\n                    for(int q = 0; q <= Mm; q++){\n                        d[i + 1][j][k][l][q] = d[i][j][k][l][q];\n                        if(j >= p[i] && k >= a[i] && l >= c[i] && q >= m[i]){\n                            int tmp = v[i] + d[i][j - p[i]][k - a[i]][l - c[i]][q - m[i]];\n                            if(tmp > d[i + 1][j][k][l][q]) {\n                                d[i + 1][j][k][l][q] = tmp;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //记录路径部分\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][Pm][Am][Cm][Mm] != d[i][Pm][Am][Cm][Mm]){\n            used[i] = 1;\n            Pm -= p[i];\n            Am -= a[i];\n            Cm -= c[i];\n            Mm -= m[i];\n        }\n    }\n    int cnt = 0;\n    for(int i = 0; i < n; i++){\n        if(used[i] == 1){\n            cnt++;\n        }\n    }\n    printf(\"%d\\n\", cnt);\n    if(cnt){\n        for(int i = 0; i < n; i++){\n            if(used[i]) printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n# 坑点\n数据d的类型要是short类型，int类型会爆内存，char类型会数据溢出．\n\n# 背包记录路径问题总结\n## 方法一核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            if(j < w[i]){\n                d[i + 1][j] = d[i][j];\n            }\n            else{\n                d[i + 1][j] = max(d[i][j], d[i][j - w[i]] + v[i]);\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][W] != d[i][W]){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n## 方法二核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            d[i + 1][j] = d[i][j];\n            if(j >= w[i]){\n                int tmp = d[i][j - w[i]] + v[i];\n                if(tmp > d[i + 1][j]){\n                    d[i + 1][j] = tmp;\n                    path[i][j] = 1;\n                }\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(path[i][W] == 1){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n","slug":"Nowcoder-Third-A","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nlg000rh8vnesh7p6vn","comments":1,"layout":"post","photos":[],"link":""},{"title":"My little angel","date":"2018-06-10T01:57:06.000Z","_content":"\n# 重庆之旅\n　　和邱小笨蛋在一起四个多月了，但是快一年没见了，她在重庆，我在北京，她读高中，我读大学。感觉有些不可思议，能够遇到，能够在一起。感谢女票的勇敢，我是非常怂的，，，。\n　　在重庆度过了非常非常开心的几天，刚到的那天晚上给女票发消息说到了之后激动的睡不着，第二天早上终于见到了穿着裙裙来找我的女票票～(｡･ω･｡)ﾉ♡\n\n![邱小雁](/qxy1.jpg)\n<!--more-->\n\n　　女票比印象中要瘦了，可能是高中太累了吧，有些心疼，让她多长些肉肉她还不愿意Ծ‸ Ծ 。之后两人一起牵爪爪去逛商场玩了和女票期待已久的密室逃脱，可惜太菜了，小哥哥可能是可怜我们哈哈让我们看了最后的一关。\n　　一直想去女票学校看看的心愿也达成了，想感受一下女票平时给我发的照片里的地方、花花到底是什么样子的。去了女票平时自习的自习室，稍微有点冷，女票下次去的时候多穿一点啊。竟然还遇到了抓早恋的老师＝＝（害怕.jpg），女票好机智，话说我都大三了为什么还怕这种老师。。\n　　第三天早上和女票在一起吃的早餐，还是要说一下女票吃的太少了，多长肉肉啊亲爱的，不用担心，男票抱得动的(•̀⌄•́)。吃了早餐一起去女票住的小区里打了篮球，之前说要教女票投篮可是自己投了十几个才中了一个，，呜呜呜T^T树立了一个篮球小菜鸡的形象，不过一起吃了可爱多很开心(๑❛ᴗ❛๑)。中午去吃了自助，女票怕我吃不了太辣点了清汤的小火锅，委屈重庆小妹纸了。下午一起做了情侣必做的事情，看电影！而且是小哆啦哈哈，抱着女票看电影的感觉好幸福。\n　　女票怕妈妈担心本来是要在家吃晚饭的，我晚上不知道吃什么和女票说想点外卖，女票就从家跑出来陪我了，感动::>_<::（虽然最后在一起抱了好久连外卖也没吃成哈哈哈），感谢我女票票。晚上送女票回家一起在长江边散步也超级开心，女票还热情的给我介绍了重庆的“移动公厕”哈哈。\n\n![邱小雁](/moon1.jpg)\n\n![邱小雁](/together1.jpg)\n\n　　周五要回学校了，女票早上发消息说她准备来找我了，昨晚梦到我突然就不见了，我骗女票说我是9:45的飞机，我已经走了（其实是11:45的飞机，那时候大概7:40左右我刚醒），本来我以为傻女票不会相信，没想到她直接哭着给我打电话问我“你干嘛啊”，天啊，心都要化了。可能是之前和她说机场有点远不想让她送我，所以她才相信我真的走了吧♡。见到女票后果然被打了，，但是那句“你是猪吗”我却听的如痴如醉，怎么会有这么可爱的女孩子啊。\n　　我爱你，傻女票。","source":"_posts/My-little-angel.md","raw":"---\ntitle: My little angel\ndate: 2018-06-10 09:57:06\ncategories:\n- Diary\ntags:\n- Lover\n---\n\n# 重庆之旅\n　　和邱小笨蛋在一起四个多月了，但是快一年没见了，她在重庆，我在北京，她读高中，我读大学。感觉有些不可思议，能够遇到，能够在一起。感谢女票的勇敢，我是非常怂的，，，。\n　　在重庆度过了非常非常开心的几天，刚到的那天晚上给女票发消息说到了之后激动的睡不着，第二天早上终于见到了穿着裙裙来找我的女票票～(｡･ω･｡)ﾉ♡\n\n![邱小雁](/qxy1.jpg)\n<!--more-->\n\n　　女票比印象中要瘦了，可能是高中太累了吧，有些心疼，让她多长些肉肉她还不愿意Ծ‸ Ծ 。之后两人一起牵爪爪去逛商场玩了和女票期待已久的密室逃脱，可惜太菜了，小哥哥可能是可怜我们哈哈让我们看了最后的一关。\n　　一直想去女票学校看看的心愿也达成了，想感受一下女票平时给我发的照片里的地方、花花到底是什么样子的。去了女票平时自习的自习室，稍微有点冷，女票下次去的时候多穿一点啊。竟然还遇到了抓早恋的老师＝＝（害怕.jpg），女票好机智，话说我都大三了为什么还怕这种老师。。\n　　第三天早上和女票在一起吃的早餐，还是要说一下女票吃的太少了，多长肉肉啊亲爱的，不用担心，男票抱得动的(•̀⌄•́)。吃了早餐一起去女票住的小区里打了篮球，之前说要教女票投篮可是自己投了十几个才中了一个，，呜呜呜T^T树立了一个篮球小菜鸡的形象，不过一起吃了可爱多很开心(๑❛ᴗ❛๑)。中午去吃了自助，女票怕我吃不了太辣点了清汤的小火锅，委屈重庆小妹纸了。下午一起做了情侣必做的事情，看电影！而且是小哆啦哈哈，抱着女票看电影的感觉好幸福。\n　　女票怕妈妈担心本来是要在家吃晚饭的，我晚上不知道吃什么和女票说想点外卖，女票就从家跑出来陪我了，感动::>_<::（虽然最后在一起抱了好久连外卖也没吃成哈哈哈），感谢我女票票。晚上送女票回家一起在长江边散步也超级开心，女票还热情的给我介绍了重庆的“移动公厕”哈哈。\n\n![邱小雁](/moon1.jpg)\n\n![邱小雁](/together1.jpg)\n\n　　周五要回学校了，女票早上发消息说她准备来找我了，昨晚梦到我突然就不见了，我骗女票说我是9:45的飞机，我已经走了（其实是11:45的飞机，那时候大概7:40左右我刚醒），本来我以为傻女票不会相信，没想到她直接哭着给我打电话问我“你干嘛啊”，天啊，心都要化了。可能是之前和她说机场有点远不想让她送我，所以她才相信我真的走了吧♡。见到女票后果然被打了，，但是那句“你是猪吗”我却听的如痴如醉，怎么会有这么可爱的女孩子啊。\n　　我爱你，傻女票。","slug":"My-little-angel","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nlh000sh8vnk9ewij12","comments":1,"layout":"post","photos":[],"link":""},{"title":"POJ2481-线段树单点更新","date":"2018-04-22T08:51:50.000Z","_content":"最近刚刚开始做线段树相关的题目，很艰难...依照现在的理解其实线段树的题的暴力求解思路比较容易想到，但是暴力求解的时间复杂度一般肯会超，而线段树也正是这样一种通过区间更新来解决大量输入数据问题、降低时间复杂度的高级数据结构。线段树的关键是确定每个节点维护的是什么数据，以及以什么参数为依据进行区间的查询。\n被POJ上的这道题卡了很久，一开始是思路问题，后来是一些细节问题，总之还是熟练度不高...\n[参考博客链接](http://111qqz.com/2015/08/poj2481/)\n<!-- more -->\n# 题目链接\n[POJ2481](http://poj.org/problem?id=2481)\n# 题目描述\n共有N头牛，每头牛对应一个进食区间[$S$,$E$], 对两头牛$i$,$j$来说，假设它们对应的区间分别为[$S\\_i$,$E\\_i$]和[$S\\_j$,$E\\_j$]，如果满足$S\\_i<=S\\_j，E\\_j<=E\\_i$且$E\\_i-S\\_i>E\\_j-S\\_j$,那么我们可以说牛$i$要比牛$j$强壮。\n现对于每头牛来说计算比它强壮的牛的数量。\n# 题解\n先对区间进行排序，右端点降序为第一关键字，左端点升序为第二关键字。这样进行处理后第$i$个区间的右端点一定小于前$i-1$个区间的右端点了，那么只要进行左端点的判决就可以了，具体做法为：\n每次处理一个区间后都将该区间的左端点更新到线段树中（插入后相对应叶节点数值+1，插入前为0）。\n那么当我们查询第$i$个区间时其实也就是查询线段树中从1到$i-1$的区间内左端点的标记个数。\n**于是线段树每个节点维护的就是以该节点为根节点的子树所代表的区间中左端点的个数，而进行区间查询依据的参数也就是每个区间的左端点。**\n*需要注意的问题*:\n**两个区间重合时的情况要特殊处理，这种情况不算在内，做法可以是对排好序的每个区间进行处理前先检查它是否和上一查询区间重合，若重合则直接将上一区间的查询结果赋予该区间，并将该区间对应的左端点在线段树中再次更新（再次加1）,而后跳过该区间的查询。**详见代码：\n# 代码\n关于线段树的实现部分基于《挑战程序设计竞赛》一书中的实现模板，也可参考其它实现模板，形成自己的书写习惯。\n``` C++\n//#include <bits/stdc++.h> //POJ上大部分题不支持该头文件\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1 << 18;\ntypedef struct node{\n    int vl;\n    int vr;\n    int id;\n} nod;\nnod a[maxn];\nint d[2 * maxn];\nint n, pn;\nint ans[maxn];\n//排序部分\nbool cmp(const nod& a, const nod& b){\n    if(a.vr == b.vr) \n        return a.vl < b.vl;\n    else\n        return a.vr > b.vr;\n}\n//初始化\nvoid init(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n    for(int i = 0; i < 2 * n - 1; i++){\n        d[i] = 0;\n    }\n}\n//查询操作\nint query(int a, int b, int k, int l, int r){\n    if(a <= l && b >= r) return d[k];\n    if(b <= l) return 0;\n    else{\n        int res1 = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        int res2 = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return res1 + res2;\n    }\n}\n//更新操作\nvoid update(int k){\n    k += n - 1;\n    d[k] += 1;\n    while(k > 0){\n        k = (k - 1) / 2;\n        d[k] = d[2 *k + 1] + d[2 * k + 2];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int t1, t2;\n    while(~scanf(\"%d\", &n)){\n        memset(ans, 0, sizeof(ans));\n        memset(d, 0, sizeof(d));\n\t    if(n == 0) break;\n\t    for(int i = 0; i < n; i++){\n            scanf(\"%d%d\", &t1, &t2);\n            a[i].vl = t1;\n            a[i].vr = t2;\n            a[i].id = i;\n        }\n        sort(a, a + n, cmp);\n        pn = n;\n        init(n);\n        for(int i = 0; i < pn; i++){\n            //if内为判断重合区间部分\n            if(i >= 1 && a[i].vl == a[i - 1].vl && a[i].vr == a[i - 1].vr){\n                ans[a[i].id] = ans[a[i - 1].id];\n                update(a[i].vl);\n                continue;\n            }\n            ans[a[i].id] = query(0, a[i].vl + 1, 0, 0, n);\n            update(a[i].vl);\n\t\t\t\n        }\n        for(int i = 0; i < pn; i++){\n            printf(\"%d%c\", ans[i], i < pn - 1 ? ' ' : '\\n');\n        }\n    }\n\t\n    return 0;\n}\n```","source":"_posts/POJ2481.md","raw":"---\ntitle: POJ2481-线段树单点更新\ndate: 2018-04-22 16:51:50\ncategories: \n- ACM\n- 线段树\ntags:\n- POJ\n- 线段树\n---\n最近刚刚开始做线段树相关的题目，很艰难...依照现在的理解其实线段树的题的暴力求解思路比较容易想到，但是暴力求解的时间复杂度一般肯会超，而线段树也正是这样一种通过区间更新来解决大量输入数据问题、降低时间复杂度的高级数据结构。线段树的关键是确定每个节点维护的是什么数据，以及以什么参数为依据进行区间的查询。\n被POJ上的这道题卡了很久，一开始是思路问题，后来是一些细节问题，总之还是熟练度不高...\n[参考博客链接](http://111qqz.com/2015/08/poj2481/)\n<!-- more -->\n# 题目链接\n[POJ2481](http://poj.org/problem?id=2481)\n# 题目描述\n共有N头牛，每头牛对应一个进食区间[$S$,$E$], 对两头牛$i$,$j$来说，假设它们对应的区间分别为[$S\\_i$,$E\\_i$]和[$S\\_j$,$E\\_j$]，如果满足$S\\_i<=S\\_j，E\\_j<=E\\_i$且$E\\_i-S\\_i>E\\_j-S\\_j$,那么我们可以说牛$i$要比牛$j$强壮。\n现对于每头牛来说计算比它强壮的牛的数量。\n# 题解\n先对区间进行排序，右端点降序为第一关键字，左端点升序为第二关键字。这样进行处理后第$i$个区间的右端点一定小于前$i-1$个区间的右端点了，那么只要进行左端点的判决就可以了，具体做法为：\n每次处理一个区间后都将该区间的左端点更新到线段树中（插入后相对应叶节点数值+1，插入前为0）。\n那么当我们查询第$i$个区间时其实也就是查询线段树中从1到$i-1$的区间内左端点的标记个数。\n**于是线段树每个节点维护的就是以该节点为根节点的子树所代表的区间中左端点的个数，而进行区间查询依据的参数也就是每个区间的左端点。**\n*需要注意的问题*:\n**两个区间重合时的情况要特殊处理，这种情况不算在内，做法可以是对排好序的每个区间进行处理前先检查它是否和上一查询区间重合，若重合则直接将上一区间的查询结果赋予该区间，并将该区间对应的左端点在线段树中再次更新（再次加1）,而后跳过该区间的查询。**详见代码：\n# 代码\n关于线段树的实现部分基于《挑战程序设计竞赛》一书中的实现模板，也可参考其它实现模板，形成自己的书写习惯。\n``` C++\n//#include <bits/stdc++.h> //POJ上大部分题不支持该头文件\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1 << 18;\ntypedef struct node{\n    int vl;\n    int vr;\n    int id;\n} nod;\nnod a[maxn];\nint d[2 * maxn];\nint n, pn;\nint ans[maxn];\n//排序部分\nbool cmp(const nod& a, const nod& b){\n    if(a.vr == b.vr) \n        return a.vl < b.vl;\n    else\n        return a.vr > b.vr;\n}\n//初始化\nvoid init(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n    for(int i = 0; i < 2 * n - 1; i++){\n        d[i] = 0;\n    }\n}\n//查询操作\nint query(int a, int b, int k, int l, int r){\n    if(a <= l && b >= r) return d[k];\n    if(b <= l) return 0;\n    else{\n        int res1 = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        int res2 = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return res1 + res2;\n    }\n}\n//更新操作\nvoid update(int k){\n    k += n - 1;\n    d[k] += 1;\n    while(k > 0){\n        k = (k - 1) / 2;\n        d[k] = d[2 *k + 1] + d[2 * k + 2];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int t1, t2;\n    while(~scanf(\"%d\", &n)){\n        memset(ans, 0, sizeof(ans));\n        memset(d, 0, sizeof(d));\n\t    if(n == 0) break;\n\t    for(int i = 0; i < n; i++){\n            scanf(\"%d%d\", &t1, &t2);\n            a[i].vl = t1;\n            a[i].vr = t2;\n            a[i].id = i;\n        }\n        sort(a, a + n, cmp);\n        pn = n;\n        init(n);\n        for(int i = 0; i < pn; i++){\n            //if内为判断重合区间部分\n            if(i >= 1 && a[i].vl == a[i - 1].vl && a[i].vr == a[i - 1].vr){\n                ans[a[i].id] = ans[a[i - 1].id];\n                update(a[i].vl);\n                continue;\n            }\n            ans[a[i].id] = query(0, a[i].vl + 1, 0, 0, n);\n            update(a[i].vl);\n\t\t\t\n        }\n        for(int i = 0; i < pn; i++){\n            printf(\"%d%c\", ans[i], i < pn - 1 ? ' ' : '\\n');\n        }\n    }\n\t\n    return 0;\n}\n```","slug":"POJ2481","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nlj000th8vnf1o8isuf","comments":1,"layout":"post","photos":[],"link":""},{"title":"POJ1970-The Game-DFS","date":"2018-08-14T11:39:48.000Z","_content":"在一个$19×19$的棋盘上有一局五子棋的棋局，要求判断是白棋获胜还是黑棋获胜，并输出获胜一方获胜棋子部分的最左上一个棋子的位置．\n相比其它迷宫问题稍微变化了一点点，多了一个方向因素，通过这道题对迷宫问题和DFS有了更进一步的理解．\n<!-- more -->\n# 链接\n[POJ1970-The Game](http://poj.org/problem?id=1970)\n# 原题描述\nA game of Renju is played on a 19*19 board by two players. One player uses black stones and the other uses white stones. The game begins in an empty board and two players alternate in placing black stones and white stones. Black always goes first. There are 19 horizontal lines and 19 vertical lines in the board and the stones are placed on the intersections of the lines. \nHorizontal lines are marked 1, 2, ..., 19 from up to down and vertical lines are marked 1, 2, ..., 19 from left to right. \n![example](/Renju.png)\nThe objective of this game is to put five stones of the same color consecutively along a horizontal, vertical, or diagonal line. So, black wins in the above figure. But, a player does not win the game if more than five stones of the same color were put consecutively. \nGiven a configuration of the game, write a program to determine whether white has won or black has won or nobody has won yet. There will be no input data where the black and the white both win at the same time. Also there will be no input data where the white or the black wins in more than one place. \n# 题解\n相比于其它迷宫问题的搜索，这个问题要求每一次DFS始终沿一个方向进行搜索判断，判断出一方的某一个方向上的棋子个数等于5时该方获胜，所以在DFS函数上加上一个控制方向的参数，并把方向的选择放在DFS外部（main函数中）．还有一个需要注意的地方是连续棋子个数大于5的情况不算获胜．\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 14 Aug 17:36:47 CST 2018\n *\n */\n \n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nint d[25][25];\nint t;\n/**/\n//搜索方向为向下，向右，右斜上，右斜下（方便获得最左上的棋子坐标）\nint dx[4] = {1, 0, -1, 1};\nint dy[4] = {0, 1, 1, 1};\n/**/\nint cnt = 0;\n\n//参数k为方向参数\nvoid dfs(int x, int y, int k){\n    cnt++;\n    int nx = x + dx[k], ny = y + dy[k];\n    if(nx >= 1 && nx <= 19 && ny >= 1 && ny <= 19 && d[nx][ny] == d[x][y])\n        dfs(nx, ny, k);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        int leftx = 0, lefty = 0;\n        int win = 0;\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                cin >> d[i][j];\n                //cout << d[i][j] << \" \";\n            }\n            //cout << endl;\n        }\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                if(!d[i][j]) continue;\n                for(int k = 0; k < 4; k++){\n                    cnt = 0;\n                    dfs(i, j, k);\n                    if(cnt == 5){\n                        int xx = i - dx[k], yy = j - dy[k];\n                        //判断是否连续棋子个数大于5\n                        if(xx >= 1 && xx <= 19 && yy >= 1 && yy <= 19){\n                            if(d[xx][yy] != d[i][j]){\n                                win = d[i][j], leftx = i, lefty = j;\n                                break;\n                            }\n                        }\n                        else{\n                            win = d[i][j], leftx = i, lefty = j;\n                            break;\n                        }\n                    }\n                }\n                if(win) break;\n            }\n            if(win) break;\n        }\n        cout << win << endl;\n        if(win) cout << leftx << \" \" << lefty << endl;\n    }\n    \n    return 0;\n}\n```","source":"_posts/POJ1970-The-Game-DFS.md","raw":"---\ntitle: POJ1970-The Game-DFS\ndate: 2018-08-14 19:39:48\ncategories:\n- ACM\n- DFS\ntags:\n- POJ\n- DFS\n- 迷宫问题\n---\n在一个$19×19$的棋盘上有一局五子棋的棋局，要求判断是白棋获胜还是黑棋获胜，并输出获胜一方获胜棋子部分的最左上一个棋子的位置．\n相比其它迷宫问题稍微变化了一点点，多了一个方向因素，通过这道题对迷宫问题和DFS有了更进一步的理解．\n<!-- more -->\n# 链接\n[POJ1970-The Game](http://poj.org/problem?id=1970)\n# 原题描述\nA game of Renju is played on a 19*19 board by two players. One player uses black stones and the other uses white stones. The game begins in an empty board and two players alternate in placing black stones and white stones. Black always goes first. There are 19 horizontal lines and 19 vertical lines in the board and the stones are placed on the intersections of the lines. \nHorizontal lines are marked 1, 2, ..., 19 from up to down and vertical lines are marked 1, 2, ..., 19 from left to right. \n![example](/Renju.png)\nThe objective of this game is to put five stones of the same color consecutively along a horizontal, vertical, or diagonal line. So, black wins in the above figure. But, a player does not win the game if more than five stones of the same color were put consecutively. \nGiven a configuration of the game, write a program to determine whether white has won or black has won or nobody has won yet. There will be no input data where the black and the white both win at the same time. Also there will be no input data where the white or the black wins in more than one place. \n# 题解\n相比于其它迷宫问题的搜索，这个问题要求每一次DFS始终沿一个方向进行搜索判断，判断出一方的某一个方向上的棋子个数等于5时该方获胜，所以在DFS函数上加上一个控制方向的参数，并把方向的选择放在DFS外部（main函数中）．还有一个需要注意的地方是连续棋子个数大于5的情况不算获胜．\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 14 Aug 17:36:47 CST 2018\n *\n */\n \n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nint d[25][25];\nint t;\n/**/\n//搜索方向为向下，向右，右斜上，右斜下（方便获得最左上的棋子坐标）\nint dx[4] = {1, 0, -1, 1};\nint dy[4] = {0, 1, 1, 1};\n/**/\nint cnt = 0;\n\n//参数k为方向参数\nvoid dfs(int x, int y, int k){\n    cnt++;\n    int nx = x + dx[k], ny = y + dy[k];\n    if(nx >= 1 && nx <= 19 && ny >= 1 && ny <= 19 && d[nx][ny] == d[x][y])\n        dfs(nx, ny, k);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        int leftx = 0, lefty = 0;\n        int win = 0;\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                cin >> d[i][j];\n                //cout << d[i][j] << \" \";\n            }\n            //cout << endl;\n        }\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                if(!d[i][j]) continue;\n                for(int k = 0; k < 4; k++){\n                    cnt = 0;\n                    dfs(i, j, k);\n                    if(cnt == 5){\n                        int xx = i - dx[k], yy = j - dy[k];\n                        //判断是否连续棋子个数大于5\n                        if(xx >= 1 && xx <= 19 && yy >= 1 && yy <= 19){\n                            if(d[xx][yy] != d[i][j]){\n                                win = d[i][j], leftx = i, lefty = j;\n                                break;\n                            }\n                        }\n                        else{\n                            win = d[i][j], leftx = i, lefty = j;\n                            break;\n                        }\n                    }\n                }\n                if(win) break;\n            }\n            if(win) break;\n        }\n        cout << win << endl;\n        if(win) cout << leftx << \" \" << lefty << endl;\n    }\n    \n    return 0;\n}\n```","slug":"POJ1970-The-Game-DFS","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nlk000uh8vn8v7waa0i","comments":1,"layout":"post","photos":[],"link":""},{"title":"开源的NES游戏模拟器","date":"2018-12-02T16:28:38.000Z","_content":"偶然发现一个博主分享的开源NES游戏模拟器，安装后只要再去下载rom游戏就可以重温小时候的小霸王游戏机上的游戏！安装之后迫不及待的下载了超级马里奥，还是当年的感觉！激动(≧▽≦)\n![SuperMario](/SuperMario.png)\n<!--more-->\n# 参考链接\n[WTF Daily Blog](http://blog.topspeedsnail.com/archives/4249)\n感谢博主！下面只列出了开源的NES游戏模拟器，更多类型的模拟器请转到博主博客原文。\n\n[NES游戏下载地址](http://nesyouxi.net/)\n\n# NES模拟器\n\n## FCEUX\n[FCEUX](http://www.fceux.com/web/home.html)是开源的NES模拟器，使用C++编写，大概也是Linux上最好用的NES模拟器。它同样支持Windows、Mac os x。如果你使用的是Ubuntu，执行``sudo apt-get install fceux``安装fceux。如果你使用其他Linux发型版，可以从[这里](http://www.fceux.com/web/download.html)下载源代码编译安装 。\n\nPs.你可能会遇到无法解析安装包的情况，可以``sudo apt-get update``之后重新安装。如果依旧安装失败，可以尝试更新软件源。\n\n## Nestopia\n[Nestopia](http://nestopia.sourceforge.net/)另一个开源的NES模拟器，貌似很久没有更新了，它支持Windows、Linux、Mac os x系统。Nestopia也是使用c++编写，并且使用了大量的模版（难读）。它的执行效率还是挺高的。去年，我（指WTF Daily Blog的博主）把它移植到了andorid上，在低端手机上可以流畅运行。\n\n## My Nes\n[My Nes](https://sourceforge.net/projects/mynes/)是使用C#编写的开源NES模拟器，它只支持Windows系统。My Nes的代码非常易读，也许是因为这个原因，导致执行效率不高。","source":"_posts/Super-Mario.md","raw":"---\ntitle: 开源的NES游戏模拟器\ndate: 2018-12-03 00:28:38\ncategories:\n- Messy article\ntags:\n- Game\n---\n偶然发现一个博主分享的开源NES游戏模拟器，安装后只要再去下载rom游戏就可以重温小时候的小霸王游戏机上的游戏！安装之后迫不及待的下载了超级马里奥，还是当年的感觉！激动(≧▽≦)\n![SuperMario](/SuperMario.png)\n<!--more-->\n# 参考链接\n[WTF Daily Blog](http://blog.topspeedsnail.com/archives/4249)\n感谢博主！下面只列出了开源的NES游戏模拟器，更多类型的模拟器请转到博主博客原文。\n\n[NES游戏下载地址](http://nesyouxi.net/)\n\n# NES模拟器\n\n## FCEUX\n[FCEUX](http://www.fceux.com/web/home.html)是开源的NES模拟器，使用C++编写，大概也是Linux上最好用的NES模拟器。它同样支持Windows、Mac os x。如果你使用的是Ubuntu，执行``sudo apt-get install fceux``安装fceux。如果你使用其他Linux发型版，可以从[这里](http://www.fceux.com/web/download.html)下载源代码编译安装 。\n\nPs.你可能会遇到无法解析安装包的情况，可以``sudo apt-get update``之后重新安装。如果依旧安装失败，可以尝试更新软件源。\n\n## Nestopia\n[Nestopia](http://nestopia.sourceforge.net/)另一个开源的NES模拟器，貌似很久没有更新了，它支持Windows、Linux、Mac os x系统。Nestopia也是使用c++编写，并且使用了大量的模版（难读）。它的执行效率还是挺高的。去年，我（指WTF Daily Blog的博主）把它移植到了andorid上，在低端手机上可以流畅运行。\n\n## My Nes\n[My Nes](https://sourceforge.net/projects/mynes/)是使用C#编写的开源NES模拟器，它只支持Windows系统。My Nes的代码非常易读，也许是因为这个原因，导致执行效率不高。","slug":"Super-Mario","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nlk000vh8vn4ildy84z","comments":1,"layout":"post","photos":[],"link":""},{"title":"STL中自定义比较函数和重载运算符总结","date":"2018-08-07T14:13:16.000Z","_content":"\nSTL中自定义比较函数和重载运算符总结。部分内容转载自[Ohazyi Zone's blog](https://www.ohazyi.com/c_cmp/)\n<!-- more -->\n\n# sort\n## 自定义比较函数\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool cmp(const node& a, const node& b){\n    return a.x > b.x //对x降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n, cmp);\n    return 0;\n}\n```\n注：自定义比较函数的形式同样也适用于pair类型数据排序。\n\n## 重载运算符<\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x; //重载为降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n);\n    return 0;\n}\n```\n注：由于sort默认less(升序),所以重载'<'运算符。重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n\n# priority_queue\n## 重载运算符< (运算符重载函数放到结构体外)\n```C++\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x //less默认大顶堆，改为小顶堆\n}\n\n//bool operator >(const node& a, const node& b){\n//    return a.x < b.x //greater默认小顶堆，改为大顶堆\n//}\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同样重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n\n## 重载运算符< (运算符重载函数放到结构体内)\n```C++\nstruct node{\n    int x, y;\n    bool operator <(const node& a) const { //必须加const\n        return x > a.x;\n    }\n    //bool operator >(const node& a) const { //必须加const\n    //    return x < a.x;\n    //}\n};\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同上。\n\n## 自定义比较函数\n```C++\nstruct node{\n    int x, y;\n};\n\nstruct cmp1{\n    bool operator()(node a, node b){\n        return a.x > b.x; //小顶堆\n    }\n}\n\nstruct cmp2{\n    bool operator()(node a, node b){\n        return a.x < b.x; //大顶堆\n    }\n}\n\nint main(){\n    priority_queue<node, vector<node>, cmp1> que1; //小顶堆\n    priority_queue<node, vector<node>, cmp2> que2; //大顶堆\n    return 0;\n}\n```\n注：同样适用于pair类型数据排序。\n\n# 其它\n```C++\nset<int, greater<int> > st; //按照从大到小，默认是less<int>\ntypedef pair <int,int> P;\nset<P> st; //按照pair的第一个元素来排，第一个相等的话按第二个来排\nset<P, greater<P> > st;//按照从大到小的greater来排\n```\n注：set、map的自定义比较函数和重载运算符与优先队列priority_queue类似。","source":"_posts/STL-cmp.md","raw":"---\ntitle: STL中自定义比较函数和重载运算符总结\ndate: 2018-08-07 22:13:16\ncategories:\n- C++\ntags:\n- STL\n---\n\nSTL中自定义比较函数和重载运算符总结。部分内容转载自[Ohazyi Zone's blog](https://www.ohazyi.com/c_cmp/)\n<!-- more -->\n\n# sort\n## 自定义比较函数\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool cmp(const node& a, const node& b){\n    return a.x > b.x //对x降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n, cmp);\n    return 0;\n}\n```\n注：自定义比较函数的形式同样也适用于pair类型数据排序。\n\n## 重载运算符<\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x; //重载为降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n);\n    return 0;\n}\n```\n注：由于sort默认less(升序),所以重载'<'运算符。重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n\n# priority_queue\n## 重载运算符< (运算符重载函数放到结构体外)\n```C++\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x //less默认大顶堆，改为小顶堆\n}\n\n//bool operator >(const node& a, const node& b){\n//    return a.x < b.x //greater默认小顶堆，改为大顶堆\n//}\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同样重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n\n## 重载运算符< (运算符重载函数放到结构体内)\n```C++\nstruct node{\n    int x, y;\n    bool operator <(const node& a) const { //必须加const\n        return x > a.x;\n    }\n    //bool operator >(const node& a) const { //必须加const\n    //    return x < a.x;\n    //}\n};\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同上。\n\n## 自定义比较函数\n```C++\nstruct node{\n    int x, y;\n};\n\nstruct cmp1{\n    bool operator()(node a, node b){\n        return a.x > b.x; //小顶堆\n    }\n}\n\nstruct cmp2{\n    bool operator()(node a, node b){\n        return a.x < b.x; //大顶堆\n    }\n}\n\nint main(){\n    priority_queue<node, vector<node>, cmp1> que1; //小顶堆\n    priority_queue<node, vector<node>, cmp2> que2; //大顶堆\n    return 0;\n}\n```\n注：同样适用于pair类型数据排序。\n\n# 其它\n```C++\nset<int, greater<int> > st; //按照从大到小，默认是less<int>\ntypedef pair <int,int> P;\nset<P> st; //按照pair的第一个元素来排，第一个相等的话按第二个来排\nset<P, greater<P> > st;//按照从大到小的greater来排\n```\n注：set、map的自定义比较函数和重载运算符与优先队列priority_queue类似。","slug":"STL-cmp","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nll000wh8vnquj6g7s4","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva10129-Play on Words-欧拉路","date":"2018-11-11T23:25:48.000Z","_content":"输入n个单词，是否可以把所有这些单词排成一个序列，使得每个单词的第一个字母和上一个单词的最后一个字母相同。\n<!--more-->\n# 链接\n[Uva10129-Play on Words](https://vjudge.net/problem/UVA-10129)\n\n# 题解\n建图。将字母看做结点，单词看做有向边。例如单词acm, mouse建图为a->m->e。如果该图存在一条欧拉路则问题有解。首先判断忽略边方向后的无向图是否连通，有两种方法来判断，一种是DFS，另一种是并查集（此代码采用DFS判断）。然后依据建图时统计的各个结点的出度和入度信息判断是否有欧拉路存在。\n**有一个需要注意的地方是，可能两个结点之间存在多条边，但是判断连通性的时候可以忽略，多边存在时按单边处理，不影响连通性。**\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon  12 Nov 07:00:18 CST 2018\n *`\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Degree{\n\tint in;\n\tint out;\n};\nint G[30][30];\nDegree d[30];\nint T, n;\n\nvoid dfs(int x){\n\tfor(int i = 0; i < 26; i++){\n\t\tif(G[x][i]){\n\t\t\tG[x][i] = G[i][0] = 0;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\nbool JudgeEulr(){\n\tvector<int> vec;\n\tfor(int i = 0; i < 26; i++){\n\t\tif(d[i].in != d[i].out){\n\t\t\tvec.push_back(i);\n\t\t} \n\t}\n\tint len = vec.size();\n\tif(len == 0) \n\t\treturn true;\n\telse if(len == 2){\n\t\tif((d[vec[0]].in - 1 == d[vec[0]].out && d[vec[1]].out - 1 == d[vec[1]].in) || (d[vec[0]].out - 1 == d[vec[0]].in && d[vec[1]].in - 1 == d[vec[1]].out))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse\n\t\treturn false;\n}\n\nint main(){\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout.tie(0);\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t#endif\n\n\tcin >> T;\n\twhile(T--){\n\t\tcin >> n;\n\t\tmemset(G, 0, sizeof(G));\n\t\tmemset(d, 0, sizeof(d));\n\t\tstring s;\n\t\tint a, b;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s;\n\t\t\tint len = s.length();\n\t\t\ta = s[0] - 'a', b = s[len - 1] - 'a';\n\t\t\tG[a][b] = 1, G[b][a] = 1;\n\t\t\td[a].out++, d[b].in++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tdfs(i);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << cnt << endl;\n\t\tif(cnt > 1){\n\t\t\tcout << \"The door cannot be opened.\" << endl;\n\t\t}\n\t\telse{\n\t\t\tif(JudgeEulr())\n\t\t\t\tcout << \"Ordering is possible.\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"The door cannot be opened.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```","source":"_posts/Uva10129-Play-on-Words.md","raw":"---\ntitle: Uva10129-Play on Words-欧拉路\ndate: 2018-11-12 07:25:48\ncategories:\n- ACM\n- 欧拉路\ntags:\n- 欧拉路\n- DFS\n---\n输入n个单词，是否可以把所有这些单词排成一个序列，使得每个单词的第一个字母和上一个单词的最后一个字母相同。\n<!--more-->\n# 链接\n[Uva10129-Play on Words](https://vjudge.net/problem/UVA-10129)\n\n# 题解\n建图。将字母看做结点，单词看做有向边。例如单词acm, mouse建图为a->m->e。如果该图存在一条欧拉路则问题有解。首先判断忽略边方向后的无向图是否连通，有两种方法来判断，一种是DFS，另一种是并查集（此代码采用DFS判断）。然后依据建图时统计的各个结点的出度和入度信息判断是否有欧拉路存在。\n**有一个需要注意的地方是，可能两个结点之间存在多条边，但是判断连通性的时候可以忽略，多边存在时按单边处理，不影响连通性。**\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon  12 Nov 07:00:18 CST 2018\n *`\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Degree{\n\tint in;\n\tint out;\n};\nint G[30][30];\nDegree d[30];\nint T, n;\n\nvoid dfs(int x){\n\tfor(int i = 0; i < 26; i++){\n\t\tif(G[x][i]){\n\t\t\tG[x][i] = G[i][0] = 0;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\nbool JudgeEulr(){\n\tvector<int> vec;\n\tfor(int i = 0; i < 26; i++){\n\t\tif(d[i].in != d[i].out){\n\t\t\tvec.push_back(i);\n\t\t} \n\t}\n\tint len = vec.size();\n\tif(len == 0) \n\t\treturn true;\n\telse if(len == 2){\n\t\tif((d[vec[0]].in - 1 == d[vec[0]].out && d[vec[1]].out - 1 == d[vec[1]].in) || (d[vec[0]].out - 1 == d[vec[0]].in && d[vec[1]].in - 1 == d[vec[1]].out))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse\n\t\treturn false;\n}\n\nint main(){\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout.tie(0);\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t#endif\n\n\tcin >> T;\n\twhile(T--){\n\t\tcin >> n;\n\t\tmemset(G, 0, sizeof(G));\n\t\tmemset(d, 0, sizeof(d));\n\t\tstring s;\n\t\tint a, b;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s;\n\t\t\tint len = s.length();\n\t\t\ta = s[0] - 'a', b = s[len - 1] - 'a';\n\t\t\tG[a][b] = 1, G[b][a] = 1;\n\t\t\td[a].out++, d[b].in++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tdfs(i);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << cnt << endl;\n\t\tif(cnt > 1){\n\t\t\tcout << \"The door cannot be opened.\" << endl;\n\t\t}\n\t\telse{\n\t\t\tif(JudgeEulr())\n\t\t\t\tcout << \"Ordering is possible.\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"The door cannot be opened.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```","slug":"Uva10129-Play-on-Words","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nll000xh8vnce7verf5","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva10410-Tree Reconstruction-树还原","date":"2018-12-14T12:02:42.000Z","_content":"根据一棵树的BFS和DFS序列还原这颗树的结构。关于树的一种新的类型的题，mark。\n<!--more-->\n# 链接\n题目链接[Uva10410-Tree Reconstruction](https://vjudge.net/problem/UVA-10410)\n参考链接[20143605--pcx's Blog](https://www.cnblogs.com/20143605--pcx/p/4859424.html)和[Chengrui's Blog](https://wcr1996.com/2015/02/24/uva-10410-tree-reconstruction/)\n\n# 题解\n用BFS序列去分离DFS，首先根据BFS序列顺序记录每个节点的位置。子结点的下标一定比父结点的下标至少大于1，（根节点除外，根结点和第一个子结点的下标距离等于1）。\n用栈维护DFS序列，根据条件不断判断栈中的top结点和新读入结点之间的位置关系，``若top结点下标 + 1 < 新结点下标，或者top结点是根节点``，则表示新结点是top的结点的一个子结点；``若top结点下标 + 1 = 新结点下标``，表示新结点和top结点之间是兄弟结点，同时表示当前top结点往下的分支已扫描完毕，pop出top结点；``若top结点下标 + 1 > 新结点下标``，表示新结点已不在top结点所在子树，同样pop出top结点。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 14 Dec 19:36:24 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e3 + 7;\nint n;\nint pos[maxn];\nstack<int> dfs;\nvector<int> tree[maxn];\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        while(!dfs.empty()) dfs.pop();\n        \n        int x;\n        for(int i = 0; i < n; i++){\n            cin >> x;\n            pos[x] = i;\n            tree[i + 1].clear();\n        }\n\n        int root;\n        cin >> root;\n        dfs.push(root);\n        for(int i = 1; i < n; i++){\n            cin >> x;\n            while(1){\n                int u = dfs.top();\n                if(u == root || pos[u] + 1 < pos[x]){\n                    tree[u].push_back(x);\n                    dfs.push(x);\n                    break;\n                }\n                dfs.pop();\n            }\n        }\n\n        for(int i = 1; i <= n; i++){\n            cout << i << \":\";\n            int len = tree[i].size();\n            for(int j = 0; j < len; j++){\n                cout << \" \" << tree[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n```","source":"_posts/Uva10410-Tree-Reconstruction.md","raw":"---\ntitle: Uva10410-Tree Reconstruction-树还原\ndate: 2018-12-14 20:02:42\ncategories:\n- ACM\n- 树\ntags:\n- 树\n---\n根据一棵树的BFS和DFS序列还原这颗树的结构。关于树的一种新的类型的题，mark。\n<!--more-->\n# 链接\n题目链接[Uva10410-Tree Reconstruction](https://vjudge.net/problem/UVA-10410)\n参考链接[20143605--pcx's Blog](https://www.cnblogs.com/20143605--pcx/p/4859424.html)和[Chengrui's Blog](https://wcr1996.com/2015/02/24/uva-10410-tree-reconstruction/)\n\n# 题解\n用BFS序列去分离DFS，首先根据BFS序列顺序记录每个节点的位置。子结点的下标一定比父结点的下标至少大于1，（根节点除外，根结点和第一个子结点的下标距离等于1）。\n用栈维护DFS序列，根据条件不断判断栈中的top结点和新读入结点之间的位置关系，``若top结点下标 + 1 < 新结点下标，或者top结点是根节点``，则表示新结点是top的结点的一个子结点；``若top结点下标 + 1 = 新结点下标``，表示新结点和top结点之间是兄弟结点，同时表示当前top结点往下的分支已扫描完毕，pop出top结点；``若top结点下标 + 1 > 新结点下标``，表示新结点已不在top结点所在子树，同样pop出top结点。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 14 Dec 19:36:24 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e3 + 7;\nint n;\nint pos[maxn];\nstack<int> dfs;\nvector<int> tree[maxn];\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        while(!dfs.empty()) dfs.pop();\n        \n        int x;\n        for(int i = 0; i < n; i++){\n            cin >> x;\n            pos[x] = i;\n            tree[i + 1].clear();\n        }\n\n        int root;\n        cin >> root;\n        dfs.push(root);\n        for(int i = 1; i < n; i++){\n            cin >> x;\n            while(1){\n                int u = dfs.top();\n                if(u == root || pos[u] + 1 < pos[x]){\n                    tree[u].push_back(x);\n                    dfs.push(x);\n                    break;\n                }\n                dfs.pop();\n            }\n        }\n\n        for(int i = 1; i <= n; i++){\n            cout << i << \":\";\n            int len = tree[i].size();\n            for(int j = 0; j < len; j++){\n                cout << \" \" << tree[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n```","slug":"Uva10410-Tree-Reconstruction","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nlm000yh8vnqvc6hj01","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva10305-Ordering Tasks-拓扑排序","date":"2018-11-04T11:47:51.000Z","_content":"有n个变量，m个二元组(u, v), 分别表示u小于v。要求给出一种所有变量从小到大排列的可能。\n<!--more-->\n# 链接\n[Uva10305-Ordering Tasks](https://vjudge.net/problem/UVA-10305)\n# 题解\n建图，以变量为顶点，“小于”关系为有向边。问题变为求这个图的拓扑排序。借助DFS来完成排序。\n```\n在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：\n1. 每个顶点出现且只出现一次；\n2. 若A在序列中排在B的前面，则在图中不存在从B到A的路径。\n```\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun  4 Nov 18:47:13 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint n, m;\nint c[maxn];\nint res[maxn];\nint G[maxn][maxn];\nint t;\n\nbool dfs(int u){\n    c[u] = -1;\n    for(int i = 1; i <= n; i++){\n        if(G[u][i]){\n            if(c[i] == -1) return false;\n            else if(c[i] == 0 && !dfs(i)) return false;\n        }\n        //c[u] = 1, res[--t] = u;\n    }\n    c[u] = 1, res[--t] = u;\n    return true;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        t = n;\n        memset(c, 0, sizeof(c));\n        memset(res, 0, sizeof(res));\n        memset(G, 0, sizeof(G));\n        int x, y;\n        for(int i = 0; i < m; i++){\n            cin >> x >> y;\n            G[x][y] = 1;\n        }\n        for(int i = 1; i <= n; i++){\n            if(!c[i]){\n                //cout << \"i: \" << i << endl;\n                dfs(i);\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(!i) cout << res[i];\n            else cout << \" \" << res[i];\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n# 拓展\n拓扑等价：\n有多个解释，其中一个几何上的解释是，一个曲面经过扭转、弯曲、拉长或收缩得到另一个曲面，期间没有出现任何点的重叠与断开，那么可以说这两个曲面是拓扑等价的。\n```\n//知乎上看到的一个笑话\n“美女和丑女在数学上是不是拓扑等价的？”\n“这要看她有没有打耳洞”\n（逃\n```","source":"_posts/Uva10305-Ordering-Tasks.md","raw":"---\ntitle: Uva10305-Ordering Tasks-拓扑排序\ndate: 2018-11-04 19:47:51\ncategories:\n- ACM\n- 拓扑排序\ntags:\n- DFS\n- 拓扑排序\n---\n有n个变量，m个二元组(u, v), 分别表示u小于v。要求给出一种所有变量从小到大排列的可能。\n<!--more-->\n# 链接\n[Uva10305-Ordering Tasks](https://vjudge.net/problem/UVA-10305)\n# 题解\n建图，以变量为顶点，“小于”关系为有向边。问题变为求这个图的拓扑排序。借助DFS来完成排序。\n```\n在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：\n1. 每个顶点出现且只出现一次；\n2. 若A在序列中排在B的前面，则在图中不存在从B到A的路径。\n```\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun  4 Nov 18:47:13 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint n, m;\nint c[maxn];\nint res[maxn];\nint G[maxn][maxn];\nint t;\n\nbool dfs(int u){\n    c[u] = -1;\n    for(int i = 1; i <= n; i++){\n        if(G[u][i]){\n            if(c[i] == -1) return false;\n            else if(c[i] == 0 && !dfs(i)) return false;\n        }\n        //c[u] = 1, res[--t] = u;\n    }\n    c[u] = 1, res[--t] = u;\n    return true;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        t = n;\n        memset(c, 0, sizeof(c));\n        memset(res, 0, sizeof(res));\n        memset(G, 0, sizeof(G));\n        int x, y;\n        for(int i = 0; i < m; i++){\n            cin >> x >> y;\n            G[x][y] = 1;\n        }\n        for(int i = 1; i <= n; i++){\n            if(!c[i]){\n                //cout << \"i: \" << i << endl;\n                dfs(i);\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(!i) cout << res[i];\n            else cout << \" \" << res[i];\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n# 拓展\n拓扑等价：\n有多个解释，其中一个几何上的解释是，一个曲面经过扭转、弯曲、拉长或收缩得到另一个曲面，期间没有出现任何点的重叠与断开，那么可以说这两个曲面是拓扑等价的。\n```\n//知乎上看到的一个笑话\n“美女和丑女在数学上是不是拓扑等价的？”\n“这要看她有没有打耳洞”\n（逃\n```","slug":"Uva10305-Ordering-Tasks","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nlm000zh8vnjvrz8sxm","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva10562-Undraw the trees","date":"2018-11-12T23:33:42.000Z","_content":"看图写树。把类似如图所示的树用\"$(A(B()C(E()F())D(G())))$\"的形式输出出来。在奇怪的地方卡了好久= =，记录一下。\n![tree](/tree.png)\n<!--more-->\n# 链接\n[Uva10562-Undraw the trees](https://vjudge.net/problem/UVA-10562)\n\n# 题解\n直接递归输出。主要说一下自己的卡点：最开始代码34行部分写的是$r = y$，WA到怀疑人生，后来突然想到把字符串读入字符数组中时是覆盖操作，也就是说如果新读入的字符串的长度比已经缓存的要短的话，之前的字符串会有残留。例如，buf[10] = \"abcdef\"，然后再读入新的字符串\"xyz\"后，buf中的内容是\"xyz0ef\"（其中0表示字符串结束标志'\\0'）,自己也就是坑在了这个地方。解决方法有两种，一种是让$r = l$，然后遍历到'\\0'时结束,也就是注释的那种写法；另一种是每次都memset一下= =（经历这次事件后一定每次都记得memset...）。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 13 Nov 08:09:46 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200 + 7;\nchar mp[maxn][maxn];\nint t;\nint n;\n\nvoid dfs(int x, int y){\n    char c = mp[x][y];\n    cout << c << \"(\";\n    if(x + 1 < n && mp[x + 1][y] == '|'){\n        int l = y;\n        while(l > 0 && mp[x + 2][l - 1] == '-') l--;\n        int r = l;\n        while(mp[x + 2][r] == '-' && mp[x + 3][r] != '\\0') r++;\n        for(int i = l; i < r; i++){\n            if(!isspace(mp[x + 3][i])){\n                dfs(x + 3, i);\n            }\n        }\n        \n        /*\n        while(mp[x + 2][l] == '-' && mp[x + 3][l] != '\\0'){\n            if(!isspace(mp[x + 3][l])) dfs(x + 3, l);\n            l++;\n        }\n        */\n\n    }\n    cout << \")\";\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"../in.txt\", \"r\", stdin);\n    #endif\n    cin >> t;\n    getchar();\n    while(t--){\n        memset(mp, 0, sizeof(mp));\n        n = 0;\n        cout << \"(\";\n        while(fgets(mp[n], maxn, stdin)){\n            if(mp[n][0] == '#') break;\n            n++;\n        }\n        if(n){\n            for(int i = 0; i < maxn; i++){\n                if(mp[0][i] != ' '){\n                    dfs(0, i);\n                    break;\n                }\n            }\n        }\n        cout << \")\" << endl;\n    }\n    return 0;\n}\n```","source":"_posts/Uva10562-Undraw the trees.md","raw":"---\ntitle: Uva10562-Undraw the trees\ndate: 2018-11-13 07:33:42\ncategories:\n- ACM\n- 树\ntags:\n- 二叉树\n---\n看图写树。把类似如图所示的树用\"$(A(B()C(E()F())D(G())))$\"的形式输出出来。在奇怪的地方卡了好久= =，记录一下。\n![tree](/tree.png)\n<!--more-->\n# 链接\n[Uva10562-Undraw the trees](https://vjudge.net/problem/UVA-10562)\n\n# 题解\n直接递归输出。主要说一下自己的卡点：最开始代码34行部分写的是$r = y$，WA到怀疑人生，后来突然想到把字符串读入字符数组中时是覆盖操作，也就是说如果新读入的字符串的长度比已经缓存的要短的话，之前的字符串会有残留。例如，buf[10] = \"abcdef\"，然后再读入新的字符串\"xyz\"后，buf中的内容是\"xyz0ef\"（其中0表示字符串结束标志'\\0'）,自己也就是坑在了这个地方。解决方法有两种，一种是让$r = l$，然后遍历到'\\0'时结束,也就是注释的那种写法；另一种是每次都memset一下= =（经历这次事件后一定每次都记得memset...）。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 13 Nov 08:09:46 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200 + 7;\nchar mp[maxn][maxn];\nint t;\nint n;\n\nvoid dfs(int x, int y){\n    char c = mp[x][y];\n    cout << c << \"(\";\n    if(x + 1 < n && mp[x + 1][y] == '|'){\n        int l = y;\n        while(l > 0 && mp[x + 2][l - 1] == '-') l--;\n        int r = l;\n        while(mp[x + 2][r] == '-' && mp[x + 3][r] != '\\0') r++;\n        for(int i = l; i < r; i++){\n            if(!isspace(mp[x + 3][i])){\n                dfs(x + 3, i);\n            }\n        }\n        \n        /*\n        while(mp[x + 2][l] == '-' && mp[x + 3][l] != '\\0'){\n            if(!isspace(mp[x + 3][l])) dfs(x + 3, l);\n            l++;\n        }\n        */\n\n    }\n    cout << \")\";\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"../in.txt\", \"r\", stdin);\n    #endif\n    cin >> t;\n    getchar();\n    while(t--){\n        memset(mp, 0, sizeof(mp));\n        n = 0;\n        cout << \"(\";\n        while(fgets(mp[n], maxn, stdin)){\n            if(mp[n][0] == '#') break;\n            n++;\n        }\n        if(n){\n            for(int i = 0; i < maxn; i++){\n                if(mp[0][i] != ' '){\n                    dfs(0, i);\n                    break;\n                }\n            }\n        }\n        cout << \")\" << endl;\n    }\n    return 0;\n}\n```","slug":"Uva10562-Undraw the trees","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nlm0010h8vn822ze6s4","comments":1,"layout":"post","photos":[],"link":""},{"title":"Rand-C++随机数","date":"2019-04-28T10:55:29.000Z","_content":"![random](/random.jpg)\n\n　　*C++随机数发生器。*\n<!--more-->\n\n# Update\n　　c++11中提供了一种新的产生随机数的方式:\n\n```C++\n#include <iostream>\n#include <random>\n\nint main(){\n    std::random_device device;\n    std::mt19937 generator(device());\n    std::uniform_int_distribution<int> distribution(1, 10); // random integer number bewteen [1, 10]\n    //std::uniform_real_distribution<> distribution(0, 1); // random real number bewteen [0, 1]\n\n    for (uint8_t i = 0; i < 10; i++){\n        std::cout << distribution(generator) << ' ';\n    }\n    std::cout << std::endl;\n}\n```\n## 参考链接\n[Generating random numbers in C++](https://diego.assencio.com/?index=6890b8c50169ef45b74db135063c227c)\n\n\n---------------------------------------------------------------------------------------\n\n**以下为原答案**\n\n---------------------------------------------------------------------------------------\n\n# rand()\n　　生成随机整数的核心函数是``cstdlib``中的``rand()``，它生成一个闭区间 [0, RAND_MAX] 内的均匀随机数（均匀的含义是：该区间内每个整数被随机获取的概率相同），其中``RAND_MAX``是定义在cstdlib中的一个宏变量，在不同环境下的值可能不同，但是保证至少为$32767(2^{15} - 1)$。\n　　*严格地说，这里的随机数是“伪随机数”，因为它也是由数学公式计算出来的，不过在算法领域，多数情况下可以把它当作真正的随机数。*\n\n# 产生[0, n]之间的整数\n　　可以用``rand() % n``的方式产生区间 $[0, n - 1]$ 内的一个随机整数。但是一方面这会破坏产生的整数分布的均匀性，另一方面只要``n``大于 ``RAND_MAX``这种方法就不能得到期望的结果。由于``RAND_MAX``可能只有 32767 这么小，所以在使用这种方法的时候要小心。\n　　另一个方法是执行``rand()``后先除以``RAND_MAX``，得到 $[0, 1]$ 之间的随机实数，扩大``n``倍后四舍五入，得到 $[0, n]$ 之间的均匀整数。\n\n# 具体用法\n　　需要随机数的程序在最开始时一般会执行一次``srand(time(NULL))``，目的是初始化“随机数种子”。简单来说，种子是生成随机数的计算依据。**种子相同，计算出来的“随机数”序列总是相同**。譬如运行下面的程序：\n\n```C++\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nint main(){\n    srand(100);\n    for(int i = 0; i < 3; i++){\n        cout << rand() << endl;\n    }\n    return 0;\n}\n```\n　　可以得到这样的一组随机数：\n```\n677741240\n611911301\n516687479\n```\n　　但是当我们第二次运行这段代码的时候，我们会得到相同的一组随机数，原因就在于，我们每次运行时``srand``函数中初始化的种子始终是``100``。\n　　而当我们使用``srand(time(NULL))``来替代上面的``srand(100)``时，由于``time()``函数会返回系统当前时间，所以每次运行程序时这个值都会不一样，也就使得每次运行生成的随机数序列不同。\n　　*如果不调用``srand``而直接使用``rand()``，相当于调用过一次``srand(1)``。*\n　　另外，**不要在同一个程序每次生成随机数之前都重新调用一次srand。**譬如运行下面的程序：\n```C++\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nint main(){\n    for(int i = 0; i < 3; i++){\n        srand(time(NULL));\n        cout << rand() << endl;\n    }\n    return 0;\n}\n```\n　　会发现生成的三个随机数是相同的（随机数的具体值因人而异）：\n```\n805428961\n805428961\n805428961\n```\n　　仔细思考一下就很可以分析出原因：生成随机数的序列是由“种子”决定的，在这段代码里的种子就是``time(NULL)``的返回值了，也就是系统当前时间（准确来说是自UTC时间1970年1月1日0点依赖经过的“秒数”），它**每秒变化一次**，但是程序在上面三次运行的**时间间隔过短**，应该毫秒甚至微秒级的，因此上面三个随机数是同一个种子生成的，而且因为每次都被重新初始化，所以都是同一个随机数序列的第一个值。\n\n　　*“同一套随机数”可能是好事也可能是坏事。例如，若要反复测试程序对不同随机数据的响应，需要每次得到的随机数不同。另一方面，如果发现某一程序对于一组随机数据报错，就需要在调试时“重现”这组数据。另外，不同的编译器计算随机数的方法可能不同。如果是不同编译器编译出来的程序，即使是用相同参数调用``srand()``，也可能的都不同的随机序列。*\n\n# 参考\n\n　　主要参考了刘汝佳老师的《算法竞赛入门经典》(第2版)第五章中5.2.6-测试STL一节中的内容。\n\n","source":"_posts/Rand-C-随机数.md","raw":"---\ntitle: Rand-C++随机数\ndate: 2019-04-28 18:55:29\ncategories:\n- C++\ntags:\n- Random\n---\n![random](/random.jpg)\n\n　　*C++随机数发生器。*\n<!--more-->\n\n# Update\n　　c++11中提供了一种新的产生随机数的方式:\n\n```C++\n#include <iostream>\n#include <random>\n\nint main(){\n    std::random_device device;\n    std::mt19937 generator(device());\n    std::uniform_int_distribution<int> distribution(1, 10); // random integer number bewteen [1, 10]\n    //std::uniform_real_distribution<> distribution(0, 1); // random real number bewteen [0, 1]\n\n    for (uint8_t i = 0; i < 10; i++){\n        std::cout << distribution(generator) << ' ';\n    }\n    std::cout << std::endl;\n}\n```\n## 参考链接\n[Generating random numbers in C++](https://diego.assencio.com/?index=6890b8c50169ef45b74db135063c227c)\n\n\n---------------------------------------------------------------------------------------\n\n**以下为原答案**\n\n---------------------------------------------------------------------------------------\n\n# rand()\n　　生成随机整数的核心函数是``cstdlib``中的``rand()``，它生成一个闭区间 [0, RAND_MAX] 内的均匀随机数（均匀的含义是：该区间内每个整数被随机获取的概率相同），其中``RAND_MAX``是定义在cstdlib中的一个宏变量，在不同环境下的值可能不同，但是保证至少为$32767(2^{15} - 1)$。\n　　*严格地说，这里的随机数是“伪随机数”，因为它也是由数学公式计算出来的，不过在算法领域，多数情况下可以把它当作真正的随机数。*\n\n# 产生[0, n]之间的整数\n　　可以用``rand() % n``的方式产生区间 $[0, n - 1]$ 内的一个随机整数。但是一方面这会破坏产生的整数分布的均匀性，另一方面只要``n``大于 ``RAND_MAX``这种方法就不能得到期望的结果。由于``RAND_MAX``可能只有 32767 这么小，所以在使用这种方法的时候要小心。\n　　另一个方法是执行``rand()``后先除以``RAND_MAX``，得到 $[0, 1]$ 之间的随机实数，扩大``n``倍后四舍五入，得到 $[0, n]$ 之间的均匀整数。\n\n# 具体用法\n　　需要随机数的程序在最开始时一般会执行一次``srand(time(NULL))``，目的是初始化“随机数种子”。简单来说，种子是生成随机数的计算依据。**种子相同，计算出来的“随机数”序列总是相同**。譬如运行下面的程序：\n\n```C++\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nint main(){\n    srand(100);\n    for(int i = 0; i < 3; i++){\n        cout << rand() << endl;\n    }\n    return 0;\n}\n```\n　　可以得到这样的一组随机数：\n```\n677741240\n611911301\n516687479\n```\n　　但是当我们第二次运行这段代码的时候，我们会得到相同的一组随机数，原因就在于，我们每次运行时``srand``函数中初始化的种子始终是``100``。\n　　而当我们使用``srand(time(NULL))``来替代上面的``srand(100)``时，由于``time()``函数会返回系统当前时间，所以每次运行程序时这个值都会不一样，也就使得每次运行生成的随机数序列不同。\n　　*如果不调用``srand``而直接使用``rand()``，相当于调用过一次``srand(1)``。*\n　　另外，**不要在同一个程序每次生成随机数之前都重新调用一次srand。**譬如运行下面的程序：\n```C++\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nint main(){\n    for(int i = 0; i < 3; i++){\n        srand(time(NULL));\n        cout << rand() << endl;\n    }\n    return 0;\n}\n```\n　　会发现生成的三个随机数是相同的（随机数的具体值因人而异）：\n```\n805428961\n805428961\n805428961\n```\n　　仔细思考一下就很可以分析出原因：生成随机数的序列是由“种子”决定的，在这段代码里的种子就是``time(NULL)``的返回值了，也就是系统当前时间（准确来说是自UTC时间1970年1月1日0点依赖经过的“秒数”），它**每秒变化一次**，但是程序在上面三次运行的**时间间隔过短**，应该毫秒甚至微秒级的，因此上面三个随机数是同一个种子生成的，而且因为每次都被重新初始化，所以都是同一个随机数序列的第一个值。\n\n　　*“同一套随机数”可能是好事也可能是坏事。例如，若要反复测试程序对不同随机数据的响应，需要每次得到的随机数不同。另一方面，如果发现某一程序对于一组随机数据报错，就需要在调试时“重现”这组数据。另外，不同的编译器计算随机数的方法可能不同。如果是不同编译器编译出来的程序，即使是用相同参数调用``srand()``，也可能的都不同的随机序列。*\n\n# 参考\n\n　　主要参考了刘汝佳老师的《算法竞赛入门经典》(第2版)第五章中5.2.6-测试STL一节中的内容。\n\n","slug":"Rand-C-随机数","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nln0011h8vny6mmc66z","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva1103-Ancient Messages-DFS","date":"2018-10-28T13:41:19.000Z","_content":"一道让人惊呼“DFS还能这么玩”的题目。给定一个由象形文字组成的图像，要求按字典序输出图中所有象形文字（输出时每个象形文字由一个给定的英文表示）。关键是通过什么方法区分这些象形文字。\n![hier](/hier.png)\n<!--more-->\n# 链接\n[Uva1103-Ancient Messages](https://vjudge.net/problem/UVA-1103)\n# 题目描述\n图像的像素由 $0$ 和 $1$ 组成，其中 $0$ 代表白色像素点，$1$ 代表黑色像素点。整个图像以十六进制形式给出。图像包含六种象形符号中的至少一个，不同的符号不会相互接触。符号的形状和上图给出的拓扑等价（可以随意拉伸但不能拉断）。\n<div style=\"width: 300px; margin: auto\">\n    ![1.png](/1.png)\n    ![2.png](/2.png)\n</div>\n## 题解\n需要找出能够区别出这些不同象形符号的特征量。可以发现每个符号都包含一些白色的色块区域，6个符号从左到右分别包含 $1$，$3$，$5$，$4$，$0$，$2$ 个白色区域，各不相同。所以可以根据这一特征量区分不同的象形符号。\n具体做法为用dfs方法对每一块黑色或白色区域染色，这样可以把图像分为几个不同的颜色区域，再从每个黑色像素区域出发去统计在它内部的白色像素区域的个数。\n\n*需要注意的是初始时要在图像四周多添加一圈白色像素，以保证color 1 每次都表示的是背景白色像素区域*（因为这个地方$WA$了好多次，$QAQ$）\n\n另外这题没有测试数据也很坑2333，最后友情赠送几组测试数据。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 28 Oct 22:24:10 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxh = 207;\nconst int maxw = 50 * 4 + 7;\nint h, w;\nchar pix[maxh][maxw];\nint dig[maxh][maxw];\nint color[maxh][maxw];\nint dcode[256];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nvector<int> rec;\nset<int> st[maxw];\nconst string s = \"WAKJSD\";\n\nvoid decode(char c, int h, int pos){\n    int x = dcode[(int)c];\n    for(int i = 0; i < 4; i++){\n        if(x & (1 << (3 - i))) dig[h][pos + i] = 1;\n        else dig[h][pos + i] = 0;\n    }\n}\n\nvoid dye(int x, int y, int c){\n    color[x][y] = c;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx >= 0 && nx < h && ny >= 0 && ny < w && color[nx][ny] == 0 && dig[nx][ny] == dig[x][y]){\n            dye(nx, ny, c);\n        }\n    }\n}\n\nvoid cal(int x, int y, int c){\n    //cout << x << \" \" << y << endl;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx >= 0 && nx < h && ny >= 0 && ny < w && color[nx][ny] != 1 && dig[nx][ny] == 0){\n            //cout << \"color:\" << color[nx][ny] << endl;\n            st[c].insert(color[nx][ny]);\n        }\n    }\n}\n\nvoid print(){\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cout << dig[i][j] << \" \";\n        }\n    }\n    cout << endl;\n}\n\nvoid printcolor(){\n    cout << endl;\n    for(int j = 0; j < h; j++){\n        for(int i = 0; i < w; i++){\n            cout << color[j][i] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid init(){\n    dcode['0'] = 0x00;\n    dcode['1'] = 0x01;\n    dcode['2'] = 0x02;\n    dcode['3'] = 0x03;\n    dcode['4'] = 0x04;\n    dcode['5'] = 0x05;\n    dcode['6'] = 0x06;\n    dcode['7'] = 0x07;\n    dcode['8'] = 0x08;\n    dcode['9'] = 0x09;\n    dcode['a'] = 0x0a;\n    dcode['b'] = 0x0b;\n    dcode['c'] = 0x0c;\n    dcode['d'] = 0x0d;\n    dcode['e'] = 0x0e;\n    dcode['f'] = 0x0f;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    init();\n    int cs = 0;\n    while(cin >> h >> w){\n        //cout << h << \" \" << w << endl;\n        if(h == 0 && w == 0) break;\n        cout << \"Case \" << (++cs) << \": \";\n        memset(color, 0, sizeof(color));\n        memset(dig, 0, sizeof(dig));\n        for(int i = 0; i < maxw; i++){\n            st[i].clear();\n        }\n        rec.clear();\n        for(int i = 0; i < h; i++){\n            cin >> pix[i];\n            //cout << pix[i] << endl;\n            for(int j = 0; j < w; j++){\n                decode(pix[i][j], i + 1, j * 4 + 1);\n            }\n        }\n        //给图像四周添加一圈白色像素\n        h += 2;\n        w = w * 4 + 2;\n        \n        //print();\n        \n        int cnt = 0;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(color[i][j] == 0){\n                    dye(i, j, ++cnt);\n                    if(dig[i][j] == 1)\n                        rec.push_back(cnt);\n                }\n            }\n        }\n        //printcolor();\n        for(auto x : rec){\n            //cout << x << endl;\n            for(int i = 0; i < h; i++){\n                for(int j = 0; j < w; j++){\n                    if(color[i][j] == x){\n                        cal(i, j, x);\n                    }\n                }\n            }\n        }\n        vector<int> ans;\n        for(auto x : rec){\n            ans.push_back(st[x].size());\n        }\n        char res[10000];\n        int ct = 0;\n        for(size_t i = 0; i < ans.size(); i++){\n            res[ct++] = s[ans[i]];\n        }\n        sort(res, res + ct);\n        for(int i = 0; i < ct; i++){\n            cout << res[i];\n        }\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n# 测试数据及答案\n```\n//数据\n4 4\n0f00\n330e\n1e06\n0c02\n10 5\n00f00\n0198c\n00f0e\n01f8e\n00604\n001e0\n00330\n003f0\n00210\n003f0\n5 5\n0e00e\n1b3ea\n0e32e\n043e4\n000c0\n5 3\nfff\nf0f\nfff\nf0f\nfff\n5 3\nfff\n70e\n7fe\n70e\n7fe\n0 0\n\n//答案\nCase 1: AW\nCase 2: AKW\nCase 3: AAA\nCase 4: K\nCase 5: K\n```","source":"_posts/Uva1103-Ancient-Messages.md","raw":"---\ntitle: Uva1103-Ancient Messages-DFS\ndate: 2018-10-28 21:41:19\ncategories:\n- ACM\n- DFS\ntags:\n- DFS\n- 全局思维\n---\n一道让人惊呼“DFS还能这么玩”的题目。给定一个由象形文字组成的图像，要求按字典序输出图中所有象形文字（输出时每个象形文字由一个给定的英文表示）。关键是通过什么方法区分这些象形文字。\n![hier](/hier.png)\n<!--more-->\n# 链接\n[Uva1103-Ancient Messages](https://vjudge.net/problem/UVA-1103)\n# 题目描述\n图像的像素由 $0$ 和 $1$ 组成，其中 $0$ 代表白色像素点，$1$ 代表黑色像素点。整个图像以十六进制形式给出。图像包含六种象形符号中的至少一个，不同的符号不会相互接触。符号的形状和上图给出的拓扑等价（可以随意拉伸但不能拉断）。\n<div style=\"width: 300px; margin: auto\">\n    ![1.png](/1.png)\n    ![2.png](/2.png)\n</div>\n## 题解\n需要找出能够区别出这些不同象形符号的特征量。可以发现每个符号都包含一些白色的色块区域，6个符号从左到右分别包含 $1$，$3$，$5$，$4$，$0$，$2$ 个白色区域，各不相同。所以可以根据这一特征量区分不同的象形符号。\n具体做法为用dfs方法对每一块黑色或白色区域染色，这样可以把图像分为几个不同的颜色区域，再从每个黑色像素区域出发去统计在它内部的白色像素区域的个数。\n\n*需要注意的是初始时要在图像四周多添加一圈白色像素，以保证color 1 每次都表示的是背景白色像素区域*（因为这个地方$WA$了好多次，$QAQ$）\n\n另外这题没有测试数据也很坑2333，最后友情赠送几组测试数据。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 28 Oct 22:24:10 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxh = 207;\nconst int maxw = 50 * 4 + 7;\nint h, w;\nchar pix[maxh][maxw];\nint dig[maxh][maxw];\nint color[maxh][maxw];\nint dcode[256];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nvector<int> rec;\nset<int> st[maxw];\nconst string s = \"WAKJSD\";\n\nvoid decode(char c, int h, int pos){\n    int x = dcode[(int)c];\n    for(int i = 0; i < 4; i++){\n        if(x & (1 << (3 - i))) dig[h][pos + i] = 1;\n        else dig[h][pos + i] = 0;\n    }\n}\n\nvoid dye(int x, int y, int c){\n    color[x][y] = c;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx >= 0 && nx < h && ny >= 0 && ny < w && color[nx][ny] == 0 && dig[nx][ny] == dig[x][y]){\n            dye(nx, ny, c);\n        }\n    }\n}\n\nvoid cal(int x, int y, int c){\n    //cout << x << \" \" << y << endl;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx >= 0 && nx < h && ny >= 0 && ny < w && color[nx][ny] != 1 && dig[nx][ny] == 0){\n            //cout << \"color:\" << color[nx][ny] << endl;\n            st[c].insert(color[nx][ny]);\n        }\n    }\n}\n\nvoid print(){\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cout << dig[i][j] << \" \";\n        }\n    }\n    cout << endl;\n}\n\nvoid printcolor(){\n    cout << endl;\n    for(int j = 0; j < h; j++){\n        for(int i = 0; i < w; i++){\n            cout << color[j][i] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid init(){\n    dcode['0'] = 0x00;\n    dcode['1'] = 0x01;\n    dcode['2'] = 0x02;\n    dcode['3'] = 0x03;\n    dcode['4'] = 0x04;\n    dcode['5'] = 0x05;\n    dcode['6'] = 0x06;\n    dcode['7'] = 0x07;\n    dcode['8'] = 0x08;\n    dcode['9'] = 0x09;\n    dcode['a'] = 0x0a;\n    dcode['b'] = 0x0b;\n    dcode['c'] = 0x0c;\n    dcode['d'] = 0x0d;\n    dcode['e'] = 0x0e;\n    dcode['f'] = 0x0f;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    init();\n    int cs = 0;\n    while(cin >> h >> w){\n        //cout << h << \" \" << w << endl;\n        if(h == 0 && w == 0) break;\n        cout << \"Case \" << (++cs) << \": \";\n        memset(color, 0, sizeof(color));\n        memset(dig, 0, sizeof(dig));\n        for(int i = 0; i < maxw; i++){\n            st[i].clear();\n        }\n        rec.clear();\n        for(int i = 0; i < h; i++){\n            cin >> pix[i];\n            //cout << pix[i] << endl;\n            for(int j = 0; j < w; j++){\n                decode(pix[i][j], i + 1, j * 4 + 1);\n            }\n        }\n        //给图像四周添加一圈白色像素\n        h += 2;\n        w = w * 4 + 2;\n        \n        //print();\n        \n        int cnt = 0;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(color[i][j] == 0){\n                    dye(i, j, ++cnt);\n                    if(dig[i][j] == 1)\n                        rec.push_back(cnt);\n                }\n            }\n        }\n        //printcolor();\n        for(auto x : rec){\n            //cout << x << endl;\n            for(int i = 0; i < h; i++){\n                for(int j = 0; j < w; j++){\n                    if(color[i][j] == x){\n                        cal(i, j, x);\n                    }\n                }\n            }\n        }\n        vector<int> ans;\n        for(auto x : rec){\n            ans.push_back(st[x].size());\n        }\n        char res[10000];\n        int ct = 0;\n        for(size_t i = 0; i < ans.size(); i++){\n            res[ct++] = s[ans[i]];\n        }\n        sort(res, res + ct);\n        for(int i = 0; i < ct; i++){\n            cout << res[i];\n        }\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n# 测试数据及答案\n```\n//数据\n4 4\n0f00\n330e\n1e06\n0c02\n10 5\n00f00\n0198c\n00f0e\n01f8e\n00604\n001e0\n00330\n003f0\n00210\n003f0\n5 5\n0e00e\n1b3ea\n0e32e\n043e4\n000c0\n5 3\nfff\nf0f\nfff\nf0f\nfff\n5 3\nfff\n70e\n7fe\n70e\n7fe\n0 0\n\n//答案\nCase 1: AW\nCase 2: AKW\nCase 3: AAA\nCase 4: K\nCase 5: K\n```","slug":"Uva1103-Ancient-Messages","published":1,"updated":"2021-04-21T03:30:14.760Z","_id":"ck0uh6nln0012h8vndydzbugr","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva11059-Maximum Product-暴力枚举","date":"2018-12-17T12:07:59.000Z","_content":"输入$n$个元素组成的序列$S$，找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，输出0。$1 <=n <= 18，-10 <= S_i <= 10$。\n<!--more-->\n# 链接\n[Uva11059-Maximum Product](https://vjudge.net/problem/UVA-11059)\n\n# 题解\n**连续子序列有两个要素：起点和终点**。因此枚举起点和终点即可。\n\n*注意用long long存储。*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 16 Dec 23:18:45 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 20;\nint n;\nint d[maxn];\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int cnt = 0;\n    while(cin >> n){\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        \n        long long res = 0, p = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                p = 1;\n                for(int k = i; k <= j; k++){\n                    p *= d[k];\n                }\n                res = max(res, p);\n            }\n        }        \n\n        cout << \"Case #\" << ++cnt << \": The maximum product is \" << res << \".\" << endl << endl;\n    }\n    return 0;\n}\n```\n循环枚举部分还可以写成这种稍难理解但简单的形式：\n```C++\nfor(int i = 0; i < n; i++){\n    p = 1;\n    for(int j = i; j < n; j++){\n        p *= d[j];\n        res = max(res, p);\n    }\n}\n```","source":"_posts/Uva11059-Maximum-Product.md","raw":"---\ntitle: Uva11059-Maximum Product-暴力枚举\ndate: 2018-12-17 20:07:59\ncategories:\n- ACM\n- 暴力枚举\ntags:\n- 暴力枚举\n---\n输入$n$个元素组成的序列$S$，找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，输出0。$1 <=n <= 18，-10 <= S_i <= 10$。\n<!--more-->\n# 链接\n[Uva11059-Maximum Product](https://vjudge.net/problem/UVA-11059)\n\n# 题解\n**连续子序列有两个要素：起点和终点**。因此枚举起点和终点即可。\n\n*注意用long long存储。*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 16 Dec 23:18:45 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 20;\nint n;\nint d[maxn];\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int cnt = 0;\n    while(cin >> n){\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        \n        long long res = 0, p = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                p = 1;\n                for(int k = i; k <= j; k++){\n                    p *= d[k];\n                }\n                res = max(res, p);\n            }\n        }        \n\n        cout << \"Case #\" << ++cnt << \": The maximum product is \" << res << \".\" << endl << endl;\n    }\n    return 0;\n}\n```\n循环枚举部分还可以写成这种稍难理解但简单的形式：\n```C++\nfor(int i = 0; i < n; i++){\n    p = 1;\n    for(int j = i; j < n; j++){\n        p *= d[j];\n        res = max(res, p);\n    }\n}\n```","slug":"Uva11059-Maximum-Product","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlo0013h8vnlzl3v5iu","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva12118-Inspetor's Dilemma-DFS求连通+欧拉路","date":"2018-12-17T10:36:53.000Z","_content":"V个城市之间两两相连，给定E条需要走的边，走过一条边需要时间T。求走完所有的E条边需要的最少时间。E条边不一定在一个连通图中。\n竟然卡在``ifndef ONLINE_JUDGE``上好久，单词``ONLINE``手滑打成了``ONLIEN``，= =。吐血。\n\n*紫书第六章结束*\n<!--more-->\n# 链接\n题目链接[Uva12118-Inspetor's Dilemma](https://vjudge.net/problem/UVA-12118)\n参考[SingleK's Blog](https://blog.csdn.net/xiao_k666/article/details/79209697)精简了自己的代码。\n\n# 题解\n因为E条边不一定在一个连通图中，所以首先DFS遍历连通块，统计每一个连通块中度数为奇数的结点个数。若能满足构成欧拉路的条件，则一次“一笔画”就可以走完当前连通块中的边。若不能构成欧拉路（奇度数结点个数大于2），则通过加边的方式，使其可以构成欧拉路。n个连通块之间还需要n - 1条边连接。\n所以最后的所需要走过的边是E，加上添加边的个数，再加上连通块个数减1。\n\n*最后不要忘记乘以T得到总耗时 = =，以及当给定E为0时，结果会出现负数，要特判。*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 15 Dec 17:21:07 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e3 + 7;\nint V, E, T;\nbool vis[maxn];\nvector<int> d[maxn];\nint ans;\nint odd;\n\nvoid dfs(int u){\n    vis[u] = 1;\n    if(d[u].size() % 2) odd++;\n    for(size_t i = 0; i < d[u].size(); i++){\n        int v = d[u][i];\n        if(!vis[v]){\n            dfs(v);\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int kase = 0;\n    while(cin >> V >> E >> T){\n        if(V == 0 && E == 0 && T == 0) break;\n        kase++;\n        memset(vis, 0, sizeof(vis));\n        for(int i = 1; i <= V; i++){\n            d[i].clear();\n        }\n        ans = 0;\n\n        int u, v;\n        for(int i = 0; i < E; i++){\n            cin >> u >> v;\n            d[u].push_back(v);\n            d[v].push_back(u);\n        }\n\n        int cnt = 0;\n        for(int i = 1; i <= V; i++){\n            odd = 0;\n            if(!d[i].empty() && !vis[i]){\n                dfs(i);\n                cnt++;\n                if(odd > 2) ans += (odd - 2) / 2;\n            }\n        }\n        ans += E;\n        ans += cnt - 1;\n        ans *= T;\n        if(ans < 0) cout << \"Case \" << kase << \": \" << 0 << endl;\n        else cout << \"Case \" << kase << \": \" << ans << endl;\n    }\n    return 0;\n}\n```","source":"_posts/Uva12118-Inspetor-s-Dilemma.md","raw":"---\ntitle: Uva12118-Inspetor's Dilemma-DFS求连通+欧拉路\ndate: 2018-12-17 18:36:53\ncategories:\n- ACM\n- 欧拉路\ntags:\n- 欧拉路\n---\nV个城市之间两两相连，给定E条需要走的边，走过一条边需要时间T。求走完所有的E条边需要的最少时间。E条边不一定在一个连通图中。\n竟然卡在``ifndef ONLINE_JUDGE``上好久，单词``ONLINE``手滑打成了``ONLIEN``，= =。吐血。\n\n*紫书第六章结束*\n<!--more-->\n# 链接\n题目链接[Uva12118-Inspetor's Dilemma](https://vjudge.net/problem/UVA-12118)\n参考[SingleK's Blog](https://blog.csdn.net/xiao_k666/article/details/79209697)精简了自己的代码。\n\n# 题解\n因为E条边不一定在一个连通图中，所以首先DFS遍历连通块，统计每一个连通块中度数为奇数的结点个数。若能满足构成欧拉路的条件，则一次“一笔画”就可以走完当前连通块中的边。若不能构成欧拉路（奇度数结点个数大于2），则通过加边的方式，使其可以构成欧拉路。n个连通块之间还需要n - 1条边连接。\n所以最后的所需要走过的边是E，加上添加边的个数，再加上连通块个数减1。\n\n*最后不要忘记乘以T得到总耗时 = =，以及当给定E为0时，结果会出现负数，要特判。*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 15 Dec 17:21:07 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e3 + 7;\nint V, E, T;\nbool vis[maxn];\nvector<int> d[maxn];\nint ans;\nint odd;\n\nvoid dfs(int u){\n    vis[u] = 1;\n    if(d[u].size() % 2) odd++;\n    for(size_t i = 0; i < d[u].size(); i++){\n        int v = d[u][i];\n        if(!vis[v]){\n            dfs(v);\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int kase = 0;\n    while(cin >> V >> E >> T){\n        if(V == 0 && E == 0 && T == 0) break;\n        kase++;\n        memset(vis, 0, sizeof(vis));\n        for(int i = 1; i <= V; i++){\n            d[i].clear();\n        }\n        ans = 0;\n\n        int u, v;\n        for(int i = 0; i < E; i++){\n            cin >> u >> v;\n            d[u].push_back(v);\n            d[v].push_back(u);\n        }\n\n        int cnt = 0;\n        for(int i = 1; i <= V; i++){\n            odd = 0;\n            if(!d[i].empty() && !vis[i]){\n                dfs(i);\n                cnt++;\n                if(odd > 2) ans += (odd - 2) / 2;\n            }\n        }\n        ans += E;\n        ans += cnt - 1;\n        ans *= T;\n        if(ans < 0) cout << \"Case \" << kase << \": \" << 0 << endl;\n        else cout << \"Case \" << kase << \": \" << ans << endl;\n    }\n    return 0;\n}\n```","slug":"Uva12118-Inspetor-s-Dilemma","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlo0014h8vn7z0u31dd","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva11212-Editing a Book-IDA*","date":"2019-01-12T01:20:13.000Z","_content":"有$n（1 < n < 10）$个段落初始按一定顺序排列，要求通过“剪切”和“粘贴”操作把这n个段落调整为按编号1，2，...，n顺序排列。其中每次可以同时剪几个连续的段落，求最少的操作步数。\n<!--more-->\n# 链接\n[Uva11212-Editing a Book](https://vjudge.net/problem/UVA-11212)\n\n# 题解\n如果采用BFS进行状态搜索，总的状态数为$9! = 362880$，这个状态数量不是很大，但是每个状态的后继转移情况很多（可以剪切任意一个区间粘贴在剪切后的序列的任意一个位置处），所以可能会超时。\n采用IDA\\*求解，可以发现$n <= 9$ 时最多只需要8步，因为深度上限为8。接下来考虑剪切时的启发函数，统计序列中后继不正确的数字个数h，可以证明每次剪切时h最多减少3，因此当``h / 3 > maxd - d``，即``3d + h > 3maxd``时可以剪枝，其中d为当前深度，maxd为深度限制。\n![prune](/prune.png)\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 11 Jan 21:47:39 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10;\nint n;\nint d[maxn];\nint maxd;\n\nbool judge(){\n    for(int i = 0; i < n - 1; i++){\n        if(d[i] > d[i + 1]) return false;\n    }\n    return true;\n}\n\nint h(){\n    int cnt = 0;\n    for(int i = 0; i < n - 1; i++){\n        if(d[i] != d[i + 1] - 1) cnt++;\n    }\n    if(d[n - 1] - d[0] != n - 1) cnt++;\n    return cnt;\n}\n\nbool dfs(int dep, int maxd){\n    if(3 * dep + h() > 3 * maxd) return false;\n    if(dep >= maxd){\n        if(judge()) return true;\n        else return false;\n    }\n    int tmp[10], oldd[10];\n    memcpy(oldd, d, sizeof(d));\n    for(int i = 0; i < n; i++){\n        for(int j = i; j < n; j++){\n            \n            //cut\n            int cnt = 0;\n            for(int k = 0; k < n; k++){\n                if(k < i || k > j) tmp[cnt++] = d[k];\n            }\n\n            //find a position to paste before it\n            int cnt2;\n            for(int k = 0; k <= cnt; k++){\n                cnt2 = 0;\n                for(int p = 0; p < k; p++) d[cnt2++] = tmp[p];\n                for(int p = i; p <= j; p++) d[cnt2++] = oldd[p];\n                for(int p = k; p < cnt; p++) d[cnt2++] = tmp[p];\n                if(dfs(dep + 1, maxd)) return true;\n                memcpy(d, oldd, sizeof(d));\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int kase = 0;\n    while(cin >> n){\n        if(n == 0) break;\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        for(maxd = 0; maxd < 10; maxd++){\n            if(dfs(0, maxd)) break;\n        }\n        cout << \"Case \" << ++kase << \": \" << maxd << endl;\n    }\n    return 0;\n}\n```","source":"_posts/Uva11212-Editing-a-Book.md","raw":"---\ntitle: Uva11212-Editing a Book-IDA*\ndate: 2019-01-12 09:20:13\ncategories:\n- ACM\n- IDA*\ntags:\n- 迭代加深\n---\n有$n（1 < n < 10）$个段落初始按一定顺序排列，要求通过“剪切”和“粘贴”操作把这n个段落调整为按编号1，2，...，n顺序排列。其中每次可以同时剪几个连续的段落，求最少的操作步数。\n<!--more-->\n# 链接\n[Uva11212-Editing a Book](https://vjudge.net/problem/UVA-11212)\n\n# 题解\n如果采用BFS进行状态搜索，总的状态数为$9! = 362880$，这个状态数量不是很大，但是每个状态的后继转移情况很多（可以剪切任意一个区间粘贴在剪切后的序列的任意一个位置处），所以可能会超时。\n采用IDA\\*求解，可以发现$n <= 9$ 时最多只需要8步，因为深度上限为8。接下来考虑剪切时的启发函数，统计序列中后继不正确的数字个数h，可以证明每次剪切时h最多减少3，因此当``h / 3 > maxd - d``，即``3d + h > 3maxd``时可以剪枝，其中d为当前深度，maxd为深度限制。\n![prune](/prune.png)\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 11 Jan 21:47:39 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10;\nint n;\nint d[maxn];\nint maxd;\n\nbool judge(){\n    for(int i = 0; i < n - 1; i++){\n        if(d[i] > d[i + 1]) return false;\n    }\n    return true;\n}\n\nint h(){\n    int cnt = 0;\n    for(int i = 0; i < n - 1; i++){\n        if(d[i] != d[i + 1] - 1) cnt++;\n    }\n    if(d[n - 1] - d[0] != n - 1) cnt++;\n    return cnt;\n}\n\nbool dfs(int dep, int maxd){\n    if(3 * dep + h() > 3 * maxd) return false;\n    if(dep >= maxd){\n        if(judge()) return true;\n        else return false;\n    }\n    int tmp[10], oldd[10];\n    memcpy(oldd, d, sizeof(d));\n    for(int i = 0; i < n; i++){\n        for(int j = i; j < n; j++){\n            \n            //cut\n            int cnt = 0;\n            for(int k = 0; k < n; k++){\n                if(k < i || k > j) tmp[cnt++] = d[k];\n            }\n\n            //find a position to paste before it\n            int cnt2;\n            for(int k = 0; k <= cnt; k++){\n                cnt2 = 0;\n                for(int p = 0; p < k; p++) d[cnt2++] = tmp[p];\n                for(int p = i; p <= j; p++) d[cnt2++] = oldd[p];\n                for(int p = k; p < cnt; p++) d[cnt2++] = tmp[p];\n                if(dfs(dep + 1, maxd)) return true;\n                memcpy(d, oldd, sizeof(d));\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int kase = 0;\n    while(cin >> n){\n        if(n == 0) break;\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        for(maxd = 0; maxd < 10; maxd++){\n            if(dfs(0, maxd)) break;\n        }\n        cout << \"Case \" << ++kase << \": \" << maxd << endl;\n    }\n    return 0;\n}\n```","slug":"Uva11212-Editing-a-Book","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlo0015h8vnnf3vvbpj","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva11853-Painball-全局+DFS","date":"2018-11-20T02:53:30.000Z","_content":"好题哇。有一个 $1000 \\times 1000$ 的方形场地，有n个敌人分别在 $(x_i，y_i)$ 处，且每个人有一个攻击范围 $r_i$ ,求解是否可以在不受攻击的情况下从场地的最西侧走到场地的最东侧，若可以，输出起始和终点坐标。如果有多个位置满足条件，输出最靠北的位置。\n<!--more-->\n# 链接\n[Uva-Painball](https://vjudge.net/problem/UVA-11853)\n\n# 题解\n一开始的思路是建一个 $1000 \\times 1000$ 的图，将每一个敌人攻击范围内的所有点做标记，做为图中的障碍物，然后从上边界开始跑一遍DFS/BFS，看是否可以到达下边界。如果可以的话说明图被分成了左右两部分，东西两侧不可达。参考了刘汝佳老师的代码后发现完全没有这个必要 = =。\n不以坐标为基本单位，而直接以各个圆为基本单位，从一个与上边界有交的圆出发，不断递归寻找和它自身相交的圆，判断是否可以到达一个与下边界相交的圆。同时沿途检查这一系列中和左右边界有交的圆，这些圆和左边界的所有交点中最南边的点就是最北起始点，和右边界的所有交点中最南边的点就是最北终止点。膜Orz。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 20 Nov 09:54:58 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1000 + 7;\nconst double brd = 1000.0;\nint n;\ndouble x[maxn], y[maxn], r[maxn];\nbool vis[maxn];\nbool ok;\ndouble lb, rb;\n\nbool intersect(int u, int v){\n    return (x[u] - x[v]) * (x[u] - x[v]) + (y[u] - y[v]) * (y[u] - y[v]) <= (r[u] + r[v]) * (r[u] + r[v]);\n}\n\nvoid checkcircle(int c){\n    if(x[c] - r[c] <= 0){\n        lb = min(lb, y[c] - sqrt(r[c] * r[c] - x[c] * x[c]));\n    }\n    if(x[c] + r[c] >= brd){\n        rb = min(rb, y[c] - sqrt(r[c] * r[c] - (brd - x[c]) * (brd - x[c])));\n    }\n}\n\nvoid dfs(int c){\n    if(y[c] - r[c] <= 0){\n        ok = false;\n        return;\n    }\n    for(int i = 0; i < n; i++){\n        if(!vis[i] && intersect(c, i)){\n            vis[i] = 1;\n            dfs(i);\n        }\n    }\n    checkcircle(c);\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        ok = true;\n        lb = rb = brd;\n        memset(vis, 0, sizeof(vis));\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i] >> r[i];\n        }\n        for(int i = 0; i < n; i++){\n            if(y[i] + r[i] >= brd){\n                vis[i] = 1;\n                dfs(i);\n                if(!ok) break;\n            }\n        }\n        if(!ok) cout << \"IMPOSSIBLE\" << endl;\n        else printf(\"0.00 %.2f 1000.00 %.2f\\n\", lb, rb);\n    }\n    return 0;\n}\n```","source":"_posts/Uva11853-Painball.md","raw":"---\ntitle: Uva11853-Painball-全局+DFS\ndate: 2018-11-20 10:53:30\ncategories:\n- ACM\n- DFS\ntags:\n- DFS\n- 全局思想\n---\n好题哇。有一个 $1000 \\times 1000$ 的方形场地，有n个敌人分别在 $(x_i，y_i)$ 处，且每个人有一个攻击范围 $r_i$ ,求解是否可以在不受攻击的情况下从场地的最西侧走到场地的最东侧，若可以，输出起始和终点坐标。如果有多个位置满足条件，输出最靠北的位置。\n<!--more-->\n# 链接\n[Uva-Painball](https://vjudge.net/problem/UVA-11853)\n\n# 题解\n一开始的思路是建一个 $1000 \\times 1000$ 的图，将每一个敌人攻击范围内的所有点做标记，做为图中的障碍物，然后从上边界开始跑一遍DFS/BFS，看是否可以到达下边界。如果可以的话说明图被分成了左右两部分，东西两侧不可达。参考了刘汝佳老师的代码后发现完全没有这个必要 = =。\n不以坐标为基本单位，而直接以各个圆为基本单位，从一个与上边界有交的圆出发，不断递归寻找和它自身相交的圆，判断是否可以到达一个与下边界相交的圆。同时沿途检查这一系列中和左右边界有交的圆，这些圆和左边界的所有交点中最南边的点就是最北起始点，和右边界的所有交点中最南边的点就是最北终止点。膜Orz。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 20 Nov 09:54:58 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1000 + 7;\nconst double brd = 1000.0;\nint n;\ndouble x[maxn], y[maxn], r[maxn];\nbool vis[maxn];\nbool ok;\ndouble lb, rb;\n\nbool intersect(int u, int v){\n    return (x[u] - x[v]) * (x[u] - x[v]) + (y[u] - y[v]) * (y[u] - y[v]) <= (r[u] + r[v]) * (r[u] + r[v]);\n}\n\nvoid checkcircle(int c){\n    if(x[c] - r[c] <= 0){\n        lb = min(lb, y[c] - sqrt(r[c] * r[c] - x[c] * x[c]));\n    }\n    if(x[c] + r[c] >= brd){\n        rb = min(rb, y[c] - sqrt(r[c] * r[c] - (brd - x[c]) * (brd - x[c])));\n    }\n}\n\nvoid dfs(int c){\n    if(y[c] - r[c] <= 0){\n        ok = false;\n        return;\n    }\n    for(int i = 0; i < n; i++){\n        if(!vis[i] && intersect(c, i)){\n            vis[i] = 1;\n            dfs(i);\n        }\n    }\n    checkcircle(c);\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        ok = true;\n        lb = rb = brd;\n        memset(vis, 0, sizeof(vis));\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i] >> r[i];\n        }\n        for(int i = 0; i < n; i++){\n            if(y[i] + r[i] >= brd){\n                vis[i] = 1;\n                dfs(i);\n                if(!ok) break;\n            }\n        }\n        if(!ok) cout << \"IMPOSSIBLE\" << endl;\n        else printf(\"0.00 %.2f 1000.00 %.2f\\n\", lb, rb);\n    }\n    return 0;\n}\n```","slug":"Uva11853-Painball","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlp0016h8vndsasio9t","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva12096-The SetStack Computer-STL","date":"2018-08-09T14:44:02.000Z","_content":"最近在看刘汝佳老师的《算法竞赛入门经典（第2版）》，收获很大，很多知识都在上面查漏补缺，书上有一道STL的例题，用到了stack、vector、map、set，而且“化集合为ID”的思路很好，记录一下。\n<!-- more -->\n# 链接\n[Uva12096-The SetStack Computer](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3248)\n# 题目描述\n有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且支持一下操作。\n- PUSH:空集“{}”入栈。\n- DUP:把当前栈顶元素复制一份后再入栈。\n- UNION:出栈两个集合，然后把二者的并集入栈。\n- INTERSECT:出栈两个集合，然后把出栈的集合加入到后出栈的集合中，把结果入栈。\n\n每次操作后，输出栈顶集合的大小（即元素个数）。\n\n# 题解\n本题的集合并不是简单的整数集合或者字符串集合，而是集合的集合。为了方便为每个不同的集合分配一个唯一的ID，则每个集合都可以表示成所包含元素的ID的集合，这样就可以用STL的set<int> 来表示了，而整个栈则是一个stack<int>。map用来把集合映射成ID，vector则根据ID取集合。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu  9 Aug 16:19:36 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nint n;\ntypedef set<int> Set;\nmap<Set, int> mp;\nvector<Set> vec;\n\nint ID(Set st){\n    if(mp.count(st)) return mp[st];\n    vec.push_back(st);\n    return mp[st] = vec.size() - 1;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        cin >> n;\n        stack<int> stc;\n        string s;\n        vec.clear();\n        mp.clear();\n        for(int i = 0; i < n; i++){\n            cin >> s;\n            if(s[0] == 'P') stc.push(ID(Set ()));\n            else if(s[0] == 'D') stc.push(stc.top());\n            else{\n                Set st1 = vec[stc.top()]; stc.pop();\n                Set st2 = vec[stc.top()]; stc.pop();\n                Set st;\n                if(s[0] == 'U') set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'I') set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'A') {st = st2; st.insert(ID(st1));}\n                stc.push(ID(st));\n            }\n            cout << vec[stc.top()].size() << endl;\n        }\n        cout << \"***\" << endl;\n    }\n    \n    return 0;\n}\n```\n# 补充\n## 并集\n对两个集合取交集可以使用std::set_union，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n## 交集\n对两个集合取交集可以使用std::set_intersection，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n类似的还有：\n- set_difference:差集，从第一个区间去除第二个区间的元素。\n- set_merge:合并，与set_union不同，set_merge不会去除重复的元素（不能用于set，可用于vector）。\n\n注意：set_union和set_intersection等也可用于vector，但必须是排好序的vector。\n","source":"_posts/Uva12096-The-SetStack-Computer-STL.md","raw":"---\ntitle: Uva12096-The SetStack Computer-STL\ndate: 2018-08-09 22:44:02\ncategories:\n- ACM\n- map\ntags:\n- stack\n- STL\n---\n最近在看刘汝佳老师的《算法竞赛入门经典（第2版）》，收获很大，很多知识都在上面查漏补缺，书上有一道STL的例题，用到了stack、vector、map、set，而且“化集合为ID”的思路很好，记录一下。\n<!-- more -->\n# 链接\n[Uva12096-The SetStack Computer](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3248)\n# 题目描述\n有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且支持一下操作。\n- PUSH:空集“{}”入栈。\n- DUP:把当前栈顶元素复制一份后再入栈。\n- UNION:出栈两个集合，然后把二者的并集入栈。\n- INTERSECT:出栈两个集合，然后把出栈的集合加入到后出栈的集合中，把结果入栈。\n\n每次操作后，输出栈顶集合的大小（即元素个数）。\n\n# 题解\n本题的集合并不是简单的整数集合或者字符串集合，而是集合的集合。为了方便为每个不同的集合分配一个唯一的ID，则每个集合都可以表示成所包含元素的ID的集合，这样就可以用STL的set<int> 来表示了，而整个栈则是一个stack<int>。map用来把集合映射成ID，vector则根据ID取集合。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu  9 Aug 16:19:36 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nint n;\ntypedef set<int> Set;\nmap<Set, int> mp;\nvector<Set> vec;\n\nint ID(Set st){\n    if(mp.count(st)) return mp[st];\n    vec.push_back(st);\n    return mp[st] = vec.size() - 1;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        cin >> n;\n        stack<int> stc;\n        string s;\n        vec.clear();\n        mp.clear();\n        for(int i = 0; i < n; i++){\n            cin >> s;\n            if(s[0] == 'P') stc.push(ID(Set ()));\n            else if(s[0] == 'D') stc.push(stc.top());\n            else{\n                Set st1 = vec[stc.top()]; stc.pop();\n                Set st2 = vec[stc.top()]; stc.pop();\n                Set st;\n                if(s[0] == 'U') set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'I') set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'A') {st = st2; st.insert(ID(st1));}\n                stc.push(ID(st));\n            }\n            cout << vec[stc.top()].size() << endl;\n        }\n        cout << \"***\" << endl;\n    }\n    \n    return 0;\n}\n```\n# 补充\n## 并集\n对两个集合取交集可以使用std::set_union，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n## 交集\n对两个集合取交集可以使用std::set_intersection，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n类似的还有：\n- set_difference:差集，从第一个区间去除第二个区间的元素。\n- set_merge:合并，与set_union不同，set_merge不会去除重复的元素（不能用于set，可用于vector）。\n\n注意：set_union和set_intersection等也可用于vector，但必须是排好序的vector。\n","slug":"Uva12096-The-SetStack-Computer-STL","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlp0017h8vni8zki75q","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva1343-The Rotation Game-IDA*","date":"2019-01-13T03:13:57.000Z","_content":"如下图所以，#字型方格中填充有数字1，2，3。每种数字的个数为8，每行每列都可以“滚动”，实际上是指每行每列的数组可以左右移位。求使得中间8个小格子变为同一种数字的“滚动”方式，要求步数最少，步数相同的情况下滚动序列的字典序最小。\n\n_我发现IDA\\*好像因为深度限制以及估价函数的存在而不需要进行判重。_\n![game](/game.png)\n<!--more-->\n\n# 链接\n题目链接：[Uva1343-The Rotation Game](https://vjudge.net/problem/UVA-1343)\n参考链接：[Rujia Liu's repository](https://github.com/aoapc-book/aoapc-bac2nd/blob/master/ch7/UVa1343.cpp)\n\n# 题解\n一开始想用BFS进行状态空间搜索，但是状态数总共有``24!/(8!*8!*8!) = 9465511770``种情况，而且我也不知道怎样构造哈希比较合适=　=。刘汝佳老师的IDA\\*实现方法代码简单清晰，而且很自然的满足了题目中的步数最少，字典序最小的要求。__而且我发现IDA\\*好像因为深度的限制和估价函数的存在而不需要考虑判重的问题。__\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 13 Jan 10:18:02 CST 2019\n *\n */\n\n/* \n      00    01\n      02    03\n04 05 06 07 08 09 10\n      11    12\n13 14 15 16 17 18 19\n      20    21\n      22    23\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[24];\nint id[8][7] = {\n    {0, 2, 6, 11, 15, 20, 22},\n    {1, 3, 8, 12, 17, 21, 23},\n    {10, 9, 8, 7, 6, 5, 4},\n    {19, 18, 17, 16, 15, 14, 13},\n    {23, 21, 17, 12, 8, 3, 1},\n    {22, 20, 15, 11, 6, 2, 0},\n    {13, 14, 15, 16, 17, 18, 19},\n    {4, 5, 6, 7, 8, 9, 10}\n};\nint reff[8] = {5, 4, 7, 6, 1, 0, 3, 2}; // reverse lines of each line\nint center[8] = {6, 7, 8, 11, 12, 15, 16, 17}; //center squares's real idex in array d\nchar ans[1000];\nint res;\n\nbool ok(){\n    for(int i = 0; i < 7; i++){\n        if(d[center[i]] != d[center[i + 1]]) return false;\n    }\n    return true;\n}\n\nvoid move(int p){\n    int tmp = d[id[p][0]];\n    for(int i = 0; i < 6; i++){\n        d[id[p][i]] = d[id[p][i + 1]];\n    }\n    d[id[p][6]] = tmp;\n}\n\nint cal(int x){\n    int sum = 0;\n    for(int i = 0; i < 8; i++){\n        if(d[center[i]] != x) sum++;\n    }\n    return sum;\n}\n\nint h(){\n    return min(min(cal(1), cal(2)), cal(3));\n}\n\nbool dfs(int dep, int maxd){\n    if(dep + h() > maxd) return false;\n    if(dep >= maxd){\n        if(ok()){\n            res = d[center[0]];\n            for(int i = 0; i < dep; i++){\n                cout << ans[i];\n            }\n            cout << endl;\n            cout << res << endl;\n            return true;\n        }\n        return false;\n    }\n\n    for(int i = 0; i < 8; i++){\n        ans[dep] = 'A' + i;\n        move(i);\n        if(dfs(dep + 1, maxd)) return true;\n        move(reff[i]);\n    }\n    return false;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(1){\n        cin >> d[0];\n        if(d[0] == 0) break;\n        for(int i = 1; i < 24; i++){\n            cin >> d[i];\n        }\n\n        if(ok()){\n            cout << \"No moves needed\" << endl;\n            cout << d[center[0]] << endl;\n            continue;\n        }\n        int maxd;\n        for(maxd = 1; ; maxd++){\n            if(dfs(0, maxd)) break;\n        }\n    }\n    \n    return 0;\n}\n```","source":"_posts/Uva1343-The-Rotation-Game.md","raw":"---\ntitle: Uva1343-The Rotation Game-IDA*\ndate: 2019-01-13 11:13:57\ncategories:\n- ACM\n- IDA*\ntags:\n---\n如下图所以，#字型方格中填充有数字1，2，3。每种数字的个数为8，每行每列都可以“滚动”，实际上是指每行每列的数组可以左右移位。求使得中间8个小格子变为同一种数字的“滚动”方式，要求步数最少，步数相同的情况下滚动序列的字典序最小。\n\n_我发现IDA\\*好像因为深度限制以及估价函数的存在而不需要进行判重。_\n![game](/game.png)\n<!--more-->\n\n# 链接\n题目链接：[Uva1343-The Rotation Game](https://vjudge.net/problem/UVA-1343)\n参考链接：[Rujia Liu's repository](https://github.com/aoapc-book/aoapc-bac2nd/blob/master/ch7/UVa1343.cpp)\n\n# 题解\n一开始想用BFS进行状态空间搜索，但是状态数总共有``24!/(8!*8!*8!) = 9465511770``种情况，而且我也不知道怎样构造哈希比较合适=　=。刘汝佳老师的IDA\\*实现方法代码简单清晰，而且很自然的满足了题目中的步数最少，字典序最小的要求。__而且我发现IDA\\*好像因为深度的限制和估价函数的存在而不需要考虑判重的问题。__\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 13 Jan 10:18:02 CST 2019\n *\n */\n\n/* \n      00    01\n      02    03\n04 05 06 07 08 09 10\n      11    12\n13 14 15 16 17 18 19\n      20    21\n      22    23\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint d[24];\nint id[8][7] = {\n    {0, 2, 6, 11, 15, 20, 22},\n    {1, 3, 8, 12, 17, 21, 23},\n    {10, 9, 8, 7, 6, 5, 4},\n    {19, 18, 17, 16, 15, 14, 13},\n    {23, 21, 17, 12, 8, 3, 1},\n    {22, 20, 15, 11, 6, 2, 0},\n    {13, 14, 15, 16, 17, 18, 19},\n    {4, 5, 6, 7, 8, 9, 10}\n};\nint reff[8] = {5, 4, 7, 6, 1, 0, 3, 2}; // reverse lines of each line\nint center[8] = {6, 7, 8, 11, 12, 15, 16, 17}; //center squares's real idex in array d\nchar ans[1000];\nint res;\n\nbool ok(){\n    for(int i = 0; i < 7; i++){\n        if(d[center[i]] != d[center[i + 1]]) return false;\n    }\n    return true;\n}\n\nvoid move(int p){\n    int tmp = d[id[p][0]];\n    for(int i = 0; i < 6; i++){\n        d[id[p][i]] = d[id[p][i + 1]];\n    }\n    d[id[p][6]] = tmp;\n}\n\nint cal(int x){\n    int sum = 0;\n    for(int i = 0; i < 8; i++){\n        if(d[center[i]] != x) sum++;\n    }\n    return sum;\n}\n\nint h(){\n    return min(min(cal(1), cal(2)), cal(3));\n}\n\nbool dfs(int dep, int maxd){\n    if(dep + h() > maxd) return false;\n    if(dep >= maxd){\n        if(ok()){\n            res = d[center[0]];\n            for(int i = 0; i < dep; i++){\n                cout << ans[i];\n            }\n            cout << endl;\n            cout << res << endl;\n            return true;\n        }\n        return false;\n    }\n\n    for(int i = 0; i < 8; i++){\n        ans[dep] = 'A' + i;\n        move(i);\n        if(dfs(dep + 1, maxd)) return true;\n        move(reff[i]);\n    }\n    return false;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(1){\n        cin >> d[0];\n        if(d[0] == 0) break;\n        for(int i = 1; i < 24; i++){\n            cin >> d[i];\n        }\n\n        if(ok()){\n            cout << \"No moves needed\" << endl;\n            cout << d[center[0]] << endl;\n            continue;\n        }\n        int maxd;\n        for(maxd = 1; ; maxd++){\n            if(dfs(0, maxd)) break;\n        }\n    }\n    \n    return 0;\n}\n```","slug":"Uva1343-The-Rotation-Game","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlq0018h8vn7un4bbad","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva122-二叉树构建与层次遍历","date":"2018-09-21T10:36:04.000Z","_content":"根据输入构建一颗二叉树并输出层次遍历的结果，二叉树的构建有结构体和数组两种形式。\n<!--more-->\n# 链接\n[Uva122-Trees on the level](https://vjudge.net/problem/UVA-122)\n# 题目描述\n以一组$(n, s)$的形式给定一棵二叉树，其中$n$是从根节点出发以$s$为路径到达的节点的权值。要求输出这棵二叉树的层次遍历结果。\n# 题解\n层次遍历直接用$BFS$就可以得到。关键是构建出二叉树，构建二叉树的方式有两种：一种是采用动态结构，即以结构体来表示一个节点，储存这个节点的权值、左右子树的信息；另一种是采用静态结构，即用数组来储存节点信息，例如$val[maxn]$，$left[maxn]$，$right[maxn]$分别存储节点的权值和左右子树信息。\n# 代码\n## 动态结构\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu 20 Sep 22:23:49 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 307;\nchar s[maxn];\nbool failed;\n\nstruct Node{\n    int v;\n    Node *left, *right;\n    bool h_val;\n    Node():left(NULL), right(NULL), h_val(false){}; \n};\n\nNode* root;\n\nvoid addnode(char* s, int v){\n    int n = strlen(s);\n    Node* u = root;\n    for(int i = 0; i < n - 1; i++){\n        if(s[i] == 'L'){\n            if(u->left == NULL) u->left = new Node();\n            u = u->left;\n        }\n        else if(s[i] == 'R'){\n            if(u->right == NULL) u->right = new Node();\n            u = u->right;\n        }\n    }\n    if(u->h_val) failed = true;\n    u->v = v;\n    u->h_val = true;\n}\n\nbool read_input(){\n    int v;\n    failed = false;\n    root = new Node();\n    while(1){\n        if(scanf(\"%s\", s) == EOF) return false;\n        if(strcmp(s, \"()\") == 0) break;\n        sscanf(s + 1, \"%d\", &v);\n        addnode(strchr(s, ',') + 1, v);\n    }\n    return true;\n}\n\nvoid bfs(){\n    vector<int> vec;\n    queue<Node*> que;\n    que.push(root);\n    while(!que.empty()){\n        Node* u = que.front();\n        que.pop();\n        if(!u->h_val){\n            cout << \"not complete\" << endl;\n            return;\n        }\n        vec.push_back(u->v);\n        if(u->left != NULL) que.push(u->left);\n        if(u->right != NULL) que.push(u->right);\n    }\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(1){\n        if(read_input()){\n            if(failed) cout << \"not complete\" << endl;\n            else bfs();\n        }\n        else{\n            break;\n        }\n    }\n    return 0;\n}\n```\n## 静态结构\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 14:10:14 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 307;\nint leftt[maxn], rightt[maxn], val[maxn];\nbool h_val[maxn], failed;\nchar s[maxn];\nint root, cnt;\n\nvoid bfs(){\n    vector<int> vec;\n    queue<int> que;\n    que.push(root);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        if(!h_val[v]){\n            cout << \"not complete\" << endl;\n            return;\n        }\n        vec.push_back(val[v]);\n        if(leftt[v]) que.push(leftt[v]);\n        if(rightt[v]) que.push(rightt[v]);\n    }\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n}\n\nvoid addnode(char* s, int v){\n    int n = strlen(s);\n    int u = root;\n    for(int i = 0; i < n - 1; i++){\n        if(s[i] == 'L'){\n            if(leftt[u] == 0){\n                cnt++;\n                leftt[u] = cnt;\n            }\n            u = leftt[u];\n        }\n        else if(s[i] == 'R'){\n            if(rightt[u] == 0){\n                cnt++;\n                rightt[u] = cnt;\n            }\n            u = rightt[u];\n        }\n    }\n    if(h_val[u]) failed = true;\n    val[u] = v;\n    h_val[u] = true;\n}\n\nbool read_input(){\n    memset(h_val, false, sizeof(h_val));\n    memset(leftt, 0, sizeof(leftt));\n    memset(rightt, 0, sizeof(rightt));\n    int v;\n    root = 1;\n    cnt = 1;\n    failed = false;\n    leftt[root] = 0, rightt[root] = 0; \n    while(1){\n        if(scanf(\"%s\", s) == EOF) return false;\n        if(strcmp(s, \"()\") == 0) break;\n        sscanf(s + 1, \"%d\", &v);\n        addnode(strchr(s, ',') + 1, v);\n    }\n    return true;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(1){\n        if(read_input()){\n            if(failed) cout << \"not complete\" << endl;\n            else bfs();\n        }\n        else\n            break;\n    }\n    \n    return 0;\n}\n```","source":"_posts/Uva122-二叉树构建与层次遍历.md","raw":"---\ntitle: Uva122-二叉树构建与层次遍历\ndate: 2018-09-21 18:36:04\ncategories:\n- ACM\n- 树\ntags:\n- 二叉树\n- BFS\n---\n根据输入构建一颗二叉树并输出层次遍历的结果，二叉树的构建有结构体和数组两种形式。\n<!--more-->\n# 链接\n[Uva122-Trees on the level](https://vjudge.net/problem/UVA-122)\n# 题目描述\n以一组$(n, s)$的形式给定一棵二叉树，其中$n$是从根节点出发以$s$为路径到达的节点的权值。要求输出这棵二叉树的层次遍历结果。\n# 题解\n层次遍历直接用$BFS$就可以得到。关键是构建出二叉树，构建二叉树的方式有两种：一种是采用动态结构，即以结构体来表示一个节点，储存这个节点的权值、左右子树的信息；另一种是采用静态结构，即用数组来储存节点信息，例如$val[maxn]$，$left[maxn]$，$right[maxn]$分别存储节点的权值和左右子树信息。\n# 代码\n## 动态结构\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu 20 Sep 22:23:49 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 307;\nchar s[maxn];\nbool failed;\n\nstruct Node{\n    int v;\n    Node *left, *right;\n    bool h_val;\n    Node():left(NULL), right(NULL), h_val(false){}; \n};\n\nNode* root;\n\nvoid addnode(char* s, int v){\n    int n = strlen(s);\n    Node* u = root;\n    for(int i = 0; i < n - 1; i++){\n        if(s[i] == 'L'){\n            if(u->left == NULL) u->left = new Node();\n            u = u->left;\n        }\n        else if(s[i] == 'R'){\n            if(u->right == NULL) u->right = new Node();\n            u = u->right;\n        }\n    }\n    if(u->h_val) failed = true;\n    u->v = v;\n    u->h_val = true;\n}\n\nbool read_input(){\n    int v;\n    failed = false;\n    root = new Node();\n    while(1){\n        if(scanf(\"%s\", s) == EOF) return false;\n        if(strcmp(s, \"()\") == 0) break;\n        sscanf(s + 1, \"%d\", &v);\n        addnode(strchr(s, ',') + 1, v);\n    }\n    return true;\n}\n\nvoid bfs(){\n    vector<int> vec;\n    queue<Node*> que;\n    que.push(root);\n    while(!que.empty()){\n        Node* u = que.front();\n        que.pop();\n        if(!u->h_val){\n            cout << \"not complete\" << endl;\n            return;\n        }\n        vec.push_back(u->v);\n        if(u->left != NULL) que.push(u->left);\n        if(u->right != NULL) que.push(u->right);\n    }\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(1){\n        if(read_input()){\n            if(failed) cout << \"not complete\" << endl;\n            else bfs();\n        }\n        else{\n            break;\n        }\n    }\n    return 0;\n}\n```\n## 静态结构\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 14:10:14 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 307;\nint leftt[maxn], rightt[maxn], val[maxn];\nbool h_val[maxn], failed;\nchar s[maxn];\nint root, cnt;\n\nvoid bfs(){\n    vector<int> vec;\n    queue<int> que;\n    que.push(root);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        if(!h_val[v]){\n            cout << \"not complete\" << endl;\n            return;\n        }\n        vec.push_back(val[v]);\n        if(leftt[v]) que.push(leftt[v]);\n        if(rightt[v]) que.push(rightt[v]);\n    }\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n}\n\nvoid addnode(char* s, int v){\n    int n = strlen(s);\n    int u = root;\n    for(int i = 0; i < n - 1; i++){\n        if(s[i] == 'L'){\n            if(leftt[u] == 0){\n                cnt++;\n                leftt[u] = cnt;\n            }\n            u = leftt[u];\n        }\n        else if(s[i] == 'R'){\n            if(rightt[u] == 0){\n                cnt++;\n                rightt[u] = cnt;\n            }\n            u = rightt[u];\n        }\n    }\n    if(h_val[u]) failed = true;\n    val[u] = v;\n    h_val[u] = true;\n}\n\nbool read_input(){\n    memset(h_val, false, sizeof(h_val));\n    memset(leftt, 0, sizeof(leftt));\n    memset(rightt, 0, sizeof(rightt));\n    int v;\n    root = 1;\n    cnt = 1;\n    failed = false;\n    leftt[root] = 0, rightt[root] = 0; \n    while(1){\n        if(scanf(\"%s\", s) == EOF) return false;\n        if(strcmp(s, \"()\") == 0) break;\n        sscanf(s + 1, \"%d\", &v);\n        addnode(strchr(s, ',') + 1, v);\n    }\n    return true;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(1){\n        if(read_input()){\n            if(failed) cout << \"not complete\" << endl;\n            else bfs();\n        }\n        else\n            break;\n    }\n    \n    return 0;\n}\n```","slug":"Uva122-二叉树构建与层次遍历","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlq0019h8vnupeq2qvi","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva127-Accordian Patience-链表","date":"2018-12-12T02:25:11.000Z","_content":"一副扑克牌（52张），按照从左往右的顺序，若当前扑克牌和它的左一或左三扑克牌的数字或花色相同，就把它移动到那张牌的上方，移动后如果继续满足条件则继续移动。左一和左三同时满足时，左三优先。当有某个位置的牌为空时，要及时把这个位置消除。\n实战了一把数组模拟链表，还发现了一个大佬的博客，嚯嚯。收获了感动，坚定了继续坚持下去的信念。\n<!--more-->\n# 链接\n题目链接[Uva127-\"Accordian Patience\"](https://vjudge.net/problem/UVA-127)\n参考链接[shuangde800的博客](https://blog.csdn.net/shuangde800/article/details/7703781#commentBox)\n\n# 题解\n52个位置的牌堆分别用一个栈来维护。因为有消除牌堆的过程，所以会有频繁的移动，用链表来维护牌堆之间的关系效率比较高。代码里用两个数组next_idx和front_idx模拟了双向链表。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 11 Dec 20:19:53 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstack<string> d[60];\nint next_idx[60];\nint front_idx[60];\n\nbool input(){\n    memset(next_idx, -1, sizeof(next_idx));\n    memset(front_idx, -1, sizeof(front_idx));\n    string s;\n    stack<string> stk;\n    for(int i = 0; i < 52; i++){\n        cin >> s;\n        if(s == \"#\") return false;\n        stk.push(s);\n        d[i] = stk;\n        stk.pop();\n    }\n    return true;\n}\n\n//judge if we can move 3 steps\nbool ok_3(int i){\n    int last3;\n    last3 = front_idx[front_idx[front_idx[i]]];\n    //if(last3 < 0) return false;\n    if(d[last3].top()[0] == d[i].top()[0] || d[last3].top()[1] == d[i].top()[1]){\n        d[last3].push(d[i].top());\n        d[i].pop();\n        return true;\n    }\n    else return false;\n}\n\n//judge if we can move 1 step\nbool ok_1(int i){\n    int last1;\n    last1 = front_idx[i];\n    //if(last1 < 0) return false;\n    if(d[last1].top()[0] == d[i].top()[0] || d[last1].top()[1] == d[i].top()[1]){\n        d[last1].push(d[i].top());\n        d[i].pop();\n        return true;\n    }\n    else return false;\n}\n\nbool move(){\n    int cnt = 0;\n    for(int i = 0; i != -1; i = next_idx[i], cnt++){\n        if(cnt > 2)\n            if(ok_3(i)) return true;\n        if(cnt > 0)\n            if(ok_1(i)) return true;\n    }\n    return false;\n}\n\n//erase empty position\nvoid erase(){\n    for(int i = 0; i != -1; i = next_idx[i]){\n        if(d[i].empty()){\n            int l = front_idx[i];\n            int r = next_idx[i];\n            next_idx[l] = r;\n            front_idx[r] = l;\n            next_idx[i] = front_idx[i] = -1;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE    \n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(input()){\n        for(int i = 0; i < 51; i++){\n            next_idx[i] = i + 1;\n        }\n        for(int i = 1; i < 53; i++){\n            front_idx[i] = i - 1;\n        }\n\n        while(move()){\n            erase();\n        }\n\n        vector<int> ans;\n        for(int i = 0; i != -1; i = next_idx[i]){\n            ans.push_back(d[i].size());\n        }\n        int len = ans.size();\n        if(len == 1){\n            cout << \"1 pile remaining: \" << ans[0] << endl;\n        }\n        else{\n            cout << len << \" piles remaining:\";\n            for(int x : ans){\n                cout << \" \" << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n```","source":"_posts/Uva127-Accordian-Patience.md","raw":"---\ntitle: Uva127-Accordian Patience-链表\ndate: 2018-12-12 10:25:11\ncategories:\n- ACM\n- 链表\ntags:\n- 链表\n- 栈\n---\n一副扑克牌（52张），按照从左往右的顺序，若当前扑克牌和它的左一或左三扑克牌的数字或花色相同，就把它移动到那张牌的上方，移动后如果继续满足条件则继续移动。左一和左三同时满足时，左三优先。当有某个位置的牌为空时，要及时把这个位置消除。\n实战了一把数组模拟链表，还发现了一个大佬的博客，嚯嚯。收获了感动，坚定了继续坚持下去的信念。\n<!--more-->\n# 链接\n题目链接[Uva127-\"Accordian Patience\"](https://vjudge.net/problem/UVA-127)\n参考链接[shuangde800的博客](https://blog.csdn.net/shuangde800/article/details/7703781#commentBox)\n\n# 题解\n52个位置的牌堆分别用一个栈来维护。因为有消除牌堆的过程，所以会有频繁的移动，用链表来维护牌堆之间的关系效率比较高。代码里用两个数组next_idx和front_idx模拟了双向链表。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 11 Dec 20:19:53 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstack<string> d[60];\nint next_idx[60];\nint front_idx[60];\n\nbool input(){\n    memset(next_idx, -1, sizeof(next_idx));\n    memset(front_idx, -1, sizeof(front_idx));\n    string s;\n    stack<string> stk;\n    for(int i = 0; i < 52; i++){\n        cin >> s;\n        if(s == \"#\") return false;\n        stk.push(s);\n        d[i] = stk;\n        stk.pop();\n    }\n    return true;\n}\n\n//judge if we can move 3 steps\nbool ok_3(int i){\n    int last3;\n    last3 = front_idx[front_idx[front_idx[i]]];\n    //if(last3 < 0) return false;\n    if(d[last3].top()[0] == d[i].top()[0] || d[last3].top()[1] == d[i].top()[1]){\n        d[last3].push(d[i].top());\n        d[i].pop();\n        return true;\n    }\n    else return false;\n}\n\n//judge if we can move 1 step\nbool ok_1(int i){\n    int last1;\n    last1 = front_idx[i];\n    //if(last1 < 0) return false;\n    if(d[last1].top()[0] == d[i].top()[0] || d[last1].top()[1] == d[i].top()[1]){\n        d[last1].push(d[i].top());\n        d[i].pop();\n        return true;\n    }\n    else return false;\n}\n\nbool move(){\n    int cnt = 0;\n    for(int i = 0; i != -1; i = next_idx[i], cnt++){\n        if(cnt > 2)\n            if(ok_3(i)) return true;\n        if(cnt > 0)\n            if(ok_1(i)) return true;\n    }\n    return false;\n}\n\n//erase empty position\nvoid erase(){\n    for(int i = 0; i != -1; i = next_idx[i]){\n        if(d[i].empty()){\n            int l = front_idx[i];\n            int r = next_idx[i];\n            next_idx[l] = r;\n            front_idx[r] = l;\n            next_idx[i] = front_idx[i] = -1;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE    \n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(input()){\n        for(int i = 0; i < 51; i++){\n            next_idx[i] = i + 1;\n        }\n        for(int i = 1; i < 53; i++){\n            front_idx[i] = i - 1;\n        }\n\n        while(move()){\n            erase();\n        }\n\n        vector<int> ans;\n        for(int i = 0; i != -1; i = next_idx[i]){\n            ans.push_back(d[i].size());\n        }\n        int len = ans.size();\n        if(len == 1){\n            cout << \"1 pile remaining: \" << ans[0] << endl;\n        }\n        else{\n            cout << len << \" piles remaining:\";\n            for(int x : ans){\n                cout << \" \" << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n```","slug":"Uva127-Accordian-Patience","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlq001ah8vnh0czjkw2","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva12166-Equilibrium Mobile-思维+二叉树","date":"2018-12-04T02:40:03.000Z","_content":"吹爆思维好题！给定一个深度不超过16的二叉树，代表一个天平，天平两端可能是递归的子天平也可能是砝码。每个砝码的质量已知，求至少修改多少个砝码的质量才能让天平平衡。\n![balance](/balance.png)\n如图，把7改成3天平平衡。\n<!--more-->\n# 链接\n题目链接[Uva12166-Equilibrium Mobile](https://vjudge.net/problem/UVA-12166)\n\n参考链接[crazysillynerd's csdn blog](https://blog.csdn.net/crazysillynerd/article/details/43876123)\n\n# 题解\n想要修改砝码使天平平衡，需要找其中一个砝码作为基准，用它来调整整个天平。假设基准砝码的质量为w，它在二叉树中的深度为d，则用它调整后的整个天平的重量为$w * pow(2，d)$。\n可能存在一些砝码，当以他们为基准时，调整后天平的总重量相同。那么这些砝码的数量就代表了保持不变的砝码数量，总砝码数量减去保持不变的砝码数量就是需要修改的砝码数量。\n用DFS构建二叉树，对每一个叶节点计算调整后的天平总重量；用STL中的map来维护不同总重量所代表的砝码个数。\n\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue  4 Dec 10:02:37 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nint sum;\nmap<long long, int> mp;\nstring s;\n\nvoid dfs(int st, int ed, int depth){\n    //cout << st << \" \" << ed << \" \" << depth << endl;\n    if(s[st] == '['){\n        int p = 0;\n        for(int i = st + 1; i <= ed; i++){\n            if(s[i] == '[') p++;\n            if(s[i] == ']') p--;\n            if(s[i] == ',' && p == 0){\n                //cout << st + 1 << \" \" << i - 1 << \" \" << depth + 1 << endl;\n                dfs(st + 1, i - 1, depth + 1);\n                //cout << i + 1 << \" \" << ed - 1 << \" \" << depth + 1 << endl;\n                dfs(i + 1, ed - 1, depth + 1);\n            }\n        }\n    }\n    else{\n        long long w = 0;\n        for(int i = st; i <= ed; i++){\n            w *= 10;\n            w += s[i] - '0';\n        }\n        //cout << w << endl;\n        sum++;\n        mp[w << depth]++;\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> t;\n    while(t--){\n        mp.clear();\n        sum = 0;\n\n        cin >> s;\n        dfs(0, s.length() - 1, 0);\n\n        int ans = 0;\n        for(auto x : mp){\n            ans = max(ans, x.second);\n        }\n        cout << sum - ans << endl;\n    }\n    return 0;\n}\n```\n","source":"_posts/Uva12166-Equilibrium-Mobile.md","raw":"---\ntitle: Uva12166-Equilibrium Mobile-思维+二叉树\ndate: 2018-12-04 10:40:03\ncategories:\n- ACM\n- 树\ntags:\n- 思维\n- 二叉树\n---\n吹爆思维好题！给定一个深度不超过16的二叉树，代表一个天平，天平两端可能是递归的子天平也可能是砝码。每个砝码的质量已知，求至少修改多少个砝码的质量才能让天平平衡。\n![balance](/balance.png)\n如图，把7改成3天平平衡。\n<!--more-->\n# 链接\n题目链接[Uva12166-Equilibrium Mobile](https://vjudge.net/problem/UVA-12166)\n\n参考链接[crazysillynerd's csdn blog](https://blog.csdn.net/crazysillynerd/article/details/43876123)\n\n# 题解\n想要修改砝码使天平平衡，需要找其中一个砝码作为基准，用它来调整整个天平。假设基准砝码的质量为w，它在二叉树中的深度为d，则用它调整后的整个天平的重量为$w * pow(2，d)$。\n可能存在一些砝码，当以他们为基准时，调整后天平的总重量相同。那么这些砝码的数量就代表了保持不变的砝码数量，总砝码数量减去保持不变的砝码数量就是需要修改的砝码数量。\n用DFS构建二叉树，对每一个叶节点计算调整后的天平总重量；用STL中的map来维护不同总重量所代表的砝码个数。\n\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue  4 Dec 10:02:37 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nint sum;\nmap<long long, int> mp;\nstring s;\n\nvoid dfs(int st, int ed, int depth){\n    //cout << st << \" \" << ed << \" \" << depth << endl;\n    if(s[st] == '['){\n        int p = 0;\n        for(int i = st + 1; i <= ed; i++){\n            if(s[i] == '[') p++;\n            if(s[i] == ']') p--;\n            if(s[i] == ',' && p == 0){\n                //cout << st + 1 << \" \" << i - 1 << \" \" << depth + 1 << endl;\n                dfs(st + 1, i - 1, depth + 1);\n                //cout << i + 1 << \" \" << ed - 1 << \" \" << depth + 1 << endl;\n                dfs(i + 1, ed - 1, depth + 1);\n            }\n        }\n    }\n    else{\n        long long w = 0;\n        for(int i = st; i <= ed; i++){\n            w *= 10;\n            w += s[i] - '0';\n        }\n        //cout << w << endl;\n        sum++;\n        mp[w << depth]++;\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> t;\n    while(t--){\n        mp.clear();\n        sum = 0;\n\n        cin >> s;\n        dfs(0, s.length() - 1, 0);\n\n        int ans = 0;\n        for(auto x : mp){\n            ans = max(ans, x.second);\n        }\n        cout << sum - ans << endl;\n    }\n    return 0;\n}\n```\n","slug":"Uva12166-Equilibrium-Mobile","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlr001bh8vn19lb8qlm","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva1600-Patrol Robot-BFS","date":"2018-12-03T01:20:27.000Z","_content":"一个$ m \\times n $的长方形场地，0表示可走格子，1表示障碍物。求从 $(1，1)$ 到 $(m，n)$的最短路径。其中可以走存在障碍物的格子，但不能在障碍物上连续走k步。\n<!--more-->\n# 链接\n[Uva1600-Patrol Robot](https://vjudge.net/problem/UVA-1600)\n\n# 题解\n用BFS和DFS搜索路径都可以，但如果不剪枝的用DFS会TL。用BFS搜索，为队列中的每一项，除了x，y坐标属性之外，再加上当前的k值属性。同时还有需要注意的一点是，**这个问题里同一格子可以被多次放入队列，只要它的k值属性或距离d值相比之前有提升**。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 30 Nov 19:05:23 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 27;\nint mp[maxn][maxn];\nint d[maxn][maxn];\nint record_k[maxn][maxn];\nint t, m, n, k;\nstruct Node{\n    Node(int x = 0, int y = 0, int k = 0):x(x), y(y), k(k){}\n    int x, y;\n    int k;\n};\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint bfs(){\n    d[0][0] = 0;\n    record_k[0][0] = k;\n    queue<Node> que;\n    que.push(Node(0, 0, k));\n\n    while(!que.empty()){\n        Node nd = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = nd.x + dx[i], ny = nd.y + dy[i];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                if(mp[nx][ny] == 0){\n                    if(d[nx][ny] == -1 || (d[nx][ny] > d[nd.x][nd.y] && record_k[nx][ny] < k)){\n                        d[nx][ny] = d[nd.x][nd.y] + 1;\n                        record_k[nx][ny] = k;\n                        que.push(Node(nx, ny, k));\n                    }\n                }\n                else if(mp[nx][ny] == 1 && nd.k > 0){\n                    if(d[nx][ny] == -1 || (d[nx][ny] > d[nd.x][nd.y] && record_k[nx][ny] < nd.k - 1)){\n                        d[nx][ny] = d[nd.x][nd.y] + 1;\n                        record_k[nx][ny] = nd.k - 1;\n                        que.push(Node(nx, ny, nd.k - 1));\n                    }\n                }\n            }\n        }\n    }\n\n    return d[m - 1][n - 1];\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> t;\n    while(t--){\n        memset(d, -1, sizeof(d));\n        memset(record_k, 0, sizeof(record_k));\n        cin >> m >> n >> k;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                cin >> mp[i][j];\n            }\n        }\n        int ans = bfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n```","source":"_posts/Uva1600-Patrol-Robot.md","raw":"---\ntitle: Uva1600-Patrol Robot-BFS\ndate: 2018-12-03 09:20:27\ncategories:\n- ACM\n- BFS\ntags:\n- BFS\n---\n一个$ m \\times n $的长方形场地，0表示可走格子，1表示障碍物。求从 $(1，1)$ 到 $(m，n)$的最短路径。其中可以走存在障碍物的格子，但不能在障碍物上连续走k步。\n<!--more-->\n# 链接\n[Uva1600-Patrol Robot](https://vjudge.net/problem/UVA-1600)\n\n# 题解\n用BFS和DFS搜索路径都可以，但如果不剪枝的用DFS会TL。用BFS搜索，为队列中的每一项，除了x，y坐标属性之外，再加上当前的k值属性。同时还有需要注意的一点是，**这个问题里同一格子可以被多次放入队列，只要它的k值属性或距离d值相比之前有提升**。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 30 Nov 19:05:23 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 27;\nint mp[maxn][maxn];\nint d[maxn][maxn];\nint record_k[maxn][maxn];\nint t, m, n, k;\nstruct Node{\n    Node(int x = 0, int y = 0, int k = 0):x(x), y(y), k(k){}\n    int x, y;\n    int k;\n};\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint bfs(){\n    d[0][0] = 0;\n    record_k[0][0] = k;\n    queue<Node> que;\n    que.push(Node(0, 0, k));\n\n    while(!que.empty()){\n        Node nd = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = nd.x + dx[i], ny = nd.y + dy[i];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                if(mp[nx][ny] == 0){\n                    if(d[nx][ny] == -1 || (d[nx][ny] > d[nd.x][nd.y] && record_k[nx][ny] < k)){\n                        d[nx][ny] = d[nd.x][nd.y] + 1;\n                        record_k[nx][ny] = k;\n                        que.push(Node(nx, ny, k));\n                    }\n                }\n                else if(mp[nx][ny] == 1 && nd.k > 0){\n                    if(d[nx][ny] == -1 || (d[nx][ny] > d[nd.x][nd.y] && record_k[nx][ny] < nd.k - 1)){\n                        d[nx][ny] = d[nd.x][nd.y] + 1;\n                        record_k[nx][ny] = nd.k - 1;\n                        que.push(Node(nx, ny, nd.k - 1));\n                    }\n                }\n            }\n        }\n    }\n\n    return d[m - 1][n - 1];\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> t;\n    while(t--){\n        memset(d, -1, sizeof(d));\n        memset(record_k, 0, sizeof(record_k));\n        cin >> m >> n >> k;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                cin >> mp[i][j];\n            }\n        }\n        int ans = bfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n```","slug":"Uva1600-Patrol-Robot","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlr001ch8vn3byo5f22","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva1602-Lattice Animals-搜索+仿射变换技巧","date":"2019-02-12T15:53:39.000Z","_content":"给定$n，w，h$，求在$n \\times n$的网格中，最多能放入几种宽和高不超过$w和h$的连通块。其中一个连通块经过平移、旋转和翻转得到的连通块不属于新的连通块。\n![pic](/pic.png)\n<!--more-->\n# 链接\n题目链接：[Uva1602-Lattice Animals](https://vjudge.net/problem/UVA-1602)\n参考链接：[XDU_Skyline's Blog](https://blog.csdn.net/u014800748/article/details/47400557)，[Rujia Liu's Github Repository](https://github.com/aoapc-book/aoapc-bac2nd/blob/master/ch7/UVa1602.cpp)\n\n# 题解\n分为两部分，一部分为搜索，另一部分为判重。\n搜索可以采用BFS也可以采用DFS。示例代码里采用了BFS。\n判重部分，因为一个连通块经过平移、旋转和翻转后得到的连通块不属于新的连通块，所以在判断一个连通块是否重复时首先要对其**每一种可能的形态**进行判断。\n对于**平移操作**，我们考虑将连通块进行**标准化**normalize，即统计连通块的x方向和y方向的最小值minX和minY，然后将连通块中的每一个单元格都**减去矢量(minX，minY)**得到标准化后的连通块。\n对于**旋转操作**，假设一个单元格的**坐标为(x，y),**表示逆时针旋转90°的旋转矩阵为\n$$\n \\begin{bmatrix}\n   0 & -1 \\\\\\\\\n   1 & 0\n  \\end{bmatrix}\n$$\n所以该单元格**逆时针旋转90°之后的坐标为(-y, x)。**对连通块中的每一个单元格都执行此操作就得到了旋转后的连通块。*旋转之后的连通块还要进行一次normalize操作再判重。*\n对于**翻转操作**，可以沿x轴翻转也可以沿y轴翻转。其对应的**坐标变换是(x，y)->(-x，y)。**(以沿y轴翻转为例)。翻转之后还要进行一圈的旋转判重，事实上沿x轴进行翻转后再旋转180°就可以得到沿y轴翻转后的图形，所以不需要再分开讨论这两种不同的翻转情况。*同样翻转之后的连通块也要进行normalize操作后再判重。*\n\n以上是思路部分，关于具体的实现，搜索部分采用BFS，判重部分利用STL中的set判重。单元格通过一个结构体存储x和y坐标来表示，联通块通过set存储其各个单元格来表示。*连通块之所以用set表示，而不是vector，是因为set会自动排序，这样就避免了因插入顺序不同导致的判重失败问题。*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 11 Feb 22:03:44 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10;\nconst int inf = 100;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nstruct Cell{\n    int x, y;\n    Cell(int x = 0, int y = 0):x(x), y(y){}\n    bool operator <(const Cell& c) const{\n        if(this->x == c.x) return this->y < c.y;\n        else return this->x < c.x;\n    }\n};\ntypedef set<Cell> Polyomino;\nset<Polyomino> Poly[maxn + 1];\n\nPolyomino normalize(Polyomino p){\n    Polyomino p0;\n    int minx, miny;\n    minx = miny = inf;\n\n    for(Polyomino::iterator t = p.begin(); t != p.end(); t++){\n        minx = min(minx, t->x);\n        miny = min(miny, t->y);\n    }\n    for(Polyomino::iterator t = p.begin(); t != p.end(); t++){\n        p0.insert(Cell(t->x - minx, t->y - miny));\n    }\n    return p0;\n}\n\nPolyomino rotate(Polyomino p){\n    Polyomino p0;\n    for(Polyomino::iterator t = p.begin(); t != p.end(); t++){\n        p0.insert(Cell(-t->y, t->x));\n    }\n    return normalize(p0);\n}\n\nPolyomino flip(Polyomino p){\n    Polyomino p0;\n    for(Polyomino::iterator t = p.begin(); t != p.end(); t++){\n        p0.insert(Cell(-t->x, t->y));\n    }\n    return normalize(p0);\n}\n\nvoid check(Polyomino p, Cell c, int n){\n    p.insert(c);\n\n    p = normalize(p);\n    for(int i = 0; i < 4; i++){\n        if(Poly[n].count(p) != 0) return;\n        p = rotate(p);\n    }\n\n    p = flip(p);\n    for(int i = 0; i < 4; i++){\n        if(Poly[n].count(p) != 0) return;\n        p = rotate(p);\n    }\n\n    Poly[n].insert(p);\n}\n\nvoid search(){\n    Polyomino p1;\n    p1.insert(Cell(0, 0));\n    Poly[1].insert(p1);\n\n    for(int n = 2; n <= maxn; n++){\n        for(auto p : Poly[n - 1]){\n            for(auto t : p){\n                for(int i = 0; i < 4; i++){\n                    int nx = t.x + dx[i];\n                    int ny = t.y + dy[i];\n                    Cell c(nx, ny);\n                    if(p.count(c) == 0) check(p, c, n);\n                }\n            }\n        }\n    }\n}\n\nint getAns(int n, int w, int h){\n    int minx, miny, maxx, maxy;\n    int cnt = 0;\n\n    for(auto p : Poly[n]){\n        minx = miny = inf;\n        maxx = maxy = 0;\n        for(auto t : p){\n            minx = min(minx, t.x);\n            miny = min(miny, t.y);\n            maxx = max(maxx, t.x);\n            maxy = max(maxy, t.y);\n        }\n        int lx = maxx - minx;\n        int ly = maxy - miny;\n        if(min(lx, ly) < min(w, h) && max(lx, ly) < max(w, h)){\n            cnt++;\n        }\n    }\n\n    return cnt;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int n, w, h;\n\n    search();\n\n    while(cin >> n >> w >> h){\n        int ans = getAns(n, w, h);\n        cout << ans << endl;\n    }\n    return 0;\n}\n```","source":"_posts/Uva1602-Lattice-Animals.md","raw":"---\ntitle: Uva1602-Lattice Animals-搜索+仿射变换技巧\ndate: 2019-02-12 23:53:39\ncategories:\n- ACM\n- BFS\ntags:\n- 搜索\n- 仿射变换\n---\n给定$n，w，h$，求在$n \\times n$的网格中，最多能放入几种宽和高不超过$w和h$的连通块。其中一个连通块经过平移、旋转和翻转得到的连通块不属于新的连通块。\n![pic](/pic.png)\n<!--more-->\n# 链接\n题目链接：[Uva1602-Lattice Animals](https://vjudge.net/problem/UVA-1602)\n参考链接：[XDU_Skyline's Blog](https://blog.csdn.net/u014800748/article/details/47400557)，[Rujia Liu's Github Repository](https://github.com/aoapc-book/aoapc-bac2nd/blob/master/ch7/UVa1602.cpp)\n\n# 题解\n分为两部分，一部分为搜索，另一部分为判重。\n搜索可以采用BFS也可以采用DFS。示例代码里采用了BFS。\n判重部分，因为一个连通块经过平移、旋转和翻转后得到的连通块不属于新的连通块，所以在判断一个连通块是否重复时首先要对其**每一种可能的形态**进行判断。\n对于**平移操作**，我们考虑将连通块进行**标准化**normalize，即统计连通块的x方向和y方向的最小值minX和minY，然后将连通块中的每一个单元格都**减去矢量(minX，minY)**得到标准化后的连通块。\n对于**旋转操作**，假设一个单元格的**坐标为(x，y),**表示逆时针旋转90°的旋转矩阵为\n$$\n \\begin{bmatrix}\n   0 & -1 \\\\\\\\\n   1 & 0\n  \\end{bmatrix}\n$$\n所以该单元格**逆时针旋转90°之后的坐标为(-y, x)。**对连通块中的每一个单元格都执行此操作就得到了旋转后的连通块。*旋转之后的连通块还要进行一次normalize操作再判重。*\n对于**翻转操作**，可以沿x轴翻转也可以沿y轴翻转。其对应的**坐标变换是(x，y)->(-x，y)。**(以沿y轴翻转为例)。翻转之后还要进行一圈的旋转判重，事实上沿x轴进行翻转后再旋转180°就可以得到沿y轴翻转后的图形，所以不需要再分开讨论这两种不同的翻转情况。*同样翻转之后的连通块也要进行normalize操作后再判重。*\n\n以上是思路部分，关于具体的实现，搜索部分采用BFS，判重部分利用STL中的set判重。单元格通过一个结构体存储x和y坐标来表示，联通块通过set存储其各个单元格来表示。*连通块之所以用set表示，而不是vector，是因为set会自动排序，这样就避免了因插入顺序不同导致的判重失败问题。*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 11 Feb 22:03:44 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10;\nconst int inf = 100;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nstruct Cell{\n    int x, y;\n    Cell(int x = 0, int y = 0):x(x), y(y){}\n    bool operator <(const Cell& c) const{\n        if(this->x == c.x) return this->y < c.y;\n        else return this->x < c.x;\n    }\n};\ntypedef set<Cell> Polyomino;\nset<Polyomino> Poly[maxn + 1];\n\nPolyomino normalize(Polyomino p){\n    Polyomino p0;\n    int minx, miny;\n    minx = miny = inf;\n\n    for(Polyomino::iterator t = p.begin(); t != p.end(); t++){\n        minx = min(minx, t->x);\n        miny = min(miny, t->y);\n    }\n    for(Polyomino::iterator t = p.begin(); t != p.end(); t++){\n        p0.insert(Cell(t->x - minx, t->y - miny));\n    }\n    return p0;\n}\n\nPolyomino rotate(Polyomino p){\n    Polyomino p0;\n    for(Polyomino::iterator t = p.begin(); t != p.end(); t++){\n        p0.insert(Cell(-t->y, t->x));\n    }\n    return normalize(p0);\n}\n\nPolyomino flip(Polyomino p){\n    Polyomino p0;\n    for(Polyomino::iterator t = p.begin(); t != p.end(); t++){\n        p0.insert(Cell(-t->x, t->y));\n    }\n    return normalize(p0);\n}\n\nvoid check(Polyomino p, Cell c, int n){\n    p.insert(c);\n\n    p = normalize(p);\n    for(int i = 0; i < 4; i++){\n        if(Poly[n].count(p) != 0) return;\n        p = rotate(p);\n    }\n\n    p = flip(p);\n    for(int i = 0; i < 4; i++){\n        if(Poly[n].count(p) != 0) return;\n        p = rotate(p);\n    }\n\n    Poly[n].insert(p);\n}\n\nvoid search(){\n    Polyomino p1;\n    p1.insert(Cell(0, 0));\n    Poly[1].insert(p1);\n\n    for(int n = 2; n <= maxn; n++){\n        for(auto p : Poly[n - 1]){\n            for(auto t : p){\n                for(int i = 0; i < 4; i++){\n                    int nx = t.x + dx[i];\n                    int ny = t.y + dy[i];\n                    Cell c(nx, ny);\n                    if(p.count(c) == 0) check(p, c, n);\n                }\n            }\n        }\n    }\n}\n\nint getAns(int n, int w, int h){\n    int minx, miny, maxx, maxy;\n    int cnt = 0;\n\n    for(auto p : Poly[n]){\n        minx = miny = inf;\n        maxx = maxy = 0;\n        for(auto t : p){\n            minx = min(minx, t.x);\n            miny = min(miny, t.y);\n            maxx = max(maxx, t.x);\n            maxy = max(maxy, t.y);\n        }\n        int lx = maxx - minx;\n        int ly = maxy - miny;\n        if(min(lx, ly) < min(w, h) && max(lx, ly) < max(w, h)){\n            cnt++;\n        }\n    }\n\n    return cnt;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int n, w, h;\n\n    search();\n\n    while(cin >> n >> w >> h){\n        int ans = getAns(n, w, h);\n        cout << ans << endl;\n    }\n    return 0;\n}\n```","slug":"Uva1602-Lattice-Animals","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nls001dh8vnigphx4z6","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva221-Urban Elevations-离散化","date":"2018-11-14T02:00:10.000Z","_content":"输入每个建筑物左下角坐标、宽度、深度和高度，输出正视图中能看到的所有建筑物，按照左下角x坐标从小到大进行排序。坐下角x坐标相同时，按y坐标从小到大排序。\n![building](/building.png)\n*第一眼看上去很像当时面试北航计算机时候的机试题，后来做着做着发现不对劲= =。结尾放一个彩蛋，把印象中的机试题和解题思路说一下。*\n<!--more-->\n# 链接\n[Uva221-Urban Elevation](https://vjudge.net/problem/UVA-221)\n\n# 题解\n因为是正视图，所以判断可见性的时候忽略深度参数，只把它当做判断前后层次的一个信息。判断一个建筑物是否可见，只要满足建筑物在x方向上有一些点（大于一个）可见，那么建筑物可见。因为x值连续有无穷个，所以无法枚举x。需要进行离散化，把无穷变为有限。\n把所有x坐标排序去重，则任意两个相邻x坐标形成的区间要么完全可见，要么完全不可见。等效于按照所有建筑物的垂直轮廓线进行区间划分，然后只要对这几个区间进行判断，任取区间一点，若这点对建筑物可见，则这段区间对建筑物可见，则可以说这个建筑物可见。判断一个建筑物是否在某个坐标点可见的条件是：建筑物坐标中必须包含这个坐标；建筑物前方不能有包含这个坐标且高于它的其它建筑物。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed 14 Nov 07:22:41 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nstruct Building{\n    int id;\n    double x, y, w, d, h;\n};\nBuilding bld[maxn];\nint xp[maxn * 2];\nint n;\n\nbool cmp(const Building& a, const Building& b){\n    if(a.x == b.x){\n        return a.y < b.y;\n    }\n    else{\n        return a.x < b.x;\n    }\n}\n\nbool visible(int ct, int x){\n    ///cout << \"target: \" << bld[ct].id << endl;\n    for(int i = 0; i < n; i++){\n        if(i == ct) continue;\n        if(bld[i].y <= bld[ct].y && bld[i].x <= x && bld[i].x + bld[i].w >= x){\n            //cout << bld[i].id << endl;\n            if(bld[i].h >= bld[ct].h) return false;\n        }\n    }\n    //cout << \"******\" << endl;\n    return true;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    while(cin >> n){\n        if(n == 0) break;\n        memset(bld, 0, sizeof(bld));\n        double x, y, w, d, h;\n        for(int i = 0; i < n; i++){\n            bld[i].id = i + 1;\n            cin >> x >> y >> w >> d >> h;\n            bld[i].x = x, bld[i].y = y, bld[i].w = w, bld[i].d = d, bld[i].h = h;\n            xp[2 * i] = x, xp[2 * i + 1] = x + w;\n        }\n        sort(bld, bld + n, cmp);\n        sort(xp, xp + 2 * n);\n        int m = unique(xp, xp + 2 * n) - xp;\n        vector<int> vec;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m - 1; j++){\n                if(bld[i].x >= xp[j + 1] || bld[i].x + bld[i].w <= xp[j]) continue;\n                if(visible(i, (xp[j] + xp[j + 1]) / 2)){\n                    vec.push_back(bld[i].id);\n                    break;\n                }\n            }\n        }\n\n        if(cnt > 1) cout << endl;\n        printf(\"For map #%d, the visible buildings are numbered as follows:\\n\", cnt++);\n        int len = vec.size();\n        for(int i = 0; i < len; i++){\n            if(!i) cout << vec[i];\n            else cout << \" \" << vec[i];\n        }\n        cout << endl;\n\n    }\n    return 0;    \n}\n```\n\n# 彩蛋\n北航那道机试题的题意大致是模拟点击window窗口的操作。平面上有几个窗口，以左下角坐标、长度和宽度的形式给出，同时以字符串形式给出每个窗口中的内容。接着给定n组坐标，表示鼠标点击的位置，（鼠标点击到某个窗口的有效位置，即未被遮挡的位置时，该窗口上升到第一层），要求输出这n次点击之后，其中一个指定窗口的可见内容部分。例如，一个窗口中的内容为```I am the content in this window```，经过n次点击之后，它在第三层，在它之上有两个窗口且对它的内容有部分遮挡，假设它的可见部分为```I```，```the```，```in```，```win```，那么应输出```I****the*********in******win***```，其中```*```表示不可见。\n思路就是进行模拟。定义一个结构体保存窗口编号、坐标、长度、宽度、内容以及它当前所在层。接下来模拟点击，鼠标每点击一次，根据点击区域调整各个窗口所在层并重新按层次进行排序。模拟完点击之后，对要输出内容的窗口中的每一个字符首先求出它的坐标，接着判断这个坐标是否包含在它之上窗口的区域内，若包含则输出```*```，若不包含则输出原字符。\n之所以说后面发现和上面那道题不一致，是因为北航这道题其实本来就是离散的，一个字符相当于一个坐标点，不存在小数坐标点的情况。\n\n*北航计算机的机试基本不涉及算法，比较考验基本功。考场提供的IDE有codeblocks、DEV和VC++6.0，语言要求C/C++，不限制STL的使用，时间是2个小时，题目数量2~3道，我那年是两道，第一道是简单的排序题，用sort函数加上自定义比较函数就能解决*","source":"_posts/Uva221-Urban-Elevations.md","raw":"---\ntitle: Uva221-Urban Elevations-离散化\ndate: 2018-11-14 10:00:10\ncategories:\n- ACM\n- 离散化\ntags:\n- 离散化\n---\n输入每个建筑物左下角坐标、宽度、深度和高度，输出正视图中能看到的所有建筑物，按照左下角x坐标从小到大进行排序。坐下角x坐标相同时，按y坐标从小到大排序。\n![building](/building.png)\n*第一眼看上去很像当时面试北航计算机时候的机试题，后来做着做着发现不对劲= =。结尾放一个彩蛋，把印象中的机试题和解题思路说一下。*\n<!--more-->\n# 链接\n[Uva221-Urban Elevation](https://vjudge.net/problem/UVA-221)\n\n# 题解\n因为是正视图，所以判断可见性的时候忽略深度参数，只把它当做判断前后层次的一个信息。判断一个建筑物是否可见，只要满足建筑物在x方向上有一些点（大于一个）可见，那么建筑物可见。因为x值连续有无穷个，所以无法枚举x。需要进行离散化，把无穷变为有限。\n把所有x坐标排序去重，则任意两个相邻x坐标形成的区间要么完全可见，要么完全不可见。等效于按照所有建筑物的垂直轮廓线进行区间划分，然后只要对这几个区间进行判断，任取区间一点，若这点对建筑物可见，则这段区间对建筑物可见，则可以说这个建筑物可见。判断一个建筑物是否在某个坐标点可见的条件是：建筑物坐标中必须包含这个坐标；建筑物前方不能有包含这个坐标且高于它的其它建筑物。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed 14 Nov 07:22:41 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nstruct Building{\n    int id;\n    double x, y, w, d, h;\n};\nBuilding bld[maxn];\nint xp[maxn * 2];\nint n;\n\nbool cmp(const Building& a, const Building& b){\n    if(a.x == b.x){\n        return a.y < b.y;\n    }\n    else{\n        return a.x < b.x;\n    }\n}\n\nbool visible(int ct, int x){\n    ///cout << \"target: \" << bld[ct].id << endl;\n    for(int i = 0; i < n; i++){\n        if(i == ct) continue;\n        if(bld[i].y <= bld[ct].y && bld[i].x <= x && bld[i].x + bld[i].w >= x){\n            //cout << bld[i].id << endl;\n            if(bld[i].h >= bld[ct].h) return false;\n        }\n    }\n    //cout << \"******\" << endl;\n    return true;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    while(cin >> n){\n        if(n == 0) break;\n        memset(bld, 0, sizeof(bld));\n        double x, y, w, d, h;\n        for(int i = 0; i < n; i++){\n            bld[i].id = i + 1;\n            cin >> x >> y >> w >> d >> h;\n            bld[i].x = x, bld[i].y = y, bld[i].w = w, bld[i].d = d, bld[i].h = h;\n            xp[2 * i] = x, xp[2 * i + 1] = x + w;\n        }\n        sort(bld, bld + n, cmp);\n        sort(xp, xp + 2 * n);\n        int m = unique(xp, xp + 2 * n) - xp;\n        vector<int> vec;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m - 1; j++){\n                if(bld[i].x >= xp[j + 1] || bld[i].x + bld[i].w <= xp[j]) continue;\n                if(visible(i, (xp[j] + xp[j + 1]) / 2)){\n                    vec.push_back(bld[i].id);\n                    break;\n                }\n            }\n        }\n\n        if(cnt > 1) cout << endl;\n        printf(\"For map #%d, the visible buildings are numbered as follows:\\n\", cnt++);\n        int len = vec.size();\n        for(int i = 0; i < len; i++){\n            if(!i) cout << vec[i];\n            else cout << \" \" << vec[i];\n        }\n        cout << endl;\n\n    }\n    return 0;    \n}\n```\n\n# 彩蛋\n北航那道机试题的题意大致是模拟点击window窗口的操作。平面上有几个窗口，以左下角坐标、长度和宽度的形式给出，同时以字符串形式给出每个窗口中的内容。接着给定n组坐标，表示鼠标点击的位置，（鼠标点击到某个窗口的有效位置，即未被遮挡的位置时，该窗口上升到第一层），要求输出这n次点击之后，其中一个指定窗口的可见内容部分。例如，一个窗口中的内容为```I am the content in this window```，经过n次点击之后，它在第三层，在它之上有两个窗口且对它的内容有部分遮挡，假设它的可见部分为```I```，```the```，```in```，```win```，那么应输出```I****the*********in******win***```，其中```*```表示不可见。\n思路就是进行模拟。定义一个结构体保存窗口编号、坐标、长度、宽度、内容以及它当前所在层。接下来模拟点击，鼠标每点击一次，根据点击区域调整各个窗口所在层并重新按层次进行排序。模拟完点击之后，对要输出内容的窗口中的每一个字符首先求出它的坐标，接着判断这个坐标是否包含在它之上窗口的区域内，若包含则输出```*```，若不包含则输出原字符。\n之所以说后面发现和上面那道题不一致，是因为北航这道题其实本来就是离散的，一个字符相当于一个坐标点，不存在小数坐标点的情况。\n\n*北航计算机的机试基本不涉及算法，比较考验基本功。考场提供的IDE有codeblocks、DEV和VC++6.0，语言要求C/C++，不限制STL的使用，时间是2个小时，题目数量2~3道，我那年是两道，第一道是简单的排序题，用sort函数加上自定义比较函数就能解决*","slug":"Uva221-Urban-Elevations","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nls001eh8vnxfsa1bsb","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva673-Parentheses Balance-栈","date":"2018-11-26T23:08:53.000Z","_content":"输入一个包含 $“()”$ 和 $“[]”$ 的括号序列，判断是否合法。具体规则：\n- 空串合法\n- 如果A和B都合法，则AB合法\n- 如果A合法则(A)和[A]都合法\n\n可能最近DFS，BFS做多了，总想往搜索上套...不过最后能想到栈还是很鸡冻＼（≧▽≦）／\n<!--more-->\n# 链接\n[Uva673-Parentheses Balance](https://vjudge.net/problem/UVA-673)\n\n# 题解\n能想到用栈之后这道题基本就可解了，将字符序列依次放入栈中遇到可以匹配的括号对　$“()”$ 或 $“[]”$　就出栈。如果最后栈中还有未匹配的括号，则不合法；否则若栈空，则合法。\n*可能含有空串所以读入的时候用getline(cin, s)读入，因为cin会自动忽略'\\n'，即忽略空串。*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 26 Nov 23:30:58 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 130;\nstring s;\nint n;\nstack<char> stk;\nbool p;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> n;\n    getchar();\n    while(n--){\n        while(!stk.empty()){\n            stk.pop();\n        }\n\n        getline(cin , s);\n        if(s.length() % 2){\n            cout << \"No\" << endl;\n            continue;\n        }\n        for(size_t i = 0; i < s.length(); i++){\n            p = false;\n            if(!stk.empty()){\n                if((stk.top() == '(' && s[i] == ')') || (stk.top() == '[' && s[i] == ']')){\n                    stk.pop();\n                    p = true;\n                }\n            }\n            if(!p) stk.push(s[i]);\n        }\n\n        if(!stk.empty()) cout << \"No\" << endl;\n        else cout << \"Yes\" << endl;\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Uva673-Parentheses-Balance.md","raw":"---\ntitle: Uva673-Parentheses Balance-栈\ndate: 2018-11-27 07:08:53\ncategories:\n- ACM\n- 栈\ntags:\n- Stack\n---\n输入一个包含 $“()”$ 和 $“[]”$ 的括号序列，判断是否合法。具体规则：\n- 空串合法\n- 如果A和B都合法，则AB合法\n- 如果A合法则(A)和[A]都合法\n\n可能最近DFS，BFS做多了，总想往搜索上套...不过最后能想到栈还是很鸡冻＼（≧▽≦）／\n<!--more-->\n# 链接\n[Uva673-Parentheses Balance](https://vjudge.net/problem/UVA-673)\n\n# 题解\n能想到用栈之后这道题基本就可解了，将字符序列依次放入栈中遇到可以匹配的括号对　$“()”$ 或 $“[]”$　就出栈。如果最后栈中还有未匹配的括号，则不合法；否则若栈空，则合法。\n*可能含有空串所以读入的时候用getline(cin, s)读入，因为cin会自动忽略'\\n'，即忽略空串。*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 26 Nov 23:30:58 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 130;\nstring s;\nint n;\nstack<char> stk;\nbool p;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> n;\n    getchar();\n    while(n--){\n        while(!stk.empty()){\n            stk.pop();\n        }\n\n        getline(cin , s);\n        if(s.length() % 2){\n            cout << \"No\" << endl;\n            continue;\n        }\n        for(size_t i = 0; i < s.length(); i++){\n            p = false;\n            if(!stk.empty()){\n                if((stk.top() == '(' && s[i] == ')') || (stk.top() == '[' && s[i] == ']')){\n                    stk.pop();\n                    p = true;\n                }\n            }\n            if(!p) stk.push(s[i]);\n        }\n\n        if(!stk.empty()) cout << \"No\" << endl;\n        else cout << \"Yes\" << endl;\n    }\n    return 0;\n}\n```\n\n","slug":"Uva673-Parentheses-Balance","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nls001fh8vn6fbz8mq5","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva1374-Power Calculus-IDA*","date":"2019-02-08T08:36:27.000Z","_content":"给定一个数n，求从$x$计算到$x^n$至少需要多少步，允许得到的各中间变量之间进行乘法和除法。\n<!--more-->\n# 链接\n题目链接：[Uva1374-Power Calculus](https://vjudge.net/problem/UVA-1374)\n\n# 题解\n看到这道题，最开始想到的是快速幂的计算方法。但是快速幂计算其实是分为“计算过程数据”和“有效过程数据相乘”两部分构成的，步数不一定最少，而且，这道题目中允许除法的运算。所以不能将快速幂的计算方法的过程步骤作为最少步数的结果。\n采用递归的方式进行搜索，由于具体的步数即深度不清楚，所以适合采用迭代加深搜索来做。同时将``maxVal * pow(2, maxd - d)``与n的大小关系作为剪枝的条件。其中maxVal为当前中间变量构成的序列中的最大值。若上式的值仍小于n，那么在当前的深度限制下不可能达到n值，需要进行剪枝。\n\n**用位运算``maxVal << maxd - d``的方式来代替``maxVal * pow(2, maxd - d)``的运算方式有助于提升速度。**\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri  8 Feb 16:18:30 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1007;\nint a[maxn];\nint n;\nint res;\n\nint findMaxVal(int dep){\n    int ans = 0;\n    for(int i = 0; i <= dep; i++){\n        ans = max(ans, a[i]);\n    }\n    return ans;\n}\n\nbool dfs(int dep, int maxd){\n    if(dep >= maxd){\n        if(a[dep] == n) return true;\n        else return false;\n    }\n\n    //prune\n    int maxVal = findMaxVal(dep);\n    if(maxVal << (maxd - dep) < n) return false;\n\n    for(int i = dep; i >= 0; i--){\n        a[dep + 1] = a[dep] + a[i];\n        if(dfs(dep + 1, maxd)) return true;\n        if(a[dep] - a[i] > 0){\n            a[dep + 1] = a[dep] - a[i];\n            if(dfs(dep + 1, maxd)) return true;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    #ifndef    ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        if(n == 0) break;\n        if(n == 1){\n            cout << 0 << endl;\n            continue;\n        }\n\n        a[0] = 1;\n        for(int maxd = 1; maxd <= maxn; maxd++){\n            if(dfs(0, maxd)){\n                res = maxd;\n                break;\n            }\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}\n```","source":"_posts/Uva1374-Power-Calculus.md","raw":"---\ntitle: Uva1374-Power Calculus-IDA*\ndate: 2019-02-08 16:36:27\ncategories:\n- ACM\n- IDA*\ntags:\n- IDA*\n---\n给定一个数n，求从$x$计算到$x^n$至少需要多少步，允许得到的各中间变量之间进行乘法和除法。\n<!--more-->\n# 链接\n题目链接：[Uva1374-Power Calculus](https://vjudge.net/problem/UVA-1374)\n\n# 题解\n看到这道题，最开始想到的是快速幂的计算方法。但是快速幂计算其实是分为“计算过程数据”和“有效过程数据相乘”两部分构成的，步数不一定最少，而且，这道题目中允许除法的运算。所以不能将快速幂的计算方法的过程步骤作为最少步数的结果。\n采用递归的方式进行搜索，由于具体的步数即深度不清楚，所以适合采用迭代加深搜索来做。同时将``maxVal * pow(2, maxd - d)``与n的大小关系作为剪枝的条件。其中maxVal为当前中间变量构成的序列中的最大值。若上式的值仍小于n，那么在当前的深度限制下不可能达到n值，需要进行剪枝。\n\n**用位运算``maxVal << maxd - d``的方式来代替``maxVal * pow(2, maxd - d)``的运算方式有助于提升速度。**\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri  8 Feb 16:18:30 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1007;\nint a[maxn];\nint n;\nint res;\n\nint findMaxVal(int dep){\n    int ans = 0;\n    for(int i = 0; i <= dep; i++){\n        ans = max(ans, a[i]);\n    }\n    return ans;\n}\n\nbool dfs(int dep, int maxd){\n    if(dep >= maxd){\n        if(a[dep] == n) return true;\n        else return false;\n    }\n\n    //prune\n    int maxVal = findMaxVal(dep);\n    if(maxVal << (maxd - dep) < n) return false;\n\n    for(int i = dep; i >= 0; i--){\n        a[dep + 1] = a[dep] + a[i];\n        if(dfs(dep + 1, maxd)) return true;\n        if(a[dep] - a[i] > 0){\n            a[dep + 1] = a[dep] - a[i];\n            if(dfs(dep + 1, maxd)) return true;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    #ifndef    ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        if(n == 0) break;\n        if(n == 1){\n            cout << 0 << endl;\n            continue;\n        }\n\n        a[0] = 1;\n        for(int maxd = 1; maxd <= maxn; maxd++){\n            if(dfs(0, maxd)){\n                res = maxd;\n                break;\n            }\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}\n```","slug":"Uva1374-Power-Calculus","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlt001gh8vnxwdqzdy4","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva1599-Ideal Path-双向BFS","date":"2018-11-18T02:49:44.000Z","_content":"给定一个n个顶点和m条边的无向图，每条边都有颜色，求从结点1到结点n的一条最短路，若有多条则取路径颜色序列字典序最小的那条。可能会有重边和自环。\n<!--more-->\n# 链接\n[Uva1599-Ideal Path](https://vjudge.net/problem/UVA-1599)\n\n# 题解\n这里每条边的权值都是一样的，可以求最短路的方式有 $BFS$，$SPFA$，$Dijkstra$ 等。但是这些方法都不能保证求得的最短路的字典序最小。可以先从节点n出发跑一次 $BFS$。这样再从节点1出发时可以按照各个结点已经标记好的距离，每次到达一个新结点时保证d值恰好减1,直到到达终点。\n按照上述规则从起点出发，优先选择颜色字典序最小的走，若多条边的颜色字典序都最小则记录所有这些边的终点，下一步时考虑从所有这些点出发的边。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 17 Nov 23:09:12 CST 2018\n *\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nconst int inf = 1e9 + 7;\nstruct Edge{\n    int to;\n    int color;\n};\nvector<Edge> G[maxn];\nint n, m;\nint d[maxn];\nbool vis[maxn];\n\nvoid back_bfs(){\n    d[n - 1] = 0;\n    vis[n - 1] = true;\n    queue<int> que;\n    que.push(n - 1);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        for(size_t i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            int u = e.to;\n            if(!vis[u]){\n                d[u] = d[v] + 1;\n                que.push(u);\n                vis[u] = true;\n            }\n        }\n\n    }\n}\n\nvector<int> ans;\n\nvoid bfs(){\n    memset(vis, 0, sizeof(vis));\n    vis[0] = true;\n\n    vector<int> next;\n    next.push_back(0);\n    for(int i = 0; i < d[0]; i++){\n        int minColor = inf;\n        for(size_t j = 0; j < next.size(); j++){\n            int v = next[j];\n            for(size_t k = 0; k < G[v].size(); k++){\n                Edge e = G[v][k];\n                int u = e.to;\n                if(d[u] == d[v] - 1){\n                    minColor = min(minColor, e.color);\n                }\n            }\n        }\n        ans.push_back(minColor);\n\n        vector<int> next2;\n        for(size_t j = 0; j < next.size(); j++){\n            int v = next[j];\n            for(size_t k = 0; k < G[v].size(); k++){\n                Edge e = G[v][k];\n                if(e.color == minColor && !vis[e.to] && d[e.to] == d[v] - 1){\n                    next2.push_back(e.to);\n                    vis[e.to] = true;\n                }\n            }\n        }\n        next = next2;\n    }\n\n    int res = ans.size();\n    cout << res << endl;\n    for(int i = 0; i < res; i++){\n        if(i == 0) cout << ans[i];\n        else cout << \" \" << ans[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n >> m){\n        memset(d, 0, sizeof(d));\n        memset(vis, 0, sizeof(vis));\n        ans.clear();\n        for(int i = 0; i < n; i++){\n            G[i].clear();\n        }\n\n        int a, b, c;\n        Edge e;\n        for(int i = 0; i < m; i++){\n            cin >> a >> b >> c;\n            e.to = b - 1;\n            e.color = c;\n            G[a - 1].push_back(e);\n            e.to = a - 1;\n            G[b - 1].push_back(e);\n        }\n\n        back_bfs();\n        bfs();\n    }\n    return 0;\n}\n```\n","source":"_posts/Uva1599-Ideal-Path.md","raw":"---\ntitle: Uva1599-Ideal Path-双向BFS\ndate: 2018-11-18 10:49:44\ncategories:\n- ACM\n- BFS\ntags:\n- BFS\n---\n给定一个n个顶点和m条边的无向图，每条边都有颜色，求从结点1到结点n的一条最短路，若有多条则取路径颜色序列字典序最小的那条。可能会有重边和自环。\n<!--more-->\n# 链接\n[Uva1599-Ideal Path](https://vjudge.net/problem/UVA-1599)\n\n# 题解\n这里每条边的权值都是一样的，可以求最短路的方式有 $BFS$，$SPFA$，$Dijkstra$ 等。但是这些方法都不能保证求得的最短路的字典序最小。可以先从节点n出发跑一次 $BFS$。这样再从节点1出发时可以按照各个结点已经标记好的距离，每次到达一个新结点时保证d值恰好减1,直到到达终点。\n按照上述规则从起点出发，优先选择颜色字典序最小的走，若多条边的颜色字典序都最小则记录所有这些边的终点，下一步时考虑从所有这些点出发的边。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 17 Nov 23:09:12 CST 2018\n *\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nconst int inf = 1e9 + 7;\nstruct Edge{\n    int to;\n    int color;\n};\nvector<Edge> G[maxn];\nint n, m;\nint d[maxn];\nbool vis[maxn];\n\nvoid back_bfs(){\n    d[n - 1] = 0;\n    vis[n - 1] = true;\n    queue<int> que;\n    que.push(n - 1);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        for(size_t i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            int u = e.to;\n            if(!vis[u]){\n                d[u] = d[v] + 1;\n                que.push(u);\n                vis[u] = true;\n            }\n        }\n\n    }\n}\n\nvector<int> ans;\n\nvoid bfs(){\n    memset(vis, 0, sizeof(vis));\n    vis[0] = true;\n\n    vector<int> next;\n    next.push_back(0);\n    for(int i = 0; i < d[0]; i++){\n        int minColor = inf;\n        for(size_t j = 0; j < next.size(); j++){\n            int v = next[j];\n            for(size_t k = 0; k < G[v].size(); k++){\n                Edge e = G[v][k];\n                int u = e.to;\n                if(d[u] == d[v] - 1){\n                    minColor = min(minColor, e.color);\n                }\n            }\n        }\n        ans.push_back(minColor);\n\n        vector<int> next2;\n        for(size_t j = 0; j < next.size(); j++){\n            int v = next[j];\n            for(size_t k = 0; k < G[v].size(); k++){\n                Edge e = G[v][k];\n                if(e.color == minColor && !vis[e.to] && d[e.to] == d[v] - 1){\n                    next2.push_back(e.to);\n                    vis[e.to] = true;\n                }\n            }\n        }\n        next = next2;\n    }\n\n    int res = ans.size();\n    cout << res << endl;\n    for(int i = 0; i < res; i++){\n        if(i == 0) cout << ans[i];\n        else cout << \" \" << ans[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n >> m){\n        memset(d, 0, sizeof(d));\n        memset(vis, 0, sizeof(vis));\n        ans.clear();\n        for(int i = 0; i < n; i++){\n            G[i].clear();\n        }\n\n        int a, b, c;\n        Edge e;\n        for(int i = 0; i < m; i++){\n            cin >> a >> b >> c;\n            e.to = b - 1;\n            e.color = c;\n            G[a - 1].push_back(e);\n            e.to = a - 1;\n            G[b - 1].push_back(e);\n        }\n\n        back_bfs();\n        bfs();\n    }\n    return 0;\n}\n```\n","slug":"Uva1599-Ideal-Path","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlt001hh8vng8vo9a9h","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva548-二叉树构建&&DFS","date":"2018-09-22T03:30:57.000Z","_content":"首先根据二叉树的中序和后序遍历构建二叉树，然后找一个叶子节点使得它到根的路径上的权和最小。\n<!--more-->\n# 链接\n[Uva548-Tree](https://vjudge.net/problem/UVA-548)\n# 题目描述\n给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍历，找一个叶子节点使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。\n# 题解\n根据中序和后序遍历可以构建出这棵二叉，然后用DFS搜索找到结果。\n# 代码\n**通过设置best_sum和best找到最优解的方法值得学习啊。**\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 22 Sep 11:20:12 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e4 + 7;\nint in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];\nstring line;\nint n;\nint best, best_sum;\n\nbool read(int* s){\n    if(!getline(cin, line)) return false;\n    stringstream ss(line);\n    n = 0;\n    int x;\n    while(ss >> x){\n        s[n++] = x;\n    }\n    return true;\n}\n\nint build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return 0;\n    int v = post_order[r2];\n    int pos = 0;\n    while(in_order[pos] != v) pos++;\n    int len = pos - l1;\n    lch[v] = build(l1, l1 + len - 1, l2, l2 + len - 1);\n    rch[v] = build(l1 + len + 1, r1, l2 + len, r2 - 1);\n    return v;\n}\n\nvoid dfs(int v, int sum){\n    sum += v;\n    if(!lch[v] && !rch[v]){\n        if(sum < best_sum || (sum == best_sum && v < best)){\n            best_sum = sum;\n            best = v;\n        }\n        return;\n    }\n    if(lch[v]) dfs(lch[v], sum);\n    if(rch[v]) dfs(rch[v], sum);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(read(in_order)){\n        read(post_order);\n        int root = build(0, n - 1, 0, n - 1);\n        best_sum = 1e9;\n        dfs(root, 0);\n        cout << best << endl;\n    }\n    \n    return 0;\n}\n```","source":"_posts/Uva548-二叉树构建-DFS.md","raw":"---\ntitle: Uva548-二叉树构建&&DFS\ndate: 2018-09-22 11:30:57\ncategories:\n- ACM\n- 树\ntags:\n- 二叉树\n- DFS\n---\n首先根据二叉树的中序和后序遍历构建二叉树，然后找一个叶子节点使得它到根的路径上的权和最小。\n<!--more-->\n# 链接\n[Uva548-Tree](https://vjudge.net/problem/UVA-548)\n# 题目描述\n给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍历，找一个叶子节点使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。\n# 题解\n根据中序和后序遍历可以构建出这棵二叉，然后用DFS搜索找到结果。\n# 代码\n**通过设置best_sum和best找到最优解的方法值得学习啊。**\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 22 Sep 11:20:12 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e4 + 7;\nint in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];\nstring line;\nint n;\nint best, best_sum;\n\nbool read(int* s){\n    if(!getline(cin, line)) return false;\n    stringstream ss(line);\n    n = 0;\n    int x;\n    while(ss >> x){\n        s[n++] = x;\n    }\n    return true;\n}\n\nint build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return 0;\n    int v = post_order[r2];\n    int pos = 0;\n    while(in_order[pos] != v) pos++;\n    int len = pos - l1;\n    lch[v] = build(l1, l1 + len - 1, l2, l2 + len - 1);\n    rch[v] = build(l1 + len + 1, r1, l2 + len, r2 - 1);\n    return v;\n}\n\nvoid dfs(int v, int sum){\n    sum += v;\n    if(!lch[v] && !rch[v]){\n        if(sum < best_sum || (sum == best_sum && v < best)){\n            best_sum = sum;\n            best = v;\n        }\n        return;\n    }\n    if(lch[v]) dfs(lch[v], sum);\n    if(rch[v]) dfs(rch[v], sum);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(read(in_order)){\n        read(post_order);\n        int root = build(0, n - 1, 0, n - 1);\n        best_sum = 1e9;\n        dfs(root, 0);\n        cout << best << endl;\n    }\n    \n    return 0;\n}\n```","slug":"Uva548-二叉树构建-DFS","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlu001ih8vncjvz07f2","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva806-Spatial Structures-四分树","date":"2018-12-04T12:48:34.000Z","_content":"有幸做World Final的题，，做了一下午= =，刷新我的单题代码长度了，怕了怕了。\n黑白图像有两种表示方法，点阵表示和路径表示。路径表示法首先需要把图像转化为四分树，然后记录所有黑结点到根的路径。\n任务是在这两种表示法之间进行转换。\n<!--more-->\n\n# 链接\n[Uva806-Spatial Structures](https://vjudge.net/problem/UVA-806)\n\n# 题目描述\n中间图为点阵表示：\n![1](/1.png)\n四分树：\n![2](/2.png)\n四分树中NW，NE，SW，SE分别用1、2、3、4表示。其实它们的代表是把图像四分后的左上、右上、左下和右下部分。把得到的路径数字串看成是五进制的，转化为十进制后排序。例如上面的树在转化，排序后的结果是：9 14 17 22 23 44 63 69 88 94 113。\n要求给定一串数字路径还原点阵形式，或给定点阵写出所有黑结点的数字路径并排序输出。\n\n# 题解\n题目本身难度不是很大，只不过有很多细节需要注意。自己就被Presentation Error了好久= =。点阵转路径的时候，递归进行四分，如果子区域全白或全黑，跳出递归，边递归边统计路径，全黑时就把路径转成十进制存起来。路径转点阵的过程类似，可以用队列维护数字串，每取出一个就重新规划区域，直到队列为空，把当前区域全部涂黑。\n*除去输出格式的问题，还有一个需要注意的是，若初始图像全白，则路径用空串来表示，需要特殊处理，同时意味着读入路径数据的时候要用getline。*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue  4 Dec 14:36:07 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 70;\nint n;\nchar d[maxn][maxn];\nint x, y;\nstack<int> rec;\nvector<int> ans;\nint cnt = 0;\n\nbool All_Black(int r, int c, int w){\n    for(int i = r; i < r + w; i++){\n        for(int j = c; j < c + w; j++){\n            if(d[i][j] == '0') return false;\n        }\n    }\n    return true;\n}\n\nbool All_White(int r, int c, int w){\n    for(int i = r; i < r + w; i++){\n        for(int j = c; j < c + w; j++){\n            if(d[i][j] == '1') return false;\n        }\n    }\n    return true;\n}\n\nvoid cal(){\n    int sum = 0;\n    stack<int> tmp = rec;\n    while(!tmp.empty()){\n        sum *= 5;\n        sum += tmp.top();\n        tmp.pop();\n    }\n    ans.push_back(sum);\n}\n\nvoid dfs(int r, int c, int w, stack<int>& rec){\n    //cout << r << \" \" << c << \" \" << w << endl;\n    if(All_Black(r, c, w)){\n        //cout << \"all black\" << endl;\n        cal();\n        return;\n    }\n    if(All_White(r, c, w)){\n        //cout << \"all white\" << endl;\n        return;\n    }\n    rec.push(1);\n    dfs(r, c, w / 2, rec);\n    rec.pop();\n    rec.push(2);\n    dfs(r, c + w / 2, w / 2, rec);\n    rec.pop();\n    rec.push(3);\n    dfs(r + w / 2, c, w / 2, rec);\n    rec.pop();\n    rec.push(4);\n    dfs(r + w / 2, c + w / 2, w / 2, rec);\n    rec.pop();\n} \n\nvoid solve1(){\n    for(int i = 0; i < n; i++){\n        scanf(\"%s\", d[i]);\n    }\n    while(!rec.empty()) rec.pop();\n    dfs(0, 0, n, rec);\n    sort(ans.begin(), ans.end());\n\n    printf(\"Image %d\\n\", cnt);\n    int len = ans.size();\n    for(int i = 0; i < len; i++){\n        if((i + 1) %12 == 1) printf(\"%d\", ans[i]);\n        else printf(\" %d\", ans[i]);\n\n        if((i + 1) % 12 == 0) printf(\"\\n\");\n    }\n    if((len % 12) != 0) printf(\"\\n\");\n    printf(\"Total number of black nodes = %d\\n\", len);\n}\n\nvoid draw(int r, int c, int w, queue<int>& que){\n    if(que.empty()){\n        for(int i = r; i < r + w; i++){\n            for(int j = c; j < c + w; j++){\n                d[i][j] = '*';\n            }\n        }\n        return;\n    }\n    int tmp = que.front();\n    que.pop();\n    if(tmp == 1) draw(r, c, w / 2, que);\n    if(tmp == 2) draw(r, c + w / 2, w / 2, que);\n    if(tmp == 3) draw(r + w / 2, c, w / 2, que);\n    if(tmp == 4) draw(r + w / 2, c + w / 2, w / 2, que); \n}\n\nvoid Print_White(){\n    printf(\"Image %d\\n\", cnt);\n    for(int i = 0; i < -n; i++){\n        for(int j = 0; j < -n; j++){\n            printf(\".\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid solve2(){\n    getchar();\n    int num;\n    queue<int> que;\n    stringstream ss1, ss2;\n    string s1, s2;\n    //fgets(s, 1000, stdin);\n    getline(cin, s1);\n    if(s1[0] == '\\n') {\n        Print_White();\n        return;\n    }\n\n    ss1.str(s1);\n    while(ss1 >> s2){\n        ss2.str(s2);\n        ss2 >> num;\n        ss2.clear();\n        if(num == -1) break;\n\n        while(!que.empty()) que.pop();\n\n        while(num){\n            que.push(num % 5);\n            num /= 5;\n        }\n        draw(0, 0, -n, que);\n    }\n\n    printf(\"Image %d\\n\", cnt);\n    for(int i = 0; i < -n; i++){\n        for(int j = 0; j < -n; j++){\n            if(d[i][j] != '*'){\n                d[i][j] = '.';\n            }\n            printf(\"%c\", d[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(1){\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n\n        memset(d, 0, sizeof(d));\n        ans.clear();\n\n        if(cnt > 0) printf(\"\\n\");\n        cnt++;\n        if(n > 0){\n            solve1();\n        }\n        if(n < 0){\n            solve2();\n        }\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Uva806-Spatial-Structures.md","raw":"---\ntitle: Uva806-Spatial Structures-四分树\ndate: 2018-12-04 20:48:34\ncategories:\n- ACM\n- 树\ntags:\n- 四分树\n---\n有幸做World Final的题，，做了一下午= =，刷新我的单题代码长度了，怕了怕了。\n黑白图像有两种表示方法，点阵表示和路径表示。路径表示法首先需要把图像转化为四分树，然后记录所有黑结点到根的路径。\n任务是在这两种表示法之间进行转换。\n<!--more-->\n\n# 链接\n[Uva806-Spatial Structures](https://vjudge.net/problem/UVA-806)\n\n# 题目描述\n中间图为点阵表示：\n![1](/1.png)\n四分树：\n![2](/2.png)\n四分树中NW，NE，SW，SE分别用1、2、3、4表示。其实它们的代表是把图像四分后的左上、右上、左下和右下部分。把得到的路径数字串看成是五进制的，转化为十进制后排序。例如上面的树在转化，排序后的结果是：9 14 17 22 23 44 63 69 88 94 113。\n要求给定一串数字路径还原点阵形式，或给定点阵写出所有黑结点的数字路径并排序输出。\n\n# 题解\n题目本身难度不是很大，只不过有很多细节需要注意。自己就被Presentation Error了好久= =。点阵转路径的时候，递归进行四分，如果子区域全白或全黑，跳出递归，边递归边统计路径，全黑时就把路径转成十进制存起来。路径转点阵的过程类似，可以用队列维护数字串，每取出一个就重新规划区域，直到队列为空，把当前区域全部涂黑。\n*除去输出格式的问题，还有一个需要注意的是，若初始图像全白，则路径用空串来表示，需要特殊处理，同时意味着读入路径数据的时候要用getline。*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue  4 Dec 14:36:07 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 70;\nint n;\nchar d[maxn][maxn];\nint x, y;\nstack<int> rec;\nvector<int> ans;\nint cnt = 0;\n\nbool All_Black(int r, int c, int w){\n    for(int i = r; i < r + w; i++){\n        for(int j = c; j < c + w; j++){\n            if(d[i][j] == '0') return false;\n        }\n    }\n    return true;\n}\n\nbool All_White(int r, int c, int w){\n    for(int i = r; i < r + w; i++){\n        for(int j = c; j < c + w; j++){\n            if(d[i][j] == '1') return false;\n        }\n    }\n    return true;\n}\n\nvoid cal(){\n    int sum = 0;\n    stack<int> tmp = rec;\n    while(!tmp.empty()){\n        sum *= 5;\n        sum += tmp.top();\n        tmp.pop();\n    }\n    ans.push_back(sum);\n}\n\nvoid dfs(int r, int c, int w, stack<int>& rec){\n    //cout << r << \" \" << c << \" \" << w << endl;\n    if(All_Black(r, c, w)){\n        //cout << \"all black\" << endl;\n        cal();\n        return;\n    }\n    if(All_White(r, c, w)){\n        //cout << \"all white\" << endl;\n        return;\n    }\n    rec.push(1);\n    dfs(r, c, w / 2, rec);\n    rec.pop();\n    rec.push(2);\n    dfs(r, c + w / 2, w / 2, rec);\n    rec.pop();\n    rec.push(3);\n    dfs(r + w / 2, c, w / 2, rec);\n    rec.pop();\n    rec.push(4);\n    dfs(r + w / 2, c + w / 2, w / 2, rec);\n    rec.pop();\n} \n\nvoid solve1(){\n    for(int i = 0; i < n; i++){\n        scanf(\"%s\", d[i]);\n    }\n    while(!rec.empty()) rec.pop();\n    dfs(0, 0, n, rec);\n    sort(ans.begin(), ans.end());\n\n    printf(\"Image %d\\n\", cnt);\n    int len = ans.size();\n    for(int i = 0; i < len; i++){\n        if((i + 1) %12 == 1) printf(\"%d\", ans[i]);\n        else printf(\" %d\", ans[i]);\n\n        if((i + 1) % 12 == 0) printf(\"\\n\");\n    }\n    if((len % 12) != 0) printf(\"\\n\");\n    printf(\"Total number of black nodes = %d\\n\", len);\n}\n\nvoid draw(int r, int c, int w, queue<int>& que){\n    if(que.empty()){\n        for(int i = r; i < r + w; i++){\n            for(int j = c; j < c + w; j++){\n                d[i][j] = '*';\n            }\n        }\n        return;\n    }\n    int tmp = que.front();\n    que.pop();\n    if(tmp == 1) draw(r, c, w / 2, que);\n    if(tmp == 2) draw(r, c + w / 2, w / 2, que);\n    if(tmp == 3) draw(r + w / 2, c, w / 2, que);\n    if(tmp == 4) draw(r + w / 2, c + w / 2, w / 2, que); \n}\n\nvoid Print_White(){\n    printf(\"Image %d\\n\", cnt);\n    for(int i = 0; i < -n; i++){\n        for(int j = 0; j < -n; j++){\n            printf(\".\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid solve2(){\n    getchar();\n    int num;\n    queue<int> que;\n    stringstream ss1, ss2;\n    string s1, s2;\n    //fgets(s, 1000, stdin);\n    getline(cin, s1);\n    if(s1[0] == '\\n') {\n        Print_White();\n        return;\n    }\n\n    ss1.str(s1);\n    while(ss1 >> s2){\n        ss2.str(s2);\n        ss2 >> num;\n        ss2.clear();\n        if(num == -1) break;\n\n        while(!que.empty()) que.pop();\n\n        while(num){\n            que.push(num % 5);\n            num /= 5;\n        }\n        draw(0, 0, -n, que);\n    }\n\n    printf(\"Image %d\\n\", cnt);\n    for(int i = 0; i < -n; i++){\n        for(int j = 0; j < -n; j++){\n            if(d[i][j] != '*'){\n                d[i][j] = '.';\n            }\n            printf(\"%c\", d[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(1){\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n\n        memset(d, 0, sizeof(d));\n        ans.clear();\n\n        if(cnt > 0) printf(\"\\n\");\n        cnt++;\n        if(n > 0){\n            solve1();\n        }\n        if(n < 0){\n            solve2();\n        }\n    }\n    return 0;\n}\n```\n\n","slug":"Uva806-Spatial-Structures","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlu001jh8vncplguoa8","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva816-Abbott's Revenge-BFS","date":"2018-11-01T08:18:17.000Z","_content":"一道比较别致的BFS搜索题，题目规定了在迷宫里沿特定方向到达某点后只能再沿特定一个或几个方向继续前进，而不是平常的任意四个方向都可以前进。\n在输出格式上WA了很久，，什么时候我才能“Bug Free”啊，哭QAQ\n<!--more-->\n# 链接\n[Uva816-Abbott's Revenge](https://vjudge.net/problem/UVA-816)\n# 题目描述\n迷宫找最短路径问题，不同于以往的障碍物形式，题目规定沿某一方向进入节点（东，南，西，北）之后只能按照给定的方向离开该节点（前进，左转，右转）。给定起点和终点，要求输出最短路径。\n# 题解\n带方向的BFS，在构建地图的时候添加上方向和转向两个维度。在更新节点距离和记录路径的时候加上方向维度。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed 31 Oct 07:40:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10, dir = 4, turn = 3;\nchar dirs[] = \"NESW\", turns[] = \"FLR\";\nint mp[maxn][maxn][dir][turn];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\nint dis[maxn][maxn][dir];\nstruct Node{\n    int x;\n    int y;\n    int dir;\n    Node(){}\n    Node(int xx, int yy, int ddir): x(xx), y(yy), dir(ddir){}\n};\nNode path[maxn][maxn][dir];\nint stx, sty, edx, edy;\nchar stdir;\n\nint finddir(char c){\n    return strchr(dirs, c) - dirs;\n}\n\nint findturn(char c){\n    return strchr(turns, c) - turns;\n}\n\n\nvoid read(){\n    int x, y, dr, tr;\n    string s;\n    while(1){\n        cin >> x;\n        if(x == 0) break;\n        cin >> y;\n        for(;;){\n            cin >> s;\n            //cout << s << endl;\n            if(s == \"*\") break;\n            dr = finddir(s[0]);\n            //cout << dr << endl;\n            for(size_t i = 1; i < s.length(); i++){\n                tr = findturn(s[i]);\n                //cout << tr << endl;\n                mp[x][y][dr][tr] = 1;\n            }\n        }\n    }\n}\n\nbool inside(int x, int y){\n    if(x >= 1 && x <= 9 && y >= 1 && y <= 9) return true;\n    else return false;\n}\n\nint trans(int turn, int dir){\n    if(turn == 0) return dir;\n    else if(turn == 1) return (dir + 3) % 4;\n    else return (dir + 1) % 4;\n}\n\nvoid print(Node node){\n    //cout << \"GodBlessMe!\" << endl;\n    vector<Node> vec;\n    vec.push_back(node);\n    Node nd;\n    while(1){\n        nd = path[node.x][node.y][node.dir];\n        if(nd.x == -1) break;\n        vec.push_back(nd);\n        node = nd;\n    }\n    vec.push_back(Node(stx, sty, finddir(stdir)));\n    reverse(vec.begin(), vec.end());\n    \n    int cnt = 0;\n    for(auto x : vec){\n        if(cnt % 10 == 0) cout << \" \";\n        cout << \" (\" << x.x << \",\" << x.y << \")\";\n        if(++cnt % 10 == 0) cout << \"\\n\";\n    }\n    if(vec.size() % 10 != 0) cout << endl;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    string s;\n    bool ok;\n    while(cin >> s){\n        if(s == \"END\") break;\n        memset(mp, 0, sizeof(mp));\n        memset(dis, -1, sizeof(dis));\n        memset(path, -1, sizeof(path));\n        ok = false;\n        \n        cin >> stx >> sty >> stdir >> edx >> edy;\n        read();\n        queue<Node> que;\n        Node node;\n        int num = finddir(stdir);\n        node.x = stx + dx[num], node.y = sty + dy[num], node.dir = num;\n        que.push(node);\n        dis[node.x][node.y][node.dir] = 0;\n        while(!que.empty()){\n            Node nd = que.front();\n            if(nd.x == edx && nd.y == edy){\n                ok = true;\n                break;\n            }\n            que.pop();\n            for(int i = 0; i < 3; i++){\n                int k = trans(i, nd.dir);\n                int nx = nd.x + dx[k], ny = nd.y + dy[k];\n                if(mp[nd.x][nd.y][nd.dir][i] && inside(nx, ny) && dis[nx][ny][k] == -1){\n                    dis[nx][ny][k] = dis[nd.x][nd.y][nd.dir] + 1;\n                    que.push(Node(nx, ny, k));\n                    path[nx][ny][k] = nd;\n                }\n            }\n        }\n        cout << s << endl;\n        if(ok) print(que.front());\n        else cout << \"  No Solution Possible\" << endl;\n    }\n    \n    return 0;\n}\n```","source":"_posts/Uva816-Abbott-s-Revenge-BFS.md","raw":"---\ntitle: Uva816-Abbott's Revenge-BFS\ndate: 2018-11-01 16:18:17\ncategories:\n- ACM\n- BFS\ntags:\n- BFS\n---\n一道比较别致的BFS搜索题，题目规定了在迷宫里沿特定方向到达某点后只能再沿特定一个或几个方向继续前进，而不是平常的任意四个方向都可以前进。\n在输出格式上WA了很久，，什么时候我才能“Bug Free”啊，哭QAQ\n<!--more-->\n# 链接\n[Uva816-Abbott's Revenge](https://vjudge.net/problem/UVA-816)\n# 题目描述\n迷宫找最短路径问题，不同于以往的障碍物形式，题目规定沿某一方向进入节点（东，南，西，北）之后只能按照给定的方向离开该节点（前进，左转，右转）。给定起点和终点，要求输出最短路径。\n# 题解\n带方向的BFS，在构建地图的时候添加上方向和转向两个维度。在更新节点距离和记录路径的时候加上方向维度。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed 31 Oct 07:40:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10, dir = 4, turn = 3;\nchar dirs[] = \"NESW\", turns[] = \"FLR\";\nint mp[maxn][maxn][dir][turn];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\nint dis[maxn][maxn][dir];\nstruct Node{\n    int x;\n    int y;\n    int dir;\n    Node(){}\n    Node(int xx, int yy, int ddir): x(xx), y(yy), dir(ddir){}\n};\nNode path[maxn][maxn][dir];\nint stx, sty, edx, edy;\nchar stdir;\n\nint finddir(char c){\n    return strchr(dirs, c) - dirs;\n}\n\nint findturn(char c){\n    return strchr(turns, c) - turns;\n}\n\n\nvoid read(){\n    int x, y, dr, tr;\n    string s;\n    while(1){\n        cin >> x;\n        if(x == 0) break;\n        cin >> y;\n        for(;;){\n            cin >> s;\n            //cout << s << endl;\n            if(s == \"*\") break;\n            dr = finddir(s[0]);\n            //cout << dr << endl;\n            for(size_t i = 1; i < s.length(); i++){\n                tr = findturn(s[i]);\n                //cout << tr << endl;\n                mp[x][y][dr][tr] = 1;\n            }\n        }\n    }\n}\n\nbool inside(int x, int y){\n    if(x >= 1 && x <= 9 && y >= 1 && y <= 9) return true;\n    else return false;\n}\n\nint trans(int turn, int dir){\n    if(turn == 0) return dir;\n    else if(turn == 1) return (dir + 3) % 4;\n    else return (dir + 1) % 4;\n}\n\nvoid print(Node node){\n    //cout << \"GodBlessMe!\" << endl;\n    vector<Node> vec;\n    vec.push_back(node);\n    Node nd;\n    while(1){\n        nd = path[node.x][node.y][node.dir];\n        if(nd.x == -1) break;\n        vec.push_back(nd);\n        node = nd;\n    }\n    vec.push_back(Node(stx, sty, finddir(stdir)));\n    reverse(vec.begin(), vec.end());\n    \n    int cnt = 0;\n    for(auto x : vec){\n        if(cnt % 10 == 0) cout << \" \";\n        cout << \" (\" << x.x << \",\" << x.y << \")\";\n        if(++cnt % 10 == 0) cout << \"\\n\";\n    }\n    if(vec.size() % 10 != 0) cout << endl;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    string s;\n    bool ok;\n    while(cin >> s){\n        if(s == \"END\") break;\n        memset(mp, 0, sizeof(mp));\n        memset(dis, -1, sizeof(dis));\n        memset(path, -1, sizeof(path));\n        ok = false;\n        \n        cin >> stx >> sty >> stdir >> edx >> edy;\n        read();\n        queue<Node> que;\n        Node node;\n        int num = finddir(stdir);\n        node.x = stx + dx[num], node.y = sty + dy[num], node.dir = num;\n        que.push(node);\n        dis[node.x][node.y][node.dir] = 0;\n        while(!que.empty()){\n            Node nd = que.front();\n            if(nd.x == edx && nd.y == edy){\n                ok = true;\n                break;\n            }\n            que.pop();\n            for(int i = 0; i < 3; i++){\n                int k = trans(i, nd.dir);\n                int nx = nd.x + dx[k], ny = nd.y + dy[k];\n                if(mp[nd.x][nd.y][nd.dir][i] && inside(nx, ny) && dis[nx][ny][k] == -1){\n                    dis[nx][ny][k] = dis[nd.x][nd.y][nd.dir] + 1;\n                    que.push(Node(nx, ny, k));\n                    path[nx][ny][k] = nd;\n                }\n            }\n        }\n        cout << s << endl;\n        if(ok) print(que.front());\n        else cout << \"  No Solution Possible\" << endl;\n    }\n    \n    return 0;\n}\n```","slug":"Uva816-Abbott-s-Revenge-BFS","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlv001kh8vngvc08ozp","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva839-二叉树的递归处理","date":"2018-09-22T14:53:32.000Z","_content":"输入一个树状天平，根据力矩相等原则判断是否平衡。即判断是否满足$W_lD_l=W_rD_r$。\n![example](/tree.png)\n<!--more-->\n# 链接\n[Uva839-Not so Mobile](https://vjudge.net/problem/UVA-839)\n# 题目描述\n题目输入采用递归（先序）方式：每个天平的格式为$W_l$，$D_l$，$W_r$，$D_r$，当$W_l$或$W_r$为$0$时，表示该“砝码”实际是一个子天平，接下来会进一步描述这个子天平。当$W_l=W_r=0$时，会先描述左子天平，然后是右子天平。\n# 题解\n因为题目的输入就采取了递归方式定义，所以编写一个递归过程读取输入同时进行处理比较合适。在递归的过程中判断子天平是否满足平衡并自下向上不断的更新$W$为$0$的节点（更新为其左子砝码重量$W_l$和右子砝码重量$W_r$之和）。可以定义一个标志变量来标明整个过程是否一直都满足平衡条件。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 22 Sep 22:02:34 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nbool f;\n\nint solve(){\n    int w1, d1, w2, d2;\n    cin >> w1 >> d1 >> w2 >> d2;\n    if(!w1) w1 = solve();\n    if(!w2) w2 = solve();\n    if(w1 * d1 != w2 * d2) f = false;\n    return w1 + w2;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        f = true;\n        solve();\n        if(f) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        if(t) cout << endl;\n    }\n    \n    return 0;\n}\n```","source":"_posts/Uva839-二叉树的递归处理.md","raw":"---\ntitle: Uva839-二叉树的递归处理\ndate: 2018-09-22 22:53:32\ncategories:\n- ACM\n- 树\ntags:\n- 二叉树\n- DFS\n---\n输入一个树状天平，根据力矩相等原则判断是否平衡。即判断是否满足$W_lD_l=W_rD_r$。\n![example](/tree.png)\n<!--more-->\n# 链接\n[Uva839-Not so Mobile](https://vjudge.net/problem/UVA-839)\n# 题目描述\n题目输入采用递归（先序）方式：每个天平的格式为$W_l$，$D_l$，$W_r$，$D_r$，当$W_l$或$W_r$为$0$时，表示该“砝码”实际是一个子天平，接下来会进一步描述这个子天平。当$W_l=W_r=0$时，会先描述左子天平，然后是右子天平。\n# 题解\n因为题目的输入就采取了递归方式定义，所以编写一个递归过程读取输入同时进行处理比较合适。在递归的过程中判断子天平是否满足平衡并自下向上不断的更新$W$为$0$的节点（更新为其左子砝码重量$W_l$和右子砝码重量$W_r$之和）。可以定义一个标志变量来标明整个过程是否一直都满足平衡条件。\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 22 Sep 22:02:34 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nbool f;\n\nint solve(){\n    int w1, d1, w2, d2;\n    cin >> w1 >> d1 >> w2 >> d2;\n    if(!w1) w1 = solve();\n    if(!w2) w2 = solve();\n    if(w1 * d1 != w2 * d2) f = false;\n    return w1 + w2;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        f = true;\n        solve();\n        if(f) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        if(t) cout << endl;\n    }\n    \n    return 0;\n}\n```","slug":"Uva839-二叉树的递归处理","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlv001lh8vngx9c3wn6","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva725-Division-暴力枚举","date":"2018-12-17T11:41:14.000Z","_content":"求满足$$\\frac{abcde}{fghij} = N$$的所有$abcde$ 和 $fghij$的值，其中$2 <= N <= 79。$\n刘汝佳老师：``即使采用暴力法求解问题，对问题进行一定的分析往往会让算法更简介、高效。``\n受益匪浅。\n<!--more-->\n# 链接\n[Uva725-Division](https://vjudge.net/problem/UVA-725)\n\n# 题解\n一开始直接DFS暴力出来0~9的不同排列，判断是否满足条件，TL了。看了刘汝佳老师的解法，只枚举$fghij$，然后算出$abcde$，再判断是否所有数字都不相同。而且当$abcde$ 和 $fghij$加起来超过10位时可以终止枚举。复杂度大大降低。\n\n# 代码-循环枚举\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 17 Dec 07:05:55 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nchar buff[100];\nbool flag;\nstruct Node{\n    Node(int a, int b):a(a), b(b){}\n    int a, b;\n};\nvector<Node> vec;\nint cnt = 0;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        if(n == 0) break;\n        if(cnt++) cout << endl;\n        vec.clear();\n        for(int a = 1234; ; a++){\n            int b = n * a;\n            //cout << a << \" \" << b << endl;\n            sprintf(buff, \"%05d%05d\", a, b);\n            if(strlen(buff) > 10) break;\n            sort(buff, buff + 10);\n            flag = false;\n            for(int i = 0; i < 10; i++){\n                if(buff[i] != '0' + i){\n                    flag = true;\n                    break;\n                }\n            }\n            if(!flag) vec.push_back(Node(a, b));\n        }\n\n        int len = vec.size();\n        if(len == 0) cout << \"There are no solutions for \" << n << \".\" << endl;\n        else{\n            for(auto x : vec){\n                cout << setfill('0') << setw(5) << x.b;\n                cout << \" / \";\n                cout << setfill('0') << setw(5) << x.a;\n                cout << \" = \";\n                cout << n << endl;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n# 代码-DFS枚举\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 16 Dec 17:39:29 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nbool vis[10];\nbool test[10];\nvector<int> vec;\nint a, b;\nstruct Node{\n    Node(int u, int v):u(u), v(v){}\n    int u, v;\n};\nvector<Node> ans;\nbool flag;\n\nbool ok(){\n    a = 0;\n    for(int i = 0; i < 5; i++){\n        a *= 10;\n        a += vec[i];\n    }\n    b = a * n;\n    vector<int> tmp;\n    int b2 = b;\n    for(int i = 0; i < 5; i++){\n        tmp.push_back(vec[i]);\n        tmp.push_back(b2 % 10);\n        b2 /= 10;\n    }\n    if(b2){\n        flag = true;\n        return false;\n    }\n\n    memset(test, 0, sizeof(test));\n    int cnt = 0;\n    for(int i = 0; i < 10; i++){\n        int val = tmp[i];\n        if(!test[val]){\n            cnt++;\n            test[val] = 1;\n        }\n    }\n    if(cnt == 10) return true;\n    else return false;\n\n}\n\nvoid dfs(){\n    if(flag) return; // over 10 bits, no need to enumerate\n    if(vec.size() == 5){\n        if(ok()){\n            ans.push_back(Node(b, a));\n        }\n        return;\n    }\n    for(int i = 0; i <= 9; i++){\n        if(!vis[i]){\n            vec.push_back(i);\n            vis[i] = 1;\n            dfs();\n            vec.pop_back();\n            vis[i] = 0;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 0;\n    while(cin >> n){\n        if(n == 0) break;\n\n        cnt++;\n        if(cnt > 1) cout << endl;\n        \n        memset(vis, 0, sizeof(vis));\n        ans.clear();\n        vec.clear();\n        flag = false;\n\n        dfs();\n        if(ans.size() == 0){\n            cout << \"There are no solutions for \" << n << \".\" << endl;\n        }\n        else{\n            for(auto x : ans){\n                cout << right << setfill('0') << setw(5) << x.u << \" / \";\n                cout << right << setfill('0') << setw(5) << x.v << \" = \" << n << endl;\n            }\n        }\n    }\n    return 0;\n}\n```","source":"_posts/Uva725-Division.md","raw":"---\ntitle: Uva725-Division-暴力枚举\ndate: 2018-12-17 19:41:14\ncategories:\n- ACM\n- 暴力枚举\ntags:\n- 暴力枚举\n---\n求满足$$\\frac{abcde}{fghij} = N$$的所有$abcde$ 和 $fghij$的值，其中$2 <= N <= 79。$\n刘汝佳老师：``即使采用暴力法求解问题，对问题进行一定的分析往往会让算法更简介、高效。``\n受益匪浅。\n<!--more-->\n# 链接\n[Uva725-Division](https://vjudge.net/problem/UVA-725)\n\n# 题解\n一开始直接DFS暴力出来0~9的不同排列，判断是否满足条件，TL了。看了刘汝佳老师的解法，只枚举$fghij$，然后算出$abcde$，再判断是否所有数字都不相同。而且当$abcde$ 和 $fghij$加起来超过10位时可以终止枚举。复杂度大大降低。\n\n# 代码-循环枚举\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 17 Dec 07:05:55 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nchar buff[100];\nbool flag;\nstruct Node{\n    Node(int a, int b):a(a), b(b){}\n    int a, b;\n};\nvector<Node> vec;\nint cnt = 0;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        if(n == 0) break;\n        if(cnt++) cout << endl;\n        vec.clear();\n        for(int a = 1234; ; a++){\n            int b = n * a;\n            //cout << a << \" \" << b << endl;\n            sprintf(buff, \"%05d%05d\", a, b);\n            if(strlen(buff) > 10) break;\n            sort(buff, buff + 10);\n            flag = false;\n            for(int i = 0; i < 10; i++){\n                if(buff[i] != '0' + i){\n                    flag = true;\n                    break;\n                }\n            }\n            if(!flag) vec.push_back(Node(a, b));\n        }\n\n        int len = vec.size();\n        if(len == 0) cout << \"There are no solutions for \" << n << \".\" << endl;\n        else{\n            for(auto x : vec){\n                cout << setfill('0') << setw(5) << x.b;\n                cout << \" / \";\n                cout << setfill('0') << setw(5) << x.a;\n                cout << \" = \";\n                cout << n << endl;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n# 代码-DFS枚举\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 16 Dec 17:39:29 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nbool vis[10];\nbool test[10];\nvector<int> vec;\nint a, b;\nstruct Node{\n    Node(int u, int v):u(u), v(v){}\n    int u, v;\n};\nvector<Node> ans;\nbool flag;\n\nbool ok(){\n    a = 0;\n    for(int i = 0; i < 5; i++){\n        a *= 10;\n        a += vec[i];\n    }\n    b = a * n;\n    vector<int> tmp;\n    int b2 = b;\n    for(int i = 0; i < 5; i++){\n        tmp.push_back(vec[i]);\n        tmp.push_back(b2 % 10);\n        b2 /= 10;\n    }\n    if(b2){\n        flag = true;\n        return false;\n    }\n\n    memset(test, 0, sizeof(test));\n    int cnt = 0;\n    for(int i = 0; i < 10; i++){\n        int val = tmp[i];\n        if(!test[val]){\n            cnt++;\n            test[val] = 1;\n        }\n    }\n    if(cnt == 10) return true;\n    else return false;\n\n}\n\nvoid dfs(){\n    if(flag) return; // over 10 bits, no need to enumerate\n    if(vec.size() == 5){\n        if(ok()){\n            ans.push_back(Node(b, a));\n        }\n        return;\n    }\n    for(int i = 0; i <= 9; i++){\n        if(!vis[i]){\n            vec.push_back(i);\n            vis[i] = 1;\n            dfs();\n            vec.pop_back();\n            vis[i] = 0;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 0;\n    while(cin >> n){\n        if(n == 0) break;\n\n        cnt++;\n        if(cnt > 1) cout << endl;\n        \n        memset(vis, 0, sizeof(vis));\n        ans.clear();\n        vec.clear();\n        flag = false;\n\n        dfs();\n        if(ans.size() == 0){\n            cout << \"There are no solutions for \" << n << \".\" << endl;\n        }\n        else{\n            for(auto x : ans){\n                cout << right << setfill('0') << setw(5) << x.u << \" / \";\n                cout << right << setfill('0') << setw(5) << x.v << \" = \" << n << endl;\n            }\n        }\n    }\n    return 0;\n}\n```","slug":"Uva725-Division","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlw001mh8vnhpnbkdq1","comments":1,"layout":"post","photos":[],"link":""},{"title":"Build Binary Tree","date":"2019-03-04T01:39:27.000Z","_content":"众所周知，leetcode上不需要自己写读入数据部分的代码。但是这样对于二叉树类型的题目，调试起来就会有点麻烦，因为需要自己现场建一颗树。不太熟悉也不太习惯用leetcode自带的调试功能，所以为了偷懒，我提前写好了一份建二叉树的模板。然后就可以方便的用sublime或者gedit调试了(σ･ω･)σYO♪\n<!--more-->\n# 使用方法\n## 输入\n![BinaryTree](/BinaryTree.png)\n在源文件路径下的``in.txt``文件中写入这颗二叉树的**先序遍历序列**。和传统意义上的先序遍历序列不同的是，用-1来代表空子树。\n譬如上图所示的二叉树的输入方式是：\n```\n1 2 -1 5 -1 -1 3\n```\n## 函数返回\n函数返回的是指向建立好的二叉树的根节点的指针。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon  4 Mar 11:06:42 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct TreeNode{\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x):val(x), left(NULL), right(NULL){}\n};\nint x;\n\nTreeNode* buildTree(){\n    if(cin >> x){\n        if(x == -1) return NULL;\n        TreeNode* node = new TreeNode(0);\n        node->val = x;\n        node->left = buildTree();\n        node->right = buildTree();\n        return node;\n    }\n    else return NULL;\n}\n\nint main(){\n    freopen(\"in.txt\", \"r\", stdin);\n\n    TreeNode* root = buildTree();\n\n    return 0;\n}\n```","source":"_posts/buildBinaryTree.md","raw":"---\ntitle: Build Binary Tree\ndate: 2019-03-04 09:39:27\ncategories:\n- Template\ntags:\n- Binary Tree\n---\n众所周知，leetcode上不需要自己写读入数据部分的代码。但是这样对于二叉树类型的题目，调试起来就会有点麻烦，因为需要自己现场建一颗树。不太熟悉也不太习惯用leetcode自带的调试功能，所以为了偷懒，我提前写好了一份建二叉树的模板。然后就可以方便的用sublime或者gedit调试了(σ･ω･)σYO♪\n<!--more-->\n# 使用方法\n## 输入\n![BinaryTree](/BinaryTree.png)\n在源文件路径下的``in.txt``文件中写入这颗二叉树的**先序遍历序列**。和传统意义上的先序遍历序列不同的是，用-1来代表空子树。\n譬如上图所示的二叉树的输入方式是：\n```\n1 2 -1 5 -1 -1 3\n```\n## 函数返回\n函数返回的是指向建立好的二叉树的根节点的指针。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon  4 Mar 11:06:42 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct TreeNode{\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x):val(x), left(NULL), right(NULL){}\n};\nint x;\n\nTreeNode* buildTree(){\n    if(cin >> x){\n        if(x == -1) return NULL;\n        TreeNode* node = new TreeNode(0);\n        node->val = x;\n        node->left = buildTree();\n        node->right = buildTree();\n        return node;\n    }\n    else return NULL;\n}\n\nint main(){\n    freopen(\"in.txt\", \"r\", stdin);\n\n    TreeNode* root = buildTree();\n\n    return 0;\n}\n```","slug":"buildBinaryTree","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlw001nh8vn780e30nv","comments":1,"layout":"post","photos":[],"link":""},{"title":"hexo中mathjax使用坑点","date":"2018-04-09T07:29:50.000Z","_content":"刚刚开始自己的博客之旅，开始真是无比艰难啊，各种被坑。过程中博客需要插入数学公式，下载了mathjax插件(安装之后就可以使用Latex定义的宏写数学公式了)，结果被坑惨(也不算是mathjax的锅，markdown自己也要背)，卡了2个小时，气愤(╯‵□′)╯︵┻━┻\n这里记录一下在mathjax里踩到的坑。\nmathjax的安装配置和使用大家可以参照[Steven's space的博文](http://stevenshi.me/2017/06/26/hexo-insert-formula/)，不再赘述了。\n<!-- more -->\n# 坑点\nmarkdown本身的特殊符号和Latex中的符号会出现冲突。\n- 下划线\\_在markdown中是斜体，但是Latex中下划线是下标的意思，所以这里会冲突。\n- 双斜线\\\\\\\\在markdown中会被转义为\\，所以Latex的\\\\\\\\换行功能也会不正常。\n- 乘法符号\\*在markdown中是粗体＝＝(就是在这被卡了)，所以Latex在写两个数相乘时不能直接写\n```\n$a*b$\n```\n以上情况都会导致无法在mathjax中渲染出来。\n\n# 解决方法\n手动转义：\n比如需要在公式中写乘法*可以写成\n```\n$a\\*b$\n```\n下标写成\n```\n$a\\_1$\n```\n换行写成\n```\n$\\\\\\\\$\n```\n解决，散花。\n\n更多解决方法可以参考[hexo下mathjax的转义问题](http://shomy.top/2016/10/22/hexo-markdown-mathjax/)\n","source":"_posts/hexo-mathjax.md","raw":"---\ntitle: hexo中mathjax使用坑点\ndate: 2018-04-09 15:29:50\ncategories:\n- Messy article\ntags:\n- mathjax\n- hexo插入数学公式\n- 总结\n---\n刚刚开始自己的博客之旅，开始真是无比艰难啊，各种被坑。过程中博客需要插入数学公式，下载了mathjax插件(安装之后就可以使用Latex定义的宏写数学公式了)，结果被坑惨(也不算是mathjax的锅，markdown自己也要背)，卡了2个小时，气愤(╯‵□′)╯︵┻━┻\n这里记录一下在mathjax里踩到的坑。\nmathjax的安装配置和使用大家可以参照[Steven's space的博文](http://stevenshi.me/2017/06/26/hexo-insert-formula/)，不再赘述了。\n<!-- more -->\n# 坑点\nmarkdown本身的特殊符号和Latex中的符号会出现冲突。\n- 下划线\\_在markdown中是斜体，但是Latex中下划线是下标的意思，所以这里会冲突。\n- 双斜线\\\\\\\\在markdown中会被转义为\\，所以Latex的\\\\\\\\换行功能也会不正常。\n- 乘法符号\\*在markdown中是粗体＝＝(就是在这被卡了)，所以Latex在写两个数相乘时不能直接写\n```\n$a*b$\n```\n以上情况都会导致无法在mathjax中渲染出来。\n\n# 解决方法\n手动转义：\n比如需要在公式中写乘法*可以写成\n```\n$a\\*b$\n```\n下标写成\n```\n$a\\_1$\n```\n换行写成\n```\n$\\\\\\\\$\n```\n解决，散花。\n\n更多解决方法可以参考[hexo下mathjax的转义问题](http://shomy.top/2016/10/22/hexo-markdown-mathjax/)\n","slug":"hexo-mathjax","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlw001oh8vn1ahhv3rh","comments":1,"layout":"post","photos":[],"link":""},{"title":"新起点","date":"2018-04-08T15:12:00.000Z","_content":"　　搭一个自己的独立博客的想法记得从去年暑假就有了，可是当时还是小菜鸡蛋，什么都不懂＝＝，现在孵成了小菜鸡，才终于磨磨蹭蹭的搭了起来，内心还是十分激动的(〃∇〃)，其间走了很多弯路，陷进了很多坑，感谢[CrazyMilk的这篇博文](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)以及[陶司机](http://logqtainia.github.io/)的指导，感谢女票的支持，也感谢自己没有就此放弃ヽ(•̀ω•́ )ゝ。\n<!-- more -->\n\n# 为什么要搭建独立博客\n　　最近3个月左右，一直在跟着校内的ACM队进行训练，最初是想提高自己的编程能力，后来发现自己无论对这个团队还是对这项竞赛都有一种由衷的向往，虽然最后因为个人能力以及年级太高(大三下)等方面因素没能成为正式队员，但还是想至少沿这个方向走下去。从接触ACM开始后就发现，优秀的人实在太多太多，自己会的实在太少太少，都不敢以菜鸡自称，简直是菜鸡蛋2333\n　　所以想在这里记录自己的成长，努力成为一个优秀的人。我也十分赞同CrazyMilk博主提到的Litten（Yilia主题的制作者）说的那句话：有了一个独立博客，就有了属于自己的一片田，开始默默耕作。\n　　等到自己不再是小菜鸡的那一天再回头来看那个曾经的小菜鸡的成长历程，应该会别有一番滋味吧，哈哈，期待。\n\n　　Hello, Aincrad.\n\n　　要去耕作了(ง •̀_•́)ง，告辞。\n\n*Ps:博客框架采用hexo,及其经典的next主题。*\n","source":"_posts/new start point.md","raw":"---\ntitle: 新起点\ndate : 2018-04-08 23:12:00\ncategories:\n- Diary\ntags:\n- 生活\n- 总结\n---\n　　搭一个自己的独立博客的想法记得从去年暑假就有了，可是当时还是小菜鸡蛋，什么都不懂＝＝，现在孵成了小菜鸡，才终于磨磨蹭蹭的搭了起来，内心还是十分激动的(〃∇〃)，其间走了很多弯路，陷进了很多坑，感谢[CrazyMilk的这篇博文](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)以及[陶司机](http://logqtainia.github.io/)的指导，感谢女票的支持，也感谢自己没有就此放弃ヽ(•̀ω•́ )ゝ。\n<!-- more -->\n\n# 为什么要搭建独立博客\n　　最近3个月左右，一直在跟着校内的ACM队进行训练，最初是想提高自己的编程能力，后来发现自己无论对这个团队还是对这项竞赛都有一种由衷的向往，虽然最后因为个人能力以及年级太高(大三下)等方面因素没能成为正式队员，但还是想至少沿这个方向走下去。从接触ACM开始后就发现，优秀的人实在太多太多，自己会的实在太少太少，都不敢以菜鸡自称，简直是菜鸡蛋2333\n　　所以想在这里记录自己的成长，努力成为一个优秀的人。我也十分赞同CrazyMilk博主提到的Litten（Yilia主题的制作者）说的那句话：有了一个独立博客，就有了属于自己的一片田，开始默默耕作。\n　　等到自己不再是小菜鸡的那一天再回头来看那个曾经的小菜鸡的成长历程，应该会别有一番滋味吧，哈哈，期待。\n\n　　Hello, Aincrad.\n\n　　要去耕作了(ง •̀_•́)ง，告辞。\n\n*Ps:博客框架采用hexo,及其经典的next主题。*\n","slug":"new start point","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlx001ph8vnq4ox7lng","comments":1,"layout":"post","photos":[],"link":""},{"title":"pick numbers-DFS","date":"2018-08-11T09:23:02.000Z","_content":"从$n$个整数中任选$k$个整数相加，求得到的一系列和中为素数的共有多少种．\n<!-- more -->\n# 链接\n[NOIP2002](http://acmoj.shu.edu.cn/problem/264/)\n# 题目\n已知$n$个整数$x1, x2,...,xn$，以及一个整数$k$．从$n$个整数中任选$k$个整数相加，可分别得到一系列的和．例如当$n = 4, k = 3$, $4$个整数分别为$3, 7, 12, 19$时，可得到全部的组合与它们的和为：\n$3 + 7 + 12 = 22$\n$3 + 7 + 19 = 29$\n$7 + 12 + 19 = 38$\n$3 + 12 + 19 = 34$\n现在，要求你计算和为素数共有多少种．\n# 思路\nDFS对每一种情况遍历．\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 11 Aug 16:32:41 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n, k;\nint d[maxn];\nint ans = 0;\nint sum = 0;\n\nbool is_prime(){\n    if(sum < 2)\n        return false;\n    int tmp = sqrt(sum);\n    for(int i = 2; i <= tmp; i++){\n        if(!(sum % i)) \n            return false;\n    }\n    return true;\n}\n\nvoid dfs(int now, int dep){\n    if(dep == k){\n        if(is_prime())\n            ans++;\n        return;\n    }\n    if(now == n){\n        return;\n    }\n    for(int i = now; i < n; i++){\n        sum += d[i];\n        dfs(i + 1, dep + 1);\n        sum -= d[i];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(cin >> n >> k){\n        ans = 0;\n        sum = 0;\n        //cout << n << \" \" << k << endl;\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/pick-numbers.md","raw":"---\ntitle: pick numbers-DFS\ndate: 2018-08-11 17:23:02\ncategories:\n- ACM\n- DFS\ntags:\n- DFS\n---\n从$n$个整数中任选$k$个整数相加，求得到的一系列和中为素数的共有多少种．\n<!-- more -->\n# 链接\n[NOIP2002](http://acmoj.shu.edu.cn/problem/264/)\n# 题目\n已知$n$个整数$x1, x2,...,xn$，以及一个整数$k$．从$n$个整数中任选$k$个整数相加，可分别得到一系列的和．例如当$n = 4, k = 3$, $4$个整数分别为$3, 7, 12, 19$时，可得到全部的组合与它们的和为：\n$3 + 7 + 12 = 22$\n$3 + 7 + 19 = 29$\n$7 + 12 + 19 = 38$\n$3 + 12 + 19 = 34$\n现在，要求你计算和为素数共有多少种．\n# 思路\nDFS对每一种情况遍历．\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 11 Aug 16:32:41 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n, k;\nint d[maxn];\nint ans = 0;\nint sum = 0;\n\nbool is_prime(){\n    if(sum < 2)\n        return false;\n    int tmp = sqrt(sum);\n    for(int i = 2; i <= tmp; i++){\n        if(!(sum % i)) \n            return false;\n    }\n    return true;\n}\n\nvoid dfs(int now, int dep){\n    if(dep == k){\n        if(is_prime())\n            ans++;\n        return;\n    }\n    if(now == n){\n        return;\n    }\n    for(int i = now; i < n; i++){\n        sum += d[i];\n        dfs(i + 1, dep + 1);\n        sum -= d[i];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(cin >> n >> k){\n        ans = 0;\n        sum = 0;\n        //cout << n << \" \" << k << endl;\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n```\n","slug":"pick-numbers","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlx001qh8vnvxjruxxw","comments":1,"layout":"post","photos":[],"link":""},{"title":"extern-外部变量","date":"2018-12-02T22:56:26.000Z","_content":"　　前两天被同学问起extern的用法，才发现自己对extern的用法也不清晰，囧，整理一下。\n<!--more-->\n# 参考链接\n[when to use extern in C++](https://stackoverflow.com/questions/10422034/when-to-use-extern-in-c)\n\n# extern\n　　extern用于多文件编程时，不同源文件之间共享变量。我们在头文件中声明外部变量，这样所有包含该头文件的的源文件就都有了这个外部变量的**声明**，而我们只需要在**其中一个**源文件中**定义**一次。\n　　``extern int x``告诉编译器有一个叫``x``的``int``型变量在某个地方，正如之前[C语言编译连接过程](https://ain-crad.github.io/2018/12/02/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A-h%E5%92%8C-c%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/)里说的那样，此时编译器并不关心``x``的具体实现，即不关心``x``定义在哪个源文件中。编译器只需要知道这个变量的类型和名字，就知道了该如何使用它。编译完成生成之后，链接器会将所有**引用**``x``的地方定向到**定义**它的某一个源文件中。\n　　为了使上述过程顺利进行，``x``必须要在某个源文件中被定义为**全局变量**，并且不能包含``static``关键字。\n\n# 例子\nprint.h\n```C\n#ifndef _PRINT_H\n#define _PRINT_H\n\nextern int global_x;    //任何包含这个头文件的源文件都将可以使用global_x变量\nvoid print_global_x();\n\n#endif\n\n```\n\nprint.c\n```C\n#include <stdio.h>\n#include \"print.h\"\n\nint global_x;   //global_x的具体定义的位置\n\nvoid print_global_x(){\n    printf(\"%d\\n\", global_x);\n}\n```\n\nmain.c\n```C\n#include \"print.h\"  //头文件中包含global_x的声明\n\nint main(){\n    global_x = 5;\n    print_global_x();\n\n    return 0;\n}\n```","source":"_posts/extern-外部变量.md","raw":"---\ntitle: extern-外部变量\ndate: 2018-12-03 06:56:26\ncategories:\n- C++\ntags:\n- C语言\n---\n　　前两天被同学问起extern的用法，才发现自己对extern的用法也不清晰，囧，整理一下。\n<!--more-->\n# 参考链接\n[when to use extern in C++](https://stackoverflow.com/questions/10422034/when-to-use-extern-in-c)\n\n# extern\n　　extern用于多文件编程时，不同源文件之间共享变量。我们在头文件中声明外部变量，这样所有包含该头文件的的源文件就都有了这个外部变量的**声明**，而我们只需要在**其中一个**源文件中**定义**一次。\n　　``extern int x``告诉编译器有一个叫``x``的``int``型变量在某个地方，正如之前[C语言编译连接过程](https://ain-crad.github.io/2018/12/02/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A-h%E5%92%8C-c%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/)里说的那样，此时编译器并不关心``x``的具体实现，即不关心``x``定义在哪个源文件中。编译器只需要知道这个变量的类型和名字，就知道了该如何使用它。编译完成生成之后，链接器会将所有**引用**``x``的地方定向到**定义**它的某一个源文件中。\n　　为了使上述过程顺利进行，``x``必须要在某个源文件中被定义为**全局变量**，并且不能包含``static``关键字。\n\n# 例子\nprint.h\n```C\n#ifndef _PRINT_H\n#define _PRINT_H\n\nextern int global_x;    //任何包含这个头文件的源文件都将可以使用global_x变量\nvoid print_global_x();\n\n#endif\n\n```\n\nprint.c\n```C\n#include <stdio.h>\n#include \"print.h\"\n\nint global_x;   //global_x的具体定义的位置\n\nvoid print_global_x(){\n    printf(\"%d\\n\", global_x);\n}\n```\n\nmain.c\n```C\n#include \"print.h\"  //头文件中包含global_x的声明\n\nint main(){\n    global_x = 5;\n    print_global_x();\n\n    return 0;\n}\n```","slug":"extern-外部变量","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nly001rh8vnvsvtk9tb","comments":1,"layout":"post","photos":[],"link":""},{"title":"next_permutation解析","date":"2018-12-18T02:34:22.000Z","_content":"next_permutation是C++的STL中提供的一个库函数，声明在algorithm头文件中，用来求下一个排列。好奇内部是怎么实现的，在Stack Overflow上看到了精彩的回答。\n<!--more-->\n# 链接\n参考链接[std::next_permutation Implementation Explanation](https://stackoverflow.com/questions/11483060/stdnext-permutation-implementation-explanation)\n\n# 内部实现\n```C++\n\ntemplate<typename It>\nbool next_permutation(It begin, It end)\n{\n    if (begin == end)\n        return false;\n\n    It i = begin;\n    ++i;\n    if (i == end)\n        return false;\n\n    i = end;\n    --i;\n\n    while (true)\n    {\n        It j = i;\n        --i;\n\n        if (*i < *j)\n        {\n            It k = end;\n\n             while (!(*i < *--k))\n                /* pass */;\n\n            iter_swap(i, k);\n            reverse(j, end);\n            return true;\n        }\n\n        if (i == begin)\n        {\n            reverse(begin, end);\n            return false;\n        }\n    }\n}\n\n```\n\n# 解析\n```\n1 2 3 4\n1 2 4 3\n1 3 2 4\n1 3 4 2\n1 4 3 2 \n2 1 3 4\n...\n```\n要得到一个排列的下一个排列，**我们可以把排列中的每一个元素看做数字中的某一位，整个排列看做一个具体的数**。这样求下一个排列的问题就变成了求比当前数字的大的那些数字中最小的那个数（即上确界）。例如排列组成的所有可能的数中，比1234大的数中最小的那个就是1243。\n在上面的例子里我们看到前几个排列都是1作为排列的首部，当1作为首部的情况被改变的时候是1后面的三个数字降序排列的时候。\n所以算法设计的关键是**从后向前找到第一个打破降序的数字，将它和它右边降序排列中它的上确界调换位置，之后再将原本的降序序列部分反转**。之所以反转是因为调换位置后已经是一个新的排列，而反转后的升序序列是原本降序序列的最小状态。\n\n核心代码：\n```\nwhile (true)\n    {\n        It j = i;\n        --i;\n\n        //找到最先打破降序的元素\n        if (*i < *j)\n        {\n            It k = end;\n\n            //找到这个元素在它右边降序序列的上确界\n             while (!(*i < *--k))\n                /* pass */;\n\n            iter_swap(i, k);//交换元素\n            reverse(j, end);//降序序列部分反转\n            return true;\n        }\n\n        //表示整个序列已经是降序序列\n        if (i == begin)\n        {\n            reverse(begin, end);\n            return false;\n        }\n    }\n```\n\n","source":"_posts/next-permutation解析.md","raw":"---\ntitle: next_permutation解析\ndate: 2018-12-18 10:34:22\ncategories:\n- C++\ntags:\n- 排列\n---\nnext_permutation是C++的STL中提供的一个库函数，声明在algorithm头文件中，用来求下一个排列。好奇内部是怎么实现的，在Stack Overflow上看到了精彩的回答。\n<!--more-->\n# 链接\n参考链接[std::next_permutation Implementation Explanation](https://stackoverflow.com/questions/11483060/stdnext-permutation-implementation-explanation)\n\n# 内部实现\n```C++\n\ntemplate<typename It>\nbool next_permutation(It begin, It end)\n{\n    if (begin == end)\n        return false;\n\n    It i = begin;\n    ++i;\n    if (i == end)\n        return false;\n\n    i = end;\n    --i;\n\n    while (true)\n    {\n        It j = i;\n        --i;\n\n        if (*i < *j)\n        {\n            It k = end;\n\n             while (!(*i < *--k))\n                /* pass */;\n\n            iter_swap(i, k);\n            reverse(j, end);\n            return true;\n        }\n\n        if (i == begin)\n        {\n            reverse(begin, end);\n            return false;\n        }\n    }\n}\n\n```\n\n# 解析\n```\n1 2 3 4\n1 2 4 3\n1 3 2 4\n1 3 4 2\n1 4 3 2 \n2 1 3 4\n...\n```\n要得到一个排列的下一个排列，**我们可以把排列中的每一个元素看做数字中的某一位，整个排列看做一个具体的数**。这样求下一个排列的问题就变成了求比当前数字的大的那些数字中最小的那个数（即上确界）。例如排列组成的所有可能的数中，比1234大的数中最小的那个就是1243。\n在上面的例子里我们看到前几个排列都是1作为排列的首部，当1作为首部的情况被改变的时候是1后面的三个数字降序排列的时候。\n所以算法设计的关键是**从后向前找到第一个打破降序的数字，将它和它右边降序排列中它的上确界调换位置，之后再将原本的降序序列部分反转**。之所以反转是因为调换位置后已经是一个新的排列，而反转后的升序序列是原本降序序列的最小状态。\n\n核心代码：\n```\nwhile (true)\n    {\n        It j = i;\n        --i;\n\n        //找到最先打破降序的元素\n        if (*i < *j)\n        {\n            It k = end;\n\n            //找到这个元素在它右边降序序列的上确界\n             while (!(*i < *--k))\n                /* pass */;\n\n            iter_swap(i, k);//交换元素\n            reverse(j, end);//降序序列部分反转\n            return true;\n        }\n\n        //表示整个序列已经是降序序列\n        if (i == begin)\n        {\n            reverse(begin, end);\n            return false;\n        }\n    }\n```\n\n","slug":"next-permutation解析","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nly001sh8vn1yrurqu8","comments":1,"layout":"post","photos":[],"link":""},{"title":"new keyword","date":"2018-09-20T05:21:31.000Z","_content":"使用$new$关键字和不使用$new$关键字创建对象的异同及优劣对比。\n<!--more-->\n\n# 参考链接\n[When should I use the new keyword in C++](https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c)\n\n顺便安利一波[Stack Overflow](https://stackoverflow.com/) |･ω･｀)\n# 使用new关键字\n```C++\nMyClass* myClass = new Myclass();\nmyClass->MyField = \"Hello World!\";\n```\n\n特点：\n1. 为创建的对象在自由存储区分配内存。\n2. 之后需要使用$delete$手动释放分配的内存（否则会造成内存泄露）。\n3. 在使用$delete$之前被分配的内存空间持续存在（意味着用$new$关键字创建的对象可以作为指针被函数返回）。\n\n# 不使用new关键字\n```C++\nMyClass myClass;\nmyClass.MyField = \"Hello World!\";\n```\n\n特点：\n1. 为创建的对象在堆栈段分配内存。\n2. 不需要使用$delete$来手动释放。\n3. 调用结束时内存空间被清除（意味着用这种方式创建的对象不能作为指针来被函数返回）。\n\n# 拓展\n可执行文件由正文段、数据段、和$BSS$段组成。\n- 正文段（$Text Segment$）:用于储存指令。\n- 数据段（$Data Segment$）:用于储存已初始化的全局变量。\n- $BSS$段（$BSS Segment$）:用于储存未赋值的全局变量所需的空间。\n\n调用栈不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为**堆栈段**（$Stack Segment$）。\n调用栈：调用栈描述的是函数之间的调用关系。它由多个栈帧（$Stack Frame$）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的**返回地址**和**局部变量**，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证不同函数间的局部变量互不相干－－因为不同函数对应着不同的栈帧。\n堆栈段的空间相对于自由空间十分有限（具体大小和操作系统相关，大概几十$M$）。所以建议把较大的数组放在$main$函数外，因为局部变量也是放在堆栈段的。栈溢出（$Segmentation fault$）不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。\n# 总结\n如果不想时刻担心要调用$delete$释放内存，那么就不要使用$new$关键字。\n如果需要在一个函数中返回对象的指针，那么就一定要使用$new$关键字（局部变量的方式会在函数调用结束时清除分配的空间）。","source":"_posts/new-keyword.md","raw":"---\ntitle: new keyword\ndate: 2018-09-20 13:21:31\ncategories:\n- C++\ntags:\n- C++\n---\n使用$new$关键字和不使用$new$关键字创建对象的异同及优劣对比。\n<!--more-->\n\n# 参考链接\n[When should I use the new keyword in C++](https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c)\n\n顺便安利一波[Stack Overflow](https://stackoverflow.com/) |･ω･｀)\n# 使用new关键字\n```C++\nMyClass* myClass = new Myclass();\nmyClass->MyField = \"Hello World!\";\n```\n\n特点：\n1. 为创建的对象在自由存储区分配内存。\n2. 之后需要使用$delete$手动释放分配的内存（否则会造成内存泄露）。\n3. 在使用$delete$之前被分配的内存空间持续存在（意味着用$new$关键字创建的对象可以作为指针被函数返回）。\n\n# 不使用new关键字\n```C++\nMyClass myClass;\nmyClass.MyField = \"Hello World!\";\n```\n\n特点：\n1. 为创建的对象在堆栈段分配内存。\n2. 不需要使用$delete$来手动释放。\n3. 调用结束时内存空间被清除（意味着用这种方式创建的对象不能作为指针来被函数返回）。\n\n# 拓展\n可执行文件由正文段、数据段、和$BSS$段组成。\n- 正文段（$Text Segment$）:用于储存指令。\n- 数据段（$Data Segment$）:用于储存已初始化的全局变量。\n- $BSS$段（$BSS Segment$）:用于储存未赋值的全局变量所需的空间。\n\n调用栈不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为**堆栈段**（$Stack Segment$）。\n调用栈：调用栈描述的是函数之间的调用关系。它由多个栈帧（$Stack Frame$）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的**返回地址**和**局部变量**，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证不同函数间的局部变量互不相干－－因为不同函数对应着不同的栈帧。\n堆栈段的空间相对于自由空间十分有限（具体大小和操作系统相关，大概几十$M$）。所以建议把较大的数组放在$main$函数外，因为局部变量也是放在堆栈段的。栈溢出（$Segmentation fault$）不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。\n# 总结\n如果不想时刻担心要调用$delete$释放内存，那么就不要使用$new$关键字。\n如果需要在一个函数中返回对象的指针，那么就一定要使用$new$关键字（局部变量的方式会在函数调用结束时清除分配的空间）。","slug":"new-keyword","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlz001th8vn8wnkje12","comments":1,"layout":"post","photos":[],"link":""},{"title":"矩阵快速幂","date":"2018-05-14T01:41:44.000Z","_content":"最近在做一道DP的题时发现数据范围竟然是1e18，这样的话只能用log(n)复杂度的算法来实现了，于是从队长那里了解到了矩阵快速幂。在这里记录一下快速幂以及其它矩阵处理的模板。\n矩阵快速幂模板参考自[eecrazy](https://github.com/eecrazy/ACM/blob/master/%E6%95%B0%E8%AE%BA/poj3233%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.cpp)\n<!-- more -->\n\n# 常数快速幂\n```C++\ntypedef long long ll;\nll mod_pow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res *= x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n```\n# 矩阵快速幂\n``` C++\nstruct Ma\n{\n    int m[maxn][maxn];\n};\n\nMa a,per;\nint n, mod;\n\nvoid init()//矩阵初始化\n{\n    int i,j;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n        {\n            scanf(\"%d\", &a.m[i][j]);\n            a.m[i][j] %= mod;\n            per.m[i][j] = (i == j);\n        }\n}\n\nMa add(Ma a,Ma b)//矩阵加法\n{\n    Ma c;\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n        {\n            c.m[i][j] = (a.m[i][j] + b.m[i][j]) % mod;\n        }\n    }\n    return c;\n}\n\n\nMa multi(Ma a,Ma b)//矩阵乘法\n{\n    Ma c;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n        {\n            c.m[i][j] = 0;\n            for(int k = 0; k < n; k++)\n            {\n                c.m[i][j] += a.m[i][k] * b.m[k][j];\n            }\n            c.m[i][j] %= mod;\n        }\n    return c;\n}\n\nMa quick_pow(long long x)//矩阵快速幂\n{\n    Ma res = per;\n    Ma p = a;\n    while(x)\n    {\n        if(x&1) res = multi(res,p);\n        p = multi(p,p);\n        x >>= 1;\n    }\n    return res;\n}\n```","source":"_posts/quick-matrix.md","raw":"---\ntitle: 矩阵快速幂\ndate: 2018-05-14 09:41:44\ncategories:\n- ACM\ntags:\n- math\n---\n最近在做一道DP的题时发现数据范围竟然是1e18，这样的话只能用log(n)复杂度的算法来实现了，于是从队长那里了解到了矩阵快速幂。在这里记录一下快速幂以及其它矩阵处理的模板。\n矩阵快速幂模板参考自[eecrazy](https://github.com/eecrazy/ACM/blob/master/%E6%95%B0%E8%AE%BA/poj3233%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.cpp)\n<!-- more -->\n\n# 常数快速幂\n```C++\ntypedef long long ll;\nll mod_pow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res *= x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n```\n# 矩阵快速幂\n``` C++\nstruct Ma\n{\n    int m[maxn][maxn];\n};\n\nMa a,per;\nint n, mod;\n\nvoid init()//矩阵初始化\n{\n    int i,j;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n        {\n            scanf(\"%d\", &a.m[i][j]);\n            a.m[i][j] %= mod;\n            per.m[i][j] = (i == j);\n        }\n}\n\nMa add(Ma a,Ma b)//矩阵加法\n{\n    Ma c;\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n        {\n            c.m[i][j] = (a.m[i][j] + b.m[i][j]) % mod;\n        }\n    }\n    return c;\n}\n\n\nMa multi(Ma a,Ma b)//矩阵乘法\n{\n    Ma c;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n        {\n            c.m[i][j] = 0;\n            for(int k = 0; k < n; k++)\n            {\n                c.m[i][j] += a.m[i][k] * b.m[k][j];\n            }\n            c.m[i][j] %= mod;\n        }\n    return c;\n}\n\nMa quick_pow(long long x)//矩阵快速幂\n{\n    Ma res = per;\n    Ma p = a;\n    while(x)\n    {\n        if(x&1) res = multi(res,p);\n        p = multi(p,p);\n        x >>= 1;\n    }\n    return res;\n}\n```","slug":"quick-matrix","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nlz001uh8vnq9yzlica","comments":1,"layout":"post","photos":[],"link":""},{"title":"线段树单点更新模板","date":"2018-05-06T13:47:10.000Z","_content":"之前一直在用大白上的线段树单点更新模板，最近渐渐发现有一些不太舒服的地方，一方面是大白上的模板会强行把线段树建成一个满二叉树，这样虽然比较好理解一些，但同时也会因为要考虑多出来的那些点的影响而相对麻烦。另一方面是因为大家貌似都不用大白上的线段树模板= =||，这样搜题解以及和队友交流的时候会存在一些障碍（其实这一方面是主要原因），所以最后通过权衡还是选择了一个自己觉得通用性比较好也比较好实现的模板。[参考博客链接](http://www.hysonn.com/2017/01/26/segtree/)\nPs:关于线段树区间更新目前正在学习中，之后再补上关于区间更新的模板。\n<!-- more -->\n# 基于最大值查询的线段树模板\n```C++\n//首先定义线段树的结构体\nstruct SegTree{\n    int vl, vr;         //每个tree[k]对应一个节点，其中vl, vr是节点对应的区间\n    int mv;             //表示节点维护的数据，视情况而定，以维护区间最大值为例\n}tree[maxn << 2];       //绝对安全的情况是建议开四倍数据量的大小\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\n```\n# 例题实现\n[HDU-1754--I Hate It(线段树单点更新入门题)](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint n, m;\nstruct SegTree{\n    int vl, vr;\n    int mv;\n}tree[maxn << 2];\n\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)//doubt\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\t\n    while(~scanf(\"%d%d\", &n, &m)){\n        char c[10];\n        int a, b;\n        for(int i = 1; i <= n; i++){\n            scanf(\"%d\", &d[i]);\n        }\n        build(1, 1, n);\n        for(int i = 1; i <= m; i++){\n            scanf(\"%s%d%d\", c, &a, &b);\n            if(c[0] == 'Q')\n                printf(\"%d\\n\", query(1, a, b));\n            else if(c[0] == 'U')\n            update(1, a, b);\n        }\n\t\t\n\t}\n\t\n    return 0;\n}\n```\n\n","source":"_posts/segtree-template.md","raw":"---\ntitle: 线段树单点更新模板\ndate: 2018-05-06 21:47:10\ncategories:\n- Template\ntags:\n- 线段树单点更新\n---\n之前一直在用大白上的线段树单点更新模板，最近渐渐发现有一些不太舒服的地方，一方面是大白上的模板会强行把线段树建成一个满二叉树，这样虽然比较好理解一些，但同时也会因为要考虑多出来的那些点的影响而相对麻烦。另一方面是因为大家貌似都不用大白上的线段树模板= =||，这样搜题解以及和队友交流的时候会存在一些障碍（其实这一方面是主要原因），所以最后通过权衡还是选择了一个自己觉得通用性比较好也比较好实现的模板。[参考博客链接](http://www.hysonn.com/2017/01/26/segtree/)\nPs:关于线段树区间更新目前正在学习中，之后再补上关于区间更新的模板。\n<!-- more -->\n# 基于最大值查询的线段树模板\n```C++\n//首先定义线段树的结构体\nstruct SegTree{\n    int vl, vr;         //每个tree[k]对应一个节点，其中vl, vr是节点对应的区间\n    int mv;             //表示节点维护的数据，视情况而定，以维护区间最大值为例\n}tree[maxn << 2];       //绝对安全的情况是建议开四倍数据量的大小\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\n```\n# 例题实现\n[HDU-1754--I Hate It(线段树单点更新入门题)](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint n, m;\nstruct SegTree{\n    int vl, vr;\n    int mv;\n}tree[maxn << 2];\n\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)//doubt\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\t\n    while(~scanf(\"%d%d\", &n, &m)){\n        char c[10];\n        int a, b;\n        for(int i = 1; i <= n; i++){\n            scanf(\"%d\", &d[i]);\n        }\n        build(1, 1, n);\n        for(int i = 1; i <= m; i++){\n            scanf(\"%s%d%d\", c, &a, &b);\n            if(c[0] == 'Q')\n                printf(\"%d\\n\", query(1, a, b));\n            else if(c[0] == 'U')\n            update(1, a, b);\n        }\n\t\t\n\t}\n\t\n    return 0;\n}\n```\n\n","slug":"segtree-template","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nm0001vh8vnsa40qt86","comments":1,"layout":"post","photos":[],"link":""},{"title":"Kick Start-2019D-X or What?","date":"2019-08-02T03:19:45.000Z","_content":"Kick Start-2019D 签到失败 (◉ω◉ )\n<!--more-->\n# 题目链接\n[Kick Start-2019D-X or What?](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000051061/0000000000161426)\n\n# 题意\n给定 $N$ 个非负整数组成的序列 $A$，求最大的区间，满足区间内所有数异或的结果是 $xor-even$，即结果的二进制形式中 $1$ 的个数为偶数个。\n每组数据包含 $N$ 个非负整数以及 $Q$ 个修改，每次修改将位置 $P_i$ 处（下标从0开始）的元素替换成 $V_i$。输出每次修改后满足 $xor-even$ 的最大区间中元素的个数。\n\n# 题解\n假设两个数分别为 $a$，$b$，它们二进制形式中 $1$ 的个数分别为 $i$，$j$。那么 $a$ 和 $b$ 异或后结果的二进制形式中 $1$ 的个数为 ``i + j - k * 2``，其中 $k=0,1,2,3...$。所以有如下结论：\n- 若两个数都满足 $xor-even$，那么两个数异或的结果也满足 $xor-even$。\n- 若两个数都满足 $xor-odd$，那么两个数异或的结果满足 $xor-even$。\n- 若两个数一个满足 $xor-odd$ 另一个满足 $xor-even$，那么两个数异或的结果满足 $xor-odd$。\n\n所以对于每次修改我们只要统计所有的 $N$ 个数中满足 $xor-odd$ 的数的个数是偶数还是奇数，并记录所有 $xor-odd$ 的数的下标。若 $xor-odd$ 的个数是偶数，那么结果是整个区间的长度；若 $xor-odd$ 的个数是奇数，那么结果是 ``max( length([0, last_Xor-odd)), length((first_Xor-odd, N - 1]) )``，其中 ``last_Xor-odd`` 表示满足 $xor-odd$ 的最后一个数的下标，``first_Xor-odd`` 表示满足 $xor-odd$ 的第一个数的下标。 \n\n# 代码\n```C++\n#include <iostream>\n#include <set>\n\n#include <cstdio>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nint T;\nint n, q;\nint a[maxn];\nset<int> pos;\n\nbool checkEven(int x){\n    int cnt = 0;\n    while(x > 0){\n        if(x & 1) cnt++;\n        x >>= 1;\n    }\n    if(cnt % 2 == 0) return true;\n    else return false;\n}\n\nint main(){\n    //freopen(\"in.txt\", \"r\", stdin);\n    cin >> T;\n    int Case = 0;\n\n    while(T--){\n        pos.clear();\n        cin >> n >> q;\n        for(int i = 0; i < n; i++){\n            cin >> a[i];\n            if(!checkEven(a[i])) pos.insert(i);\n        }\n\n        cout << \"Case #\" << ++Case << \":\"; \n        for(int i = 0; i < q; i++){\n            int p, v;\n            cin >> p >> v;\n\n            if(!checkEven(v)) pos.insert(p);\n            else pos.erase(p);\n\n            if(pos.size() % 2 == 0){\n                cout << \" \" << n;\n            }\n            else{\n                int l = *pos.begin();\n                int r = *pos.rbegin();\n                cout << \" \" << max(n - 1 - l, r);\n            }\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```\n","source":"_posts/kickstart-2019D-X-or-What.md","raw":"---\ntitle: Kick Start-2019D-X or What?\ndate: 2019-08-02 11:19:45\ncategories:\n- Google Kick Start\ntags:\n---\nKick Start-2019D 签到失败 (◉ω◉ )\n<!--more-->\n# 题目链接\n[Kick Start-2019D-X or What?](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000051061/0000000000161426)\n\n# 题意\n给定 $N$ 个非负整数组成的序列 $A$，求最大的区间，满足区间内所有数异或的结果是 $xor-even$，即结果的二进制形式中 $1$ 的个数为偶数个。\n每组数据包含 $N$ 个非负整数以及 $Q$ 个修改，每次修改将位置 $P_i$ 处（下标从0开始）的元素替换成 $V_i$。输出每次修改后满足 $xor-even$ 的最大区间中元素的个数。\n\n# 题解\n假设两个数分别为 $a$，$b$，它们二进制形式中 $1$ 的个数分别为 $i$，$j$。那么 $a$ 和 $b$ 异或后结果的二进制形式中 $1$ 的个数为 ``i + j - k * 2``，其中 $k=0,1,2,3...$。所以有如下结论：\n- 若两个数都满足 $xor-even$，那么两个数异或的结果也满足 $xor-even$。\n- 若两个数都满足 $xor-odd$，那么两个数异或的结果满足 $xor-even$。\n- 若两个数一个满足 $xor-odd$ 另一个满足 $xor-even$，那么两个数异或的结果满足 $xor-odd$。\n\n所以对于每次修改我们只要统计所有的 $N$ 个数中满足 $xor-odd$ 的数的个数是偶数还是奇数，并记录所有 $xor-odd$ 的数的下标。若 $xor-odd$ 的个数是偶数，那么结果是整个区间的长度；若 $xor-odd$ 的个数是奇数，那么结果是 ``max( length([0, last_Xor-odd)), length((first_Xor-odd, N - 1]) )``，其中 ``last_Xor-odd`` 表示满足 $xor-odd$ 的最后一个数的下标，``first_Xor-odd`` 表示满足 $xor-odd$ 的第一个数的下标。 \n\n# 代码\n```C++\n#include <iostream>\n#include <set>\n\n#include <cstdio>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nint T;\nint n, q;\nint a[maxn];\nset<int> pos;\n\nbool checkEven(int x){\n    int cnt = 0;\n    while(x > 0){\n        if(x & 1) cnt++;\n        x >>= 1;\n    }\n    if(cnt % 2 == 0) return true;\n    else return false;\n}\n\nint main(){\n    //freopen(\"in.txt\", \"r\", stdin);\n    cin >> T;\n    int Case = 0;\n\n    while(T--){\n        pos.clear();\n        cin >> n >> q;\n        for(int i = 0; i < n; i++){\n            cin >> a[i];\n            if(!checkEven(a[i])) pos.insert(i);\n        }\n\n        cout << \"Case #\" << ++Case << \":\"; \n        for(int i = 0; i < q; i++){\n            int p, v;\n            cin >> p >> v;\n\n            if(!checkEven(v)) pos.insert(p);\n            else pos.erase(p);\n\n            if(pos.size() % 2 == 0){\n                cout << \" \" << n;\n            }\n            else{\n                int l = *pos.begin();\n                int r = *pos.rbegin();\n                cout << \" \" << max(n - 1 - l, r);\n            }\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```\n","slug":"kickstart-2019D-X-or-What","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nm0001wh8vnwdp6nlem","comments":1,"layout":"post","photos":[],"link":""},{"title":"stringstream-类型转换&&字符分割","date":"2018-08-08T14:07:28.000Z","_content":"继续填坑٩(•̤̀ᵕ•̤́๑)，这次是stringstream的内容，最初是看到它可以把字符串直接输出成int类型，惊了，但是一直不是很懂。在网上查了很多资料，才终于差不多理解。stringstream是C++提供的一个字符串流，和cin，cout输入输出流类似，只不过它不是从从键盘或文件输入，也不是输出到屏幕或文件中，而是接受一个对象的输入，或把缓存区的内容输出到一个对象中。具体可以用在类型转换和字符分割中。\n<!-- more -->\n# 基本方法(操作)\n```C++\nclear()－用来清空流标志(输入，输出标志)\nstr()－获得当前流中的内容\nstr(\"content\")－设置流的内容（或清空流的内容）\noperator <<－添加内容到stringstream对象\noperator >>－从stringstream流缓存区中输出内容\n```\n# 应用\n## 类型转换\n```C++\nint a;\nstring s;\nstringstream ss;\n//int型转换为字符串类型\nss << a;　//将a输入流中（输入模式）\nss >> s;　//将流中的数值输出到字符串s中（输出模式）\n\n//字符串类型转换为int型\nss << s;　//将字符串输入到流中\nss >> a;　//将流中的字符串输出到int型变量a中\n\n//注意：如果做多次数据转换须调用clear()和str(\"\")来清空输入输出标志和内容\nint a = 0, b = 0;\nstringstream ss;\nss << \"123\";\nss >> a;\nss.clear();\nss.str(\"\");\nss << \"456\";\nss >> b;\ncout << \"a:\" << a << endl;\ncout << \"b:\" << b << endl;\ncout << \"ss:\" << ss.str() << endl;\n\n//运行结果,不加clear()和str(\"\");\na:123\nb:0\nss:123\n//原因：不加clear()和str(\"\")，流处于输出模式无法接收新内容\"456\"且未被清空，所以ss仍为\"123\"，又由于缓存区的内容已输出到a中，所以b中无内容。\n\n//运行结果，加clear()但不加str(\"\");\na:123\nb:456\nss:123456\n//原因：加入clear()清空模式，可以接收新内容\"456\"，所以ss:123456。缓存区依次缓存\"123\"，\"456\"并分别输出到a, b，所以a:123, b:456\n\n//运行结果，加clear()和str(\"\");\na:123\nb:456\nss:456\n//原因：clear()清空模式，str(\"\")清空ss对象的内容。\n```\n## 支持char*的输入和输出\n```C++\nchar ch[20];\nstringstream ss;\nss << 2333;\nss >> ch; //直接将数输出到ch字符数组中\n```\n## 字符分割\n```C++\nstringstream ss(\"hello hi hey\");\nstring word;\nwhile(ss >> word){\n    cout << word << endl;\n}\n\n//运行结果\nhello\nhi\nhey\n\n```\n# 三种给stringstream对象赋初值的方式\n```C++\nstringstream ss(\"123\"); //创建的时候赋初值\nss.str(\"123\"); //str()函数赋值\nss << \"123\"; //操作符\"<<\"添加内容（需注意当前模式）\n```","source":"_posts/stringstream.md","raw":"---\ntitle: stringstream-类型转换&&字符分割\ndate: 2018-08-08 22:07:28\ncategories:\n- C++\ntags:\n- 字符串\n---\n继续填坑٩(•̤̀ᵕ•̤́๑)，这次是stringstream的内容，最初是看到它可以把字符串直接输出成int类型，惊了，但是一直不是很懂。在网上查了很多资料，才终于差不多理解。stringstream是C++提供的一个字符串流，和cin，cout输入输出流类似，只不过它不是从从键盘或文件输入，也不是输出到屏幕或文件中，而是接受一个对象的输入，或把缓存区的内容输出到一个对象中。具体可以用在类型转换和字符分割中。\n<!-- more -->\n# 基本方法(操作)\n```C++\nclear()－用来清空流标志(输入，输出标志)\nstr()－获得当前流中的内容\nstr(\"content\")－设置流的内容（或清空流的内容）\noperator <<－添加内容到stringstream对象\noperator >>－从stringstream流缓存区中输出内容\n```\n# 应用\n## 类型转换\n```C++\nint a;\nstring s;\nstringstream ss;\n//int型转换为字符串类型\nss << a;　//将a输入流中（输入模式）\nss >> s;　//将流中的数值输出到字符串s中（输出模式）\n\n//字符串类型转换为int型\nss << s;　//将字符串输入到流中\nss >> a;　//将流中的字符串输出到int型变量a中\n\n//注意：如果做多次数据转换须调用clear()和str(\"\")来清空输入输出标志和内容\nint a = 0, b = 0;\nstringstream ss;\nss << \"123\";\nss >> a;\nss.clear();\nss.str(\"\");\nss << \"456\";\nss >> b;\ncout << \"a:\" << a << endl;\ncout << \"b:\" << b << endl;\ncout << \"ss:\" << ss.str() << endl;\n\n//运行结果,不加clear()和str(\"\");\na:123\nb:0\nss:123\n//原因：不加clear()和str(\"\")，流处于输出模式无法接收新内容\"456\"且未被清空，所以ss仍为\"123\"，又由于缓存区的内容已输出到a中，所以b中无内容。\n\n//运行结果，加clear()但不加str(\"\");\na:123\nb:456\nss:123456\n//原因：加入clear()清空模式，可以接收新内容\"456\"，所以ss:123456。缓存区依次缓存\"123\"，\"456\"并分别输出到a, b，所以a:123, b:456\n\n//运行结果，加clear()和str(\"\");\na:123\nb:456\nss:456\n//原因：clear()清空模式，str(\"\")清空ss对象的内容。\n```\n## 支持char*的输入和输出\n```C++\nchar ch[20];\nstringstream ss;\nss << 2333;\nss >> ch; //直接将数输出到ch字符数组中\n```\n## 字符分割\n```C++\nstringstream ss(\"hello hi hey\");\nstring word;\nwhile(ss >> word){\n    cout << word << endl;\n}\n\n//运行结果\nhello\nhi\nhey\n\n```\n# 三种给stringstream对象赋初值的方式\n```C++\nstringstream ss(\"123\"); //创建的时候赋初值\nss.str(\"123\"); //str()函数赋值\nss << \"123\"; //操作符\"<<\"添加内容（需注意当前模式）\n```","slug":"stringstream","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nm0001xh8vn5j8spxq1","comments":1,"layout":"post","photos":[],"link":""},{"title":"python脚本-tab转空格","date":"2018-06-12T03:38:20.000Z","_content":"有一个一直比较麻烦的问题，平时写代码都是在gedit上写，然后设置了tab键是4个空格的位置，但是代码粘到博客里tab就变成了8个空格的位置，严重破坏了代码的美观！不能容忍！一直没有找到怎么在hexo里面设置，所以之前一直手动把tab换成4个空格QAQ，慢慢的觉得这样很傻，我为什么不写个程序帮我自动改＝＝，首选python！（人生苦短，我用python）。虽然对python不是很熟悉，但是边查边写应该问题不大，最终完成了，从此再也不用傻傻的手动转换了，幸福/(ㄒoㄒ)/~~代码量很小\n<!-- more -->\n# 简介\n就是把文档里的tab全部转换成4个空格，其余不变\n效果图：\n转换前\n![tab](/tab.png)\n转换后\n![space](/space.png)\n# 代码\n``` python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*- \n\ndef T2S():\n    str = raw_input(\"file name:\")\n    file_path = \"/home/aincrad/Desktop/\" + str\n    f = open(file_path, \"r\")\n    fnew = open(\"/home/aincrad/Desktop/new\", \"w\")\n    data = f.read()\n    for c in data:\n        if c == '\\t':\n            fnew.write(\"    \")\n        else:\n            fnew.write(c)\n    f.close()\n    fnew.close()\n    print \"Done\"\n\nif __name__ == \"__main__\":\n    T2S()\n```\n*说明:默认了需要转换的文件在桌面，运行程序后只需要输入文件名即可，之后会在桌面上生成名为new的转换后的文件。*\n","source":"_posts/tab-to-spaces.md","raw":"---\ntitle: python脚本-tab转空格\ndate: 2018-06-12 11:38:20\ncategories:\n- Messy article\ntags:\n- python\n---\n有一个一直比较麻烦的问题，平时写代码都是在gedit上写，然后设置了tab键是4个空格的位置，但是代码粘到博客里tab就变成了8个空格的位置，严重破坏了代码的美观！不能容忍！一直没有找到怎么在hexo里面设置，所以之前一直手动把tab换成4个空格QAQ，慢慢的觉得这样很傻，我为什么不写个程序帮我自动改＝＝，首选python！（人生苦短，我用python）。虽然对python不是很熟悉，但是边查边写应该问题不大，最终完成了，从此再也不用傻傻的手动转换了，幸福/(ㄒoㄒ)/~~代码量很小\n<!-- more -->\n# 简介\n就是把文档里的tab全部转换成4个空格，其余不变\n效果图：\n转换前\n![tab](/tab.png)\n转换后\n![space](/space.png)\n# 代码\n``` python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*- \n\ndef T2S():\n    str = raw_input(\"file name:\")\n    file_path = \"/home/aincrad/Desktop/\" + str\n    f = open(file_path, \"r\")\n    fnew = open(\"/home/aincrad/Desktop/new\", \"w\")\n    data = f.read()\n    for c in data:\n        if c == '\\t':\n            fnew.write(\"    \")\n        else:\n            fnew.write(c)\n    f.close()\n    fnew.close()\n    print \"Done\"\n\nif __name__ == \"__main__\":\n    T2S()\n```\n*说明:默认了需要转换的文件在桌面，运行程序后只需要输入文件名即可，之后会在桌面上生成名为new的转换后的文件。*\n","slug":"tab-to-spaces","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nm1001yh8vnlquwag6f","comments":1,"layout":"post","photos":[],"link":""},{"title":"sscanf & sprintf","date":"2018-09-15T14:32:35.000Z","_content":"　　*关于 sscanf 和 sprintf 用法的总结。*\n<!--more-->\n\n# sscanf\n``int sscanf（const char * str，const char * format，...）``从字符串中读取格式化的输入。\n\n## Example\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main () {\n   int day, year;\n   char weekday[20], month[20], dtm[100];\n\n   strcpy( dtm, \"Saturday March 25 1989\" );\n   sscanf( dtm, \"%s %s %d  %d\", weekday, month, &day, &year );\n\n   printf(\"%s %d, %d = %s\\n\", month, day, year, weekday );\n    \n   return(0);\n}\n```\n## Output\n```\nMarch 25, 1989 = Saturday\n```\n\n# sprintf\n``int sprintf（char * str，const char * format，...）``将格式化的输出发送到str指向的字符串。\n\n## Example\n```C\n#include <stdio.h>\n#include <math.h>\n\nint main () {\n   char str[80];\n\n   sprintf(str, \"Value of Pi = %f\", M_PI);\n   puts(str);\n   \n   return(0);\n}\n```\n## Output\n```\nValue of Pi = 3.141593\n```","source":"_posts/sscanf-sprintf.md","raw":"---\ntitle: sscanf & sprintf\ndate: 2018-09-15 22:32:35\ncategories:\n- C++\ntags:\n- 总结\n---\n　　*关于 sscanf 和 sprintf 用法的总结。*\n<!--more-->\n\n# sscanf\n``int sscanf（const char * str，const char * format，...）``从字符串中读取格式化的输入。\n\n## Example\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main () {\n   int day, year;\n   char weekday[20], month[20], dtm[100];\n\n   strcpy( dtm, \"Saturday March 25 1989\" );\n   sscanf( dtm, \"%s %s %d  %d\", weekday, month, &day, &year );\n\n   printf(\"%s %d, %d = %s\\n\", month, day, year, weekday );\n    \n   return(0);\n}\n```\n## Output\n```\nMarch 25, 1989 = Saturday\n```\n\n# sprintf\n``int sprintf（char * str，const char * format，...）``将格式化的输出发送到str指向的字符串。\n\n## Example\n```C\n#include <stdio.h>\n#include <math.h>\n\nint main () {\n   char str[80];\n\n   sprintf(str, \"Value of Pi = %f\", M_PI);\n   puts(str);\n   \n   return(0);\n}\n```\n## Output\n```\nValue of Pi = 3.141593\n```","slug":"sscanf-sprintf","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nm1001zh8vneopgz0k5","comments":1,"layout":"post","photos":[],"link":""},{"title":"ubuntu下vultr服务器搭建","date":"2018-04-13T11:09:32.000Z","_content":"　　工欲善其事必先利其器。\n　　前一段时间在[陶司机学长](http://logqtainia.github.io/)的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了...，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。\n　　觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。\n<!-- more -->\n\n# 注册vultr账号\n[链接](https://www.vultr.com/)\n\n# 创建vultr主机\n　　点击右上角的蓝色加号，创建新的vultr主机\n\n![p1](/p1.png)\n\n　　服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)\n\n![p2](/p2.png)\n\n　　服务器端系统选择，选择ubuntu\n\n![p3](/p3.png)\n\n　　服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。\n\n![p4](/p4.png)\n\n　　其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)\n\n![p5](/p5.png)\n\n　　接下来等待主机部署完成即可。\n\n# 服务器端配置\n　　服务器端，也就是你刚刚创建的那台主机。\n　　点击主机右侧\"...\"展开菜单，选择\"Server Details\"可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。\n![p6](/p6.png)\n\n　　打开终端，使用ssh远程登录到主机\n\n```\n$ ssh root@你的主机IP地址\n```\n\n　　之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。\n　　登录成功后使用一键配置脚本进行配置\n\n```\n$ wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n```\n\n　　终端中会出现如下界面，输入１选择安装shadowsocksR\n\n![p7](/p7.png)\n\n　　之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择\n\n```\n加密方式(method):none\n协议(protocol):auth_chain_a\n混淆(obfs):plain\n```\n\n　　服务器端配置完成，终端中输入exit退出ssh登录\n\n```\n$ exit\n```\n\n# 客户端配置\n　　客户端，也就是你的个人电脑。\n　　在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。\n\n```\n$ wget http://www.djangoz.com/ssr\n$ sudo mv ssr /usr/local/bin\n$ sudo chmod 766 /usr/local/bin/ssr\n$ ssr install\n$ ssr config\n```\n\n　　配置和服务器端保持一致即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项\n\n```\n    \"server\": \"11.22.33.44\",\n    \"server_ipv6\": \"::\",\n    \"server_port\": 1234,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\": 1080,\n\n    \"password\": \"123456789\",\n    \"method\": \"none\",\n    \"protocol\": \"auth_chain_a\",\n    \"protocol_param\": \"\",\n    \"obfs\": \"plain\",\n    \"obfs_param\": \"\",\n    \"speed_limit_per_con\": 0,\n    \"speed_limit_per_user\": 0,\n\n    \"additional_ports\" : {}, // only works under multi-user mode\n    \"additional_ports_only\" : false, // only works under multi-user mode\n    \"timeout\": 120,\n    \"udp_timeout\": 60,\n    \"dns_ipv6\": false,\n    \"connect_verbose_info\": 0,\n    \"redirect\": \"\",\n\n```\n\n　　以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令\n\n```\nssr start\nssr stop\n```\n\n# 可能的问题\n　　检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。\n* 依次打开ubuntu系统设置->网络->网络代理，设置如下\n![p8](/p8.png)\n\n* 推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)\nproxy SwitchyOmega配置如下\n![p9](/p9.png)\n\n* 有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)\n\n　　*ps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用*","source":"_posts/vultr.md","raw":"---\ntitle: ubuntu下vultr服务器搭建\ndate: 2018-04-13 19:09:32\ncategories:\n- Messy article\ntags:\n- vultr服务器搭建\n---\n　　工欲善其事必先利其器。\n　　前一段时间在[陶司机学长](http://logqtainia.github.io/)的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了...，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。\n　　觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。\n<!-- more -->\n\n# 注册vultr账号\n[链接](https://www.vultr.com/)\n\n# 创建vultr主机\n　　点击右上角的蓝色加号，创建新的vultr主机\n\n![p1](/p1.png)\n\n　　服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)\n\n![p2](/p2.png)\n\n　　服务器端系统选择，选择ubuntu\n\n![p3](/p3.png)\n\n　　服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。\n\n![p4](/p4.png)\n\n　　其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)\n\n![p5](/p5.png)\n\n　　接下来等待主机部署完成即可。\n\n# 服务器端配置\n　　服务器端，也就是你刚刚创建的那台主机。\n　　点击主机右侧\"...\"展开菜单，选择\"Server Details\"可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。\n![p6](/p6.png)\n\n　　打开终端，使用ssh远程登录到主机\n\n```\n$ ssh root@你的主机IP地址\n```\n\n　　之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。\n　　登录成功后使用一键配置脚本进行配置\n\n```\n$ wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n```\n\n　　终端中会出现如下界面，输入１选择安装shadowsocksR\n\n![p7](/p7.png)\n\n　　之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择\n\n```\n加密方式(method):none\n协议(protocol):auth_chain_a\n混淆(obfs):plain\n```\n\n　　服务器端配置完成，终端中输入exit退出ssh登录\n\n```\n$ exit\n```\n\n# 客户端配置\n　　客户端，也就是你的个人电脑。\n　　在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。\n\n```\n$ wget http://www.djangoz.com/ssr\n$ sudo mv ssr /usr/local/bin\n$ sudo chmod 766 /usr/local/bin/ssr\n$ ssr install\n$ ssr config\n```\n\n　　配置和服务器端保持一致即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项\n\n```\n    \"server\": \"11.22.33.44\",\n    \"server_ipv6\": \"::\",\n    \"server_port\": 1234,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\": 1080,\n\n    \"password\": \"123456789\",\n    \"method\": \"none\",\n    \"protocol\": \"auth_chain_a\",\n    \"protocol_param\": \"\",\n    \"obfs\": \"plain\",\n    \"obfs_param\": \"\",\n    \"speed_limit_per_con\": 0,\n    \"speed_limit_per_user\": 0,\n\n    \"additional_ports\" : {}, // only works under multi-user mode\n    \"additional_ports_only\" : false, // only works under multi-user mode\n    \"timeout\": 120,\n    \"udp_timeout\": 60,\n    \"dns_ipv6\": false,\n    \"connect_verbose_info\": 0,\n    \"redirect\": \"\",\n\n```\n\n　　以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令\n\n```\nssr start\nssr stop\n```\n\n# 可能的问题\n　　检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。\n* 依次打开ubuntu系统设置->网络->网络代理，设置如下\n![p8](/p8.png)\n\n* 推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)\nproxy SwitchyOmega配置如下\n![p9](/p9.png)\n\n* 有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)\n\n　　*ps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用*","slug":"vultr","published":1,"updated":"2019-09-01T09:01:24.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0uh6nm20020h8vnws60suay","content":"<p>　　工欲善其事必先利其器。<br>　　前一段时间在<a href=\"http://logqtainia.github.io/\" target=\"_blank\" rel=\"noopener\">陶司机学长</a>的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了…，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。<br>　　觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"注册vultr账号\"><a href=\"#注册vultr账号\" class=\"headerlink\" title=\"注册vultr账号\"></a>注册vultr账号</h1><p><a href=\"https://www.vultr.com/\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h1 id=\"创建vultr主机\"><a href=\"#创建vultr主机\" class=\"headerlink\" title=\"创建vultr主机\"></a>创建vultr主机</h1><p>　　点击右上角的蓝色加号，创建新的vultr主机</p>\n<p><img src=\"/2018/04/13/vultr/p1.png\" alt=\"p1\"></p>\n<p>　　服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)</p>\n<p><img src=\"/2018/04/13/vultr/p2.png\" alt=\"p2\"></p>\n<p>　　服务器端系统选择，选择ubuntu</p>\n<p><img src=\"/2018/04/13/vultr/p3.png\" alt=\"p3\"></p>\n<p>　　服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。</p>\n<p><img src=\"/2018/04/13/vultr/p4.png\" alt=\"p4\"></p>\n<p>　　其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)</p>\n<p><img src=\"/2018/04/13/vultr/p5.png\" alt=\"p5\"></p>\n<p>　　接下来等待主机部署完成即可。</p>\n<h1 id=\"服务器端配置\"><a href=\"#服务器端配置\" class=\"headerlink\" title=\"服务器端配置\"></a>服务器端配置</h1><p>　　服务器端，也就是你刚刚创建的那台主机。<br>　　点击主机右侧”…”展开菜单，选择”Server Details”可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。<br><img src=\"/2018/04/13/vultr/p6.png\" alt=\"p6\"></p>\n<p>　　打开终端，使用ssh远程登录到主机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh root@你的主机IP地址</span><br></pre></td></tr></table></figure>\n\n<p>　　之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。<br>　　登录成功后使用一键配置脚本进行配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure>\n\n<p>　　终端中会出现如下界面，输入１选择安装shadowsocksR</p>\n<p><img src=\"/2018/04/13/vultr/p7.png\" alt=\"p7\"></p>\n<p>　　之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加密方式(method):none</span><br><span class=\"line\">协议(protocol):auth_chain_a</span><br><span class=\"line\">混淆(obfs):plain</span><br></pre></td></tr></table></figure>\n\n<p>　　服务器端配置完成，终端中输入exit退出ssh登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ exit</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"客户端配置\"><a href=\"#客户端配置\" class=\"headerlink\" title=\"客户端配置\"></a>客户端配置</h1><p>　　客户端，也就是你的个人电脑。<br>　　在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget http://www.djangoz.com/ssr</span><br><span class=\"line\">$ sudo mv ssr /usr/local/bin</span><br><span class=\"line\">$ sudo chmod 766 /usr/local/bin/ssr</span><br><span class=\"line\">$ ssr install</span><br><span class=\"line\">$ ssr config</span><br></pre></td></tr></table></figure>\n\n<p>　　配置和服务器端保持一致即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;server&quot;: &quot;11.22.33.44&quot;,</span><br><span class=\"line\">&quot;server_ipv6&quot;: &quot;::&quot;,</span><br><span class=\"line\">&quot;server_port&quot;: 1234,</span><br><span class=\"line\">&quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">&quot;local_port&quot;: 1080,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;password&quot;: &quot;123456789&quot;,</span><br><span class=\"line\">&quot;method&quot;: &quot;none&quot;,</span><br><span class=\"line\">&quot;protocol&quot;: &quot;auth_chain_a&quot;,</span><br><span class=\"line\">&quot;protocol_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;obfs&quot;: &quot;plain&quot;,</span><br><span class=\"line\">&quot;obfs_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;speed_limit_per_con&quot;: 0,</span><br><span class=\"line\">&quot;speed_limit_per_user&quot;: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;additional_ports&quot; : &#123;&#125;, // only works under multi-user mode</span><br><span class=\"line\">&quot;additional_ports_only&quot; : false, // only works under multi-user mode</span><br><span class=\"line\">&quot;timeout&quot;: 120,</span><br><span class=\"line\">&quot;udp_timeout&quot;: 60,</span><br><span class=\"line\">&quot;dns_ipv6&quot;: false,</span><br><span class=\"line\">&quot;connect_verbose_info&quot;: 0,</span><br><span class=\"line\">&quot;redirect&quot;: &quot;&quot;,</span><br></pre></td></tr></table></figure>\n\n<p>　　以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssr start</span><br><span class=\"line\">ssr stop</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"可能的问题\"><a href=\"#可能的问题\" class=\"headerlink\" title=\"可能的问题\"></a>可能的问题</h1><p>　　检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。</p>\n<ul>\n<li><p>依次打开ubuntu系统设置-&gt;网络-&gt;网络代理，设置如下<br><img src=\"/2018/04/13/vultr/p8.png\" alt=\"p8\"></p>\n</li>\n<li><p>推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)<br>proxy SwitchyOmega配置如下<br><img src=\"/2018/04/13/vultr/p9.png\" alt=\"p9\"></p>\n</li>\n<li><p>有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)</p>\n</li>\n</ul>\n<p>　　<em>ps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用</em></p>\n","site":{"data":{}},"excerpt":"<p>　　工欲善其事必先利其器。<br>　　前一段时间在<a href=\"http://logqtainia.github.io/\" target=\"_blank\" rel=\"noopener\">陶司机学长</a>的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了…，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。<br>　　觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。</p>","more":"<h1 id=\"注册vultr账号\"><a href=\"#注册vultr账号\" class=\"headerlink\" title=\"注册vultr账号\"></a>注册vultr账号</h1><p><a href=\"https://www.vultr.com/\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h1 id=\"创建vultr主机\"><a href=\"#创建vultr主机\" class=\"headerlink\" title=\"创建vultr主机\"></a>创建vultr主机</h1><p>　　点击右上角的蓝色加号，创建新的vultr主机</p>\n<p><img src=\"/2018/04/13/vultr/p1.png\" alt=\"p1\"></p>\n<p>　　服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)</p>\n<p><img src=\"/2018/04/13/vultr/p2.png\" alt=\"p2\"></p>\n<p>　　服务器端系统选择，选择ubuntu</p>\n<p><img src=\"/2018/04/13/vultr/p3.png\" alt=\"p3\"></p>\n<p>　　服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。</p>\n<p><img src=\"/2018/04/13/vultr/p4.png\" alt=\"p4\"></p>\n<p>　　其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)</p>\n<p><img src=\"/2018/04/13/vultr/p5.png\" alt=\"p5\"></p>\n<p>　　接下来等待主机部署完成即可。</p>\n<h1 id=\"服务器端配置\"><a href=\"#服务器端配置\" class=\"headerlink\" title=\"服务器端配置\"></a>服务器端配置</h1><p>　　服务器端，也就是你刚刚创建的那台主机。<br>　　点击主机右侧”…”展开菜单，选择”Server Details”可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。<br><img src=\"/2018/04/13/vultr/p6.png\" alt=\"p6\"></p>\n<p>　　打开终端，使用ssh远程登录到主机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh root@你的主机IP地址</span><br></pre></td></tr></table></figure>\n\n<p>　　之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。<br>　　登录成功后使用一键配置脚本进行配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure>\n\n<p>　　终端中会出现如下界面，输入１选择安装shadowsocksR</p>\n<p><img src=\"/2018/04/13/vultr/p7.png\" alt=\"p7\"></p>\n<p>　　之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加密方式(method):none</span><br><span class=\"line\">协议(protocol):auth_chain_a</span><br><span class=\"line\">混淆(obfs):plain</span><br></pre></td></tr></table></figure>\n\n<p>　　服务器端配置完成，终端中输入exit退出ssh登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ exit</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"客户端配置\"><a href=\"#客户端配置\" class=\"headerlink\" title=\"客户端配置\"></a>客户端配置</h1><p>　　客户端，也就是你的个人电脑。<br>　　在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget http://www.djangoz.com/ssr</span><br><span class=\"line\">$ sudo mv ssr /usr/local/bin</span><br><span class=\"line\">$ sudo chmod 766 /usr/local/bin/ssr</span><br><span class=\"line\">$ ssr install</span><br><span class=\"line\">$ ssr config</span><br></pre></td></tr></table></figure>\n\n<p>　　配置和服务器端保持一致即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;server&quot;: &quot;11.22.33.44&quot;,</span><br><span class=\"line\">&quot;server_ipv6&quot;: &quot;::&quot;,</span><br><span class=\"line\">&quot;server_port&quot;: 1234,</span><br><span class=\"line\">&quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">&quot;local_port&quot;: 1080,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;password&quot;: &quot;123456789&quot;,</span><br><span class=\"line\">&quot;method&quot;: &quot;none&quot;,</span><br><span class=\"line\">&quot;protocol&quot;: &quot;auth_chain_a&quot;,</span><br><span class=\"line\">&quot;protocol_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;obfs&quot;: &quot;plain&quot;,</span><br><span class=\"line\">&quot;obfs_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;speed_limit_per_con&quot;: 0,</span><br><span class=\"line\">&quot;speed_limit_per_user&quot;: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;additional_ports&quot; : &#123;&#125;, // only works under multi-user mode</span><br><span class=\"line\">&quot;additional_ports_only&quot; : false, // only works under multi-user mode</span><br><span class=\"line\">&quot;timeout&quot;: 120,</span><br><span class=\"line\">&quot;udp_timeout&quot;: 60,</span><br><span class=\"line\">&quot;dns_ipv6&quot;: false,</span><br><span class=\"line\">&quot;connect_verbose_info&quot;: 0,</span><br><span class=\"line\">&quot;redirect&quot;: &quot;&quot;,</span><br></pre></td></tr></table></figure>\n\n<p>　　以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssr start</span><br><span class=\"line\">ssr stop</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"可能的问题\"><a href=\"#可能的问题\" class=\"headerlink\" title=\"可能的问题\"></a>可能的问题</h1><p>　　检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。</p>\n<ul>\n<li><p>依次打开ubuntu系统设置-&gt;网络-&gt;网络代理，设置如下<br><img src=\"/2018/04/13/vultr/p8.png\" alt=\"p8\"></p>\n</li>\n<li><p>推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)<br>proxy SwitchyOmega配置如下<br><img src=\"/2018/04/13/vultr/p9.png\" alt=\"p9\"></p>\n</li>\n<li><p>有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)</p>\n</li>\n</ul>\n<p>　　<em>ps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用</em></p>"},{"title":"光栅化渲染(2)-透视投影","date":"2019-08-11T02:55:42.000Z","_content":"\n![perspective projection](/perspective.png)\n\n　　*画家用透视投影的方法作画，以获得接近真实三维物体的视觉效果。*\n<!--more-->\n\n# 透视投影\n　　透视投影是三维投影的一种，是将三维空间中的点映射到二维平面上的方法。由于目前绝大多数图形数据的显示方式仍是二维的，因此三维投影的在计算机图形学等方面应用广泛。\n\n# 投影原理\n　　透视投影符合人眼成像的特点，以人眼作为视点，在视网膜上的图像就是空间物体投影的结果。\n　　如图(Figure 1)，点 $P$ 为空间中的一点，$P^\\prime$ 为其投影在成像平面上的点，$A$ 为视点。\n\n![figure 1](/figure1.png)\n<center>Figure 1</center>\n\n　　由 $\\Delta ABC$ 和 $\\Delta AB^\\prime C^\\prime$ 相似可以得到：\n\n$$\n\\cfrac{BC}{AB}=\\cfrac{B^\\prime C^\\prime}{AB^\\prime}，即 \\cfrac{P.y}{P.z}=\\cfrac{P^\\prime.y}{near}\n$$\n\n　　其中``near``为视点到成像平面的距离。\n\n$$P^\\prime.y=\\cfrac{near * P.y}{P.z}$$\n\n　　同理可得，\n\n$$P^\\prime.x=\\cfrac{near * P.x}{P.z}$$\n\n　　由于默认情况下相机指向z轴的负半轴(Figure 2)，所以实际上要对相机坐标系下的z轴坐标取反。\n\n![figure 2](/figure2.png)\n<center>Figure 2</center>\n\n$$\nP_{screen}.x = \\cfrac{near * P_{camera}.x}{-P_{camera}.z} \\\\\\\\\nP_{screen}.y = \\cfrac{near * P_{camera}.y}{-P_{camera}.z}\n$$\n\n　　假设图片的尺寸为 $W \\* H$，那么投影后的坐标与该点可见性的关系如下：\n\n$$\nvisible=\n\\begin{cases}\n    yes & |P_{screen}.x| <= \\cfrac{W}{2} \\quad \\text{or} \\quad |P_{screen}.y| <= \\cfrac{H}{2} \\\\\\\\\n    no & \\text{otherwise}\n\\end{cases}\n$$\n\n# 坐标系变换\n　　我们的目标是获得投影点的像素坐标，所以要对坐标系进行变换，由成像平面坐标系变为光栅坐标系。\n　　相机成像平面上一点 $P_{screen}$ (Figure 3)\n\n![figure 3](/figure3.png)\n<center>Figure 3</center>\n\n　　先将其转换为 $NDC$ 坐标系下(Figure 4)，范围为 $[0, 1]$\n\n![figure 4](/figure4.png)\n<center>Figure 4</center>\n\n$$\nP_{normalized}.x=\\cfrac{P_{screen}.x + W/2}{W} \\\\\\\\\nP_{normalized}.y=\\cfrac{P_{screen}.y + H/2}{H}\n$$\n\n　　最后转换为光栅化坐标(Figure 5)\n\n![figure 5](/figure5.png)\n<center>Figure 5</center>\n\n$$\nP_{raster}.x=P_{normalized}.x * pixelWidth \\\\\\\\\nP_{raster}.y=(1-P_{normalized}.y) * pixelHeight\n$$\n\n　　*注意区分* $W$ *和* $pixelWidth$，*W指的是图片的物理尺寸，以 m 或 mm 等为单位，pixelWidth指的是图片的横向像素的个数。*\n　　由此可得**相机坐标系**到**光栅坐标系**的转换公式：\n\n$$\nP_{raster}.x=(1 + \\cfrac{near * P_{camera}.x}{-W * P_{camera}.z})* 0.5 * pixelWidth \\\\\\\\\nP_{raster}.y=(1 - \\cfrac{near * P_{camera}.y}{-W * P_{camera}.z}) * 0.5 * pixelHeight\n$$\n\n# 拓展\n　　上面提到的 $NDC$ 坐标范围为 $[0, 1]$，实际上在GPU的实现中， $NDC$ 坐标范围为 $[-1, 1]$。另外讨论更一般的情况，假设成像平面坐标系的 $x$ 坐标范围为 $[l, r]$，$y$ 坐标范围为 $[b, t]$。\n　　此时由成像平面坐标系到 $NDC$ 坐标系的映射关系可以通过以下方式求解，先考虑 $x$：\n　　由 $l<=x<=r$，可得 $0<=x-l<=r-l$，各项同时除以 $(r-l)$：\n\n$$\n0 <= \\cfrac{x-l}{r-l} <= 1\n$$\n\n　　公式各项同时乘以 $2$ 再减去 $1$：\n\n$$\n-1 <= 2 * \\cfrac{x-l}{r-l} - 1 <= 1\n$$\n\n　　化简得：\n\n$$\n-1 <= \\cfrac{2x}{r-l}-\\cfrac{r+l}{r-l} <= 1，即 \\quad P_{normalized}.x = \\cfrac{2*P_{screen}.x}{r-l}-\\cfrac{r+l}{r-l}\n$$\n\n　　同理可得：\n\n$$\n-1 <= \\cfrac{2y}{t-b}-\\cfrac{t+b}{t-b} <= 1，即 \\quad P_{normalized}.y = \\cfrac{2*P_{screen}.y}{t-b}-\\cfrac{t+b}{t-b}\n$$\n\n# 参考链接\n\n[Scratchpixel-Mathematics of Computing the 2D Coordinates of a 3D Point](https://www.scratchapixel.com/lessons/3d-basic-rendering/computing-pixel-coordinates-of-3d-point/mathematics-computing-2d-coordinates-of-3d-points)\n[Scratchpixel-The Projection Stage](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/projection-stage)\n","source":"_posts/光栅化渲染-2-透视投影.md","raw":"---\ntitle: 光栅化渲染(2)-透视投影\ndate: 2019-08-11 10:55:42\ncategories:\n- Computer Graphics\n- 光栅化渲染\ntags:\n- rasterization\n---\n\n![perspective projection](/perspective.png)\n\n　　*画家用透视投影的方法作画，以获得接近真实三维物体的视觉效果。*\n<!--more-->\n\n# 透视投影\n　　透视投影是三维投影的一种，是将三维空间中的点映射到二维平面上的方法。由于目前绝大多数图形数据的显示方式仍是二维的，因此三维投影的在计算机图形学等方面应用广泛。\n\n# 投影原理\n　　透视投影符合人眼成像的特点，以人眼作为视点，在视网膜上的图像就是空间物体投影的结果。\n　　如图(Figure 1)，点 $P$ 为空间中的一点，$P^\\prime$ 为其投影在成像平面上的点，$A$ 为视点。\n\n![figure 1](/figure1.png)\n<center>Figure 1</center>\n\n　　由 $\\Delta ABC$ 和 $\\Delta AB^\\prime C^\\prime$ 相似可以得到：\n\n$$\n\\cfrac{BC}{AB}=\\cfrac{B^\\prime C^\\prime}{AB^\\prime}，即 \\cfrac{P.y}{P.z}=\\cfrac{P^\\prime.y}{near}\n$$\n\n　　其中``near``为视点到成像平面的距离。\n\n$$P^\\prime.y=\\cfrac{near * P.y}{P.z}$$\n\n　　同理可得，\n\n$$P^\\prime.x=\\cfrac{near * P.x}{P.z}$$\n\n　　由于默认情况下相机指向z轴的负半轴(Figure 2)，所以实际上要对相机坐标系下的z轴坐标取反。\n\n![figure 2](/figure2.png)\n<center>Figure 2</center>\n\n$$\nP_{screen}.x = \\cfrac{near * P_{camera}.x}{-P_{camera}.z} \\\\\\\\\nP_{screen}.y = \\cfrac{near * P_{camera}.y}{-P_{camera}.z}\n$$\n\n　　假设图片的尺寸为 $W \\* H$，那么投影后的坐标与该点可见性的关系如下：\n\n$$\nvisible=\n\\begin{cases}\n    yes & |P_{screen}.x| <= \\cfrac{W}{2} \\quad \\text{or} \\quad |P_{screen}.y| <= \\cfrac{H}{2} \\\\\\\\\n    no & \\text{otherwise}\n\\end{cases}\n$$\n\n# 坐标系变换\n　　我们的目标是获得投影点的像素坐标，所以要对坐标系进行变换，由成像平面坐标系变为光栅坐标系。\n　　相机成像平面上一点 $P_{screen}$ (Figure 3)\n\n![figure 3](/figure3.png)\n<center>Figure 3</center>\n\n　　先将其转换为 $NDC$ 坐标系下(Figure 4)，范围为 $[0, 1]$\n\n![figure 4](/figure4.png)\n<center>Figure 4</center>\n\n$$\nP_{normalized}.x=\\cfrac{P_{screen}.x + W/2}{W} \\\\\\\\\nP_{normalized}.y=\\cfrac{P_{screen}.y + H/2}{H}\n$$\n\n　　最后转换为光栅化坐标(Figure 5)\n\n![figure 5](/figure5.png)\n<center>Figure 5</center>\n\n$$\nP_{raster}.x=P_{normalized}.x * pixelWidth \\\\\\\\\nP_{raster}.y=(1-P_{normalized}.y) * pixelHeight\n$$\n\n　　*注意区分* $W$ *和* $pixelWidth$，*W指的是图片的物理尺寸，以 m 或 mm 等为单位，pixelWidth指的是图片的横向像素的个数。*\n　　由此可得**相机坐标系**到**光栅坐标系**的转换公式：\n\n$$\nP_{raster}.x=(1 + \\cfrac{near * P_{camera}.x}{-W * P_{camera}.z})* 0.5 * pixelWidth \\\\\\\\\nP_{raster}.y=(1 - \\cfrac{near * P_{camera}.y}{-W * P_{camera}.z}) * 0.5 * pixelHeight\n$$\n\n# 拓展\n　　上面提到的 $NDC$ 坐标范围为 $[0, 1]$，实际上在GPU的实现中， $NDC$ 坐标范围为 $[-1, 1]$。另外讨论更一般的情况，假设成像平面坐标系的 $x$ 坐标范围为 $[l, r]$，$y$ 坐标范围为 $[b, t]$。\n　　此时由成像平面坐标系到 $NDC$ 坐标系的映射关系可以通过以下方式求解，先考虑 $x$：\n　　由 $l<=x<=r$，可得 $0<=x-l<=r-l$，各项同时除以 $(r-l)$：\n\n$$\n0 <= \\cfrac{x-l}{r-l} <= 1\n$$\n\n　　公式各项同时乘以 $2$ 再减去 $1$：\n\n$$\n-1 <= 2 * \\cfrac{x-l}{r-l} - 1 <= 1\n$$\n\n　　化简得：\n\n$$\n-1 <= \\cfrac{2x}{r-l}-\\cfrac{r+l}{r-l} <= 1，即 \\quad P_{normalized}.x = \\cfrac{2*P_{screen}.x}{r-l}-\\cfrac{r+l}{r-l}\n$$\n\n　　同理可得：\n\n$$\n-1 <= \\cfrac{2y}{t-b}-\\cfrac{t+b}{t-b} <= 1，即 \\quad P_{normalized}.y = \\cfrac{2*P_{screen}.y}{t-b}-\\cfrac{t+b}{t-b}\n$$\n\n# 参考链接\n\n[Scratchpixel-Mathematics of Computing the 2D Coordinates of a 3D Point](https://www.scratchapixel.com/lessons/3d-basic-rendering/computing-pixel-coordinates-of-3d-point/mathematics-computing-2d-coordinates-of-3d-points)\n[Scratchpixel-The Projection Stage](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/projection-stage)\n","slug":"光栅化渲染-2-透视投影","published":1,"updated":"2021-04-21T03:30:14.780Z","_id":"ck0uh6nm20021h8vnkgk9jnhm","comments":1,"layout":"post","photos":[],"link":""},{"title":"光栅化渲染(1)-算法总述","date":"2019-08-10T03:56:14.000Z","_content":"\n![discrete](/discrete.png)\n\n　　*光栅化也可以看做是针对由像素构成的平面的一种离散化。*\n<!--more-->\n\n# 光栅化算法\n　　光栅化渲染技术是一种十分常用的3D场景渲染技术。它同时也是GPU生成3D图形所采用的技术。\n　　光栅化的过程分为两个主要步骤：先将空间中的物体投影(透视投影)到成像平面上；再遍历图像中的每一个像素，检测是否在物体的投影区域内，如果在的话就用相应颜色填充该像素(Figure 1)。\n\n![Figure 1](/figure1.png)\n<center>Figure 1</center>\n\n　　*以上过程以三角面片为基本操作对象，三角面片由于几何求解方便一般作为构成3D物体的基本图元(Figure 2)。*\n\n![Figure 2](/figure2.jpg)\n<center>Figure 2</center>\n\n# Z-Buffer\n　　当有多个三角形相互重叠时，它们之上的某些点可能会投影到同一个像素位置，我们需要借助``z-buffer``来确定这种情况下像素用来显示哪个三角形的颜色（以及其它属性）。(Figure 3)\n\n![Figure 3](/figure3.png)\n<center>Figure 3</center>\n\n　　``z-buffer``其实就是一个二维矩阵，用来存储每个像素对应空间物体上某一点的深度。这样就可以在重叠的情况下找出距离相机最近的一点，用于像素的着色或其它属性操作。\n\n# 光栅化原理图\n　　其中``image-buffer``是一个二维数组，在之后的例子中用来保存每一个像素的颜色信息(RGB)，最后渲染结果以ppm（一种图片格式）的形式保存到本地。\n\n![Figure 4](/figure4.png)\n<center>Figure 4</center>\n\n# 参考链接\n\n[Scratchpixel-Rasterization: a Practical Implementation](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/overview-rasterization-algorithm)\n\n\n","source":"_posts/光栅化渲染-1-算法总述.md","raw":"---\ntitle: 光栅化渲染(1)-算法总述\ndate: 2019-08-10 11:56:14\ncategories:\n- Computer Graphics\n- 光栅化渲染\ntags:\n- Rasterization\n---\n\n![discrete](/discrete.png)\n\n　　*光栅化也可以看做是针对由像素构成的平面的一种离散化。*\n<!--more-->\n\n# 光栅化算法\n　　光栅化渲染技术是一种十分常用的3D场景渲染技术。它同时也是GPU生成3D图形所采用的技术。\n　　光栅化的过程分为两个主要步骤：先将空间中的物体投影(透视投影)到成像平面上；再遍历图像中的每一个像素，检测是否在物体的投影区域内，如果在的话就用相应颜色填充该像素(Figure 1)。\n\n![Figure 1](/figure1.png)\n<center>Figure 1</center>\n\n　　*以上过程以三角面片为基本操作对象，三角面片由于几何求解方便一般作为构成3D物体的基本图元(Figure 2)。*\n\n![Figure 2](/figure2.jpg)\n<center>Figure 2</center>\n\n# Z-Buffer\n　　当有多个三角形相互重叠时，它们之上的某些点可能会投影到同一个像素位置，我们需要借助``z-buffer``来确定这种情况下像素用来显示哪个三角形的颜色（以及其它属性）。(Figure 3)\n\n![Figure 3](/figure3.png)\n<center>Figure 3</center>\n\n　　``z-buffer``其实就是一个二维矩阵，用来存储每个像素对应空间物体上某一点的深度。这样就可以在重叠的情况下找出距离相机最近的一点，用于像素的着色或其它属性操作。\n\n# 光栅化原理图\n　　其中``image-buffer``是一个二维数组，在之后的例子中用来保存每一个像素的颜色信息(RGB)，最后渲染结果以ppm（一种图片格式）的形式保存到本地。\n\n![Figure 4](/figure4.png)\n<center>Figure 4</center>\n\n# 参考链接\n\n[Scratchpixel-Rasterization: a Practical Implementation](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/overview-rasterization-algorithm)\n\n\n","slug":"光栅化渲染-1-算法总述","published":1,"updated":"2021-04-21T03:30:14.780Z","_id":"ck0uh6nm30022h8vniui90ik2","comments":1,"layout":"post","photos":[],"link":""},{"title":"线段树区间更新模板","date":"2018-05-07T16:08:11.000Z","_content":"线段树区间更新中比较重要的一个概念是延迟标记，即lazy思想，当要对某一个区间中的所有节点进行更新时，先找到包含该区间所有节点的那一个（或多个）节点，只对它（们）进行更新，同时保存更新的值lazy。当进行区间查询时，若查询的区间的大小在lazy标记区间之内则直接返回，否则将lazy值向下进行传递，直到包含查询的区间。通过这种方式，可以用更新整个区间的值来代替更新区间中的每一个节点，从而避免了很多不必要的操作，提高了效率。说起来可能比较抽象，详见代码。\n[参考链接](https://www.zybuluo.com/lychee123/note/731591)\n<!-- more -->\n# 基于区间和的线段树区间更新模板\n```C++\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;//延迟标记\n}tree[maxn << 2];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;//延迟标记初始化为0\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n//更新下层区间的值，即将lazy向下进行传递，这里是区别于单点更新的最主要的地方\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);//区间长度乘以当前标记\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;//标记传递后清空为0\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\n```\n# 例题实现\n[POJ-3468--A Simple Problem with Integers](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nint n, q;\n\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;\n}tree[maxn << 2];\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n    pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n        return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    char s[10];\n    int a, b, c;\n    scanf(\"%d%d\", &n, &q);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", d + i);\n    build(1, 1, n);\n    while(q--){\n        scanf(\"%s\", s);\n        if(s[0] == 'Q'){\n            scanf(\"%d%d\", &a, &b);\n            printf(\"%lld\\n\", query(1, a, b));\n        }\n        else if(s[0] == 'C'){\n            scanf(\"%d%d%d\", &a, &b, &c);\n            update(1, a, b, c);\n        }\n    }\n\t\n    return 0;\n}\n\n```","source":"_posts/segtree-intval.md","raw":"---\ntitle: 线段树区间更新模板\ndate: 2018-05-08 00:08:11\ncategories:\n- Template\ntags:\n- 线段树区间更新\n---\n线段树区间更新中比较重要的一个概念是延迟标记，即lazy思想，当要对某一个区间中的所有节点进行更新时，先找到包含该区间所有节点的那一个（或多个）节点，只对它（们）进行更新，同时保存更新的值lazy。当进行区间查询时，若查询的区间的大小在lazy标记区间之内则直接返回，否则将lazy值向下进行传递，直到包含查询的区间。通过这种方式，可以用更新整个区间的值来代替更新区间中的每一个节点，从而避免了很多不必要的操作，提高了效率。说起来可能比较抽象，详见代码。\n[参考链接](https://www.zybuluo.com/lychee123/note/731591)\n<!-- more -->\n# 基于区间和的线段树区间更新模板\n```C++\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;//延迟标记\n}tree[maxn << 2];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;//延迟标记初始化为0\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n//更新下层区间的值，即将lazy向下进行传递，这里是区别于单点更新的最主要的地方\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);//区间长度乘以当前标记\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;//标记传递后清空为0\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\n```\n# 例题实现\n[POJ-3468--A Simple Problem with Integers](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nint n, q;\n\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;\n}tree[maxn << 2];\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n    pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n        return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    char s[10];\n    int a, b, c;\n    scanf(\"%d%d\", &n, &q);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", d + i);\n    build(1, 1, n);\n    while(q--){\n        scanf(\"%s\", s);\n        if(s[0] == 'Q'){\n            scanf(\"%d%d\", &a, &b);\n            printf(\"%lld\\n\", query(1, a, b));\n        }\n        else if(s[0] == 'C'){\n            scanf(\"%d%d%d\", &a, &b, &c);\n            update(1, a, b, c);\n        }\n    }\n\t\n    return 0;\n}\n\n```","slug":"segtree-intval","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nm30023h8vnwpth2rln","comments":1,"layout":"post","photos":[],"link":""},{"title":"二叉树中序和后序遍历->层序和先序遍历","date":"2018-09-21T16:39:20.000Z","_content":"给定一个二叉树的中序遍历和后序遍历求出其层序遍历和先序遍历。\n<!--more-->\n# 建成一棵二叉树\n```C++\nint in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];\n//把in_order[l1...r1]和post_order[l2...r2]建成一棵二叉树，返回树根\nint build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return 0;\n    int v = post_order[r2];\n    int pos = 0;\n    while(in_order[pos] != v) pos++;\n    int len = pos - l1;\n    lch[v] = build(l1, l1 + len - 1, l2, l2 + len - 1);\n    rch[v] = build(l1 + len + 1, r1, l2 + len, l2 - 1);\n    return v;\n}\n```\n# 层序遍历\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 21:39:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint in_order[maxn], post_order[maxn];\nstring line;\nint n;\nvector<int> vec[maxn];\n\nvoid read(int* s){\n    getline(cin, line);\n    stringstream ss;\n    ss.str(line);\n    n = 0;\n    int x;\n    \n    while(ss >> x){\n        s[n++] = x;\n    }\n}\n\nint findd(int x){\n    int i;\n    for(i = 0; i < n; i++){\n        if(in_order[i] == x) break;\n    }\n    return i;\n}\n\nvoid build(int l1, int r1, int l2, int r2, int l){\n    if(l1 > r1) return;\n    int v = post_order[r2];\n    vec[l].push_back(v);\n    int pos = findd(v);\n    int len = pos - l1;\n    build(l1, l1 + len - 1, l2, l2 + len - 1, l + 1);\n    build(l1 + len + 1, r1, l2 + len, r2 - 1, l + 1);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    read(in_order);\n    read(post_order);\n    build(0, n - 1, 0, n - 1, 0);\n    \n    for(int i = 0; i < n; i++){\n        for(size_t j = 0; j < vec[i].size(); j++){\n            if(i == 0 && j == 0) cout << vec[i][j];\n            else cout << \" \" << vec[i][j];\n        }\n    }\n    cout << endl;\n    return 0;\n}\n```\n# 先序遍历\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 21:39:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint in_order[maxn], post_order[maxn];\nstring line;\nint n;\nvector<int> vec;\n\nvoid read(int* s){\n    getline(cin, line);\n    stringstream ss;\n    ss.str(line);\n    n = 0;\n    int x;\n    \n    while(ss >> x){\n        s[n++] = x;\n    }\n}\n\nint findd(int x){\n    int i;\n    for(i = 0; i < n; i++){\n        if(in_order[i] == x) break;\n    }\n    return i;\n}\n\nvoid build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return;\n    int v = post_order[r2];\n    vec.push_back(v);\n    int pos = findd(v);\n    int len = pos - l1;\n    build(l1, l1 + len - 1, l2, l2 + len - 1);\n    build(l1 + len + 1, r1, l2 + len, r2 - 1);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    read(in_order);\n    read(post_order);\n    build(0, n - 1, 0, n - 1);\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n","source":"_posts/二叉树中序和后序遍历-层序和先序遍历.md","raw":"---\ntitle: 二叉树中序和后序遍历->层序和先序遍历\ndate: 2018-09-22 00:39:20\ncategories:\n- Template\ntags:\n- 二叉树\n---\n给定一个二叉树的中序遍历和后序遍历求出其层序遍历和先序遍历。\n<!--more-->\n# 建成一棵二叉树\n```C++\nint in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];\n//把in_order[l1...r1]和post_order[l2...r2]建成一棵二叉树，返回树根\nint build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return 0;\n    int v = post_order[r2];\n    int pos = 0;\n    while(in_order[pos] != v) pos++;\n    int len = pos - l1;\n    lch[v] = build(l1, l1 + len - 1, l2, l2 + len - 1);\n    rch[v] = build(l1 + len + 1, r1, l2 + len, l2 - 1);\n    return v;\n}\n```\n# 层序遍历\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 21:39:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint in_order[maxn], post_order[maxn];\nstring line;\nint n;\nvector<int> vec[maxn];\n\nvoid read(int* s){\n    getline(cin, line);\n    stringstream ss;\n    ss.str(line);\n    n = 0;\n    int x;\n    \n    while(ss >> x){\n        s[n++] = x;\n    }\n}\n\nint findd(int x){\n    int i;\n    for(i = 0; i < n; i++){\n        if(in_order[i] == x) break;\n    }\n    return i;\n}\n\nvoid build(int l1, int r1, int l2, int r2, int l){\n    if(l1 > r1) return;\n    int v = post_order[r2];\n    vec[l].push_back(v);\n    int pos = findd(v);\n    int len = pos - l1;\n    build(l1, l1 + len - 1, l2, l2 + len - 1, l + 1);\n    build(l1 + len + 1, r1, l2 + len, r2 - 1, l + 1);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    read(in_order);\n    read(post_order);\n    build(0, n - 1, 0, n - 1, 0);\n    \n    for(int i = 0; i < n; i++){\n        for(size_t j = 0; j < vec[i].size(); j++){\n            if(i == 0 && j == 0) cout << vec[i][j];\n            else cout << \" \" << vec[i][j];\n        }\n    }\n    cout << endl;\n    return 0;\n}\n```\n# 先序遍历\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 21:39:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint in_order[maxn], post_order[maxn];\nstring line;\nint n;\nvector<int> vec;\n\nvoid read(int* s){\n    getline(cin, line);\n    stringstream ss;\n    ss.str(line);\n    n = 0;\n    int x;\n    \n    while(ss >> x){\n        s[n++] = x;\n    }\n}\n\nint findd(int x){\n    int i;\n    for(i = 0; i < n; i++){\n        if(in_order[i] == x) break;\n    }\n    return i;\n}\n\nvoid build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return;\n    int v = post_order[r2];\n    vec.push_back(v);\n    int pos = findd(v);\n    int len = pos - l1;\n    build(l1, l1 + len - 1, l2, l2 + len - 1);\n    build(l1 + len + 1, r1, l2 + len, r2 - 1);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    read(in_order);\n    read(post_order);\n    build(0, n - 1, 0, n - 1);\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n","slug":"二叉树中序和后序遍历-层序和先序遍历","published":1,"updated":"2021-04-21T03:30:14.780Z","_id":"ck0uh6nm30024h8vntym945uw","comments":1,"layout":"post","photos":[],"link":""},{"title":"倒水问题","date":"2018-12-31T01:22:54.000Z","_content":"设有3个没有刻度的杯子的容量分别是a，b，c，最初只有第3个杯子装满了c升水，其他两个杯子为空。最少需要倒多少升水才能让某一个杯子中的水有d升。如果无法做到恰好有d升，就让某一个杯子里的水是d'升，其中d'< d，并且尽量接近d。\n<!--more-->\n\n# 解法\n解法和八数码问题一样，关键在于建立图模型，进行状态转移，把状态想象成图中的结点。\n![fill.png](/fill.png)\n问题形式有总倒水量最少和总步数最少。如果是总倒水量最少，可以用优先队列priority_queue来维护每个状态当前的总倒水量；如果是总步数最少，就可以用队列来维护状态，采用BFS进行搜索。\n\n# 总倒水量最少\n\n题目链接[Uva10603-Fill](https://vjudge.net/problem/UVA-10603)\n\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu 27 Dec 11:54:46 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200 + 7;\nint T;\nstruct Node{\n    int v[3];\n    int vol;\n    bool operator < (const Node& nd) const {\n        return vol > nd.vol;\n    }\n};\nint ans[maxn];\nbool vis[maxn][maxn];\nint cap[3];\n\nvoid update_ans(Node nd){\n    for(int i = 0; i < 3; i++){\n        int d = nd.v[i];\n        if(ans[d] < 0 || nd.vol < ans[d]) ans[d] = nd.vol;\n    }\n}\n\nvoid solve(int a, int b, int c, int d){\n    priority_queue<Node> q;\n    Node FirstItem;\n    FirstItem.v[0] = 0, FirstItem.v[1] = 0, FirstItem.v[2] = c;\n    FirstItem.vol = 0;\n    q.push(FirstItem);\n    vis[0][0] = 1;\n    while(!q.empty()){\n        Node nd = q.top();\n        q.pop();\n        update_ans(nd);\n        if(ans[d] >= 0) break;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                if(i == j) continue;\n                if(nd.v[i] == 0 || nd.v[j] == cap[j]) continue;\n                int amount = min(cap[j], nd.v[i] + nd.v[j]) - nd.v[j];\n                Node NewItem;\n                memcpy(&NewItem, &nd, sizeof(NewItem));\n                NewItem.v[i] -= amount;\n                NewItem.v[j] += amount;\n                NewItem.vol += amount;\n                if(!vis[NewItem.v[0]][NewItem.v[1]]){\n                    q.push(NewItem);\n                    vis[NewItem.v[0]][NewItem.v[1]] = 1;\n                }\n            }\n        }\n    }\n    for(int i = d; i >= 0; i--){\n        if(ans[i] >= 0){\n            cout << ans[i] << \" \" << i << endl;\n            break;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    cin >> T;\n    while(T--){\n        memset(vis, 0, sizeof(vis));\n        memset(ans, -1, sizeof(ans));\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        cap[0] = a, cap[1] = b, cap[2] = c;\n        solve(a, b, c, d);\n    }\n    return 0;\n}\n```\n\n# 总步数最少\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 31 Dec 09:44:46 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200 + 7;\nstruct Node{\n    int v[3];\n    int dis;\n};\nint cap[3];\nbool vis[maxn][maxn];\nint ans[maxn];\n\nvoid update_ans(Node& u){\n    for(int i = 0; i < 3; i++){\n        int d = u.v[i];\n        if(ans[d] < 0 || u.dis < ans[d]) ans[d] = u.dis;\n    }\n}\n\nvoid solve(int a, int b, int c, int d){\n    queue<Node> que;\n    Node FirstItem;\n    FirstItem.v[0] = 0, FirstItem.v[1] = 0, FirstItem.v[2] = c;\n    FirstItem.dis = 0;\n    que.push(FirstItem);\n    vis[0][0] = 1;\n\n    while(!que.empty()){\n        Node nd = que.front();\n        que.pop();\n        update_ans(nd);\n        if(ans[d] >= 0) break;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                if(i == j) continue;\n                if(nd.v[i] == 0 || nd.v[j] == cap[j]) continue;\n                int amount = min(cap[j], nd.v[i] + nd.v[j]) - nd.v[j];\n                Node NewItem;\n                memcpy(NewItem.v, nd.v, sizeof(NewItem.v));\n                NewItem.v[i] -= amount;\n                NewItem.v[j] += amount;\n                NewItem.dis = nd.dis + 1;\n                if(!vis[NewItem.v[0]][NewItem.v[1]]){\n                    que.push(NewItem);\n                    vis[NewItem.v[0]][NewItem.v[1]] = 1;\n                }\n            }\n        }\n    }\n\n    for(int i = d; i >= 0; i--){\n        if(ans[i] >= 0){\n            cout << ans[i] << \" \" << i << endl;\n            break;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    memset(vis, 0, sizeof(vis));\n    memset(ans, -1, sizeof(ans));\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    cap[0] = a, cap[1] = b, cap[2] = c;\n    solve(a, b, c, d);\n\n    return 0;\n}\n```","source":"_posts/倒水问题.md","raw":"---\ntitle: 倒水问题\ndate: 2018-12-31 09:22:54\ncategories:\n- Summary\ntags:\n- 状态转移\n---\n设有3个没有刻度的杯子的容量分别是a，b，c，最初只有第3个杯子装满了c升水，其他两个杯子为空。最少需要倒多少升水才能让某一个杯子中的水有d升。如果无法做到恰好有d升，就让某一个杯子里的水是d'升，其中d'< d，并且尽量接近d。\n<!--more-->\n\n# 解法\n解法和八数码问题一样，关键在于建立图模型，进行状态转移，把状态想象成图中的结点。\n![fill.png](/fill.png)\n问题形式有总倒水量最少和总步数最少。如果是总倒水量最少，可以用优先队列priority_queue来维护每个状态当前的总倒水量；如果是总步数最少，就可以用队列来维护状态，采用BFS进行搜索。\n\n# 总倒水量最少\n\n题目链接[Uva10603-Fill](https://vjudge.net/problem/UVA-10603)\n\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu 27 Dec 11:54:46 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200 + 7;\nint T;\nstruct Node{\n    int v[3];\n    int vol;\n    bool operator < (const Node& nd) const {\n        return vol > nd.vol;\n    }\n};\nint ans[maxn];\nbool vis[maxn][maxn];\nint cap[3];\n\nvoid update_ans(Node nd){\n    for(int i = 0; i < 3; i++){\n        int d = nd.v[i];\n        if(ans[d] < 0 || nd.vol < ans[d]) ans[d] = nd.vol;\n    }\n}\n\nvoid solve(int a, int b, int c, int d){\n    priority_queue<Node> q;\n    Node FirstItem;\n    FirstItem.v[0] = 0, FirstItem.v[1] = 0, FirstItem.v[2] = c;\n    FirstItem.vol = 0;\n    q.push(FirstItem);\n    vis[0][0] = 1;\n    while(!q.empty()){\n        Node nd = q.top();\n        q.pop();\n        update_ans(nd);\n        if(ans[d] >= 0) break;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                if(i == j) continue;\n                if(nd.v[i] == 0 || nd.v[j] == cap[j]) continue;\n                int amount = min(cap[j], nd.v[i] + nd.v[j]) - nd.v[j];\n                Node NewItem;\n                memcpy(&NewItem, &nd, sizeof(NewItem));\n                NewItem.v[i] -= amount;\n                NewItem.v[j] += amount;\n                NewItem.vol += amount;\n                if(!vis[NewItem.v[0]][NewItem.v[1]]){\n                    q.push(NewItem);\n                    vis[NewItem.v[0]][NewItem.v[1]] = 1;\n                }\n            }\n        }\n    }\n    for(int i = d; i >= 0; i--){\n        if(ans[i] >= 0){\n            cout << ans[i] << \" \" << i << endl;\n            break;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    cin >> T;\n    while(T--){\n        memset(vis, 0, sizeof(vis));\n        memset(ans, -1, sizeof(ans));\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        cap[0] = a, cap[1] = b, cap[2] = c;\n        solve(a, b, c, d);\n    }\n    return 0;\n}\n```\n\n# 总步数最少\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 31 Dec 09:44:46 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200 + 7;\nstruct Node{\n    int v[3];\n    int dis;\n};\nint cap[3];\nbool vis[maxn][maxn];\nint ans[maxn];\n\nvoid update_ans(Node& u){\n    for(int i = 0; i < 3; i++){\n        int d = u.v[i];\n        if(ans[d] < 0 || u.dis < ans[d]) ans[d] = u.dis;\n    }\n}\n\nvoid solve(int a, int b, int c, int d){\n    queue<Node> que;\n    Node FirstItem;\n    FirstItem.v[0] = 0, FirstItem.v[1] = 0, FirstItem.v[2] = c;\n    FirstItem.dis = 0;\n    que.push(FirstItem);\n    vis[0][0] = 1;\n\n    while(!que.empty()){\n        Node nd = que.front();\n        que.pop();\n        update_ans(nd);\n        if(ans[d] >= 0) break;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                if(i == j) continue;\n                if(nd.v[i] == 0 || nd.v[j] == cap[j]) continue;\n                int amount = min(cap[j], nd.v[i] + nd.v[j]) - nd.v[j];\n                Node NewItem;\n                memcpy(NewItem.v, nd.v, sizeof(NewItem.v));\n                NewItem.v[i] -= amount;\n                NewItem.v[j] += amount;\n                NewItem.dis = nd.dis + 1;\n                if(!vis[NewItem.v[0]][NewItem.v[1]]){\n                    que.push(NewItem);\n                    vis[NewItem.v[0]][NewItem.v[1]] = 1;\n                }\n            }\n        }\n    }\n\n    for(int i = d; i >= 0; i--){\n        if(ans[i] >= 0){\n            cout << ans[i] << \" \" << i << endl;\n            break;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    memset(vis, 0, sizeof(vis));\n    memset(ans, -1, sizeof(ans));\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    cap[0] = a, cap[1] = b, cap[2] = c;\n    solve(a, b, c, d);\n\n    return 0;\n}\n```","slug":"倒水问题","published":1,"updated":"2021-04-21T03:30:14.780Z","_id":"ck0uh6nm40025h8vnao2d17ha","comments":1,"layout":"post","photos":[],"link":""},{"title":"Binary Search以及lower_bound & upper_bound实现","date":"2019-07-27T07:22:51.000Z","_content":"![BinarySearch](/BinarySearch.jpeg)\n<!--more-->\n\n# Binary Search\n　　在数组 $A$ 的 $[x, y)$ 区间中查找值 $v$，并返回其位置下标，若不存在则返回 $-1$。\n\n```C++\nint bsearch(int *A, int x, int y, int v){\n    int m;\n    while(x < y){\n        m = x + (y - x) / 2;\n        if(A[m] == v) return m;\n        else if(A[m] > v) y = m;\n        else x = m + 1;\n    }\n\n    return -1;\n}\n```\n\n# lower_bound\n　　当 $v$ 存在时返回它出现的第一个位置；如果不存在，返回这样一个下标 $i$：在此处插入 $v$ 后序列仍然有序。\n\n```C++\nint lower_bound(int *A, int x, int y, int v){\n    int m;\n    while(x < y){\n        m = x + (y - x) / 2;\n        if(A[m] >= v) y = m;\n        else x = m + 1;\n    }\n\n    return x;\n}\n```\n　　最后的返回值不仅可能是 $x, x + 1, x + 2, ..., y - 1$ 中的一个，还可能是 $y$，如果 $v$ 大于 $A[y-1]$ 就只能插入这里了。这样，这样尽管查找区间是左闭右开区间 $[x, y)$，返回值的候选区间却是闭区间 $[x, y]$。\n\n- A[m] = v：至少已经找到一个v，而左边可能还有，因此区间变为[x, m]。\n- A[m] > v：所求位置不可能在后面，但有可能是m，因此区间变为[x, m]。\n- A[m] < v：m和前面都不可行，因此区间变为[m + 1, y]。\n\n# upper_bound\n　　当 $v$ 存在时返回它出现的最后一个位置的后面一个位置；如果不存在，返回这样一个下标 $i$：在此处插入 $v$ 后序列仍然有序。\n\n```C++\nint upper_bound(int *A, int x, int y, int v){\n    int m;\n    while(x < y){\n        m = x + (y - x) / 2;\n        if(A[m] > v) y = m;\n        else x = m + 1; \n    }\n\n    return x;\n}\n```\n\n# 参考\n\n《算法竞赛入门经典（第2版）》","source":"_posts/二分查找以及lower-bound-upper-bound实现.md","raw":"---\ntitle: Binary Search以及lower_bound & upper_bound实现\ndate: 2019-07-27 15:22:51\ncategories:\n- Template\ntags:\n- Binary Search\n---\n![BinarySearch](/BinarySearch.jpeg)\n<!--more-->\n\n# Binary Search\n　　在数组 $A$ 的 $[x, y)$ 区间中查找值 $v$，并返回其位置下标，若不存在则返回 $-1$。\n\n```C++\nint bsearch(int *A, int x, int y, int v){\n    int m;\n    while(x < y){\n        m = x + (y - x) / 2;\n        if(A[m] == v) return m;\n        else if(A[m] > v) y = m;\n        else x = m + 1;\n    }\n\n    return -1;\n}\n```\n\n# lower_bound\n　　当 $v$ 存在时返回它出现的第一个位置；如果不存在，返回这样一个下标 $i$：在此处插入 $v$ 后序列仍然有序。\n\n```C++\nint lower_bound(int *A, int x, int y, int v){\n    int m;\n    while(x < y){\n        m = x + (y - x) / 2;\n        if(A[m] >= v) y = m;\n        else x = m + 1;\n    }\n\n    return x;\n}\n```\n　　最后的返回值不仅可能是 $x, x + 1, x + 2, ..., y - 1$ 中的一个，还可能是 $y$，如果 $v$ 大于 $A[y-1]$ 就只能插入这里了。这样，这样尽管查找区间是左闭右开区间 $[x, y)$，返回值的候选区间却是闭区间 $[x, y]$。\n\n- A[m] = v：至少已经找到一个v，而左边可能还有，因此区间变为[x, m]。\n- A[m] > v：所求位置不可能在后面，但有可能是m，因此区间变为[x, m]。\n- A[m] < v：m和前面都不可行，因此区间变为[m + 1, y]。\n\n# upper_bound\n　　当 $v$ 存在时返回它出现的最后一个位置的后面一个位置；如果不存在，返回这样一个下标 $i$：在此处插入 $v$ 后序列仍然有序。\n\n```C++\nint upper_bound(int *A, int x, int y, int v){\n    int m;\n    while(x < y){\n        m = x + (y - x) / 2;\n        if(A[m] > v) y = m;\n        else x = m + 1; \n    }\n\n    return x;\n}\n```\n\n# 参考\n\n《算法竞赛入门经典（第2版）》","slug":"二分查找以及lower-bound-upper-bound实现","published":1,"updated":"2021-04-21T03:30:14.780Z","_id":"ck0uh6nm40026h8vnwg3ip6v2","comments":1,"layout":"post","photos":[],"link":""},{"title":"光栅化渲染(5)-透视矫正","date":"2019-09-02T12:57:17.000Z","_content":"\n　　*由于投影后比例的变化，在成像平面上插值计算出的颜色等属性值实际上也是存在偏差的。*\n<!--more-->\n\n# 透视矫正\n　　前面我们提到可以用重心坐标的方法来对三角形内部的点做属性的插值，来赋予各个像素相应的颜色等属性：\n\n$$\nC_p = \\lambda_0 * C_0 + \\lambda_1 * C_1 + \\lambda_2 * C_2\n$$\n\n　　其中$(\\lambda_0, \\lambda_1, \\lambda_2)$为投影平面上插值这一点的重心坐标。\n\n　　但是在[深度检测](https://ain-crad.github.io/2019/08/27/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-4-%E6%B7%B1%E5%BA%A6%E6%A3%80%E6%B5%8B/#more)中我们考虑到由于投影后的比例变化，所以我们不能把投影平面上三角形某点的重心坐标直接作为空间三角形上对应点的重心坐标（Figure 1)。**因此上面的颜色插值实际上也是存在偏差的。**\n\n![figure 1](/figure1.png)\n<center>Figure 1</center>\n\n　　我们通过投影平面上三角形的重心坐标推出了计算对应空间点深度的公式：\n\n$$\n\\cfrac{1}{Z} = \\cfrac{1}{Z_0}(1 - q) + \\cfrac{1}{Z_1}q\n$$\n\n　　现在我们可以通过深度来得到**矫正后的**颜色、纹理、法向量等其它空间点的属性（*以颜色为例推导*）。\n　　如图（Figure 2），假设三角形上两点的深度分别为 $Z_0$ 和 $Z_1$，它们的颜色属性分别为 $C_0$ 和 $C_1$，连接这两点，我们可以对连线上的任意一点做深度和颜色的插值。\n\n![figure 2](/figure2.png)\n<center>Figure 2</center>\n\n　　由于深度和颜色除了*属性名称*外没有什么不同，所以它们的插值应该是相互之间成比例的（Equation 1）：\n\n$$\n\\cfrac{Z-Z_0}{Z_1-Z_0} = \\cfrac{C-C_0}{C_1-C_0}\n$$\n\n　　由深度公式我们可以得到 $Z$ 的表达式（Equation 2）：\n\n$$\nZ = \\cfrac{1}{\\cfrac{1}{Z_0}(1 - q) + \\cfrac{1}{Z_1}q}\n$$\n\n　　把（Equation 2）带入（Equation 1）左式中化简得：\n\n![formula1](/formula1.png)\n\n　　现在我们可以求得 $C$ 的表达式：\n\n![formula2](/formula2.png)\n\n　　进一步我们可以从右式中提出 $Z$，得到更简洁的形式：\n\n![formula3](/formula3.png)\n\n　　**至此，我们得到了矫正后的颜色属性。**同样的方法可以用来矫正插值点的纹理坐标、法向量等其它属性。","source":"_posts/光栅化渲染-5-透视矫正.md","raw":"---\ntitle: 光栅化渲染(5)-透视矫正\ndate: 2019-09-02 20:57:17\ncategories:\n- Computer Graphics\n- 光栅化渲染\ntags:\n---\n\n　　*由于投影后比例的变化，在成像平面上插值计算出的颜色等属性值实际上也是存在偏差的。*\n<!--more-->\n\n# 透视矫正\n　　前面我们提到可以用重心坐标的方法来对三角形内部的点做属性的插值，来赋予各个像素相应的颜色等属性：\n\n$$\nC_p = \\lambda_0 * C_0 + \\lambda_1 * C_1 + \\lambda_2 * C_2\n$$\n\n　　其中$(\\lambda_0, \\lambda_1, \\lambda_2)$为投影平面上插值这一点的重心坐标。\n\n　　但是在[深度检测](https://ain-crad.github.io/2019/08/27/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-4-%E6%B7%B1%E5%BA%A6%E6%A3%80%E6%B5%8B/#more)中我们考虑到由于投影后的比例变化，所以我们不能把投影平面上三角形某点的重心坐标直接作为空间三角形上对应点的重心坐标（Figure 1)。**因此上面的颜色插值实际上也是存在偏差的。**\n\n![figure 1](/figure1.png)\n<center>Figure 1</center>\n\n　　我们通过投影平面上三角形的重心坐标推出了计算对应空间点深度的公式：\n\n$$\n\\cfrac{1}{Z} = \\cfrac{1}{Z_0}(1 - q) + \\cfrac{1}{Z_1}q\n$$\n\n　　现在我们可以通过深度来得到**矫正后的**颜色、纹理、法向量等其它空间点的属性（*以颜色为例推导*）。\n　　如图（Figure 2），假设三角形上两点的深度分别为 $Z_0$ 和 $Z_1$，它们的颜色属性分别为 $C_0$ 和 $C_1$，连接这两点，我们可以对连线上的任意一点做深度和颜色的插值。\n\n![figure 2](/figure2.png)\n<center>Figure 2</center>\n\n　　由于深度和颜色除了*属性名称*外没有什么不同，所以它们的插值应该是相互之间成比例的（Equation 1）：\n\n$$\n\\cfrac{Z-Z_0}{Z_1-Z_0} = \\cfrac{C-C_0}{C_1-C_0}\n$$\n\n　　由深度公式我们可以得到 $Z$ 的表达式（Equation 2）：\n\n$$\nZ = \\cfrac{1}{\\cfrac{1}{Z_0}(1 - q) + \\cfrac{1}{Z_1}q}\n$$\n\n　　把（Equation 2）带入（Equation 1）左式中化简得：\n\n![formula1](/formula1.png)\n\n　　现在我们可以求得 $C$ 的表达式：\n\n![formula2](/formula2.png)\n\n　　进一步我们可以从右式中提出 $Z$，得到更简洁的形式：\n\n![formula3](/formula3.png)\n\n　　**至此，我们得到了矫正后的颜色属性。**同样的方法可以用来矫正插值点的纹理坐标、法向量等其它属性。","slug":"光栅化渲染-5-透视矫正","published":1,"updated":"2019-09-21T03:54:18.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0uh6nm50027h8vns1jragv9","content":"<p>　　<em>由于投影后比例的变化，在成像平面上插值计算出的颜色等属性值实际上也是存在偏差的。</em></p>\n<a id=\"more\"></a>\n\n<h1 id=\"透视矫正\"><a href=\"#透视矫正\" class=\"headerlink\" title=\"透视矫正\"></a>透视矫正</h1><p>　　前面我们提到可以用重心坐标的方法来对三角形内部的点做属性的插值，来赋予各个像素相应的颜色等属性：</p>\n<p>$$<br>C_p = \\lambda_0 * C_0 + \\lambda_1 * C_1 + \\lambda_2 * C_2<br>$$</p>\n<p>　　其中$(\\lambda_0, \\lambda_1, \\lambda_2)$为投影平面上插值这一点的重心坐标。</p>\n<p>　　但是在<a href=\"https://ain-crad.github.io/2019/08/27/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-4-%E6%B7%B1%E5%BA%A6%E6%A3%80%E6%B5%8B/#more\" target=\"_blank\" rel=\"noopener\">深度检测</a>中我们考虑到由于投影后的比例变化，所以我们不能把投影平面上三角形某点的重心坐标直接作为空间三角形上对应点的重心坐标（Figure 1)。<strong>因此上面的颜色插值实际上也是存在偏差的。</strong></p>\n<p><img src=\"/2019/09/02/光栅化渲染-5-透视矫正/figure1.png\" alt=\"figure 1\"></p>\n<center>Figure 1</center>\n\n<p>　　我们通过投影平面上三角形的重心坐标推出了计算对应空间点深度的公式：</p>\n<p>$$<br>\\cfrac{1}{Z} = \\cfrac{1}{Z_0}(1 - q) + \\cfrac{1}{Z_1}q<br>$$</p>\n<p>　　现在我们可以通过深度来得到<strong>矫正后的</strong>颜色、纹理、法向量等其它空间点的属性（<em>以颜色为例推导</em>）。<br>　　如图（Figure 2），假设三角形上两点的深度分别为 $Z_0$ 和 $Z_1$，它们的颜色属性分别为 $C_0$ 和 $C_1$，连接这两点，我们可以对连线上的任意一点做深度和颜色的插值。</p>\n<p><img src=\"/2019/09/02/光栅化渲染-5-透视矫正/figure2.png\" alt=\"figure 2\"></p>\n<center>Figure 2</center>\n\n<p>　　由于深度和颜色除了<em>属性名称</em>外没有什么不同，所以它们的插值应该是相互之间成比例的（Equation 1）：</p>\n<p>$$<br>\\cfrac{Z-Z_0}{Z_1-Z_0} = \\cfrac{C-C_0}{C_1-C_0}<br>$$</p>\n<p>　　由深度公式我们可以得到 $Z$ 的表达式（Equation 2）：</p>\n<p>$$<br>Z = \\cfrac{1}{\\cfrac{1}{Z_0}(1 - q) + \\cfrac{1}{Z_1}q}<br>$$</p>\n<p>　　把（Equation 2）带入（Equation 1）左式中化简得：</p>\n<p><img src=\"/2019/09/02/光栅化渲染-5-透视矫正/formula1.png\" alt=\"formula1\"></p>\n<p>　　现在我们可以求得 $C$ 的表达式：</p>\n<p><img src=\"/2019/09/02/光栅化渲染-5-透视矫正/formula2.png\" alt=\"formula2\"></p>\n<p>　　进一步我们可以从右式中提出 $Z$，得到更简洁的形式：</p>\n<p><img src=\"/2019/09/02/光栅化渲染-5-透视矫正/formula3.png\" alt=\"formula3\"></p>\n<p>　　<strong>至此，我们得到了矫正后的颜色属性。</strong>同样的方法可以用来矫正插值点的纹理坐标、法向量等其它属性。</p>\n","site":{"data":{}},"excerpt":"<p>　　<em>由于投影后比例的变化，在成像平面上插值计算出的颜色等属性值实际上也是存在偏差的。</em></p>","more":"<h1 id=\"透视矫正\"><a href=\"#透视矫正\" class=\"headerlink\" title=\"透视矫正\"></a>透视矫正</h1><p>　　前面我们提到可以用重心坐标的方法来对三角形内部的点做属性的插值，来赋予各个像素相应的颜色等属性：</p>\n<p>$$<br>C_p = \\lambda_0 * C_0 + \\lambda_1 * C_1 + \\lambda_2 * C_2<br>$$</p>\n<p>　　其中$(\\lambda_0, \\lambda_1, \\lambda_2)$为投影平面上插值这一点的重心坐标。</p>\n<p>　　但是在<a href=\"https://ain-crad.github.io/2019/08/27/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-4-%E6%B7%B1%E5%BA%A6%E6%A3%80%E6%B5%8B/#more\" target=\"_blank\" rel=\"noopener\">深度检测</a>中我们考虑到由于投影后的比例变化，所以我们不能把投影平面上三角形某点的重心坐标直接作为空间三角形上对应点的重心坐标（Figure 1)。<strong>因此上面的颜色插值实际上也是存在偏差的。</strong></p>\n<p><img src=\"/2019/09/02/光栅化渲染-5-透视矫正/figure1.png\" alt=\"figure 1\"></p>\n<center>Figure 1</center>\n\n<p>　　我们通过投影平面上三角形的重心坐标推出了计算对应空间点深度的公式：</p>\n<p>$$<br>\\cfrac{1}{Z} = \\cfrac{1}{Z_0}(1 - q) + \\cfrac{1}{Z_1}q<br>$$</p>\n<p>　　现在我们可以通过深度来得到<strong>矫正后的</strong>颜色、纹理、法向量等其它空间点的属性（<em>以颜色为例推导</em>）。<br>　　如图（Figure 2），假设三角形上两点的深度分别为 $Z_0$ 和 $Z_1$，它们的颜色属性分别为 $C_0$ 和 $C_1$，连接这两点，我们可以对连线上的任意一点做深度和颜色的插值。</p>\n<p><img src=\"/2019/09/02/光栅化渲染-5-透视矫正/figure2.png\" alt=\"figure 2\"></p>\n<center>Figure 2</center>\n\n<p>　　由于深度和颜色除了<em>属性名称</em>外没有什么不同，所以它们的插值应该是相互之间成比例的（Equation 1）：</p>\n<p>$$<br>\\cfrac{Z-Z_0}{Z_1-Z_0} = \\cfrac{C-C_0}{C_1-C_0}<br>$$</p>\n<p>　　由深度公式我们可以得到 $Z$ 的表达式（Equation 2）：</p>\n<p>$$<br>Z = \\cfrac{1}{\\cfrac{1}{Z_0}(1 - q) + \\cfrac{1}{Z_1}q}<br>$$</p>\n<p>　　把（Equation 2）带入（Equation 1）左式中化简得：</p>\n<p><img src=\"/2019/09/02/光栅化渲染-5-透视矫正/formula1.png\" alt=\"formula1\"></p>\n<p>　　现在我们可以求得 $C$ 的表达式：</p>\n<p><img src=\"/2019/09/02/光栅化渲染-5-透视矫正/formula2.png\" alt=\"formula2\"></p>\n<p>　　进一步我们可以从右式中提出 $Z$，得到更简洁的形式：</p>\n<p><img src=\"/2019/09/02/光栅化渲染-5-透视矫正/formula3.png\" alt=\"formula3\"></p>\n<p>　　<strong>至此，我们得到了矫正后的颜色属性。</strong>同样的方法可以用来矫正插值点的纹理坐标、法向量等其它属性。</p>"},{"title":"光栅化渲染-6-透视投影矩阵","date":"2019-09-20T13:29:19.000Z","_content":"\n　　*GPU结构被设计的非常适合矩阵运算，把透视投影过程用矩阵表达出来可以加速计算。*\n<!--more-->\n\n# Unit Cube\n　　在讨论如何构造透视投影矩阵之前，我们先了解透视投影的作用（效果）。空间中一点 $P$ 乘以透视投影矩阵后，我们会得到一点 $P^\\prime$：\n\n- 它的 x' 坐标和 y' 坐标的范围是 [-1, 1]，即定义在 NDC 空间下。\n- 它的 z' 坐标的范围同样被压缩到 [-1, 1] 的范围内，边界分别为近剪切平面和远剪切平面。\n\n　　如（Figure 1）所示，这样做的效果从空间中来看，其实是把相机坐标系下的**视棱台**(viewing frustum)压缩成了**立方体**(unit cube)。\n\n![figure1](/figure1.png)\n<center>Figure 1</center>\n\n　　而这样做的目的是为了方便做**剪切(clipping)**。一方面去除那些在视野范围之外的图元（不必浪费资源渲染它们），另一方面对那些一部分在视野内一部分在视野外的图元做修剪（Figure 2）。\n\n![figure2](/figure2.png)\n<center>Figure 2</center>\n\n``这里有一个剪切空间(Clip Space)的概念，与 NDC 空间不同。我们稍后再做介绍 。``\n\n# 透视投影矩阵\n　　现在我们可以开始构造透视投影矩阵了。回顾一下之前的透视投影的内容，相机空间中的点投影到成像平面上（Figure 3）的变化为：\n\n![figure 3](/figure3.png)\n<center>Figure 3</center>\n\n$$\nP_{S_x} = \\cfrac{n * P_x}{-P_z} \\\\\\\\\nP_{S_y} = \\cfrac{n * P_y}{-P_z}\n$$\n\n　　我们发现计算投影要除以 $P_z$ 坐标，但这是矩阵的线性变换做不到的，矩阵只能线性的组合 $P_x$，$P_y$，$P_z$ 来得到 $P_{S_x}$，$P_{S_y}$，$P_{S_z}$，于是我们引入**其次坐标**，将空间点扩充为 $[P_x, P_y, P_z, P_w = 1]$。\n　　同时对矩阵做特定设定，使其将转换后的 $P_{S_w}$ 分量设置为 $-P_z$，这样通过 $[P_{S_x}, P_{S_y}, P_{S_z}, P_{S_w}]$ 整体除以 $P_{S_w}$ 分量便实现了除法变换。\n\n$$\n\\left[\n    \\begin{matrix}\n        ... & ... & ... & ... \\\\\\\\\n        ... & ... & ... & ... \\\\\\\\\n        ... & ... & ... & ... \\\\\\\\\n        0 & 0 & -1 & 0\n    \\end{matrix}\n\\right]\n\\*\n\\left[\n    \\begin{matrix}\n        P_x \\\\\\\\\n        P_y \\\\\\\\\n        P_z \\\\\\\\\n        1\n    \\end{matrix}\n\\right]\n= \n\\left[\n    \\begin{matrix}\n        P_{S_x} \\\\\\\\\n        P_{S_y} \\\\\\\\\n        P_{S_z} \\\\\\\\\n        -P_z\n    \\end{matrix}\n\\right]\n$$\n\n　　接下来继续构造其它分量，假设成像平面坐标系的 $x$ 坐标范围为 $[l, r]$，$y$ 坐标范围为 $[b, t]$，近剪切平面和远剪切平面分别为 $n, f$。\n　　由[透视投影的拓展内容](https://ain-crad.github.io/2019/08/11/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-2-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1/#more)中我们知道，若要使相机坐标 $P_x$ 变换到屏幕坐标 $P_{S_x}$ 且范围为 $[-1, 1]$，那么\n\n$$\nP_{S_x} = \\cfrac{2nP_x}{-P_z(r-l)}-\\cfrac{r+l}{r-l}\n$$\n\n　　由于 $\\cfrac{1}{-P_z}$ 部分可以除以 $P_{S_w}$ 分量得到，所以矩阵的形式可以构造为：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2n}{r-l} & 0 & \\cfrac{r+l}{r-l} & 0 \\\\\\\\\n        ... & ... & ... & ... \\\\\\\\\n        ... & ... & ... & ... \\\\\\\\\n        0 & 0 & -1 & 0\n    \\end{matrix}\n\\right]\n$$\n\n　　同理\n\n$$\nP_{S_y} = \\cfrac{2nP_y}{-P_z(t-b)}-\\cfrac{t+b}{t-b}\n$$\n\n　　进一步扩充矩阵\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2n}{r-l} & 0 & \\cfrac{r+l}{r-l} & 0 \\\\\\\\\n        0 & \\cfrac{2n}{t-b} & \\cfrac{t+b}{t-b} & 0 \\\\\\\\\n        ... & ... & ... & ... \\\\\\\\\n        0 & 0 & -1 & 0\n    \\end{matrix}\n\\right]\n$$\n\n　　现在只需要构造出 $P_z$ 分量部分的矩阵，使变换后的 $P_{S_z}$ 的范围为 $[-1, 1]$，由于 $P_{S_z}$ 和 $P_x, P_y$ 分量都无关，因此矩阵可以写成如下形式：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2n}{r-l} & 0 & \\cfrac{r+l}{r-l} & 0 \\\\\\\\\n        0 & \\cfrac{2n}{t-b} & \\cfrac{t+b}{t-b} & 0 \\\\\\\\\n        0 & 0 & A & B \\\\\\\\\n        0 & 0 & -1 & 0\n    \\end{matrix}\n\\right]\n$$\n\n　　$A$ 和 $B$ 是我们待求解的部分，它们满足：\n\n![equation 1](/equation1.png)\n\n　　当 $P_z = -n$ 即点 $P$ 在近平面上时，$P_{S_z} = -1$；当 $P_z = -f$ 即点 $P$ 在远平面上时，$P_{S_z} = 1$。所以可以得到下面的方程组：\n\n![equation 2](/equation2.png)\n\n　　解方程组得：\n\n$$\nA = -\\cfrac{f+n}{f-n} \\\\\\\\\nB = -\\cfrac{2fn}{f-n}\n$$\n\n　　于是我们就得到了最终的透视投影矩阵：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2n}{r-l} & 0 & \\cfrac{r+l}{r-l} & 0 \\\\\\\\\n        0 & \\cfrac{2n}{t-b} & \\cfrac{t+b}{t-b} & 0 \\\\\\\\\n        0 & 0 & -\\cfrac{f+n}{f-n} & -\\cfrac{2fn}{f-n} \\\\\\\\\n        0 & 0 & -1 & 0\n    \\end{matrix}\n\\right]\n$$\n   \n　　由于 $P_z$ 映射到 $[-1, 1]$ 的变化不是线性的，靠近近剪切平面的点的精度高，靠近远剪切平面的点的精度低（Figure 4），图中 $n = 1$，$f = 5$。\n\n![figure4](/figure4.png)\n<center>Figure 4</center>\n\n　　当精度过低时，可能会出现 **z-fighting** 的现象，即不同 $P_z$ 坐标的点映射到 $P_{S_z}$ 是相同的。这个问题无法被真正解决，我们只能通过使两个剪切平面之间的距离在包含所有物体的前提下尽可能的接近，来尽量避免 **z-fighting** 的问题。（Figure 5）\n\n![figure5](/figure5.png)\n<center>Figure 5</center>\n\n# 视场（Fov）和图像纵横比（Aspect Ratio）\n　　求解透视投影矩阵时用到了6个参数 **near，far，left，right，top，bottom**。其中 near 和 far 是人为指定的，而剩下的4个参数则是由**视场(Fov)**以及**图像纵横比(Aspect Ratio)**决定的（Figure 6）。\n\n![figure 6](/figure6.png)\n<center>Figure 6</center>\n\n　　由简单的比例关系可以得到：\n\n$$\ntan(\\cfrac{FOV}{2}) = \\cfrac{opposite}{adjacent} = \\cfrac{BC}{AB} = \\cfrac{top}{near}\n$$\n\n　　因此\n\n$$\n\\begin{align}\n&top = tan(\\cfrac{FOV}{2})*near \\\\\\\\\n&bottom = -top\n\\end{align}\n$$\n\n　　``这里假设了 filed-of-view 是纵向的，OpenGL 就是默认 fov 为纵向，但是同时需要注意的是其它渲染器有可能默认 fov 为横向，如 Maya 和 RenderMan。``\n\n　　如图（Figure 7）图像的纵横比有可能相等也有可能不等：\n\n![figure 7](/figure7.png)\n<center>Figure 7</center>\n\n　　若纵横比相等，由对称关系可得：\n\n$$\n\\begin{align}\n&top = tan(\\cfrac{FOV}{2})*near \\\\\\\\\n&right = top \\\\\\\\\n&left = bottom = -top\n\\end{align}\n$$\n\n　　若纵横比不等，借助 aspect ratio 可得：\n\n$$\n\\begin{align}\n&aspect ratio = \\cfrac{width}{height} \\\\\\\\\n&top = tan(\\cfrac{FOV}{2})*near \\\\\\\\\n& bottom = -top \\\\\\\\\n&right = top * aspect ratio \\\\\\\\\n&left = -right\n\\end{align}\n$$\n\n# 参考链接\n[Scratchapixel-Projection Matrices: What You Need to Know First](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrices-what-you-need-to-know-first)\n[Scratchapixel-The OpenGL Perspective Projection Matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix)\n","source":"_posts/光栅化渲染-6-透视投影矩阵.md","raw":"---\ntitle: 光栅化渲染-6-透视投影矩阵\ndate: 2019-09-20 21:29:19\ncategories:\n- Computer Graphics\n- 光栅化渲染\ntags:\n---\n\n　　*GPU结构被设计的非常适合矩阵运算，把透视投影过程用矩阵表达出来可以加速计算。*\n<!--more-->\n\n# Unit Cube\n　　在讨论如何构造透视投影矩阵之前，我们先了解透视投影的作用（效果）。空间中一点 $P$ 乘以透视投影矩阵后，我们会得到一点 $P^\\prime$：\n\n- 它的 x' 坐标和 y' 坐标的范围是 [-1, 1]，即定义在 NDC 空间下。\n- 它的 z' 坐标的范围同样被压缩到 [-1, 1] 的范围内，边界分别为近剪切平面和远剪切平面。\n\n　　如（Figure 1）所示，这样做的效果从空间中来看，其实是把相机坐标系下的**视棱台**(viewing frustum)压缩成了**立方体**(unit cube)。\n\n![figure1](/figure1.png)\n<center>Figure 1</center>\n\n　　而这样做的目的是为了方便做**剪切(clipping)**。一方面去除那些在视野范围之外的图元（不必浪费资源渲染它们），另一方面对那些一部分在视野内一部分在视野外的图元做修剪（Figure 2）。\n\n![figure2](/figure2.png)\n<center>Figure 2</center>\n\n``这里有一个剪切空间(Clip Space)的概念，与 NDC 空间不同。我们稍后再做介绍 。``\n\n# 透视投影矩阵\n　　现在我们可以开始构造透视投影矩阵了。回顾一下之前的透视投影的内容，相机空间中的点投影到成像平面上（Figure 3）的变化为：\n\n![figure 3](/figure3.png)\n<center>Figure 3</center>\n\n$$\nP_{S_x} = \\cfrac{n * P_x}{-P_z} \\\\\\\\\nP_{S_y} = \\cfrac{n * P_y}{-P_z}\n$$\n\n　　我们发现计算投影要除以 $P_z$ 坐标，但这是矩阵的线性变换做不到的，矩阵只能线性的组合 $P_x$，$P_y$，$P_z$ 来得到 $P_{S_x}$，$P_{S_y}$，$P_{S_z}$，于是我们引入**其次坐标**，将空间点扩充为 $[P_x, P_y, P_z, P_w = 1]$。\n　　同时对矩阵做特定设定，使其将转换后的 $P_{S_w}$ 分量设置为 $-P_z$，这样通过 $[P_{S_x}, P_{S_y}, P_{S_z}, P_{S_w}]$ 整体除以 $P_{S_w}$ 分量便实现了除法变换。\n\n$$\n\\left[\n    \\begin{matrix}\n        ... & ... & ... & ... \\\\\\\\\n        ... & ... & ... & ... \\\\\\\\\n        ... & ... & ... & ... \\\\\\\\\n        0 & 0 & -1 & 0\n    \\end{matrix}\n\\right]\n\\*\n\\left[\n    \\begin{matrix}\n        P_x \\\\\\\\\n        P_y \\\\\\\\\n        P_z \\\\\\\\\n        1\n    \\end{matrix}\n\\right]\n= \n\\left[\n    \\begin{matrix}\n        P_{S_x} \\\\\\\\\n        P_{S_y} \\\\\\\\\n        P_{S_z} \\\\\\\\\n        -P_z\n    \\end{matrix}\n\\right]\n$$\n\n　　接下来继续构造其它分量，假设成像平面坐标系的 $x$ 坐标范围为 $[l, r]$，$y$ 坐标范围为 $[b, t]$，近剪切平面和远剪切平面分别为 $n, f$。\n　　由[透视投影的拓展内容](https://ain-crad.github.io/2019/08/11/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-2-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1/#more)中我们知道，若要使相机坐标 $P_x$ 变换到屏幕坐标 $P_{S_x}$ 且范围为 $[-1, 1]$，那么\n\n$$\nP_{S_x} = \\cfrac{2nP_x}{-P_z(r-l)}-\\cfrac{r+l}{r-l}\n$$\n\n　　由于 $\\cfrac{1}{-P_z}$ 部分可以除以 $P_{S_w}$ 分量得到，所以矩阵的形式可以构造为：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2n}{r-l} & 0 & \\cfrac{r+l}{r-l} & 0 \\\\\\\\\n        ... & ... & ... & ... \\\\\\\\\n        ... & ... & ... & ... \\\\\\\\\n        0 & 0 & -1 & 0\n    \\end{matrix}\n\\right]\n$$\n\n　　同理\n\n$$\nP_{S_y} = \\cfrac{2nP_y}{-P_z(t-b)}-\\cfrac{t+b}{t-b}\n$$\n\n　　进一步扩充矩阵\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2n}{r-l} & 0 & \\cfrac{r+l}{r-l} & 0 \\\\\\\\\n        0 & \\cfrac{2n}{t-b} & \\cfrac{t+b}{t-b} & 0 \\\\\\\\\n        ... & ... & ... & ... \\\\\\\\\n        0 & 0 & -1 & 0\n    \\end{matrix}\n\\right]\n$$\n\n　　现在只需要构造出 $P_z$ 分量部分的矩阵，使变换后的 $P_{S_z}$ 的范围为 $[-1, 1]$，由于 $P_{S_z}$ 和 $P_x, P_y$ 分量都无关，因此矩阵可以写成如下形式：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2n}{r-l} & 0 & \\cfrac{r+l}{r-l} & 0 \\\\\\\\\n        0 & \\cfrac{2n}{t-b} & \\cfrac{t+b}{t-b} & 0 \\\\\\\\\n        0 & 0 & A & B \\\\\\\\\n        0 & 0 & -1 & 0\n    \\end{matrix}\n\\right]\n$$\n\n　　$A$ 和 $B$ 是我们待求解的部分，它们满足：\n\n![equation 1](/equation1.png)\n\n　　当 $P_z = -n$ 即点 $P$ 在近平面上时，$P_{S_z} = -1$；当 $P_z = -f$ 即点 $P$ 在远平面上时，$P_{S_z} = 1$。所以可以得到下面的方程组：\n\n![equation 2](/equation2.png)\n\n　　解方程组得：\n\n$$\nA = -\\cfrac{f+n}{f-n} \\\\\\\\\nB = -\\cfrac{2fn}{f-n}\n$$\n\n　　于是我们就得到了最终的透视投影矩阵：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2n}{r-l} & 0 & \\cfrac{r+l}{r-l} & 0 \\\\\\\\\n        0 & \\cfrac{2n}{t-b} & \\cfrac{t+b}{t-b} & 0 \\\\\\\\\n        0 & 0 & -\\cfrac{f+n}{f-n} & -\\cfrac{2fn}{f-n} \\\\\\\\\n        0 & 0 & -1 & 0\n    \\end{matrix}\n\\right]\n$$\n   \n　　由于 $P_z$ 映射到 $[-1, 1]$ 的变化不是线性的，靠近近剪切平面的点的精度高，靠近远剪切平面的点的精度低（Figure 4），图中 $n = 1$，$f = 5$。\n\n![figure4](/figure4.png)\n<center>Figure 4</center>\n\n　　当精度过低时，可能会出现 **z-fighting** 的现象，即不同 $P_z$ 坐标的点映射到 $P_{S_z}$ 是相同的。这个问题无法被真正解决，我们只能通过使两个剪切平面之间的距离在包含所有物体的前提下尽可能的接近，来尽量避免 **z-fighting** 的问题。（Figure 5）\n\n![figure5](/figure5.png)\n<center>Figure 5</center>\n\n# 视场（Fov）和图像纵横比（Aspect Ratio）\n　　求解透视投影矩阵时用到了6个参数 **near，far，left，right，top，bottom**。其中 near 和 far 是人为指定的，而剩下的4个参数则是由**视场(Fov)**以及**图像纵横比(Aspect Ratio)**决定的（Figure 6）。\n\n![figure 6](/figure6.png)\n<center>Figure 6</center>\n\n　　由简单的比例关系可以得到：\n\n$$\ntan(\\cfrac{FOV}{2}) = \\cfrac{opposite}{adjacent} = \\cfrac{BC}{AB} = \\cfrac{top}{near}\n$$\n\n　　因此\n\n$$\n\\begin{align}\n&top = tan(\\cfrac{FOV}{2})*near \\\\\\\\\n&bottom = -top\n\\end{align}\n$$\n\n　　``这里假设了 filed-of-view 是纵向的，OpenGL 就是默认 fov 为纵向，但是同时需要注意的是其它渲染器有可能默认 fov 为横向，如 Maya 和 RenderMan。``\n\n　　如图（Figure 7）图像的纵横比有可能相等也有可能不等：\n\n![figure 7](/figure7.png)\n<center>Figure 7</center>\n\n　　若纵横比相等，由对称关系可得：\n\n$$\n\\begin{align}\n&top = tan(\\cfrac{FOV}{2})*near \\\\\\\\\n&right = top \\\\\\\\\n&left = bottom = -top\n\\end{align}\n$$\n\n　　若纵横比不等，借助 aspect ratio 可得：\n\n$$\n\\begin{align}\n&aspect ratio = \\cfrac{width}{height} \\\\\\\\\n&top = tan(\\cfrac{FOV}{2})*near \\\\\\\\\n& bottom = -top \\\\\\\\\n&right = top * aspect ratio \\\\\\\\\n&left = -right\n\\end{align}\n$$\n\n# 参考链接\n[Scratchapixel-Projection Matrices: What You Need to Know First](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrices-what-you-need-to-know-first)\n[Scratchapixel-The OpenGL Perspective Projection Matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix)\n","slug":"光栅化渲染-6-透视投影矩阵","published":1,"updated":"2019-09-22T04:33:25.995Z","_id":"ck0uh6nm50028h8vn8u5ldgsa","comments":1,"layout":"post","photos":[],"link":"","content":"<p>　　<em>GPU结构被设计的非常适合矩阵运算，把透视投影过程用矩阵表达出来可以加速计算。</em></p>\n<a id=\"more\"></a>\n\n<h1 id=\"Unit-Cube\"><a href=\"#Unit-Cube\" class=\"headerlink\" title=\"Unit Cube\"></a>Unit Cube</h1><p>　　在讨论如何构造透视投影矩阵之前，我们先了解透视投影的作用（效果）。空间中一点 $P$ 乘以透视投影矩阵后，我们会得到一点 $P^\\prime$：</p>\n<ul>\n<li>它的 x’ 坐标和 y’ 坐标的范围是 [-1, 1]，即定义在 NDC 空间下。</li>\n<li>它的 z’ 坐标的范围同样被压缩到 [-1, 1] 的范围内，边界分别为近剪切平面和远剪切平面。</li>\n</ul>\n<p>　　如（Figure 1）所示，这样做的效果从空间中来看，其实是把相机坐标系下的<strong>视棱台</strong>(viewing frustum)压缩成了<strong>立方体</strong>(unit cube)。</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure1.png\" alt=\"figure1\"></p>\n<center>Figure 1</center>\n\n<p>　　而这样做的目的是为了方便做<strong>剪切(clipping)</strong>。一方面去除那些在视野范围之外的图元（不必浪费资源渲染它们），另一方面对那些一部分在视野内一部分在视野外的图元做修剪（Figure 2）。</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure2.png\" alt=\"figure2\"></p>\n<center>Figure 2</center>\n\n<p><code>这里有一个剪切空间(Clip Space)的概念，与 NDC 空间不同。我们稍后再做介绍 。</code></p>\n<h1 id=\"透视投影矩阵\"><a href=\"#透视投影矩阵\" class=\"headerlink\" title=\"透视投影矩阵\"></a>透视投影矩阵</h1><p>　　现在我们可以开始构造透视投影矩阵了。回顾一下之前的透视投影的内容，相机空间中的点投影到成像平面上（Figure 3）的变化为：</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure3.png\" alt=\"figure 3\"></p>\n<center>Figure 3</center>\n\n<p>$$<br>P_{S_x} = \\cfrac{n * P_x}{-P_z} \\\\<br>P_{S_y} = \\cfrac{n * P_y}{-P_z}<br>$$</p>\n<p>　　我们发现计算投影要除以 $P_z$ 坐标，但这是矩阵的线性变换做不到的，矩阵只能线性的组合 $P_x$，$P_y$，$P_z$ 来得到 $P_{S_x}$，$P_{S_y}$，$P_{S_z}$，于是我们引入<strong>其次坐标</strong>，将空间点扩充为 $[P_x, P_y, P_z, P_w = 1]$。<br>　　同时对矩阵做特定设定，使其将转换后的 $P_{S_w}$ 分量设置为 $-P_z$，这样通过 $[P_{S_x}, P_{S_y}, P_{S_z}, P_{S_w}]$ 整体除以 $P_{S_w}$ 分量便实现了除法变换。</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        … &amp; … &amp; … &amp; … \\\\<br>        … &amp; … &amp; … &amp; … \\\\<br>        … &amp; … &amp; … &amp; … \\\\<br>        0 &amp; 0 &amp; -1 &amp; 0<br>    \\end{matrix}<br>\\right]<br>*<br>\\left[<br>    \\begin{matrix}<br>        P_x \\\\<br>        P_y \\\\<br>        P_z \\\\<br>        1<br>    \\end{matrix}<br>\\right]<br>=<br>\\left[<br>    \\begin{matrix}<br>        P_{S_x} \\\\<br>        P_{S_y} \\\\<br>        P_{S_z} \\\\<br>        -P_z<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　接下来继续构造其它分量，假设成像平面坐标系的 $x$ 坐标范围为 $[l, r]$，$y$ 坐标范围为 $[b, t]$，近剪切平面和远剪切平面分别为 $n, f$。<br>　　由<a href=\"https://ain-crad.github.io/2019/08/11/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-2-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1/#more\" target=\"_blank\" rel=\"noopener\">透视投影的拓展内容</a>中我们知道，若要使相机坐标 $P_x$ 变换到屏幕坐标 $P_{S_x}$ 且范围为 $[-1, 1]$，那么</p>\n<p>$$<br>P_{S_x} = \\cfrac{2nP_x}{-P_z(r-l)}-\\cfrac{r+l}{r-l}<br>$$</p>\n<p>　　由于 $\\cfrac{1}{-P_z}$ 部分可以除以 $P_{S_w}$ 分量得到，所以矩阵的形式可以构造为：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2n}{r-l} &amp; 0 &amp; \\cfrac{r+l}{r-l} &amp; 0 \\\\<br>        … &amp; … &amp; … &amp; … \\\\<br>        … &amp; … &amp; … &amp; … \\\\<br>        0 &amp; 0 &amp; -1 &amp; 0<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　同理</p>\n<p>$$<br>P_{S_y} = \\cfrac{2nP_y}{-P_z(t-b)}-\\cfrac{t+b}{t-b}<br>$$</p>\n<p>　　进一步扩充矩阵</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2n}{r-l} &amp; 0 &amp; \\cfrac{r+l}{r-l} &amp; 0 \\\\<br>        0 &amp; \\cfrac{2n}{t-b} &amp; \\cfrac{t+b}{t-b} &amp; 0 \\\\<br>        … &amp; … &amp; … &amp; … \\\\<br>        0 &amp; 0 &amp; -1 &amp; 0<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　现在只需要构造出 $P_z$ 分量部分的矩阵，使变换后的 $P_{S_z}$ 的范围为 $[-1, 1]$，由于 $P_{S_z}$ 和 $P_x, P_y$ 分量都无关，因此矩阵可以写成如下形式：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2n}{r-l} &amp; 0 &amp; \\cfrac{r+l}{r-l} &amp; 0 \\\\<br>        0 &amp; \\cfrac{2n}{t-b} &amp; \\cfrac{t+b}{t-b} &amp; 0 \\\\<br>        0 &amp; 0 &amp; A &amp; B \\\\<br>        0 &amp; 0 &amp; -1 &amp; 0<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　$A$ 和 $B$ 是我们待求解的部分，它们满足：</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/equation1.png\" alt=\"equation 1\"></p>\n<p>　　当 $P_z = -n$ 即点 $P$ 在近平面上时，$P_{S_z} = -1$；当 $P_z = -f$ 即点 $P$ 在远平面上时，$P_{S_z} = 1$。所以可以得到下面的方程组：</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/equation2.png\" alt=\"equation 2\"></p>\n<p>　　解方程组得：</p>\n<p>$$<br>A = -\\cfrac{f+n}{f-n} \\\\<br>B = -\\cfrac{2fn}{f-n}<br>$$</p>\n<p>　　于是我们就得到了最终的透视投影矩阵：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2n}{r-l} &amp; 0 &amp; \\cfrac{r+l}{r-l} &amp; 0 \\\\<br>        0 &amp; \\cfrac{2n}{t-b} &amp; \\cfrac{t+b}{t-b} &amp; 0 \\\\<br>        0 &amp; 0 &amp; -\\cfrac{f+n}{f-n} &amp; -\\cfrac{2fn}{f-n} \\\\<br>        0 &amp; 0 &amp; -1 &amp; 0<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　由于 $P_z$ 映射到 $[-1, 1]$ 的变化不是线性的，靠近近剪切平面的点的精度高，靠近远剪切平面的点的精度低（Figure 4），图中 $n = 1$，$f = 5$。</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure4.png\" alt=\"figure4\"></p>\n<center>Figure 4</center>\n\n<p>　　当精度过低时，可能会出现 <strong>z-fighting</strong> 的现象，即不同 $P_z$ 坐标的点映射到 $P_{S_z}$ 是相同的。这个问题无法被真正解决，我们只能通过使两个剪切平面之间的距离在包含所有物体的前提下尽可能的接近，来尽量避免 <strong>z-fighting</strong> 的问题。（Figure 5）</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure5.png\" alt=\"figure5\"></p>\n<center>Figure 5</center>\n\n<h1 id=\"视场（Fov）和图像纵横比（Aspect-Ratio）\"><a href=\"#视场（Fov）和图像纵横比（Aspect-Ratio）\" class=\"headerlink\" title=\"视场（Fov）和图像纵横比（Aspect Ratio）\"></a>视场（Fov）和图像纵横比（Aspect Ratio）</h1><p>　　求解透视投影矩阵时用到了6个参数 <strong>near，far，left，right，top，bottom</strong>。其中 near 和 far 是人为指定的，而剩下的4个参数则是由<strong>视场(Fov)</strong>以及<strong>图像纵横比(Aspect Ratio)</strong>决定的（Figure 6）。</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure6.png\" alt=\"figure 6\"></p>\n<center>Figure 6</center>\n\n<p>　　由简单的比例关系可以得到：</p>\n<p>$$<br>tan(\\cfrac{FOV}{2}) = \\cfrac{opposite}{adjacent} = \\cfrac{BC}{AB} = \\cfrac{top}{near}<br>$$</p>\n<p>　　因此</p>\n<p>$$<br>\\begin{align}<br>&amp;top = tan(\\cfrac{FOV}{2})*near \\\\<br>&amp;bottom = -top<br>\\end{align}<br>$$</p>\n<p>　　<code>这里假设了 filed-of-view 是纵向的，OpenGL 就是默认 fov 为纵向，但是同时需要注意的是其它渲染器有可能默认 fov 为横向，如 Maya 和 RenderMan。</code></p>\n<p>　　如图（Figure 7）图像的纵横比有可能相等也有可能不等：</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure7.png\" alt=\"figure 7\"></p>\n<center>Figure 7</center>\n\n<p>　　若纵横比相等，由对称关系可得：</p>\n<p>$$<br>\\begin{align}<br>&amp;top = tan(\\cfrac{FOV}{2})*near \\\\<br>&amp;right = top \\\\<br>&amp;left = bottom = -top<br>\\end{align}<br>$$</p>\n<p>　　若纵横比不等，借助 aspect ratio 可得：</p>\n<p>$$<br>\\begin{align}<br>&amp;aspect ratio = \\cfrac{width}{height} \\\\<br>&amp;top = tan(\\cfrac{FOV}{2})*near \\\\<br>&amp; bottom = -top \\\\<br>&amp;right = top * aspect ratio \\\\<br>&amp;left = -right<br>\\end{align}<br>$$</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrices-what-you-need-to-know-first\" target=\"_blank\" rel=\"noopener\">Scratchapixel-Projection Matrices: What You Need to Know First</a><br><a href=\"https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix\" target=\"_blank\" rel=\"noopener\">Scratchapixel-The OpenGL Perspective Projection Matrix</a></p>\n","site":{"data":{}},"excerpt":"<p>　　<em>GPU结构被设计的非常适合矩阵运算，把透视投影过程用矩阵表达出来可以加速计算。</em></p>","more":"<h1 id=\"Unit-Cube\"><a href=\"#Unit-Cube\" class=\"headerlink\" title=\"Unit Cube\"></a>Unit Cube</h1><p>　　在讨论如何构造透视投影矩阵之前，我们先了解透视投影的作用（效果）。空间中一点 $P$ 乘以透视投影矩阵后，我们会得到一点 $P^\\prime$：</p>\n<ul>\n<li>它的 x’ 坐标和 y’ 坐标的范围是 [-1, 1]，即定义在 NDC 空间下。</li>\n<li>它的 z’ 坐标的范围同样被压缩到 [-1, 1] 的范围内，边界分别为近剪切平面和远剪切平面。</li>\n</ul>\n<p>　　如（Figure 1）所示，这样做的效果从空间中来看，其实是把相机坐标系下的<strong>视棱台</strong>(viewing frustum)压缩成了<strong>立方体</strong>(unit cube)。</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure1.png\" alt=\"figure1\"></p>\n<center>Figure 1</center>\n\n<p>　　而这样做的目的是为了方便做<strong>剪切(clipping)</strong>。一方面去除那些在视野范围之外的图元（不必浪费资源渲染它们），另一方面对那些一部分在视野内一部分在视野外的图元做修剪（Figure 2）。</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure2.png\" alt=\"figure2\"></p>\n<center>Figure 2</center>\n\n<p><code>这里有一个剪切空间(Clip Space)的概念，与 NDC 空间不同。我们稍后再做介绍 。</code></p>\n<h1 id=\"透视投影矩阵\"><a href=\"#透视投影矩阵\" class=\"headerlink\" title=\"透视投影矩阵\"></a>透视投影矩阵</h1><p>　　现在我们可以开始构造透视投影矩阵了。回顾一下之前的透视投影的内容，相机空间中的点投影到成像平面上（Figure 3）的变化为：</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure3.png\" alt=\"figure 3\"></p>\n<center>Figure 3</center>\n\n<p>$$<br>P_{S_x} = \\cfrac{n * P_x}{-P_z} \\\\<br>P_{S_y} = \\cfrac{n * P_y}{-P_z}<br>$$</p>\n<p>　　我们发现计算投影要除以 $P_z$ 坐标，但这是矩阵的线性变换做不到的，矩阵只能线性的组合 $P_x$，$P_y$，$P_z$ 来得到 $P_{S_x}$，$P_{S_y}$，$P_{S_z}$，于是我们引入<strong>其次坐标</strong>，将空间点扩充为 $[P_x, P_y, P_z, P_w = 1]$。<br>　　同时对矩阵做特定设定，使其将转换后的 $P_{S_w}$ 分量设置为 $-P_z$，这样通过 $[P_{S_x}, P_{S_y}, P_{S_z}, P_{S_w}]$ 整体除以 $P_{S_w}$ 分量便实现了除法变换。</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        … &amp; … &amp; … &amp; … \\\\<br>        … &amp; … &amp; … &amp; … \\\\<br>        … &amp; … &amp; … &amp; … \\\\<br>        0 &amp; 0 &amp; -1 &amp; 0<br>    \\end{matrix}<br>\\right]<br>*<br>\\left[<br>    \\begin{matrix}<br>        P_x \\\\<br>        P_y \\\\<br>        P_z \\\\<br>        1<br>    \\end{matrix}<br>\\right]<br>=<br>\\left[<br>    \\begin{matrix}<br>        P_{S_x} \\\\<br>        P_{S_y} \\\\<br>        P_{S_z} \\\\<br>        -P_z<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　接下来继续构造其它分量，假设成像平面坐标系的 $x$ 坐标范围为 $[l, r]$，$y$ 坐标范围为 $[b, t]$，近剪切平面和远剪切平面分别为 $n, f$。<br>　　由<a href=\"https://ain-crad.github.io/2019/08/11/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-2-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1/#more\" target=\"_blank\" rel=\"noopener\">透视投影的拓展内容</a>中我们知道，若要使相机坐标 $P_x$ 变换到屏幕坐标 $P_{S_x}$ 且范围为 $[-1, 1]$，那么</p>\n<p>$$<br>P_{S_x} = \\cfrac{2nP_x}{-P_z(r-l)}-\\cfrac{r+l}{r-l}<br>$$</p>\n<p>　　由于 $\\cfrac{1}{-P_z}$ 部分可以除以 $P_{S_w}$ 分量得到，所以矩阵的形式可以构造为：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2n}{r-l} &amp; 0 &amp; \\cfrac{r+l}{r-l} &amp; 0 \\\\<br>        … &amp; … &amp; … &amp; … \\\\<br>        … &amp; … &amp; … &amp; … \\\\<br>        0 &amp; 0 &amp; -1 &amp; 0<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　同理</p>\n<p>$$<br>P_{S_y} = \\cfrac{2nP_y}{-P_z(t-b)}-\\cfrac{t+b}{t-b}<br>$$</p>\n<p>　　进一步扩充矩阵</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2n}{r-l} &amp; 0 &amp; \\cfrac{r+l}{r-l} &amp; 0 \\\\<br>        0 &amp; \\cfrac{2n}{t-b} &amp; \\cfrac{t+b}{t-b} &amp; 0 \\\\<br>        … &amp; … &amp; … &amp; … \\\\<br>        0 &amp; 0 &amp; -1 &amp; 0<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　现在只需要构造出 $P_z$ 分量部分的矩阵，使变换后的 $P_{S_z}$ 的范围为 $[-1, 1]$，由于 $P_{S_z}$ 和 $P_x, P_y$ 分量都无关，因此矩阵可以写成如下形式：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2n}{r-l} &amp; 0 &amp; \\cfrac{r+l}{r-l} &amp; 0 \\\\<br>        0 &amp; \\cfrac{2n}{t-b} &amp; \\cfrac{t+b}{t-b} &amp; 0 \\\\<br>        0 &amp; 0 &amp; A &amp; B \\\\<br>        0 &amp; 0 &amp; -1 &amp; 0<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　$A$ 和 $B$ 是我们待求解的部分，它们满足：</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/equation1.png\" alt=\"equation 1\"></p>\n<p>　　当 $P_z = -n$ 即点 $P$ 在近平面上时，$P_{S_z} = -1$；当 $P_z = -f$ 即点 $P$ 在远平面上时，$P_{S_z} = 1$。所以可以得到下面的方程组：</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/equation2.png\" alt=\"equation 2\"></p>\n<p>　　解方程组得：</p>\n<p>$$<br>A = -\\cfrac{f+n}{f-n} \\\\<br>B = -\\cfrac{2fn}{f-n}<br>$$</p>\n<p>　　于是我们就得到了最终的透视投影矩阵：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2n}{r-l} &amp; 0 &amp; \\cfrac{r+l}{r-l} &amp; 0 \\\\<br>        0 &amp; \\cfrac{2n}{t-b} &amp; \\cfrac{t+b}{t-b} &amp; 0 \\\\<br>        0 &amp; 0 &amp; -\\cfrac{f+n}{f-n} &amp; -\\cfrac{2fn}{f-n} \\\\<br>        0 &amp; 0 &amp; -1 &amp; 0<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　由于 $P_z$ 映射到 $[-1, 1]$ 的变化不是线性的，靠近近剪切平面的点的精度高，靠近远剪切平面的点的精度低（Figure 4），图中 $n = 1$，$f = 5$。</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure4.png\" alt=\"figure4\"></p>\n<center>Figure 4</center>\n\n<p>　　当精度过低时，可能会出现 <strong>z-fighting</strong> 的现象，即不同 $P_z$ 坐标的点映射到 $P_{S_z}$ 是相同的。这个问题无法被真正解决，我们只能通过使两个剪切平面之间的距离在包含所有物体的前提下尽可能的接近，来尽量避免 <strong>z-fighting</strong> 的问题。（Figure 5）</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure5.png\" alt=\"figure5\"></p>\n<center>Figure 5</center>\n\n<h1 id=\"视场（Fov）和图像纵横比（Aspect-Ratio）\"><a href=\"#视场（Fov）和图像纵横比（Aspect-Ratio）\" class=\"headerlink\" title=\"视场（Fov）和图像纵横比（Aspect Ratio）\"></a>视场（Fov）和图像纵横比（Aspect Ratio）</h1><p>　　求解透视投影矩阵时用到了6个参数 <strong>near，far，left，right，top，bottom</strong>。其中 near 和 far 是人为指定的，而剩下的4个参数则是由<strong>视场(Fov)</strong>以及<strong>图像纵横比(Aspect Ratio)</strong>决定的（Figure 6）。</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure6.png\" alt=\"figure 6\"></p>\n<center>Figure 6</center>\n\n<p>　　由简单的比例关系可以得到：</p>\n<p>$$<br>tan(\\cfrac{FOV}{2}) = \\cfrac{opposite}{adjacent} = \\cfrac{BC}{AB} = \\cfrac{top}{near}<br>$$</p>\n<p>　　因此</p>\n<p>$$<br>\\begin{align}<br>&amp;top = tan(\\cfrac{FOV}{2})*near \\\\<br>&amp;bottom = -top<br>\\end{align}<br>$$</p>\n<p>　　<code>这里假设了 filed-of-view 是纵向的，OpenGL 就是默认 fov 为纵向，但是同时需要注意的是其它渲染器有可能默认 fov 为横向，如 Maya 和 RenderMan。</code></p>\n<p>　　如图（Figure 7）图像的纵横比有可能相等也有可能不等：</p>\n<p><img src=\"/2019/09/20/光栅化渲染-6-透视投影矩阵/figure7.png\" alt=\"figure 7\"></p>\n<center>Figure 7</center>\n\n<p>　　若纵横比相等，由对称关系可得：</p>\n<p>$$<br>\\begin{align}<br>&amp;top = tan(\\cfrac{FOV}{2})*near \\\\<br>&amp;right = top \\\\<br>&amp;left = bottom = -top<br>\\end{align}<br>$$</p>\n<p>　　若纵横比不等，借助 aspect ratio 可得：</p>\n<p>$$<br>\\begin{align}<br>&amp;aspect ratio = \\cfrac{width}{height} \\\\<br>&amp;top = tan(\\cfrac{FOV}{2})*near \\\\<br>&amp; bottom = -top \\\\<br>&amp;right = top * aspect ratio \\\\<br>&amp;left = -right<br>\\end{align}<br>$$</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrices-what-you-need-to-know-first\" target=\"_blank\" rel=\"noopener\">Scratchapixel-Projection Matrices: What You Need to Know First</a><br><a href=\"https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix\" target=\"_blank\" rel=\"noopener\">Scratchapixel-The OpenGL Perspective Projection Matrix</a></p>"},{"title":"光栅化渲染-8-正交投影矩阵","date":"2019-09-22T03:10:30.000Z","_content":"\n![projection](/projectionsexample.png)\n\n　　*正交投影和透视投影的对比图，正交投影可以更好的保持原始物体的比例，透视投影则具有更好的3D真实感。*\n<!--more-->\n\n# 正交投影矩阵\n　　如图（Figure 1），正交投影的效果从空间中来看，是把相机坐标系下的**边界盒**压缩成了**立方体**。\n\n![figure1](/figure1.png)\n<center>Figure 1</center>\n\n　　``与透视投影的视棱台不同，正交投影最开始的空间为长方体的边界盒。``\n\n　　正交投影矩阵的构造方式与透视投影矩阵类似，同样假设成像平面坐标系的 $x$ 坐标范围为 $[l, r]$，$y$ 坐标范围为 $[b, t]$，近剪切平面和远剪切平面分别为 $n, f$。\n　　先考虑 $x$ ，由 $l<=x<=r$，可得 $0<=x-l<=r-l$，各项同时除以 $(r-l)$：\n\n$$\n0 <= \\cfrac{x-l}{r-l} <= 1\n$$\n\n　　公式各项同时乘以 $2$ 再减去 $1$：\n\n$$\n\\left[\n    \\begin{matrix}\n        -1 <= 2\\cfrac{x-l}{r-l} - 1 <= 1 \\\\\\\\\n        -1 <= \\cfrac{2x}{r-l} - \\cfrac{r+l}{r-l} <= 1\n    \\end{matrix}\n\\right]\n$$\n\n　　于是我们就可以得到 $x$ 的转换公式：\n\n$$\nx^\\prime = \\cfrac{2x}{r-l} - \\cfrac{r+l}{r-l}\n$$\n\n　　用矩阵形式表示为：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2}{r-l} & 0 & 0 & -\\cfrac{r+l}{r-l} \\\\\\\\\n        0 & 1 & 0 & 0 \\\\\\\\\n        0 & 0 & 1 & 0 \\\\\\\\\n        0 & 0 & 0 & 1\n    \\end{matrix}\n\\right]\n$$\n\n　　$y$ 坐标的转换公式类似：\n\n$$\ny^\\prime = \\cfrac{2y}{t-b} - \\cfrac{t+b}{t-b}\n$$\n\n　　矩阵此时变为：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2}{r-l} & 0 & 0 & -\\cfrac{r+l}{r-l} \\\\\\\\\n        0 & \\cfrac{2}{t-b} & 0 & - \\cfrac{t+b}{t-b} \\\\\\\\\n        0 & 0 & 1 & 0 \\\\\\\\\n        0 & 0 & 0 & 1\n    \\end{matrix}\n\\right]\n$$\n\n　　接下来考虑 $z$， 由 $n <= -z <= f$，可得 $0 <= -z-n <= f-n$，各项同时除以 $(f-n)$：\n\n$$\n0 <=  \\cfrac{-z-n}{f-n} <= 1\n$$\n\n　　公式各项同时乘以 $2$ 再减去 $1$：\n\n$$\n\\begin{align}\n    -1 <= 2\\cfrac{-z-n}{f-n} - 1 <= 1 \\\\\\\\\n    -1 <= \\cfrac{-2z}{f-n} - \\cfrac{f+n}{f-n} <= 1\n\\end{align}\n$$\n\n　　由此可以得到完整的正交投影矩阵：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2}{r-l} & 0 & 0 & -\\cfrac{r+l}{r-l} \\\\\\\\\n        0 & \\cfrac{2}{t-b} & 0 & - \\cfrac{t+b}{t-b} \\\\\\\\\n        0 & 0 & \\cfrac{-2}{f-n} & -\\cfrac{f+n}{f-n} \\\\\\\\\n        0 & 0 & 0 & 1\n    \\end{matrix}\n\\right]\n$$\n\n# 参数计算\n　　关于如何计算 **left，right，top，bottom** 这几个参数，首先要计算出边界盒的大小，统计出场景中物体的最大 $x$ 坐标``maxX``和 最大的 $y$ 坐标``maxY``。\n　　取``top = max(maxX, maxY)``，之后按比例 aspect ratio 来设置 ``left = aspectRatio * top``，再根据对称可以得到 ``bottom = -top, right = -left``。\n\n# 参考链接\n[Scratchapixel-What Are Projection Matrices and Where/Why Are They Used](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix)\n[Scratchapixel-The OpenGL Orthographic Projection Matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix)","source":"_posts/光栅化渲染-8-正交投影矩阵.md","raw":"---\ntitle: 光栅化渲染-8-正交投影矩阵\ndate: 2019-09-22 11:10:30\ncategories:\n- Computer Graphics\n- 光栅化渲染\ntags:\n---\n\n![projection](/projectionsexample.png)\n\n　　*正交投影和透视投影的对比图，正交投影可以更好的保持原始物体的比例，透视投影则具有更好的3D真实感。*\n<!--more-->\n\n# 正交投影矩阵\n　　如图（Figure 1），正交投影的效果从空间中来看，是把相机坐标系下的**边界盒**压缩成了**立方体**。\n\n![figure1](/figure1.png)\n<center>Figure 1</center>\n\n　　``与透视投影的视棱台不同，正交投影最开始的空间为长方体的边界盒。``\n\n　　正交投影矩阵的构造方式与透视投影矩阵类似，同样假设成像平面坐标系的 $x$ 坐标范围为 $[l, r]$，$y$ 坐标范围为 $[b, t]$，近剪切平面和远剪切平面分别为 $n, f$。\n　　先考虑 $x$ ，由 $l<=x<=r$，可得 $0<=x-l<=r-l$，各项同时除以 $(r-l)$：\n\n$$\n0 <= \\cfrac{x-l}{r-l} <= 1\n$$\n\n　　公式各项同时乘以 $2$ 再减去 $1$：\n\n$$\n\\left[\n    \\begin{matrix}\n        -1 <= 2\\cfrac{x-l}{r-l} - 1 <= 1 \\\\\\\\\n        -1 <= \\cfrac{2x}{r-l} - \\cfrac{r+l}{r-l} <= 1\n    \\end{matrix}\n\\right]\n$$\n\n　　于是我们就可以得到 $x$ 的转换公式：\n\n$$\nx^\\prime = \\cfrac{2x}{r-l} - \\cfrac{r+l}{r-l}\n$$\n\n　　用矩阵形式表示为：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2}{r-l} & 0 & 0 & -\\cfrac{r+l}{r-l} \\\\\\\\\n        0 & 1 & 0 & 0 \\\\\\\\\n        0 & 0 & 1 & 0 \\\\\\\\\n        0 & 0 & 0 & 1\n    \\end{matrix}\n\\right]\n$$\n\n　　$y$ 坐标的转换公式类似：\n\n$$\ny^\\prime = \\cfrac{2y}{t-b} - \\cfrac{t+b}{t-b}\n$$\n\n　　矩阵此时变为：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2}{r-l} & 0 & 0 & -\\cfrac{r+l}{r-l} \\\\\\\\\n        0 & \\cfrac{2}{t-b} & 0 & - \\cfrac{t+b}{t-b} \\\\\\\\\n        0 & 0 & 1 & 0 \\\\\\\\\n        0 & 0 & 0 & 1\n    \\end{matrix}\n\\right]\n$$\n\n　　接下来考虑 $z$， 由 $n <= -z <= f$，可得 $0 <= -z-n <= f-n$，各项同时除以 $(f-n)$：\n\n$$\n0 <=  \\cfrac{-z-n}{f-n} <= 1\n$$\n\n　　公式各项同时乘以 $2$ 再减去 $1$：\n\n$$\n\\begin{align}\n    -1 <= 2\\cfrac{-z-n}{f-n} - 1 <= 1 \\\\\\\\\n    -1 <= \\cfrac{-2z}{f-n} - \\cfrac{f+n}{f-n} <= 1\n\\end{align}\n$$\n\n　　由此可以得到完整的正交投影矩阵：\n\n$$\n\\left[\n    \\begin{matrix}\n        \\cfrac{2}{r-l} & 0 & 0 & -\\cfrac{r+l}{r-l} \\\\\\\\\n        0 & \\cfrac{2}{t-b} & 0 & - \\cfrac{t+b}{t-b} \\\\\\\\\n        0 & 0 & \\cfrac{-2}{f-n} & -\\cfrac{f+n}{f-n} \\\\\\\\\n        0 & 0 & 0 & 1\n    \\end{matrix}\n\\right]\n$$\n\n# 参数计算\n　　关于如何计算 **left，right，top，bottom** 这几个参数，首先要计算出边界盒的大小，统计出场景中物体的最大 $x$ 坐标``maxX``和 最大的 $y$ 坐标``maxY``。\n　　取``top = max(maxX, maxY)``，之后按比例 aspect ratio 来设置 ``left = aspectRatio * top``，再根据对称可以得到 ``bottom = -top, right = -left``。\n\n# 参考链接\n[Scratchapixel-What Are Projection Matrices and Where/Why Are They Used](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix)\n[Scratchapixel-The OpenGL Orthographic Projection Matrix](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix)","slug":"光栅化渲染-8-正交投影矩阵","published":1,"updated":"2019-09-22T04:33:07.002Z","_id":"ck0uh6nm60029h8vnmu4qzv4v","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/2019/09/22/光栅化渲染-8-正交投影矩阵/projectionsexample.png\" alt=\"projection\"></p>\n<p>　　<em>正交投影和透视投影的对比图，正交投影可以更好的保持原始物体的比例，透视投影则具有更好的3D真实感。</em></p>\n<a id=\"more\"></a>\n\n<h1 id=\"正交投影矩阵\"><a href=\"#正交投影矩阵\" class=\"headerlink\" title=\"正交投影矩阵\"></a>正交投影矩阵</h1><p>　　如图（Figure 1），正交投影的效果从空间中来看，是把相机坐标系下的<strong>边界盒</strong>压缩成了<strong>立方体</strong>。</p>\n<p><img src=\"/2019/09/22/光栅化渲染-8-正交投影矩阵/figure1.png\" alt=\"figure1\"></p>\n<center>Figure 1</center>\n\n<p>　　<code>与透视投影的视棱台不同，正交投影最开始的空间为长方体的边界盒。</code></p>\n<p>　　正交投影矩阵的构造方式与透视投影矩阵类似，同样假设成像平面坐标系的 $x$ 坐标范围为 $[l, r]$，$y$ 坐标范围为 $[b, t]$，近剪切平面和远剪切平面分别为 $n, f$。<br>　　先考虑 $x$ ，由 $l&lt;=x&lt;=r$，可得 $0&lt;=x-l&lt;=r-l$，各项同时除以 $(r-l)$：</p>\n<p>$$<br>0 &lt;= \\cfrac{x-l}{r-l} &lt;= 1<br>$$</p>\n<p>　　公式各项同时乘以 $2$ 再减去 $1$：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        -1 &lt;= 2\\cfrac{x-l}{r-l} - 1 &lt;= 1 \\\\<br>        -1 &lt;= \\cfrac{2x}{r-l} - \\cfrac{r+l}{r-l} &lt;= 1<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　于是我们就可以得到 $x$ 的转换公式：</p>\n<p>$$<br>x^\\prime = \\cfrac{2x}{r-l} - \\cfrac{r+l}{r-l}<br>$$</p>\n<p>　　用矩阵形式表示为：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\cfrac{r+l}{r-l} \\\\<br>        0 &amp; 1 &amp; 0 &amp; 0 \\\\<br>        0 &amp; 0 &amp; 1 &amp; 0 \\\\<br>        0 &amp; 0 &amp; 0 &amp; 1<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　$y$ 坐标的转换公式类似：</p>\n<p>$$<br>y^\\prime = \\cfrac{2y}{t-b} - \\cfrac{t+b}{t-b}<br>$$</p>\n<p>　　矩阵此时变为：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\cfrac{r+l}{r-l} \\\\<br>        0 &amp; \\cfrac{2}{t-b} &amp; 0 &amp; - \\cfrac{t+b}{t-b} \\\\<br>        0 &amp; 0 &amp; 1 &amp; 0 \\\\<br>        0 &amp; 0 &amp; 0 &amp; 1<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　接下来考虑 $z$， 由 $n &lt;= -z &lt;= f$，可得 $0 &lt;= -z-n &lt;= f-n$，各项同时除以 $(f-n)$：</p>\n<p>$$<br>0 &lt;=  \\cfrac{-z-n}{f-n} &lt;= 1<br>$$</p>\n<p>　　公式各项同时乘以 $2$ 再减去 $1$：</p>\n<p>$$<br>\\begin{align}<br>    -1 &lt;= 2\\cfrac{-z-n}{f-n} - 1 &lt;= 1 \\\\<br>    -1 &lt;= \\cfrac{-2z}{f-n} - \\cfrac{f+n}{f-n} &lt;= 1<br>\\end{align}<br>$$</p>\n<p>　　由此可以得到完整的正交投影矩阵：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\cfrac{r+l}{r-l} \\\\<br>        0 &amp; \\cfrac{2}{t-b} &amp; 0 &amp; - \\cfrac{t+b}{t-b} \\\\<br>        0 &amp; 0 &amp; \\cfrac{-2}{f-n} &amp; -\\cfrac{f+n}{f-n} \\\\<br>        0 &amp; 0 &amp; 0 &amp; 1<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<h1 id=\"参数计算\"><a href=\"#参数计算\" class=\"headerlink\" title=\"参数计算\"></a>参数计算</h1><p>　　关于如何计算 <strong>left，right，top，bottom</strong> 这几个参数，首先要计算出边界盒的大小，统计出场景中物体的最大 $x$ 坐标<code>maxX</code>和 最大的 $y$ 坐标<code>maxY</code>。<br>　　取<code>top = max(maxX, maxY)</code>，之后按比例 aspect ratio 来设置 <code>left = aspectRatio * top</code>，再根据对称可以得到 <code>bottom = -top, right = -left</code>。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix\" target=\"_blank\" rel=\"noopener\">Scratchapixel-What Are Projection Matrices and Where/Why Are They Used</a><br><a href=\"https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix\" target=\"_blank\" rel=\"noopener\">Scratchapixel-The OpenGL Orthographic Projection Matrix</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/2019/09/22/光栅化渲染-8-正交投影矩阵/projectionsexample.png\" alt=\"projection\"></p>\n<p>　　<em>正交投影和透视投影的对比图，正交投影可以更好的保持原始物体的比例，透视投影则具有更好的3D真实感。</em></p>","more":"<h1 id=\"正交投影矩阵\"><a href=\"#正交投影矩阵\" class=\"headerlink\" title=\"正交投影矩阵\"></a>正交投影矩阵</h1><p>　　如图（Figure 1），正交投影的效果从空间中来看，是把相机坐标系下的<strong>边界盒</strong>压缩成了<strong>立方体</strong>。</p>\n<p><img src=\"/2019/09/22/光栅化渲染-8-正交投影矩阵/figure1.png\" alt=\"figure1\"></p>\n<center>Figure 1</center>\n\n<p>　　<code>与透视投影的视棱台不同，正交投影最开始的空间为长方体的边界盒。</code></p>\n<p>　　正交投影矩阵的构造方式与透视投影矩阵类似，同样假设成像平面坐标系的 $x$ 坐标范围为 $[l, r]$，$y$ 坐标范围为 $[b, t]$，近剪切平面和远剪切平面分别为 $n, f$。<br>　　先考虑 $x$ ，由 $l&lt;=x&lt;=r$，可得 $0&lt;=x-l&lt;=r-l$，各项同时除以 $(r-l)$：</p>\n<p>$$<br>0 &lt;= \\cfrac{x-l}{r-l} &lt;= 1<br>$$</p>\n<p>　　公式各项同时乘以 $2$ 再减去 $1$：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        -1 &lt;= 2\\cfrac{x-l}{r-l} - 1 &lt;= 1 \\\\<br>        -1 &lt;= \\cfrac{2x}{r-l} - \\cfrac{r+l}{r-l} &lt;= 1<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　于是我们就可以得到 $x$ 的转换公式：</p>\n<p>$$<br>x^\\prime = \\cfrac{2x}{r-l} - \\cfrac{r+l}{r-l}<br>$$</p>\n<p>　　用矩阵形式表示为：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\cfrac{r+l}{r-l} \\\\<br>        0 &amp; 1 &amp; 0 &amp; 0 \\\\<br>        0 &amp; 0 &amp; 1 &amp; 0 \\\\<br>        0 &amp; 0 &amp; 0 &amp; 1<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　$y$ 坐标的转换公式类似：</p>\n<p>$$<br>y^\\prime = \\cfrac{2y}{t-b} - \\cfrac{t+b}{t-b}<br>$$</p>\n<p>　　矩阵此时变为：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\cfrac{r+l}{r-l} \\\\<br>        0 &amp; \\cfrac{2}{t-b} &amp; 0 &amp; - \\cfrac{t+b}{t-b} \\\\<br>        0 &amp; 0 &amp; 1 &amp; 0 \\\\<br>        0 &amp; 0 &amp; 0 &amp; 1<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>　　接下来考虑 $z$， 由 $n &lt;= -z &lt;= f$，可得 $0 &lt;= -z-n &lt;= f-n$，各项同时除以 $(f-n)$：</p>\n<p>$$<br>0 &lt;=  \\cfrac{-z-n}{f-n} &lt;= 1<br>$$</p>\n<p>　　公式各项同时乘以 $2$ 再减去 $1$：</p>\n<p>$$<br>\\begin{align}<br>    -1 &lt;= 2\\cfrac{-z-n}{f-n} - 1 &lt;= 1 \\\\<br>    -1 &lt;= \\cfrac{-2z}{f-n} - \\cfrac{f+n}{f-n} &lt;= 1<br>\\end{align}<br>$$</p>\n<p>　　由此可以得到完整的正交投影矩阵：</p>\n<p>$$<br>\\left[<br>    \\begin{matrix}<br>        \\cfrac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\cfrac{r+l}{r-l} \\\\<br>        0 &amp; \\cfrac{2}{t-b} &amp; 0 &amp; - \\cfrac{t+b}{t-b} \\\\<br>        0 &amp; 0 &amp; \\cfrac{-2}{f-n} &amp; -\\cfrac{f+n}{f-n} \\\\<br>        0 &amp; 0 &amp; 0 &amp; 1<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<h1 id=\"参数计算\"><a href=\"#参数计算\" class=\"headerlink\" title=\"参数计算\"></a>参数计算</h1><p>　　关于如何计算 <strong>left，right，top，bottom</strong> 这几个参数，首先要计算出边界盒的大小，统计出场景中物体的最大 $x$ 坐标<code>maxX</code>和 最大的 $y$ 坐标<code>maxY</code>。<br>　　取<code>top = max(maxX, maxY)</code>，之后按比例 aspect ratio 来设置 <code>left = aspectRatio * top</code>，再根据对称可以得到 <code>bottom = -top, right = -left</code>。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix\" target=\"_blank\" rel=\"noopener\">Scratchapixel-What Are Projection Matrices and Where/Why Are They Used</a><br><a href=\"https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix\" target=\"_blank\" rel=\"noopener\">Scratchapixel-The OpenGL Orthographic Projection Matrix</a></p>"},{"title":"光栅化渲染-7-渲染管线","date":"2019-09-21T12:38:45.000Z","_content":"\n　　*GPU 渲染管线分为两种，一种是原始的固定管线，另一种是现在常用的可编程管线。*\n<!--more-->\n\n# 渲染流程\n　　1.在顶点着色器中，空间点由**相机空间**(camera space)变换到**裁剪空间**(clip space)。这个过程首先将顶点变为**齐次坐标**，然后乘以**透视投影矩阵**。需要注意的是，此时还没有进行标准化，即转化后的顶点各分量没有除以 $P_{S_w}$ 。\n　　2.当所有顶点都经过顶点着色器处理后，不在裁剪空间中的图元将被舍弃，部分处于裁剪空间中的图元将被裁剪。需要注意的是，这个时候由于还没有进行标准化，因此裁剪空间并不是 $[-1, -1, -1]$ 和 $[1, 1, 1]$ 定义的固定的立方体空间，而是每个顶点都有一个自己的裁剪空间。常用的裁剪算法有 **Cohen-Sutherland** 和 **Sutherland-Hodgman** 算法。\n　　3.裁剪过程结束后，所有的顶点都将进行标准化，每个顶点的 $x$，$y$，$z$ 坐标都要除以各自的 $w$ 分量。这一步也叫做 **perspective divide**。\n\n![figure 1](/figure1.png)\n<center>Figure 1</center>\n\n# 固定管线\n　　在固定管线下，OpenGL 以及其它图形 API(e.g. Direct3D) 提供了两种模式来修改相机的状态，**GL_MODELVIEW** 以及 **GL_PROJECTION**。在 GL_MODELVIEW 模式下设置 objection-to-world 以及 world-to-camera 的转换矩阵，将顶点转换到相机坐标系下；在 GL_PROJECTION 模式下通过 glFrustum 设置透视投影矩阵，将顶点转换到裁剪空间下其次坐标形式。\n\n*实例*\n```C++\nglMatrixMode (GL_PROJECTION); \nglLoadIdentity(); \nglFrustum(l, r, b, t, n, f); \nglMatrixMode(GL_MODELVIEW); \nglLoadIdentity(); \nglTranslate(0, 0, 10); \n... \n```\n\n　　*固定管线现已被弃用。*\n\n# 可编程管线\n　　可编程管线和固定管线的区别在于，舍弃了 GL_MODELVIEW 和 GL_PROJECTION 的概念，要求开发者在顶点着色器中自定义顶点的变换，即自己实现 world-to-camera 和 透视投影矩阵。OpenGL 要求程序中必须有顶点着色器和片段着色器的实现。\n\n*顶点着色器实例*\n```C++\nuniform mat4 worldToCamMatrix, projMatrix; \nin vec3 vert; \n \nvoid main() \n{ \n    gl_Position = projMatrix * worldToCamMatrix * vec4(vert, 1); \n} \n```\n\n# 参考链接\n[Scratchapixel-About the Projection Matrix, the GPU Rendering Pipeline and Clipping](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-GPU-rendering-pipeline-clipping)","source":"_posts/光栅化渲染-7-渲染管线.md","raw":"---\ntitle: 光栅化渲染-7-渲染管线\ndate: 2019-09-21 20:38:45\ncategories:\n- Computer Graphics\n- 光栅化渲染\ntags:\n---\n\n　　*GPU 渲染管线分为两种，一种是原始的固定管线，另一种是现在常用的可编程管线。*\n<!--more-->\n\n# 渲染流程\n　　1.在顶点着色器中，空间点由**相机空间**(camera space)变换到**裁剪空间**(clip space)。这个过程首先将顶点变为**齐次坐标**，然后乘以**透视投影矩阵**。需要注意的是，此时还没有进行标准化，即转化后的顶点各分量没有除以 $P_{S_w}$ 。\n　　2.当所有顶点都经过顶点着色器处理后，不在裁剪空间中的图元将被舍弃，部分处于裁剪空间中的图元将被裁剪。需要注意的是，这个时候由于还没有进行标准化，因此裁剪空间并不是 $[-1, -1, -1]$ 和 $[1, 1, 1]$ 定义的固定的立方体空间，而是每个顶点都有一个自己的裁剪空间。常用的裁剪算法有 **Cohen-Sutherland** 和 **Sutherland-Hodgman** 算法。\n　　3.裁剪过程结束后，所有的顶点都将进行标准化，每个顶点的 $x$，$y$，$z$ 坐标都要除以各自的 $w$ 分量。这一步也叫做 **perspective divide**。\n\n![figure 1](/figure1.png)\n<center>Figure 1</center>\n\n# 固定管线\n　　在固定管线下，OpenGL 以及其它图形 API(e.g. Direct3D) 提供了两种模式来修改相机的状态，**GL_MODELVIEW** 以及 **GL_PROJECTION**。在 GL_MODELVIEW 模式下设置 objection-to-world 以及 world-to-camera 的转换矩阵，将顶点转换到相机坐标系下；在 GL_PROJECTION 模式下通过 glFrustum 设置透视投影矩阵，将顶点转换到裁剪空间下其次坐标形式。\n\n*实例*\n```C++\nglMatrixMode (GL_PROJECTION); \nglLoadIdentity(); \nglFrustum(l, r, b, t, n, f); \nglMatrixMode(GL_MODELVIEW); \nglLoadIdentity(); \nglTranslate(0, 0, 10); \n... \n```\n\n　　*固定管线现已被弃用。*\n\n# 可编程管线\n　　可编程管线和固定管线的区别在于，舍弃了 GL_MODELVIEW 和 GL_PROJECTION 的概念，要求开发者在顶点着色器中自定义顶点的变换，即自己实现 world-to-camera 和 透视投影矩阵。OpenGL 要求程序中必须有顶点着色器和片段着色器的实现。\n\n*顶点着色器实例*\n```C++\nuniform mat4 worldToCamMatrix, projMatrix; \nin vec3 vert; \n \nvoid main() \n{ \n    gl_Position = projMatrix * worldToCamMatrix * vec4(vert, 1); \n} \n```\n\n# 参考链接\n[Scratchapixel-About the Projection Matrix, the GPU Rendering Pipeline and Clipping](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-GPU-rendering-pipeline-clipping)","slug":"光栅化渲染-7-渲染管线","published":1,"updated":"2019-09-22T04:33:14.898Z","_id":"ck0uh6nm6002ah8vnr0xhpzta","comments":1,"layout":"post","photos":[],"link":"","content":"<p>　　<em>GPU 渲染管线分为两种，一种是原始的固定管线，另一种是现在常用的可编程管线。</em></p>\n<a id=\"more\"></a>\n\n<h1 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h1><p>　　1.在顶点着色器中，空间点由<strong>相机空间</strong>(camera space)变换到<strong>裁剪空间</strong>(clip space)。这个过程首先将顶点变为<strong>齐次坐标</strong>，然后乘以<strong>透视投影矩阵</strong>。需要注意的是，此时还没有进行标准化，即转化后的顶点各分量没有除以 $P_{S_w}$ 。<br>　　2.当所有顶点都经过顶点着色器处理后，不在裁剪空间中的图元将被舍弃，部分处于裁剪空间中的图元将被裁剪。需要注意的是，这个时候由于还没有进行标准化，因此裁剪空间并不是 $[-1, -1, -1]$ 和 $[1, 1, 1]$ 定义的固定的立方体空间，而是每个顶点都有一个自己的裁剪空间。常用的裁剪算法有 <strong>Cohen-Sutherland</strong> 和 <strong>Sutherland-Hodgman</strong> 算法。<br>　　3.裁剪过程结束后，所有的顶点都将进行标准化，每个顶点的 $x$，$y$，$z$ 坐标都要除以各自的 $w$ 分量。这一步也叫做 <strong>perspective divide</strong>。</p>\n<p><img src=\"/2019/09/21/光栅化渲染-7-渲染管线/figure1.png\" alt=\"figure 1\"></p>\n<center>Figure 1</center>\n\n<h1 id=\"固定管线\"><a href=\"#固定管线\" class=\"headerlink\" title=\"固定管线\"></a>固定管线</h1><p>　　在固定管线下，OpenGL 以及其它图形 API(e.g. Direct3D) 提供了两种模式来修改相机的状态，<strong>GL_MODELVIEW</strong> 以及 <strong>GL_PROJECTION</strong>。在 GL_MODELVIEW 模式下设置 objection-to-world 以及 world-to-camera 的转换矩阵，将顶点转换到相机坐标系下；在 GL_PROJECTION 模式下通过 glFrustum 设置透视投影矩阵，将顶点转换到裁剪空间下其次坐标形式。</p>\n<p><em>实例</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glMatrixMode (GL_PROJECTION); </span><br><span class=\"line\">glLoadIdentity(); </span><br><span class=\"line\">glFrustum(l, r, b, t, n, f); </span><br><span class=\"line\">glMatrixMode(GL_MODELVIEW); </span><br><span class=\"line\">glLoadIdentity(); </span><br><span class=\"line\">glTranslate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>); </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>　　<em>固定管线现已被弃用。</em></p>\n<h1 id=\"可编程管线\"><a href=\"#可编程管线\" class=\"headerlink\" title=\"可编程管线\"></a>可编程管线</h1><p>　　可编程管线和固定管线的区别在于，舍弃了 GL_MODELVIEW 和 GL_PROJECTION 的概念，要求开发者在顶点着色器中自定义顶点的变换，即自己实现 world-to-camera 和 透视投影矩阵。OpenGL 要求程序中必须有顶点着色器和片段着色器的实现。</p>\n<p><em>顶点着色器实例</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform mat4 worldToCamMatrix, projMatrix; </span><br><span class=\"line\">in vec3 vert; </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    gl_Position = projMatrix * worldToCamMatrix * vec4(vert, <span class=\"number\">1</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-GPU-rendering-pipeline-clipping\" target=\"_blank\" rel=\"noopener\">Scratchapixel-About the Projection Matrix, the GPU Rendering Pipeline and Clipping</a></p>\n","site":{"data":{}},"excerpt":"<p>　　<em>GPU 渲染管线分为两种，一种是原始的固定管线，另一种是现在常用的可编程管线。</em></p>","more":"<h1 id=\"渲染流程\"><a href=\"#渲染流程\" class=\"headerlink\" title=\"渲染流程\"></a>渲染流程</h1><p>　　1.在顶点着色器中，空间点由<strong>相机空间</strong>(camera space)变换到<strong>裁剪空间</strong>(clip space)。这个过程首先将顶点变为<strong>齐次坐标</strong>，然后乘以<strong>透视投影矩阵</strong>。需要注意的是，此时还没有进行标准化，即转化后的顶点各分量没有除以 $P_{S_w}$ 。<br>　　2.当所有顶点都经过顶点着色器处理后，不在裁剪空间中的图元将被舍弃，部分处于裁剪空间中的图元将被裁剪。需要注意的是，这个时候由于还没有进行标准化，因此裁剪空间并不是 $[-1, -1, -1]$ 和 $[1, 1, 1]$ 定义的固定的立方体空间，而是每个顶点都有一个自己的裁剪空间。常用的裁剪算法有 <strong>Cohen-Sutherland</strong> 和 <strong>Sutherland-Hodgman</strong> 算法。<br>　　3.裁剪过程结束后，所有的顶点都将进行标准化，每个顶点的 $x$，$y$，$z$ 坐标都要除以各自的 $w$ 分量。这一步也叫做 <strong>perspective divide</strong>。</p>\n<p><img src=\"/2019/09/21/光栅化渲染-7-渲染管线/figure1.png\" alt=\"figure 1\"></p>\n<center>Figure 1</center>\n\n<h1 id=\"固定管线\"><a href=\"#固定管线\" class=\"headerlink\" title=\"固定管线\"></a>固定管线</h1><p>　　在固定管线下，OpenGL 以及其它图形 API(e.g. Direct3D) 提供了两种模式来修改相机的状态，<strong>GL_MODELVIEW</strong> 以及 <strong>GL_PROJECTION</strong>。在 GL_MODELVIEW 模式下设置 objection-to-world 以及 world-to-camera 的转换矩阵，将顶点转换到相机坐标系下；在 GL_PROJECTION 模式下通过 glFrustum 设置透视投影矩阵，将顶点转换到裁剪空间下其次坐标形式。</p>\n<p><em>实例</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glMatrixMode (GL_PROJECTION); </span><br><span class=\"line\">glLoadIdentity(); </span><br><span class=\"line\">glFrustum(l, r, b, t, n, f); </span><br><span class=\"line\">glMatrixMode(GL_MODELVIEW); </span><br><span class=\"line\">glLoadIdentity(); </span><br><span class=\"line\">glTranslate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>); </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>　　<em>固定管线现已被弃用。</em></p>\n<h1 id=\"可编程管线\"><a href=\"#可编程管线\" class=\"headerlink\" title=\"可编程管线\"></a>可编程管线</h1><p>　　可编程管线和固定管线的区别在于，舍弃了 GL_MODELVIEW 和 GL_PROJECTION 的概念，要求开发者在顶点着色器中自定义顶点的变换，即自己实现 world-to-camera 和 透视投影矩阵。OpenGL 要求程序中必须有顶点着色器和片段着色器的实现。</p>\n<p><em>顶点着色器实例</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform mat4 worldToCamMatrix, projMatrix; </span><br><span class=\"line\">in vec3 vert; </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    gl_Position = projMatrix * worldToCamMatrix * vec4(vert, <span class=\"number\">1</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-GPU-rendering-pipeline-clipping\" target=\"_blank\" rel=\"noopener\">Scratchapixel-About the Projection Matrix, the GPU Rendering Pipeline and Clipping</a></p>"},{"title":"八皇后问题","date":"2018-12-20T15:16:17.000Z","_content":"八皇后问题，即在$8 \\times 8$的棋盘上放置8个皇后，使得它们互不攻击（皇后的攻击范围为同行同列和同对角线）。\n![queen](/queen.png)\n<!--more-->\n# 参考\n刘汝佳《算法竞赛入门经典》（第2版）\n\n# 解法\n比较容易想到的一个思路是把这个问题转换为“从64个格子中选8个格子”的问题。但是这一共有$C^8_{64} = 4.426 \\times 10^9$种情况。我们可以考虑先排除一些明显不成立的情况，减少枚举量。首先八个皇后肯定是位于不同行不同列的，所以逐行放置可以把这个问题看做一个求$0-7$列的全排列问题。这样的话总的情况数为$8! = 40302$种，同时用回溯法进行剪枝操作，可以在1秒内完成检索。\n$(i，C[i])$和$(j，C[j])$分别表示两个皇后坐标，它们位于同一对角线上的条件：\n``i - C[i] == j - C[j] || i + C[i] == j + C[j]`` \n\n![diagonal](/diagonal.png)\n\n\n# 代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 8;\nbool vis[3][100]; //record visited columns and  diagonals\nint c[100]; //represent columns\nint cnt;\n\nvoid dfs(int n){\n    if(n == N){\n        cnt++;\n        for(int i = 0; i < N; i++){\n            cout << c[i] << \" \";\n        }\n        cout << endl;\n        return;\n    }\n    for(int i = 0; i < N; i++){\n        // n - i　could be negative number, so we plus N.\n        if(!vis[0][i] && !vis[1][n + i] && !vis[2][n - i + N]){\n            c[n] = i;\n            vis[0][i] = vis[1][n + c[n]] = vis[2][n - c[n] + N] = 1;\n            dfs(n + 1);\n            vis[0][i] = vis[1][n + c[n]] = vis[2][n - c[n] + N] = 0;\n        }\n    }\n}\n\nint main(){\n    memset(vis, 0, sizeof(vis));\n    memset(c, -1, sizeof(c));\n    cnt = 0;\n    dfs(0);\n    cout << endl;\n    cout << \"total number: \" << cnt << endl;\n    return 0;\n}\n```\n","source":"_posts/八皇后问题.md","raw":"---\ntitle: 八皇后问题\ndate: 2018-12-20 23:16:17\ncategories:\n- Summary\ntags:\n---\n八皇后问题，即在$8 \\times 8$的棋盘上放置8个皇后，使得它们互不攻击（皇后的攻击范围为同行同列和同对角线）。\n![queen](/queen.png)\n<!--more-->\n# 参考\n刘汝佳《算法竞赛入门经典》（第2版）\n\n# 解法\n比较容易想到的一个思路是把这个问题转换为“从64个格子中选8个格子”的问题。但是这一共有$C^8_{64} = 4.426 \\times 10^9$种情况。我们可以考虑先排除一些明显不成立的情况，减少枚举量。首先八个皇后肯定是位于不同行不同列的，所以逐行放置可以把这个问题看做一个求$0-7$列的全排列问题。这样的话总的情况数为$8! = 40302$种，同时用回溯法进行剪枝操作，可以在1秒内完成检索。\n$(i，C[i])$和$(j，C[j])$分别表示两个皇后坐标，它们位于同一对角线上的条件：\n``i - C[i] == j - C[j] || i + C[i] == j + C[j]`` \n\n![diagonal](/diagonal.png)\n\n\n# 代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 8;\nbool vis[3][100]; //record visited columns and  diagonals\nint c[100]; //represent columns\nint cnt;\n\nvoid dfs(int n){\n    if(n == N){\n        cnt++;\n        for(int i = 0; i < N; i++){\n            cout << c[i] << \" \";\n        }\n        cout << endl;\n        return;\n    }\n    for(int i = 0; i < N; i++){\n        // n - i　could be negative number, so we plus N.\n        if(!vis[0][i] && !vis[1][n + i] && !vis[2][n - i + N]){\n            c[n] = i;\n            vis[0][i] = vis[1][n + c[n]] = vis[2][n - c[n] + N] = 1;\n            dfs(n + 1);\n            vis[0][i] = vis[1][n + c[n]] = vis[2][n - c[n] + N] = 0;\n        }\n    }\n}\n\nint main(){\n    memset(vis, 0, sizeof(vis));\n    memset(c, -1, sizeof(c));\n    cnt = 0;\n    dfs(0);\n    cout << endl;\n    cout << \"total number: \" << cnt << endl;\n    return 0;\n}\n```\n","slug":"八皇后问题","published":1,"updated":"2021-04-21T03:30:14.790Z","_id":"ck0uh6nm7002bh8vn4p9g55pl","comments":1,"layout":"post","photos":[],"link":""},{"title":"光栅化渲染(4)-深度检测","date":"2019-08-27T12:08:56.000Z","_content":"\n![depth](/depth.png)\n\n　　*如何确定投影区域内每个像素对应的空间物体上一点的深度是本节主要讨论的内容。*\n<!--more-->\n\n# Z-Buffer\n　　在[光栅化算法总述](https://ain-crad.github.io/2019/08/10/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-1-%E7%AE%97%E6%B3%95%E6%80%BB%E8%BF%B0/#more)里我们提到当有多个三角形相互重叠时，它们之上的某些点可能会投影到同一个像素位置，我们要通过``z-buffer``方法来确定这些点的深度大小关系，从而决定像素显示哪一点的颜色。\n　　``z-buffer``是一个二维矩阵，矩阵元素初始化为一个较大的值，当遍历三角面片进行投影时不断更新元素值，用来记录每个像素对应的距离相机最近的空间物体上一点的深度。\n\n# 深度插值\n　　关于如何求解每个像素对应的空间深度值，首先想到的可能是借助上一节提到的**重心坐标**插值的方法。但是由于投影后的比例变化（Figure 1），我们不能直接把投影平面上三角形的面积比作为空间三角形的面积比来得到重心坐标。\n\n![figure 1](/figure1.png)\n<center>Figure 1</center>\n\n　　我们的目标是由投影平面上三角形的重心坐标来推出空间三角形上对应一点的深度值。在[透视投影](https://ain-crad.github.io/2019/08/11/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-2-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1/)部分我们得到了投影坐标：\n\n$$\n\\begin{align}\n&P_{screen}.x = \\cfrac{near * P_{camera}.x}{-P_{camera}.z} \\\\\\\\\n&P_{screen}.y = \\cfrac{near * P_{camera}.y}{-P_{camera}.z} \\\\\\\\\n&P_{screen}.z = -P_{camera}.z\n\\end{align}\n$$\n\n　　*投影之后我们仍然保留空间点的z坐标，利用它们还原计算空间三角形上任一点的深度值。*\n　　\n　　如图（Figure 2），为了简化问题，我们仍只考虑一条在相机空间中的线段，它的两个端点的坐标分别为 $P_0(X_0, Z_0)$ 和 $P_1(X_1, Z_1)$ ，两端点在成像平面上的投影坐标分别为 $S_0$ 和 $S_1$。$S$ 是投影线段上的一点，其分割线段的比例是 $(1 - q):q$ （即重心坐标），$P$ 是 $S$ 对应的原线段上的点，其重心坐标为 $(1-t):t$。\n\n![figure 2](/figure2.png)\n<center>Figure 2</center>\n\n　　我们可以得到如下关系式：\n\n$$\nP = P_0 \\* (1 - t) + P_1 \\* t\nS = S_0 \\* (1 - q) + S_1 \\* q\n$$\n\n　　也可以写做如下形式：\n\n$$\nP = P_0 + t \\* (P_1 - P_0)\nS = S_0 + q \\* (S_1 - S_0)\n$$\n\n　　*S是一维的坐标点，我们下面用它来同时指代自己的坐标值*\n\n　　于是我们可以插值得到 $P$ 和 $S$ 的坐标（Equation 1）：\n\n$$\n\\begin{align}\n&(X, Z)=(X_0 + t \\* (X_1 - X_0), \\quad Z_0 + t \\* (Z_1 - Z0)) \\\\\\\\\n& \\\\\\\\\n&S = S_0 + q \\* (S_1 - S_0)\n\\end{align}\n$$\n\n　　由相似三角形的比例关系我们可以得到（*假设近平面距离near为一个单位长度*）：\n\n$$\n\\cfrac{S}{X} = \\cfrac{1}{Z}\n$$\n\n　　即：\n\n$$\nZ = \\cfrac{X}{S}\n$$\n\n　　把（Equation 1）带入上式得（Equation 2）：\n\n![Equation 2](/equation2.png)\n\n　　类似的我们还有：\n\n$$\nS_0 = \\cfrac{X_0}{Z_0} \\\\\\\\\nS_1 = \\cfrac{X_1}{Z_1}\n$$\n\n　　因此（Equation 3）：\n\n$$\nX_0 = S_0 * Z_0 \\\\\\\\\n \\\\\\\\\nX_1 = S_1 * Z_1\n$$\n\n　　把（Equation 3）带入到（Equation 2）中得到（Equation 4）：\n\n![Equation 4](/equation4.png)\n\n　　由（Equation 1）中我们知道（Equation 5）：\n\n$$\nZ = Z_0 + t \\* (Z_1 - Z0)\n$$\n\n　　带入（Equation 4）中得（Equation 6）:\n\n![Equation 6](/equation6.png)\n\n　　化简（Equation 5）得：\n\n![simplify](/simplify.png)\n\n　　我们现在可以把变量 $t$ 替换掉了：\n\n$$\nt = \\cfrac{qZ_0}{qZ_0 + (1 - q)Z_1}\n$$\n\n　　带入（Equation 5）中得：\n\n![Equation 7](/equation7.png)\n\n　　进而我们就可以得到：\n\n![Equation 8](/equation8.png)\n\n　　至此我们就得到了如何通过投影平面上一点的重心坐标得到其对应空间点的深度的公式。\n\n# 参考链接\n\n[Scrathapixel-The visibility Problem](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation)\n\n\n\n","source":"_posts/光栅化渲染-4-深度检测.md","raw":"---\ntitle: 光栅化渲染(4)-深度检测\ndate: 2019-08-27 20:08:56\ncategories:\n- Computer Graphics\n- 光栅化渲染\ntags:\n---\n\n![depth](/depth.png)\n\n　　*如何确定投影区域内每个像素对应的空间物体上一点的深度是本节主要讨论的内容。*\n<!--more-->\n\n# Z-Buffer\n　　在[光栅化算法总述](https://ain-crad.github.io/2019/08/10/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-1-%E7%AE%97%E6%B3%95%E6%80%BB%E8%BF%B0/#more)里我们提到当有多个三角形相互重叠时，它们之上的某些点可能会投影到同一个像素位置，我们要通过``z-buffer``方法来确定这些点的深度大小关系，从而决定像素显示哪一点的颜色。\n　　``z-buffer``是一个二维矩阵，矩阵元素初始化为一个较大的值，当遍历三角面片进行投影时不断更新元素值，用来记录每个像素对应的距离相机最近的空间物体上一点的深度。\n\n# 深度插值\n　　关于如何求解每个像素对应的空间深度值，首先想到的可能是借助上一节提到的**重心坐标**插值的方法。但是由于投影后的比例变化（Figure 1），我们不能直接把投影平面上三角形的面积比作为空间三角形的面积比来得到重心坐标。\n\n![figure 1](/figure1.png)\n<center>Figure 1</center>\n\n　　我们的目标是由投影平面上三角形的重心坐标来推出空间三角形上对应一点的深度值。在[透视投影](https://ain-crad.github.io/2019/08/11/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93-2-%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1/)部分我们得到了投影坐标：\n\n$$\n\\begin{align}\n&P_{screen}.x = \\cfrac{near * P_{camera}.x}{-P_{camera}.z} \\\\\\\\\n&P_{screen}.y = \\cfrac{near * P_{camera}.y}{-P_{camera}.z} \\\\\\\\\n&P_{screen}.z = -P_{camera}.z\n\\end{align}\n$$\n\n　　*投影之后我们仍然保留空间点的z坐标，利用它们还原计算空间三角形上任一点的深度值。*\n　　\n　　如图（Figure 2），为了简化问题，我们仍只考虑一条在相机空间中的线段，它的两个端点的坐标分别为 $P_0(X_0, Z_0)$ 和 $P_1(X_1, Z_1)$ ，两端点在成像平面上的投影坐标分别为 $S_0$ 和 $S_1$。$S$ 是投影线段上的一点，其分割线段的比例是 $(1 - q):q$ （即重心坐标），$P$ 是 $S$ 对应的原线段上的点，其重心坐标为 $(1-t):t$。\n\n![figure 2](/figure2.png)\n<center>Figure 2</center>\n\n　　我们可以得到如下关系式：\n\n$$\nP = P_0 \\* (1 - t) + P_1 \\* t\nS = S_0 \\* (1 - q) + S_1 \\* q\n$$\n\n　　也可以写做如下形式：\n\n$$\nP = P_0 + t \\* (P_1 - P_0)\nS = S_0 + q \\* (S_1 - S_0)\n$$\n\n　　*S是一维的坐标点，我们下面用它来同时指代自己的坐标值*\n\n　　于是我们可以插值得到 $P$ 和 $S$ 的坐标（Equation 1）：\n\n$$\n\\begin{align}\n&(X, Z)=(X_0 + t \\* (X_1 - X_0), \\quad Z_0 + t \\* (Z_1 - Z0)) \\\\\\\\\n& \\\\\\\\\n&S = S_0 + q \\* (S_1 - S_0)\n\\end{align}\n$$\n\n　　由相似三角形的比例关系我们可以得到（*假设近平面距离near为一个单位长度*）：\n\n$$\n\\cfrac{S}{X} = \\cfrac{1}{Z}\n$$\n\n　　即：\n\n$$\nZ = \\cfrac{X}{S}\n$$\n\n　　把（Equation 1）带入上式得（Equation 2）：\n\n![Equation 2](/equation2.png)\n\n　　类似的我们还有：\n\n$$\nS_0 = \\cfrac{X_0}{Z_0} \\\\\\\\\nS_1 = \\cfrac{X_1}{Z_1}\n$$\n\n　　因此（Equation 3）：\n\n$$\nX_0 = S_0 * Z_0 \\\\\\\\\n \\\\\\\\\nX_1 = S_1 * Z_1\n$$\n\n　　把（Equation 3）带入到（Equation 2）中得到（Equation 4）：\n\n![Equation 4](/equation4.png)\n\n　　由（Equation 1）中我们知道（Equation 5）：\n\n$$\nZ = Z_0 + t \\* (Z_1 - Z0)\n$$\n\n　　带入（Equation 4）中得（Equation 6）:\n\n![Equation 6](/equation6.png)\n\n　　化简（Equation 5）得：\n\n![simplify](/simplify.png)\n\n　　我们现在可以把变量 $t$ 替换掉了：\n\n$$\nt = \\cfrac{qZ_0}{qZ_0 + (1 - q)Z_1}\n$$\n\n　　带入（Equation 5）中得：\n\n![Equation 7](/equation7.png)\n\n　　进而我们就可以得到：\n\n![Equation 8](/equation8.png)\n\n　　至此我们就得到了如何通过投影平面上一点的重心坐标得到其对应空间点的深度的公式。\n\n# 参考链接\n\n[Scrathapixel-The visibility Problem](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation)\n\n\n\n","slug":"光栅化渲染-4-深度检测","published":1,"updated":"2021-04-21T03:30:14.780Z","_id":"ck0uh6nm7002ch8vnic41bev6","comments":1,"layout":"post","photos":[],"link":""},{"title":"哈希表","date":"2018-12-25T13:54:22.000Z","_content":"Youtube上看到一个小哥讲的Hash Table，讲清它的原理和结构之后又带着从零开始实现了构造哈希函数、创建哈希表、增加/删除数据等一系列系统的操作，讲解和示例清晰完整，丝毫不拖泥带水，大赞。\n<!--more-->\n## 链接\n[Introduction to Hash Tables](https://www.youtube.com/watch?v=MfhjkfocRR0&list=PLTxllHdfUq4f7-uHOpxXnBUbsuLiI9pmb&index=1&pbjreload=10)\n\n*需要科学上网，有强烈欲望想要看的同学可以参考之前这篇[ubuntu下服务器搭建](https://ain-crad.github.io/2018/04/13/vultr/)的博客，自己配置外网服务器*\n\n# 哈希表\n![hash](/hash.png)\n哈希表(Hash Table)，是一种数据结构。它通过计算一个关于键值的函数，将所需查询的数据映射到表中的一个位置来访问，这加快了查找的速度。STL中的map就是哈希表的一种实现。\n键值可以是字符串或者其它较为复杂的类型，下面以字符串为例。若将它们直接存储在数组里，当想要访问它们的时候只能O(n)复杂度的遍历一遍。但是通过构造哈希函数，我们可以首先将这个字符串映射为一个整数类型，将这个整数作为它们所在数组位置的下标，这样当我们想要访问某一个字符串，只需要把它送到哈希函数里得到一个返回的哈希值，也就是它所在数组位置的下标，就能以O(1)的复杂度访问它。\n哈希函数的构造方法有很多，但一般我们得不到一个完美的哈希函数，即可能会存在两个字符串它们对应的哈希值相同。为了应对这种冲突，我们可以把数组的每个位置当做链表，存在多值时就链接到链表后面。如上图所示。\n\n# 代码\n边听着小哥的讲解边写的代码，包括了构造哈希函数、创建哈希表、增加/删除数据等操作。\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int tablesize = 40;\nstring s;\nstruct item{\n    item(){\n        name = \"empty\";\n        drink = \"empty\";\n        next = NULL;\n    }\n    string name;\n    string drink;\n    item* next;\n};\nitem* hashTable[tablesize];\n\nvoid Init();\nint Hash(string s);\nvoid AddItem(string name, string drink);\nint NumberOfItemsIndex(int idx);\nvoid PrintTable();\nvoid PrintItemInIndex(int idx);\nvoid FindDrink(string name);\nvoid RemoveItem(string name);\n\nvoid RemoveItem(string name){\n    int idx = Hash(name);\n    item* ptr = hashTable[idx];\n\n    //Case 0 - bucket is empty\n    if(ptr->name == \"empty\"){\n        cout << name << \" was not found in the hashTable\" << endl;\n    }\n\n    //Case 1 - only 1 item contained in bucket and that item has matching name\n    else if(ptr->name == name && ptr->next == NULL){\n        ptr->name = \"empty\";\n        ptr->drink = \"empty\";\n        cout << name << \"was removed from the Hash Table.\" << endl;\n    }\n\n    //Case 2 - match is located in the first item int the bucket but there are \n    //more items in the bucket\n    else if(ptr->name == name && ptr->next != NULL){\n        hashTable[idx] = ptr->next;\n        delete ptr;\n        cout << name << \" was removed from the Hash Table.\" << endl;\n    }\n\n    //Case3 - bucket contains item but first item is not a match\n    else{\n        item* p1;\n        item* p2;\n        p1 = ptr->next;\n        p2 = ptr;\n        while(p1 != NULL && p1->name != name){\n            p1 = p1->next;\n            p2 = p2->next;\n        }\n        //Case 3.1 - no match\n        if(p1 == NULL){\n            cout << name << \" was not found in the hashTable\" << endl;\n        }\n        //Case 3.2 - match is found\n        else{\n            p2->next = p1->next;\n            delete p1;\n            cout << name << \" was removed from the Hash Table.\" << endl;\n        }\n    }\n}\n\nvoid FindDrink(string name){\n    int idx = Hash(name);\n    bool foundName = false;\n    string drink;\n\n    item* ptr = hashTable[idx];\n    while(ptr){\n        if(ptr->name == name){\n            foundName = true;\n            drink = ptr->drink;\n            break;\n        }\n        ptr = ptr->next;\n    }\n    if(foundName){\n        cout << name << \"'s favorite drink = \" << drink << endl;\n    }\n    else{\n        cout << name << \"'s info was not found in the hashTable.\" << endl;\n    }\n}\n\nvoid PrintItemInIndex(int idx){\n    item* ptr = hashTable[idx];\n    if(ptr->name == \"empty\"){\n        cout << \"index \" << idx << \" is empty\" << endl;\n    }\n    else{\n        cout << \"index \" << idx << \" contains the following item\" << endl;\n        while(ptr){\n            cout << \"--------------------\\n\";\n            cout << ptr->name << endl;\n            cout << ptr->drink << endl;\n            cout << \"--------------------\\n\";\n            ptr = ptr->next;\n        }\n    }\n}\n\nvoid PrintTable(){\n    int number;\n    for(int i = 0;i < tablesize; i++){\n        number = NumberOfItemsIndex(i);\n        cout << \"--------------------\\n\";\n        cout << \"index = \" << i << endl;\n        cout << hashTable[i]->name << endl;\n        cout << hashTable[i]->drink << endl;\n        cout << \"number of items = \" << number << endl;\n        cout << \"--------------------\\n\";\n\n    }\n}\n\nint NumberOfItemsIndex(int idx){\n    int count = 0;\n    if(hashTable[idx]->name == \"empty\"){\n        return 0;\n    }\n    else{\n        item* ptr = hashTable[idx];\n        while(ptr){\n            count++;\n            ptr = ptr->next;\n        }\n        return count;\n    }\n}\n\nint Hash(string s){\n    int hashVal = 0;\n    int idx;\n    int len = s.length();\n    for(int i = 0; i < len; i++){\n        hashVal = (hashVal + s[i])*17;\n    }\n    idx = hashVal % tablesize;\n\n    return idx;\n}\n\nvoid AddItem(string name, string drink){\n    int idx = Hash(name);\n    if(hashTable[idx]->name == \"empty\"){\n        hashTable[idx]->name = name;\n        hashTable[idx]->drink = drink;\n    }\n    else{\n        item* newItem = new item();\n        newItem->name = name;\n        newItem->drink = drink;\n        newItem->next = NULL;\n\n        item* ptr = hashTable[idx];\n        while(ptr->next != NULL){\n            ptr = ptr->next;\n        }\n        ptr->next = newItem;\n    }\n}\n\nvoid Init(){\n    for(int i = 0; i < tablesize; i++){\n        hashTable[i] = new item();\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    Init();\n    \n    AddItem(\"Paul\", \"Locha\");\n    AddItem(\"Kim\", \"Iced Mocha\");\n    AddItem(\"Emma\", \"Strawberry Smoothy\");\n    AddItem(\"Annie\", \"Hot Chocolate\");\n    AddItem(\"Sarah\", \"Passion Tea\");\n    AddItem(\"Pepper\", \"Caramel Mocha\");\n    AddItem(\"Mike\", \"Chai Tea\");\n    AddItem(\"Steve\", \"Apple Cider\");\n    AddItem(\"Sill\", \"Root Beer\");\n    AddItem(\"Marie\", \"Skinny Latte\");\n    AddItem(\"Susan\", \"Water\");\n    AddItem(\"Joe\", \"Green Tea\");\n\n    //PrintTable();\n    //PrintItemInIndex(2);\n    //FindDrink(\"Joe\");\n    /*\n    string name;\n    while(name != \"exit\"){\n        cout << \"Remove \";\n        cin >> name;\n        if(s != \"exit\");\n        RemoveItem(name);\n    }\n    */\n\n    return 0;\n}\n```","source":"_posts/哈希表.md","raw":"---\ntitle: 哈希表\ndate: 2018-12-25 21:54:22\ncategories:\n- Summary\ntags:\n- Hash\n---\nYoutube上看到一个小哥讲的Hash Table，讲清它的原理和结构之后又带着从零开始实现了构造哈希函数、创建哈希表、增加/删除数据等一系列系统的操作，讲解和示例清晰完整，丝毫不拖泥带水，大赞。\n<!--more-->\n## 链接\n[Introduction to Hash Tables](https://www.youtube.com/watch?v=MfhjkfocRR0&list=PLTxllHdfUq4f7-uHOpxXnBUbsuLiI9pmb&index=1&pbjreload=10)\n\n*需要科学上网，有强烈欲望想要看的同学可以参考之前这篇[ubuntu下服务器搭建](https://ain-crad.github.io/2018/04/13/vultr/)的博客，自己配置外网服务器*\n\n# 哈希表\n![hash](/hash.png)\n哈希表(Hash Table)，是一种数据结构。它通过计算一个关于键值的函数，将所需查询的数据映射到表中的一个位置来访问，这加快了查找的速度。STL中的map就是哈希表的一种实现。\n键值可以是字符串或者其它较为复杂的类型，下面以字符串为例。若将它们直接存储在数组里，当想要访问它们的时候只能O(n)复杂度的遍历一遍。但是通过构造哈希函数，我们可以首先将这个字符串映射为一个整数类型，将这个整数作为它们所在数组位置的下标，这样当我们想要访问某一个字符串，只需要把它送到哈希函数里得到一个返回的哈希值，也就是它所在数组位置的下标，就能以O(1)的复杂度访问它。\n哈希函数的构造方法有很多，但一般我们得不到一个完美的哈希函数，即可能会存在两个字符串它们对应的哈希值相同。为了应对这种冲突，我们可以把数组的每个位置当做链表，存在多值时就链接到链表后面。如上图所示。\n\n# 代码\n边听着小哥的讲解边写的代码，包括了构造哈希函数、创建哈希表、增加/删除数据等操作。\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int tablesize = 40;\nstring s;\nstruct item{\n    item(){\n        name = \"empty\";\n        drink = \"empty\";\n        next = NULL;\n    }\n    string name;\n    string drink;\n    item* next;\n};\nitem* hashTable[tablesize];\n\nvoid Init();\nint Hash(string s);\nvoid AddItem(string name, string drink);\nint NumberOfItemsIndex(int idx);\nvoid PrintTable();\nvoid PrintItemInIndex(int idx);\nvoid FindDrink(string name);\nvoid RemoveItem(string name);\n\nvoid RemoveItem(string name){\n    int idx = Hash(name);\n    item* ptr = hashTable[idx];\n\n    //Case 0 - bucket is empty\n    if(ptr->name == \"empty\"){\n        cout << name << \" was not found in the hashTable\" << endl;\n    }\n\n    //Case 1 - only 1 item contained in bucket and that item has matching name\n    else if(ptr->name == name && ptr->next == NULL){\n        ptr->name = \"empty\";\n        ptr->drink = \"empty\";\n        cout << name << \"was removed from the Hash Table.\" << endl;\n    }\n\n    //Case 2 - match is located in the first item int the bucket but there are \n    //more items in the bucket\n    else if(ptr->name == name && ptr->next != NULL){\n        hashTable[idx] = ptr->next;\n        delete ptr;\n        cout << name << \" was removed from the Hash Table.\" << endl;\n    }\n\n    //Case3 - bucket contains item but first item is not a match\n    else{\n        item* p1;\n        item* p2;\n        p1 = ptr->next;\n        p2 = ptr;\n        while(p1 != NULL && p1->name != name){\n            p1 = p1->next;\n            p2 = p2->next;\n        }\n        //Case 3.1 - no match\n        if(p1 == NULL){\n            cout << name << \" was not found in the hashTable\" << endl;\n        }\n        //Case 3.2 - match is found\n        else{\n            p2->next = p1->next;\n            delete p1;\n            cout << name << \" was removed from the Hash Table.\" << endl;\n        }\n    }\n}\n\nvoid FindDrink(string name){\n    int idx = Hash(name);\n    bool foundName = false;\n    string drink;\n\n    item* ptr = hashTable[idx];\n    while(ptr){\n        if(ptr->name == name){\n            foundName = true;\n            drink = ptr->drink;\n            break;\n        }\n        ptr = ptr->next;\n    }\n    if(foundName){\n        cout << name << \"'s favorite drink = \" << drink << endl;\n    }\n    else{\n        cout << name << \"'s info was not found in the hashTable.\" << endl;\n    }\n}\n\nvoid PrintItemInIndex(int idx){\n    item* ptr = hashTable[idx];\n    if(ptr->name == \"empty\"){\n        cout << \"index \" << idx << \" is empty\" << endl;\n    }\n    else{\n        cout << \"index \" << idx << \" contains the following item\" << endl;\n        while(ptr){\n            cout << \"--------------------\\n\";\n            cout << ptr->name << endl;\n            cout << ptr->drink << endl;\n            cout << \"--------------------\\n\";\n            ptr = ptr->next;\n        }\n    }\n}\n\nvoid PrintTable(){\n    int number;\n    for(int i = 0;i < tablesize; i++){\n        number = NumberOfItemsIndex(i);\n        cout << \"--------------------\\n\";\n        cout << \"index = \" << i << endl;\n        cout << hashTable[i]->name << endl;\n        cout << hashTable[i]->drink << endl;\n        cout << \"number of items = \" << number << endl;\n        cout << \"--------------------\\n\";\n\n    }\n}\n\nint NumberOfItemsIndex(int idx){\n    int count = 0;\n    if(hashTable[idx]->name == \"empty\"){\n        return 0;\n    }\n    else{\n        item* ptr = hashTable[idx];\n        while(ptr){\n            count++;\n            ptr = ptr->next;\n        }\n        return count;\n    }\n}\n\nint Hash(string s){\n    int hashVal = 0;\n    int idx;\n    int len = s.length();\n    for(int i = 0; i < len; i++){\n        hashVal = (hashVal + s[i])*17;\n    }\n    idx = hashVal % tablesize;\n\n    return idx;\n}\n\nvoid AddItem(string name, string drink){\n    int idx = Hash(name);\n    if(hashTable[idx]->name == \"empty\"){\n        hashTable[idx]->name = name;\n        hashTable[idx]->drink = drink;\n    }\n    else{\n        item* newItem = new item();\n        newItem->name = name;\n        newItem->drink = drink;\n        newItem->next = NULL;\n\n        item* ptr = hashTable[idx];\n        while(ptr->next != NULL){\n            ptr = ptr->next;\n        }\n        ptr->next = newItem;\n    }\n}\n\nvoid Init(){\n    for(int i = 0; i < tablesize; i++){\n        hashTable[i] = new item();\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    Init();\n    \n    AddItem(\"Paul\", \"Locha\");\n    AddItem(\"Kim\", \"Iced Mocha\");\n    AddItem(\"Emma\", \"Strawberry Smoothy\");\n    AddItem(\"Annie\", \"Hot Chocolate\");\n    AddItem(\"Sarah\", \"Passion Tea\");\n    AddItem(\"Pepper\", \"Caramel Mocha\");\n    AddItem(\"Mike\", \"Chai Tea\");\n    AddItem(\"Steve\", \"Apple Cider\");\n    AddItem(\"Sill\", \"Root Beer\");\n    AddItem(\"Marie\", \"Skinny Latte\");\n    AddItem(\"Susan\", \"Water\");\n    AddItem(\"Joe\", \"Green Tea\");\n\n    //PrintTable();\n    //PrintItemInIndex(2);\n    //FindDrink(\"Joe\");\n    /*\n    string name;\n    while(name != \"exit\"){\n        cout << \"Remove \";\n        cin >> name;\n        if(s != \"exit\");\n        RemoveItem(name);\n    }\n    */\n\n    return 0;\n}\n```","slug":"哈希表","published":1,"updated":"2021-04-21T03:30:14.790Z","_id":"ck0uh6nm8002dh8vnxpe9i5ks","comments":1,"layout":"post","photos":[],"link":""},{"title":"八数码问题","date":"2018-12-26T15:07:55.000Z","_content":"八数码问题，最开始是在人工智能基础课上学的，然而我已无力吐槽这门课了，现在我才回想起来原来她当时所讲的open表其实就是栈和队列。而当时那些手算看起来很简单的搜索算法，实际写起来还是会有很多坑的，如果现在再重新学这门课我应该会有很多新的思考和认识吧。\n![EightDigital](/EightDigital.png)\n<!--more-->\n# 八数码问题\n编号为$1-8$的八个正方形滑块被摆成3行3列，其中有一个格子留空。每次可以把与空格相邻的滑块移到空格中，它原来的位置就成了新的空格。给定初始局面和目标局面，计算最少的移动步数。\n因为是计算最少移动步数，所以用BFS来搜索比较合适。但是和一般的图搜索不太一样，这里没有显式的结点。可以想到把每一个“状态”看做图的一个结点，然后根据合法的移动方式去扩展其它结点，直到到达目标状态。\n还有一个问题是如何标记已经访问过的状态，以避免对同一个结点做多次访问。在显式的图搜索里我们一般会开一个vis数组来标记，但是这里如果要用vis数组的话，要开到九维，$9^9$，这对空间的消耗太大了。于是我们可以考虑用之前提到的**哈希**，每一个状态对应一个整型数，一共的状态数是$9! = 362880$种。这样我们用一个vis数组就可以表示出来了。\n*下面的代码是用STL里的set代替vis数组实现判断状态是否已访问过*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed 26 Dec 08:39:43 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node{\n    int d[9];\n    int dis;\n};\nint st[9], ed[9];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nset<int> rec;\nint ans;\n\nbool vis(int x){\n    int len = rec.size();\n    rec.insert(x);\n    if((int)rec.size() > len) return false;\n    else return true;\n}\n\nint Trans(Node& u){\n    int sum = 0;\n    for(int i = 0; i < 9; i++){\n        sum *= 10;\n        sum += u.d[i];\n    }\n    return sum;\n}\n\nbool Match(Node& u){\n    if(memcmp(u.d, ed, sizeof(u.d)) == 0) return true;\n    else return false;\n}\n\nvoid bfs(){\n    queue<Node> que;\n    Node nd;\n    memcpy(nd.d, st, sizeof(nd.d));\n    nd.dis = 0;\n    que.push(nd);\n\n    while(!que.empty()){\n        Node TopItem = que.front();\n        que.pop();\n        if(Match(TopItem)){\n            ans = TopItem.dis;\n            break;\n        }\n        int pos;\n        for(int i = 0; i < 9; i++){\n            if(TopItem.d[i] == 0){\n                pos = i;\n                break;\n            }\n        }\n        int x = pos / 3, y = pos % 3;\n        for(int i = 0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(nx >= 0 && nx < 3 && ny >= 0 && ny < 3){\n                Node u;\n                memcpy(&u, &TopItem, sizeof(u));\n                int p2 = nx * 3 + ny;\n                int tmp = u.d[pos];\n                u.d[pos] = u.d[p2];\n                u.d[p2] = tmp;\n                u.dis = TopItem.dis + 1;\n                if(!vis(Trans(u))){\n                    que.push(u);\n                }\n            }\n        }\n    }\n\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    for(int i = 0; i < 9; i++){\n        cin >> st[i];\n    }\n    for(int i = 0; i < 9; i++){\n        cin >> ed[i];\n    }\n    bfs();\n    cout << ans << endl;\n\n    return 0;\n}\n```\n\n# 打印路径版代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node{\n    int d[9];\n    int dis;\n    int id;\n};\nint st[9], ed[9];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nset<int> rec;\nint ans, num, ItemId;\nint pre[1000000];\nNode data[1000000];\n\nvoid PrintPath(){\n    vector<int> vec;\n    while(ItemId >= 0){\n        vec.push_back(ItemId);\n        ItemId = pre[ItemId];\n    }\n    reverse(vec.begin(), vec.end());\n    for(int x : vec){\n        int* ptr = data[x].d;\n        for(int i = 0; i < 9; i++){\n            if((i + 1) % 3 != 0) cout << ptr[i] << \" \";\n            else cout << ptr[i] << endl;\n        }\n        cout << endl;\n        ItemId = pre[ItemId];\n    }\n}\n\nbool vis(int x){\n    int len = rec.size();\n    rec.insert(x);\n    if((int)rec.size() > len) return false;\n    else return true;\n}\n\nint Trans(Node& u){\n    int sum = 0;\n    for(int i = 0; i < 9; i++){\n        sum *= 10;\n        sum += u.d[i];\n    }\n    return sum;\n}\n\nbool Match(Node& u){\n    if(memcmp(u.d, ed, sizeof(u.d)) == 0) return true;\n    else return false;\n}\n\nvoid bfs(){\n    queue<Node> que;\n    Node nd;\n    memcpy(nd.d, st, sizeof(nd.d));\n    nd.dis = 0;\n    nd.id = num++;\n    que.push(nd);\n    data[nd.id] = nd;\n\n    while(!que.empty()){\n        Node TopItem = que.front();\n        que.pop();\n        if(Match(TopItem)){\n            ans = TopItem.dis;\n            ItemId = TopItem.id;\n            break;\n        }\n        int pos;\n        for(int i = 0; i < 9; i++){\n            if(TopItem.d[i] == 0){\n                pos = i;\n                break;\n            }\n        }\n        int x = pos / 3, y = pos % 3;\n        for(int i = 0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(nx >= 0 && nx < 3 && ny >= 0 && ny < 3){\n                Node u;\n                memcpy(&u, &TopItem, sizeof(u));\n                int p2 = nx * 3 + ny;\n                int tmp = u.d[pos];\n                u.d[pos] = u.d[p2];\n                u.d[p2] = tmp;\n                u.dis = TopItem.dis + 1;\n                if(!vis(Trans(u))){\n                    u.id = num++;\n                    pre[u.id] = TopItem.id;\n                    data[u.id] = u;\n                    que.push(u);\n                }\n            }\n        }\n    }\n\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    num = 0;\n    ans = -1;\n    memset(pre, -1, sizeof(pre));\n\n    for(int i = 0; i < 9; i++){\n        cin >> st[i];\n    }\n    for(int i = 0; i < 9; i++){\n        cin >> ed[i];\n    }\n    bfs();\n    PrintPath();\n    cout << \"Steps: \" << ans << endl;\n\n    return 0;\n}\n```","source":"_posts/八数码问题.md","raw":"---\ntitle: 八数码问题\ndate: 2018-12-26 23:07:55\ncategories:\n- Summary\ntags:\n---\n八数码问题，最开始是在人工智能基础课上学的，然而我已无力吐槽这门课了，现在我才回想起来原来她当时所讲的open表其实就是栈和队列。而当时那些手算看起来很简单的搜索算法，实际写起来还是会有很多坑的，如果现在再重新学这门课我应该会有很多新的思考和认识吧。\n![EightDigital](/EightDigital.png)\n<!--more-->\n# 八数码问题\n编号为$1-8$的八个正方形滑块被摆成3行3列，其中有一个格子留空。每次可以把与空格相邻的滑块移到空格中，它原来的位置就成了新的空格。给定初始局面和目标局面，计算最少的移动步数。\n因为是计算最少移动步数，所以用BFS来搜索比较合适。但是和一般的图搜索不太一样，这里没有显式的结点。可以想到把每一个“状态”看做图的一个结点，然后根据合法的移动方式去扩展其它结点，直到到达目标状态。\n还有一个问题是如何标记已经访问过的状态，以避免对同一个结点做多次访问。在显式的图搜索里我们一般会开一个vis数组来标记，但是这里如果要用vis数组的话，要开到九维，$9^9$，这对空间的消耗太大了。于是我们可以考虑用之前提到的**哈希**，每一个状态对应一个整型数，一共的状态数是$9! = 362880$种。这样我们用一个vis数组就可以表示出来了。\n*下面的代码是用STL里的set代替vis数组实现判断状态是否已访问过*\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed 26 Dec 08:39:43 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node{\n    int d[9];\n    int dis;\n};\nint st[9], ed[9];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nset<int> rec;\nint ans;\n\nbool vis(int x){\n    int len = rec.size();\n    rec.insert(x);\n    if((int)rec.size() > len) return false;\n    else return true;\n}\n\nint Trans(Node& u){\n    int sum = 0;\n    for(int i = 0; i < 9; i++){\n        sum *= 10;\n        sum += u.d[i];\n    }\n    return sum;\n}\n\nbool Match(Node& u){\n    if(memcmp(u.d, ed, sizeof(u.d)) == 0) return true;\n    else return false;\n}\n\nvoid bfs(){\n    queue<Node> que;\n    Node nd;\n    memcpy(nd.d, st, sizeof(nd.d));\n    nd.dis = 0;\n    que.push(nd);\n\n    while(!que.empty()){\n        Node TopItem = que.front();\n        que.pop();\n        if(Match(TopItem)){\n            ans = TopItem.dis;\n            break;\n        }\n        int pos;\n        for(int i = 0; i < 9; i++){\n            if(TopItem.d[i] == 0){\n                pos = i;\n                break;\n            }\n        }\n        int x = pos / 3, y = pos % 3;\n        for(int i = 0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(nx >= 0 && nx < 3 && ny >= 0 && ny < 3){\n                Node u;\n                memcpy(&u, &TopItem, sizeof(u));\n                int p2 = nx * 3 + ny;\n                int tmp = u.d[pos];\n                u.d[pos] = u.d[p2];\n                u.d[p2] = tmp;\n                u.dis = TopItem.dis + 1;\n                if(!vis(Trans(u))){\n                    que.push(u);\n                }\n            }\n        }\n    }\n\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    for(int i = 0; i < 9; i++){\n        cin >> st[i];\n    }\n    for(int i = 0; i < 9; i++){\n        cin >> ed[i];\n    }\n    bfs();\n    cout << ans << endl;\n\n    return 0;\n}\n```\n\n# 打印路径版代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node{\n    int d[9];\n    int dis;\n    int id;\n};\nint st[9], ed[9];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nset<int> rec;\nint ans, num, ItemId;\nint pre[1000000];\nNode data[1000000];\n\nvoid PrintPath(){\n    vector<int> vec;\n    while(ItemId >= 0){\n        vec.push_back(ItemId);\n        ItemId = pre[ItemId];\n    }\n    reverse(vec.begin(), vec.end());\n    for(int x : vec){\n        int* ptr = data[x].d;\n        for(int i = 0; i < 9; i++){\n            if((i + 1) % 3 != 0) cout << ptr[i] << \" \";\n            else cout << ptr[i] << endl;\n        }\n        cout << endl;\n        ItemId = pre[ItemId];\n    }\n}\n\nbool vis(int x){\n    int len = rec.size();\n    rec.insert(x);\n    if((int)rec.size() > len) return false;\n    else return true;\n}\n\nint Trans(Node& u){\n    int sum = 0;\n    for(int i = 0; i < 9; i++){\n        sum *= 10;\n        sum += u.d[i];\n    }\n    return sum;\n}\n\nbool Match(Node& u){\n    if(memcmp(u.d, ed, sizeof(u.d)) == 0) return true;\n    else return false;\n}\n\nvoid bfs(){\n    queue<Node> que;\n    Node nd;\n    memcpy(nd.d, st, sizeof(nd.d));\n    nd.dis = 0;\n    nd.id = num++;\n    que.push(nd);\n    data[nd.id] = nd;\n\n    while(!que.empty()){\n        Node TopItem = que.front();\n        que.pop();\n        if(Match(TopItem)){\n            ans = TopItem.dis;\n            ItemId = TopItem.id;\n            break;\n        }\n        int pos;\n        for(int i = 0; i < 9; i++){\n            if(TopItem.d[i] == 0){\n                pos = i;\n                break;\n            }\n        }\n        int x = pos / 3, y = pos % 3;\n        for(int i = 0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(nx >= 0 && nx < 3 && ny >= 0 && ny < 3){\n                Node u;\n                memcpy(&u, &TopItem, sizeof(u));\n                int p2 = nx * 3 + ny;\n                int tmp = u.d[pos];\n                u.d[pos] = u.d[p2];\n                u.d[p2] = tmp;\n                u.dis = TopItem.dis + 1;\n                if(!vis(Trans(u))){\n                    u.id = num++;\n                    pre[u.id] = TopItem.id;\n                    data[u.id] = u;\n                    que.push(u);\n                }\n            }\n        }\n    }\n\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    num = 0;\n    ans = -1;\n    memset(pre, -1, sizeof(pre));\n\n    for(int i = 0; i < 9; i++){\n        cin >> st[i];\n    }\n    for(int i = 0; i < 9; i++){\n        cin >> ed[i];\n    }\n    bfs();\n    PrintPath();\n    cout << \"Steps: \" << ans << endl;\n\n    return 0;\n}\n```","slug":"八数码问题","published":1,"updated":"2021-04-21T03:30:14.790Z","_id":"ck0uh6nm8002eh8vnzrf9lddc","comments":1,"layout":"post","photos":[],"link":""},{"title":"静态链接库(STATIC)和动态链接库(SHARED)","date":"2019-04-03T13:38:29.000Z","_content":"　　静态链接库、动态链接库的区别和特点。\n<!--more-->\n# 静态链接库\n## 概念\n　　静态链接库是以.a为后缀的文件（window下以.lib为后缀）。和库相关的所有代码都在这个文件中，它在**编译**时直接链接到程序中。如果一个程序使用静态编译，它会从静态链接库中**复制**需要的那部分代码，并使其成为**程序的一部分**。\n\n## 特点\n- 对静态库的链接是在**编译时期**完成的。\n- 由于程序是直接从静态库中**复制**代码，所以生成的二进制文件的**体积会比较大**。\n- 正是因为第二个特点程序会将静态库中代码整合成为程序的一部分，所以使得生成的程序**移植十分方便**。因为程序在运行时已经和库之间没有联系。\n- 静态库更新时，使用它的应用程序需要**重新编译**。\n\n## 示意图\n![static](/static.png)\n\n　　*图片来源：[Tyler's Blog-C++静态库与动态库](https://www.cnblogs.com/skynet/p/3372855.html)*\n\n# 动态链接库\n## 概念\n　　动态链接库是以.so为后缀的文件(windows下以.dll为后缀，OS X下以.dylib为后缀)。和库相关的所有代码都在这个文件中，它在程序**运行**时被**引用**。如果一个程序使用动态编译，它只会**引用**需要的那部分代码，不会将库中代码和自身整合在一起。\n\n## 特点\n- 动态库是在程序**运行**时被链接的。\n- 每个使用动态库的程序都只**引用**动态库的代码，使得二进制文件**体积较小**。\n- 动态库更新时，**不需要重新编译**使用它的应用程序。\n- 动态库会**增加额外的程序运行时间**，因为需要在运行时链接库中相关代码。\n\n## 示意图\n![shared](/shared.png)\n\n　　*图片来源：[Tyler's Blog-C++静态库与动态库](https://www.cnblogs.com/skynet/p/3372855.html)*\n\n# 总结\n　　静态链接库和动态链接库有各自的特点，一般情况下为了节省内存资源我们会比较多的使用动态库，但是在需要保证应用程序不受外部依赖限制的时候我们会使用静态库。\n\n# 参考链接\n\n[Stack Overflow--Difference between static and shared libraries](https://stackoverflow.com/questions/2649334/difference-between-static-and-shared-libraries)\n[Tyler's Blog-C++静态库与动态库](https://www.cnblogs.com/skynet/p/3372855.html)","source":"_posts/静态链接库-STATIC-和动态链接库-SHARED.md","raw":"---\ntitle: 静态链接库(STATIC)和动态链接库(SHARED)\ndate: 2019-04-03 21:38:29\ncategories:\n- Summary\ntags:\n- Link Library\n---\n　　静态链接库、动态链接库的区别和特点。\n<!--more-->\n# 静态链接库\n## 概念\n　　静态链接库是以.a为后缀的文件（window下以.lib为后缀）。和库相关的所有代码都在这个文件中，它在**编译**时直接链接到程序中。如果一个程序使用静态编译，它会从静态链接库中**复制**需要的那部分代码，并使其成为**程序的一部分**。\n\n## 特点\n- 对静态库的链接是在**编译时期**完成的。\n- 由于程序是直接从静态库中**复制**代码，所以生成的二进制文件的**体积会比较大**。\n- 正是因为第二个特点程序会将静态库中代码整合成为程序的一部分，所以使得生成的程序**移植十分方便**。因为程序在运行时已经和库之间没有联系。\n- 静态库更新时，使用它的应用程序需要**重新编译**。\n\n## 示意图\n![static](/static.png)\n\n　　*图片来源：[Tyler's Blog-C++静态库与动态库](https://www.cnblogs.com/skynet/p/3372855.html)*\n\n# 动态链接库\n## 概念\n　　动态链接库是以.so为后缀的文件(windows下以.dll为后缀，OS X下以.dylib为后缀)。和库相关的所有代码都在这个文件中，它在程序**运行**时被**引用**。如果一个程序使用动态编译，它只会**引用**需要的那部分代码，不会将库中代码和自身整合在一起。\n\n## 特点\n- 动态库是在程序**运行**时被链接的。\n- 每个使用动态库的程序都只**引用**动态库的代码，使得二进制文件**体积较小**。\n- 动态库更新时，**不需要重新编译**使用它的应用程序。\n- 动态库会**增加额外的程序运行时间**，因为需要在运行时链接库中相关代码。\n\n## 示意图\n![shared](/shared.png)\n\n　　*图片来源：[Tyler's Blog-C++静态库与动态库](https://www.cnblogs.com/skynet/p/3372855.html)*\n\n# 总结\n　　静态链接库和动态链接库有各自的特点，一般情况下为了节省内存资源我们会比较多的使用动态库，但是在需要保证应用程序不受外部依赖限制的时候我们会使用静态库。\n\n# 参考链接\n\n[Stack Overflow--Difference between static and shared libraries](https://stackoverflow.com/questions/2649334/difference-between-static-and-shared-libraries)\n[Tyler's Blog-C++静态库与动态库](https://www.cnblogs.com/skynet/p/3372855.html)","slug":"静态链接库-STATIC-和动态链接库-SHARED","published":1,"updated":"2021-04-21T03:30:14.790Z","_id":"ck0uh6nm9002fh8vnvsx185iz","comments":1,"layout":"post","photos":[],"link":""},{"title":"循环小数化为分数的方法","date":"2018-12-09T15:14:07.000Z","_content":"修数学双学位的朋友给我出了一道小学奥数题= =，一个以abc为循环节的小数0.abc...，（其中a，b，c都是0～9的整数，且互不相同）。假设它的真分数表达形式为$\\frac{m}{n}，0 < n < 100$，求这个范围里的所有的n的可能取值。然而我用程序暴力破解了2333。虽然被朋友谴责了，但是这就是程序猿的解决方式(逃\n下面先给出数学求解方式，最后附上暴力破解程序。\n<!--more-->\n# 参考链接\n[Wikiwand-循环小数](https://www.wikiwand.com/zh-cn/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0)\n[无限循环小数化分数](http://math001.com/decimal_to_fraction/)\n\n# 数学解法\n设x = 0.abcabcabc...，则1000x = abc.abcabcabc...。\n1000x - x = abc.abcabcabc... - 0.abcabcabc...，即999x = abc。所以$$x = \\frac{abc}{999}$$999的因子有1，3，9，27，37，111，333，999，因为a，b，c各不相同且0 < n < 100，所以n的可能取值为27和37。\n\n维基百科上关于计算更一般情况的解法：\n![wiki](/wiki.png)\n此外第二个参考链接的博主还提出了一种计算等比数列和的求解方式也很有意思。\n\n# 暴力解法\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 10 Dec 00:11:35 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\n\nbool ok(string s){\n    if(s[2] == s[5] && s[3] == s[6] && s[4] == s[7] && s[2] != s[3] && s[2] != s[4] && s[3] != s[4]){\n        return true;\n    }\n    return false;\n}\n\nint gcd(int a, int b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n\n    for(int m = 1; m < 100; m++){\n        for(int n = m + 1; n < 100; n++){\n            double x = (double)m / n;\n            stringstream ss;\n            ss << x;\n            ss >> s;\n            if(ok(s)){\n                int d = gcd(m, n);\n                cout << m / d << \" \" << n / d << \" \" << x << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n```","source":"_posts/循环小数化为分数的方法.md","raw":"---\ntitle: 循环小数化为分数的方法\ndate: 2018-12-09 23:14:07\ncategories:\n- Math\ntags:\n- Math\n---\n修数学双学位的朋友给我出了一道小学奥数题= =，一个以abc为循环节的小数0.abc...，（其中a，b，c都是0～9的整数，且互不相同）。假设它的真分数表达形式为$\\frac{m}{n}，0 < n < 100$，求这个范围里的所有的n的可能取值。然而我用程序暴力破解了2333。虽然被朋友谴责了，但是这就是程序猿的解决方式(逃\n下面先给出数学求解方式，最后附上暴力破解程序。\n<!--more-->\n# 参考链接\n[Wikiwand-循环小数](https://www.wikiwand.com/zh-cn/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0)\n[无限循环小数化分数](http://math001.com/decimal_to_fraction/)\n\n# 数学解法\n设x = 0.abcabcabc...，则1000x = abc.abcabcabc...。\n1000x - x = abc.abcabcabc... - 0.abcabcabc...，即999x = abc。所以$$x = \\frac{abc}{999}$$999的因子有1，3，9，27，37，111，333，999，因为a，b，c各不相同且0 < n < 100，所以n的可能取值为27和37。\n\n维基百科上关于计算更一般情况的解法：\n![wiki](/wiki.png)\n此外第二个参考链接的博主还提出了一种计算等比数列和的求解方式也很有意思。\n\n# 暴力解法\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 10 Dec 00:11:35 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\n\nbool ok(string s){\n    if(s[2] == s[5] && s[3] == s[6] && s[4] == s[7] && s[2] != s[3] && s[2] != s[4] && s[3] != s[4]){\n        return true;\n    }\n    return false;\n}\n\nint gcd(int a, int b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n\n    for(int m = 1; m < 100; m++){\n        for(int n = m + 1; n < 100; n++){\n            double x = (double)m / n;\n            stringstream ss;\n            ss << x;\n            ss >> s;\n            if(ok(s)){\n                int d = gcd(m, n);\n                cout << m / d << \" \" << n / d << \" \" << x << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n```","slug":"循环小数化为分数的方法","published":1,"updated":"2021-04-21T03:30:14.790Z","_id":"ck0uh6nma002gh8vnq6fmcb3r","comments":1,"layout":"post","photos":[],"link":""},{"title":"欧拉路","date":"2018-11-04T12:54:42.000Z","_content":"有一条名为Pregel的河流经过Konigsberg城。城中有7座桥，把河中的两个岛与河岸连接起来。当地居民热衷于一个难题：是否存在一条线路，可以不重复的走遍7座桥。这就是著名的七桥问题。它由大数学家欧拉首先提出，并给出完美的解答，所以这样的一条路也叫欧拉道路。\n![Elur](/Elur.png)\n\n<!--more-->\n# 参考\n《算法竞赛入门经典（2）》\n\nPs：图片来自[维基百科](https://www.wikiwand.com/zh-hans/%E6%9F%AF%E5%B0%BC%E6%96%AF%E5%A0%A1%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98)\n\n# 欧拉路（欧拉回路）\n将七桥问题用图论的形式表达：能否从无向图中的一个结点出发走出一条道路，每条边恰好经过一次。\n\n可以发现，除起点和终点外其它点的“进”和“出”是对应的，即其它点的度数应为偶数。这也是判断欧拉路是否存在的充分条件--**如果一个无向图是连通的，且最多只有两个奇点，则一定存在欧拉道路。如果有两个奇点，则必须从其中一个奇点出发，另一个奇点终止；如果奇点不存在，则可以从任意点出发，最终一点会回到该点（欧拉回路）**\n\n类似的对有向图来说--**最多只能有两个点的入度不等于出度， 而且必须是其中一个点的出度恰好比入度大1（把它作为起点），另一个的入度比出度大1（把它作为终点）。还有一个前提条件：在忽略边的方向后，图必须是连通的**\n\n# 代码\n```C++\nvoid elur(int u){\n    for(int v = 0; v < n; v++){\n        if(G[u][v] && !vis[u][v]){\n            vis[u][v] = vis[v][u] = 1;\n            elur(v);\n        }\n        printf(\"%d %d\\n\", u, v);\n    }\n}\n\n//说明\n1.上面的代码适用于无向图，但是可以改为有向图：把vis[u][v] = vis[v][u] = 1改成vis[u][v] = 1\n2.上面的代码是逆序打印，可以把printf改为push，将边压栈，最后顺序打印。\n```\n","source":"_posts/欧拉回路.md","raw":"---\ntitle: 欧拉路\ndate: 2018-11-04 20:54:42\ncategories:\n- Summary\ntags:\n- 欧拉路\n---\n有一条名为Pregel的河流经过Konigsberg城。城中有7座桥，把河中的两个岛与河岸连接起来。当地居民热衷于一个难题：是否存在一条线路，可以不重复的走遍7座桥。这就是著名的七桥问题。它由大数学家欧拉首先提出，并给出完美的解答，所以这样的一条路也叫欧拉道路。\n![Elur](/Elur.png)\n\n<!--more-->\n# 参考\n《算法竞赛入门经典（2）》\n\nPs：图片来自[维基百科](https://www.wikiwand.com/zh-hans/%E6%9F%AF%E5%B0%BC%E6%96%AF%E5%A0%A1%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98)\n\n# 欧拉路（欧拉回路）\n将七桥问题用图论的形式表达：能否从无向图中的一个结点出发走出一条道路，每条边恰好经过一次。\n\n可以发现，除起点和终点外其它点的“进”和“出”是对应的，即其它点的度数应为偶数。这也是判断欧拉路是否存在的充分条件--**如果一个无向图是连通的，且最多只有两个奇点，则一定存在欧拉道路。如果有两个奇点，则必须从其中一个奇点出发，另一个奇点终止；如果奇点不存在，则可以从任意点出发，最终一点会回到该点（欧拉回路）**\n\n类似的对有向图来说--**最多只能有两个点的入度不等于出度， 而且必须是其中一个点的出度恰好比入度大1（把它作为起点），另一个的入度比出度大1（把它作为终点）。还有一个前提条件：在忽略边的方向后，图必须是连通的**\n\n# 代码\n```C++\nvoid elur(int u){\n    for(int v = 0; v < n; v++){\n        if(G[u][v] && !vis[u][v]){\n            vis[u][v] = vis[v][u] = 1;\n            elur(v);\n        }\n        printf(\"%d %d\\n\", u, v);\n    }\n}\n\n//说明\n1.上面的代码适用于无向图，但是可以改为有向图：把vis[u][v] = vis[v][u] = 1改成vis[u][v] = 1\n2.上面的代码是逆序打印，可以把printf改为push，将边压栈，最后顺序打印。\n```\n","slug":"欧拉回路","published":1,"updated":"2021-04-21T03:30:14.790Z","_id":"ck0uh6nma002hh8vncvg47csd","comments":1,"layout":"post","photos":[],"link":""},{"title":"Kalman filter-卡尔曼滤波器","date":"2019-04-17T07:15:33.000Z","_content":"　　卡尔曼滤波理论，由卡尔曼博士在1960年访问NASA时首次提出，震惊了NASA，促成了著名的“阿波罗”计划，使人类第一次登上月球。\n\n![Rudolf_Kalman](/Rudolf_Kalman.jpg)\n<!--more-->\n\n# 什么是卡尔曼滤波\n　　[维基百科上的解释](https://www.wikiwand.com/zh-hans/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2)：卡尔曼滤波是一种高效率的递归滤波器，它能从一系列的不完全及包含杂讯的测量中，估计动态系统的状态。\n　　简单来说就是它可以有效利用多个粗糙数据之间的关系，对多个数据进行融合。下面举个简单的例子：\n\n*例子来源[Kent Zeng](https://www.zhihu.com/question/23971601/answer/26254459)*\n　　假设我们有两个传感器，测的是同一个信号，譬如说物体的位置$(x, y, z)$。可是它们每次的读数都不太一样，即传感器的信号有波动，怎么办？\n　　**取平均。**\n　　再假设我们知道其中那个价格贵一些的传感器应该更准一些，比取平均更好的方法是：\n　　**取加权平均。**即我们把精度更高的传感器的权值设的高一点，表示我们更相信它的测量结果。假设两个传感器的测量误差都符合正态分布，我们可以将这**两个正态分布合成为一个新的正态分布**。具体过程在下面的原理部分讨论，这种理解方式很重要。\n　　但是如果我们只有一个传感器，但是还有一个数学模型，譬如物体的运动模型。模型可以帮我们算出一个物体的位置值，但也不是那么准。怎么办？\n　　**把模型算出来的值和传感器测出来的值，像两个传感器那样，取加权平均。**\n\n# 卡尔曼滤波原理\n## 运动模型\n　　同样我们用测量物体的位置的例子来说明。假设我们要实时的得到机器人在空间中的位置。如上面所说，我们需要一个机器人的运动模型，如果我们不知道机器人确切的运动模型，可以先简单的假定其为匀速运动模型。\n　　有了运动模型之后，我们就可以通过一组**状态变量**$x$来描述机器人在某一时刻的状态，包括位置$p$和速度$v$。\n\n$$\nx=\n \\begin{bmatrix}\n    p \\\\\\\\\n    v \\\\\\\\\n  \\end{bmatrix}\n$$\n\n　　这里的$x, p, v$都是向量，其中，$p=\\begin{bmatrix} x \\\\\\\\ y \\\\\\\\ z \\end{bmatrix}$，$v=\\begin{bmatrix} v_x \\\\\\\\ v_y \\\\\\\\ v_z \\end{bmatrix}$\n　　这里我们只记录了位置和速度，但是取决于我们的模型以及我们期望获得的数据我们可以把任何数据变量放进系统状态里。\n　　用运动方程来表示我们建立的匀速模型：\n\n$$\np_k = p_{k - 1} + \\Delta t \\times{v_{k - 1}} \\\\\\\\\nv_k = v_{k - 1}\n$$\n\n　　写成矩阵形式：\n\n$$\nx_k=\n \\begin{bmatrix}\n    p_k \\\\\\\\\n    v_k \\\\\\\\\n  \\end{bmatrix}\n=\n \\begin{bmatrix}\n    1 & \\Delta t \\\\\\\\\n    0 & 1 \\\\\\\\\n \\end{bmatrix}\n \\begin{bmatrix}\n    p_{k -1} \\\\\\\\\n    v_{k - 1} \\\\\\\\\n \\end{bmatrix}\n$$\n\n　　因为$x$实际上是一个包含三个位置量和三个速度量的六维向量，所以由$x_{k - 1}$到$x_{k}$的转移矩阵可具体表示为：\n\n$$\nx_k=\n \\begin{bmatrix}\n    1 & 0 & 0 & \\Delta t & 0 & 0 \\\\\\\\\n    0 & 1 & 0 & 0 & \\Delta t & 0 \\\\\\\\\n    0 & 0 & 1 & 0 & 0 & \\Delta t \\\\\\\\\n    0 & 0 & 0 & 1 & 0 & 0 \\\\\\\\\n    0 & 0 & 0 & 0 & 1 & 0 \\\\\\\\\n    0 & 0 & 0 & 0 & 0 & 1 \\\\\\\\\n \\end{bmatrix}\n x_{k - 1}\n$$\n\n　　把转移矩阵记为$F$，则$x_k = Fx_{k - 1}$\n　　卡尔曼滤波假设所有变量的值符合**正态分布**，那么系统各变量间的**不确定度**可以用**[协方差](https://ain-crad.github.io/2019/03/27/Covariance-%E5%8D%8F%E6%96%B9%E5%B7%AE/)**来表示，系统状态的协方差记为$P_k$，这是一个$6\\times{6}$的对称矩阵。\n　　由于我们有下面的公式：\n\n$$\nCov(x) = \\Sigma \\\\\\\\\nCov(Ax) = A \\Sigma A^T\n$$\n\n　　所以综合上面的运动模型我们可以得到**状态变量以及误差的更新公式**：\n\n$$\nx_k = Fx_{k - 1} \\\\\\\\\nP_k = FP_{k -1}F^T\n$$\n\n　　之前提到我们的模型一般不会是100%准确的，那么就会存在一个**预测误差**，我们把这个预测误差矩阵记为$Q$，表示预测上的高斯噪声。对误差做简单的叠加，可以得到**完整的预测转换方程**：\n\n$$\nx_k = Fx_{k - 1} \\\\\\\\\nP_k = FP_{k - 1}F^T + Q\n$$\n\n　　*Ps.有时我们会看到$x_k = Fx_{k - 1} + Bu_k$这种转移方程的写法，这是引入了一个可以预测的外力影响因素，表示系统当前状态并不只依靠上一个系统状态。譬如，机器人的运动受当时风速的影响，那么$u_k$就表示风速变量，$B$表示风速变量到系统状态变量的转换矩阵。*\n\n## 观测模型\n　　我们还需要一个（或多个）传感器来提供系统状态的**观测数据**，通过测量值来精炼上一阶段模型的预测值。传感器所能够测得的变量由其功能决定，假设我们现在有一个传感器可以直接得到机器人的位置状态量$p$，$p=\\begin{bmatrix} x & y & z \\end{bmatrix}^T$。\n　　注意传感器测量量的范围和单位可能与系统状态变量的范围和单位不一致，所以我们需要做如下变换：\n\n$$\n\\mu = Hx_k \\\\\\\\\n\\Sigma = HP_kH^T\n$$\n\n　　其中$H$为变换矩阵，具体到我们所讨论的例子，传感器只能测得6个系统状态量中的3个，所以要做如下变换，把系统状态量变换到传感器测量空间中去：\n\n$$\n\\begin{bmatrix}\n    x \\\\\\\\\n    y \\\\\\\\\n    z \\\\\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    1 & 0 & 0 & 0 & 0 & 0 \\\\\\\\\n    0 & 1 & 0 & 0 & 0 & 0 \\\\\\\\\n    0 & 0 & 1 & 0 & 0 & 0 \\\\\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n    x \\\\\\\\\n    y \\\\\\\\\n    z \\\\\\\\\n    v_x \\\\\\\\\n    v_y \\\\\\\\\n    v_z \\\\\\\\\n\\end{bmatrix}\n$$\n\n　　传感器也有自己的精度范围，换句话说传感器的读数会收到高斯噪声的影响在某个范围内波动。我们把传感器**测量值不确定性**的方差记为$R$，传感器实际返回的值（即正态分布均值）记为$z_k$。\n\n## 数据融合\n　　现在每一时刻我们都有了两个高维的正态分布模型，一个来自模型的预测值，另一个来自传感器的测量值。我们尝试去进行**数据的融合**。其实非常简单，对每一个模型来说我们有了它在空间各个位置的**概率密度函数**，我们需要找到**最大可能性**的那个位置，那么我们只要将**两者相乘**就好了。\n　　非常值得高兴的是，**两个正态分布相乘，结果还是一个正态分布！**于是新的正态分布的**均值位置**就是两模型相乘后**概率密度最大**的位置处。理所当然的我们就可以把它选做该时刻的机器人的位置**估计值**。\n![gauss](/gauss.jpg)\n\n　　下面做一些简要的推导：\n\n*太懒了直接贴图，来源[米开朗基罗赵](https://www.zhihu.com/question/23971601)*\n\n　　一维正态分布定义：\n\n![g1](/g1.jpg)\n\n　　我们想知道两个均值、方差不同的正态分布相乘的结果：\n\n![g2](/g2.jpg)\n\n　　把公式(9)带入(10)然后做一些变换，可以得到：\n\n![g3](/g3.jpg)\n\n　　因式分解出一部分，表示为$k$：\n\n![g4](/g4.jpg)\n\n　　上面是一维的情况，扩展到高维，直接把(12)和(13)表示成矩阵形式就好了：\n\n![g5](/g5.jpg)\n\n　　现在出现的这个$K$就是那个让人很难理解的**卡尔曼增益**了，但是在这里这很简单，只是两个正态分布合并过程中因式分解出的一项。\n　　现在我们来把(14)和(15)中的变量替换一下，替换成我们分析出的运动模型和观测模型的均值、方差，其中把运动模型变换到传感器测量空间中：\n\n$$\n(\\mu_0, \\Sigma_0)=(Hx_k, HP_kH^T) \\\\\\\\\n(\\mu_1, \\Sigma_1)=(z_k, R)\n$$\n\n　　经过化简，我们就可以得到三个更新公式了，再加上之前的两个运动模型方程，共同组成卡尔曼滤波的**五个核心公式**：\n\n$$\nx_k = Fx_{k - 1} \\\\\\\\\nP_k = FP_{k - 1}F^T + Q \\\\\\\\\nK = P_kH^T(HP_kH^T + R)^{-1} \\\\\\\\\n\\hat{x_k} = x_k + K(z_k - Hx_k) \\\\\\\\\n\\hat{P_k} = (I - KH)P_k\n$$\n\n　　其中$\\hat{x_k}$为该时刻的位置估计值，同时将作为下一次迭代的$x_{k - 1}$，$\\hat{P_k}$为更新后的系统方差，将作为下一下迭代的$P_{k - 1}$\n\n# 实例\n　　这一部分是一个实例，具体背景是我通过双目相机追踪并还原了手指在空间中运动的一些三维轨迹点（螺旋上升轨迹），但是数据有些噪音（波动），下面是原始数据以及用卡尔曼滤波后的效果图：\n\n![origin](/origin.png)\n![afterFilter](/afterFilter.png)\n\n附上源代码：\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu 18 Apr 18:51:49 CST 2019\n *\n */\n\n#include <Eigen/Core>\n#include <Eigen/LU>\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\nusing namespace Eigen;\n\ntypedef Matrix<double, 6, 6> Matrix6d;\ntypedef Matrix<double, 6, 1> Vector6d;\n\nint main(int argc, char* argv[]){\n    char c;\n    double x, y, z, dx, dy, dz;\n    double nx, ny, nz;\n    double x1, y1, z1, x2, y2, z2;\n\n    Matrix6d F, P, Q, P_;\n    Matrix<double, 3, 6> H;\n    Matrix<double, 6, 3> G;\n    Matrix3d R;\n\n    ifstream fin;\n    ofstream fout;\n    fin.open(argv[1]);\n    fout.open(argv[2]);\n    fin >> c >> x1 >> y1 >> z1;\n    fin >> c >> x2 >> y2  >> z2;\n    fout << c << \" \" << x1 << \" \" << y1  << \" \" << z1 << endl;\n    fout << c << \" \" << x2 << \" \" << y2  << \" \" << z2 << endl;\n    x = x2, y = y2, z = z2;\n    dx = x2 - x1, dy = y2 - y1, dz = z2 - z1;\n\n    Vector6d X, X_;\n    Vector3d Z;\n    X << x , y , z , dx , dy , dz;\n\n    F << 1, 0, 0, 1, 0, 0,\n         0, 1, 0, 0, 1, 0,\n         0, 0, 1, 0, 0, 1,\n         0, 0, 0, 1, 0, 0,\n         0, 0, 0, 0, 1, 0,\n         0, 0, 0, 0, 0, 1;\n\n    H << 1, 0, 0, 0, 0, 0,\n         0, 1, 0, 0, 0, 0,\n         0, 0, 1, 0, 0, 0;\n\n    P = Matrix6d::Identity() * 1;\n\n    Q = Matrix6d::Identity() * 1e-4;\n    R = Matrix3d::Identity() * 1;\n\n    while(fin >> c >> nx >> ny >> nz){\n        Z << nx , ny , nz;\n\n        X_ = F * X;\n        P_ = F * P * F.transpose() + Q;\n\n        G = P_ * H.transpose() * (H * P_ * H.transpose() + R).inverse();\n        X = X_ + G * (Z - H * X_);\n        P = (Matrix6d::Identity() - G * H) * P_;\n        \n        fout << \"v \" << X(0) << ' ' << X(1) << ' ' << X(2) << endl;\n    }\n\n    fin.close();\n    fout.close();\n\n    return 0;\n}\n```\n使用cmake编译，CMakeLists.txt中的内容：\n```makefile\ncmake_minimum_required(VERSION 3.5.1)\nproject(Ekf)\n\nfind_package(Eigen3 REQUIRED)\ninclude_directories(${EIGEN3_INCLUDE_DIRS})\n\nadd_executable(ekf ekf.cpp)\n```\n# 参考链接\n\n[The Extended Kalman Filter:An Interactive Tutorial for Non-Experts](https://home.wlu.edu/~levys/kalman_tutorial/)\n[卡尔曼滤波－－从推导到应用](https://blog.csdn.net/heyijia0327/article/details/17487467)\n[如何通俗并尽可能详尽解释卡尔曼滤波](https://www.zhihu.com/question/23971601)\n[理解Kalman滤波的使用](https://www.cnblogs.com/jcchen1987/p/4371439.html)\n\n　　这些文章在我学习卡尔曼滤波的过程中给予了我很大的帮助，感谢各位博主。其中第三个链接为知乎的回答，我主要参考了其中的[Kent Zeng]用户、[太空精酿]用户以及[米开朗基罗赵]用户的回答。\n\n# 总结\n　　卡尔曼老爷子实在是太强了Orz。","source":"_posts/Kalman-filter-卡尔曼滤波器.md","raw":"---\ntitle: Kalman filter-卡尔曼滤波器\ndate: 2019-04-17 15:15:33\ncategories:\n- Summary\ntags:\n- Kalman filter\n---\n　　卡尔曼滤波理论，由卡尔曼博士在1960年访问NASA时首次提出，震惊了NASA，促成了著名的“阿波罗”计划，使人类第一次登上月球。\n\n![Rudolf_Kalman](/Rudolf_Kalman.jpg)\n<!--more-->\n\n# 什么是卡尔曼滤波\n　　[维基百科上的解释](https://www.wikiwand.com/zh-hans/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2)：卡尔曼滤波是一种高效率的递归滤波器，它能从一系列的不完全及包含杂讯的测量中，估计动态系统的状态。\n　　简单来说就是它可以有效利用多个粗糙数据之间的关系，对多个数据进行融合。下面举个简单的例子：\n\n*例子来源[Kent Zeng](https://www.zhihu.com/question/23971601/answer/26254459)*\n　　假设我们有两个传感器，测的是同一个信号，譬如说物体的位置$(x, y, z)$。可是它们每次的读数都不太一样，即传感器的信号有波动，怎么办？\n　　**取平均。**\n　　再假设我们知道其中那个价格贵一些的传感器应该更准一些，比取平均更好的方法是：\n　　**取加权平均。**即我们把精度更高的传感器的权值设的高一点，表示我们更相信它的测量结果。假设两个传感器的测量误差都符合正态分布，我们可以将这**两个正态分布合成为一个新的正态分布**。具体过程在下面的原理部分讨论，这种理解方式很重要。\n　　但是如果我们只有一个传感器，但是还有一个数学模型，譬如物体的运动模型。模型可以帮我们算出一个物体的位置值，但也不是那么准。怎么办？\n　　**把模型算出来的值和传感器测出来的值，像两个传感器那样，取加权平均。**\n\n# 卡尔曼滤波原理\n## 运动模型\n　　同样我们用测量物体的位置的例子来说明。假设我们要实时的得到机器人在空间中的位置。如上面所说，我们需要一个机器人的运动模型，如果我们不知道机器人确切的运动模型，可以先简单的假定其为匀速运动模型。\n　　有了运动模型之后，我们就可以通过一组**状态变量**$x$来描述机器人在某一时刻的状态，包括位置$p$和速度$v$。\n\n$$\nx=\n \\begin{bmatrix}\n    p \\\\\\\\\n    v \\\\\\\\\n  \\end{bmatrix}\n$$\n\n　　这里的$x, p, v$都是向量，其中，$p=\\begin{bmatrix} x \\\\\\\\ y \\\\\\\\ z \\end{bmatrix}$，$v=\\begin{bmatrix} v_x \\\\\\\\ v_y \\\\\\\\ v_z \\end{bmatrix}$\n　　这里我们只记录了位置和速度，但是取决于我们的模型以及我们期望获得的数据我们可以把任何数据变量放进系统状态里。\n　　用运动方程来表示我们建立的匀速模型：\n\n$$\np_k = p_{k - 1} + \\Delta t \\times{v_{k - 1}} \\\\\\\\\nv_k = v_{k - 1}\n$$\n\n　　写成矩阵形式：\n\n$$\nx_k=\n \\begin{bmatrix}\n    p_k \\\\\\\\\n    v_k \\\\\\\\\n  \\end{bmatrix}\n=\n \\begin{bmatrix}\n    1 & \\Delta t \\\\\\\\\n    0 & 1 \\\\\\\\\n \\end{bmatrix}\n \\begin{bmatrix}\n    p_{k -1} \\\\\\\\\n    v_{k - 1} \\\\\\\\\n \\end{bmatrix}\n$$\n\n　　因为$x$实际上是一个包含三个位置量和三个速度量的六维向量，所以由$x_{k - 1}$到$x_{k}$的转移矩阵可具体表示为：\n\n$$\nx_k=\n \\begin{bmatrix}\n    1 & 0 & 0 & \\Delta t & 0 & 0 \\\\\\\\\n    0 & 1 & 0 & 0 & \\Delta t & 0 \\\\\\\\\n    0 & 0 & 1 & 0 & 0 & \\Delta t \\\\\\\\\n    0 & 0 & 0 & 1 & 0 & 0 \\\\\\\\\n    0 & 0 & 0 & 0 & 1 & 0 \\\\\\\\\n    0 & 0 & 0 & 0 & 0 & 1 \\\\\\\\\n \\end{bmatrix}\n x_{k - 1}\n$$\n\n　　把转移矩阵记为$F$，则$x_k = Fx_{k - 1}$\n　　卡尔曼滤波假设所有变量的值符合**正态分布**，那么系统各变量间的**不确定度**可以用**[协方差](https://ain-crad.github.io/2019/03/27/Covariance-%E5%8D%8F%E6%96%B9%E5%B7%AE/)**来表示，系统状态的协方差记为$P_k$，这是一个$6\\times{6}$的对称矩阵。\n　　由于我们有下面的公式：\n\n$$\nCov(x) = \\Sigma \\\\\\\\\nCov(Ax) = A \\Sigma A^T\n$$\n\n　　所以综合上面的运动模型我们可以得到**状态变量以及误差的更新公式**：\n\n$$\nx_k = Fx_{k - 1} \\\\\\\\\nP_k = FP_{k -1}F^T\n$$\n\n　　之前提到我们的模型一般不会是100%准确的，那么就会存在一个**预测误差**，我们把这个预测误差矩阵记为$Q$，表示预测上的高斯噪声。对误差做简单的叠加，可以得到**完整的预测转换方程**：\n\n$$\nx_k = Fx_{k - 1} \\\\\\\\\nP_k = FP_{k - 1}F^T + Q\n$$\n\n　　*Ps.有时我们会看到$x_k = Fx_{k - 1} + Bu_k$这种转移方程的写法，这是引入了一个可以预测的外力影响因素，表示系统当前状态并不只依靠上一个系统状态。譬如，机器人的运动受当时风速的影响，那么$u_k$就表示风速变量，$B$表示风速变量到系统状态变量的转换矩阵。*\n\n## 观测模型\n　　我们还需要一个（或多个）传感器来提供系统状态的**观测数据**，通过测量值来精炼上一阶段模型的预测值。传感器所能够测得的变量由其功能决定，假设我们现在有一个传感器可以直接得到机器人的位置状态量$p$，$p=\\begin{bmatrix} x & y & z \\end{bmatrix}^T$。\n　　注意传感器测量量的范围和单位可能与系统状态变量的范围和单位不一致，所以我们需要做如下变换：\n\n$$\n\\mu = Hx_k \\\\\\\\\n\\Sigma = HP_kH^T\n$$\n\n　　其中$H$为变换矩阵，具体到我们所讨论的例子，传感器只能测得6个系统状态量中的3个，所以要做如下变换，把系统状态量变换到传感器测量空间中去：\n\n$$\n\\begin{bmatrix}\n    x \\\\\\\\\n    y \\\\\\\\\n    z \\\\\\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    1 & 0 & 0 & 0 & 0 & 0 \\\\\\\\\n    0 & 1 & 0 & 0 & 0 & 0 \\\\\\\\\n    0 & 0 & 1 & 0 & 0 & 0 \\\\\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n    x \\\\\\\\\n    y \\\\\\\\\n    z \\\\\\\\\n    v_x \\\\\\\\\n    v_y \\\\\\\\\n    v_z \\\\\\\\\n\\end{bmatrix}\n$$\n\n　　传感器也有自己的精度范围，换句话说传感器的读数会收到高斯噪声的影响在某个范围内波动。我们把传感器**测量值不确定性**的方差记为$R$，传感器实际返回的值（即正态分布均值）记为$z_k$。\n\n## 数据融合\n　　现在每一时刻我们都有了两个高维的正态分布模型，一个来自模型的预测值，另一个来自传感器的测量值。我们尝试去进行**数据的融合**。其实非常简单，对每一个模型来说我们有了它在空间各个位置的**概率密度函数**，我们需要找到**最大可能性**的那个位置，那么我们只要将**两者相乘**就好了。\n　　非常值得高兴的是，**两个正态分布相乘，结果还是一个正态分布！**于是新的正态分布的**均值位置**就是两模型相乘后**概率密度最大**的位置处。理所当然的我们就可以把它选做该时刻的机器人的位置**估计值**。\n![gauss](/gauss.jpg)\n\n　　下面做一些简要的推导：\n\n*太懒了直接贴图，来源[米开朗基罗赵](https://www.zhihu.com/question/23971601)*\n\n　　一维正态分布定义：\n\n![g1](/g1.jpg)\n\n　　我们想知道两个均值、方差不同的正态分布相乘的结果：\n\n![g2](/g2.jpg)\n\n　　把公式(9)带入(10)然后做一些变换，可以得到：\n\n![g3](/g3.jpg)\n\n　　因式分解出一部分，表示为$k$：\n\n![g4](/g4.jpg)\n\n　　上面是一维的情况，扩展到高维，直接把(12)和(13)表示成矩阵形式就好了：\n\n![g5](/g5.jpg)\n\n　　现在出现的这个$K$就是那个让人很难理解的**卡尔曼增益**了，但是在这里这很简单，只是两个正态分布合并过程中因式分解出的一项。\n　　现在我们来把(14)和(15)中的变量替换一下，替换成我们分析出的运动模型和观测模型的均值、方差，其中把运动模型变换到传感器测量空间中：\n\n$$\n(\\mu_0, \\Sigma_0)=(Hx_k, HP_kH^T) \\\\\\\\\n(\\mu_1, \\Sigma_1)=(z_k, R)\n$$\n\n　　经过化简，我们就可以得到三个更新公式了，再加上之前的两个运动模型方程，共同组成卡尔曼滤波的**五个核心公式**：\n\n$$\nx_k = Fx_{k - 1} \\\\\\\\\nP_k = FP_{k - 1}F^T + Q \\\\\\\\\nK = P_kH^T(HP_kH^T + R)^{-1} \\\\\\\\\n\\hat{x_k} = x_k + K(z_k - Hx_k) \\\\\\\\\n\\hat{P_k} = (I - KH)P_k\n$$\n\n　　其中$\\hat{x_k}$为该时刻的位置估计值，同时将作为下一次迭代的$x_{k - 1}$，$\\hat{P_k}$为更新后的系统方差，将作为下一下迭代的$P_{k - 1}$\n\n# 实例\n　　这一部分是一个实例，具体背景是我通过双目相机追踪并还原了手指在空间中运动的一些三维轨迹点（螺旋上升轨迹），但是数据有些噪音（波动），下面是原始数据以及用卡尔曼滤波后的效果图：\n\n![origin](/origin.png)\n![afterFilter](/afterFilter.png)\n\n附上源代码：\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu 18 Apr 18:51:49 CST 2019\n *\n */\n\n#include <Eigen/Core>\n#include <Eigen/LU>\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\nusing namespace Eigen;\n\ntypedef Matrix<double, 6, 6> Matrix6d;\ntypedef Matrix<double, 6, 1> Vector6d;\n\nint main(int argc, char* argv[]){\n    char c;\n    double x, y, z, dx, dy, dz;\n    double nx, ny, nz;\n    double x1, y1, z1, x2, y2, z2;\n\n    Matrix6d F, P, Q, P_;\n    Matrix<double, 3, 6> H;\n    Matrix<double, 6, 3> G;\n    Matrix3d R;\n\n    ifstream fin;\n    ofstream fout;\n    fin.open(argv[1]);\n    fout.open(argv[2]);\n    fin >> c >> x1 >> y1 >> z1;\n    fin >> c >> x2 >> y2  >> z2;\n    fout << c << \" \" << x1 << \" \" << y1  << \" \" << z1 << endl;\n    fout << c << \" \" << x2 << \" \" << y2  << \" \" << z2 << endl;\n    x = x2, y = y2, z = z2;\n    dx = x2 - x1, dy = y2 - y1, dz = z2 - z1;\n\n    Vector6d X, X_;\n    Vector3d Z;\n    X << x , y , z , dx , dy , dz;\n\n    F << 1, 0, 0, 1, 0, 0,\n         0, 1, 0, 0, 1, 0,\n         0, 0, 1, 0, 0, 1,\n         0, 0, 0, 1, 0, 0,\n         0, 0, 0, 0, 1, 0,\n         0, 0, 0, 0, 0, 1;\n\n    H << 1, 0, 0, 0, 0, 0,\n         0, 1, 0, 0, 0, 0,\n         0, 0, 1, 0, 0, 0;\n\n    P = Matrix6d::Identity() * 1;\n\n    Q = Matrix6d::Identity() * 1e-4;\n    R = Matrix3d::Identity() * 1;\n\n    while(fin >> c >> nx >> ny >> nz){\n        Z << nx , ny , nz;\n\n        X_ = F * X;\n        P_ = F * P * F.transpose() + Q;\n\n        G = P_ * H.transpose() * (H * P_ * H.transpose() + R).inverse();\n        X = X_ + G * (Z - H * X_);\n        P = (Matrix6d::Identity() - G * H) * P_;\n        \n        fout << \"v \" << X(0) << ' ' << X(1) << ' ' << X(2) << endl;\n    }\n\n    fin.close();\n    fout.close();\n\n    return 0;\n}\n```\n使用cmake编译，CMakeLists.txt中的内容：\n```makefile\ncmake_minimum_required(VERSION 3.5.1)\nproject(Ekf)\n\nfind_package(Eigen3 REQUIRED)\ninclude_directories(${EIGEN3_INCLUDE_DIRS})\n\nadd_executable(ekf ekf.cpp)\n```\n# 参考链接\n\n[The Extended Kalman Filter:An Interactive Tutorial for Non-Experts](https://home.wlu.edu/~levys/kalman_tutorial/)\n[卡尔曼滤波－－从推导到应用](https://blog.csdn.net/heyijia0327/article/details/17487467)\n[如何通俗并尽可能详尽解释卡尔曼滤波](https://www.zhihu.com/question/23971601)\n[理解Kalman滤波的使用](https://www.cnblogs.com/jcchen1987/p/4371439.html)\n\n　　这些文章在我学习卡尔曼滤波的过程中给予了我很大的帮助，感谢各位博主。其中第三个链接为知乎的回答，我主要参考了其中的[Kent Zeng]用户、[太空精酿]用户以及[米开朗基罗赵]用户的回答。\n\n# 总结\n　　卡尔曼老爷子实在是太强了Orz。","slug":"Kalman-filter-卡尔曼滤波器","published":1,"updated":"2021-04-21T03:30:14.750Z","_id":"ck0uh6nrw007lh8vnrq8wr3t6","comments":1,"layout":"post","photos":[],"link":""},{"title":"埃及分数-迭代加深搜索","date":"2019-01-03T08:21:30.000Z","_content":"迭代加深搜索实际上是人为规定搜索深度的DFS。从小到大枚举深度上限maxd，每次执行只考虑深度不超过maxd的结点。这样，只要解的深度有限，就一定可以在有限时间内枚举到。\n\n*对于可以用回溯法求解但解答树深度没有明显上限的题目，可以考虑使用迭代加深搜索。*\n<!--more-->\n\n# 埃及分数问题\n在古埃及，人们使用单位分数的和（即1/a，a是自然数）表示一切有理数。例如，``2/3 = 1/2 + 1/6``，但不允许``2/3 = 1/3 + 1/3``，因为在加数中不允许有相同的。\n对于一个分数a/b，表示方法有很多种，其中加数少的比加数多的好，如果加数个数相同，则最小的分数越大越好。例如，``19/45 = 1/5 + 1/6 + 1/18``是最优方案。\n输入整数a，b（0< a < b < 500），计算最佳表达式。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu  3 Jan 07:11:15 CST 2019\n *\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e3;\nlong long a, b;\nlong long ans[maxn];\nlong long maxd;\nlong long v[maxn];\nbool ok;\n\nlong long get_first(long long a, long long b){\n    if(b % a == 0) return b / a;\n    else return b / a + 1;\n}\n\nlong long gcd(long long a, long long b){\n    if(b == 0) return a;\n    gcd(b, a % b);\n}\n\nvoid dfs(int dep, long long from, long long a, long long b){\n    if(dep == maxd){\n        if(a * b == 0){\n            for(int i = dep - 1; i >= 0; i--){\n                if(ans[i] == -1 || v[i] < ans[i]){\n                    memcpy(ans, v, sizeof(ans));\n                    break;\n                }\n            }\n            ok = 1;\n        }\n        //cout << \"return\" << endl;\n        return;\n    }\n    from = max(from, get_first(a, b));\n    for(long long i = from; ; i++){\n        //cout << \"true: \" << maxd << \" \" << dep << \" \" << i << \" \" << a << \" \" << b << endl;\n        if(b * (maxd - dep) < i * a){\n            //cout << \"cut\" << endl;\n            break;\n        }\n        long long b2 = b * i;\n        long long a2 = a * i - b;\n        long long g = gcd(a2, b2);\n        v[dep] = i;\n        //cout << \"next: \" << maxd << \" \" << dep + 1 << \" \" << i + 1 << \" \" << a2 / g << \" \" << b2 / g << endl;\n        dfs(dep + 1, i + 1, a2 / g, b2 / g);\n    }\n}\n\nint  main(){\n    while(cin >> a >> b){\n        for(maxd = 1; ; maxd++){\n            memset(ans, -1, sizeof(ans));\n            ok = 0;\n            dfs(0, get_first(a, b), a, b);\n            if(ok) break;\n        }\n        if(ok){\n            cout << a << \"/\" << b << \" = \";\n            for(int i = 0; i < maxd; i++){\n                cout << 1 << \"/\" << ans[i];\n                if(i != maxd - 1) cout << \" + \";\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n```\n","source":"_posts/埃及分数-迭代加深搜索.md","raw":"---\ntitle: 埃及分数-迭代加深搜索\ndate: 2019-01-03 16:21:30\ncategories:\n- Summary\ntags:\n- 迭代加深搜索\n---\n迭代加深搜索实际上是人为规定搜索深度的DFS。从小到大枚举深度上限maxd，每次执行只考虑深度不超过maxd的结点。这样，只要解的深度有限，就一定可以在有限时间内枚举到。\n\n*对于可以用回溯法求解但解答树深度没有明显上限的题目，可以考虑使用迭代加深搜索。*\n<!--more-->\n\n# 埃及分数问题\n在古埃及，人们使用单位分数的和（即1/a，a是自然数）表示一切有理数。例如，``2/3 = 1/2 + 1/6``，但不允许``2/3 = 1/3 + 1/3``，因为在加数中不允许有相同的。\n对于一个分数a/b，表示方法有很多种，其中加数少的比加数多的好，如果加数个数相同，则最小的分数越大越好。例如，``19/45 = 1/5 + 1/6 + 1/18``是最优方案。\n输入整数a，b（0< a < b < 500），计算最佳表达式。\n\n# 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu  3 Jan 07:11:15 CST 2019\n *\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e3;\nlong long a, b;\nlong long ans[maxn];\nlong long maxd;\nlong long v[maxn];\nbool ok;\n\nlong long get_first(long long a, long long b){\n    if(b % a == 0) return b / a;\n    else return b / a + 1;\n}\n\nlong long gcd(long long a, long long b){\n    if(b == 0) return a;\n    gcd(b, a % b);\n}\n\nvoid dfs(int dep, long long from, long long a, long long b){\n    if(dep == maxd){\n        if(a * b == 0){\n            for(int i = dep - 1; i >= 0; i--){\n                if(ans[i] == -1 || v[i] < ans[i]){\n                    memcpy(ans, v, sizeof(ans));\n                    break;\n                }\n            }\n            ok = 1;\n        }\n        //cout << \"return\" << endl;\n        return;\n    }\n    from = max(from, get_first(a, b));\n    for(long long i = from; ; i++){\n        //cout << \"true: \" << maxd << \" \" << dep << \" \" << i << \" \" << a << \" \" << b << endl;\n        if(b * (maxd - dep) < i * a){\n            //cout << \"cut\" << endl;\n            break;\n        }\n        long long b2 = b * i;\n        long long a2 = a * i - b;\n        long long g = gcd(a2, b2);\n        v[dep] = i;\n        //cout << \"next: \" << maxd << \" \" << dep + 1 << \" \" << i + 1 << \" \" << a2 / g << \" \" << b2 / g << endl;\n        dfs(dep + 1, i + 1, a2 / g, b2 / g);\n    }\n}\n\nint  main(){\n    while(cin >> a >> b){\n        for(maxd = 1; ; maxd++){\n            memset(ans, -1, sizeof(ans));\n            ok = 0;\n            dfs(0, get_first(a, b), a, b);\n            if(ok) break;\n        }\n        if(ok){\n            cout << a << \"/\" << b << \" = \";\n            for(int i = 0; i < maxd; i++){\n                cout << 1 << \"/\" << ans[i];\n                if(i != maxd - 1) cout << \" + \";\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n```\n","slug":"埃及分数-迭代加深搜索","published":1,"updated":"2021-04-21T03:30:14.790Z","_id":"ck0uh6nrx007oh8vnoyacct5q","comments":1,"layout":"post","photos":[],"link":""},{"title":"Uva1601-The Morning after Halloween-建图+BFS状态搜索/双向BFS","date":"2019-01-02T02:02:57.000Z","_content":"卡了两天，中间曾一度自闭...(●°u°●)​ 」。不过理解了之后发现确实是好题。\n$w \\times h，（w, h <= 16）$的网格上有$n（n <= 3）$个小写字母（代表ghost）。要求把它们分别移动到对应的大写字母里。每步可以有多个ghost同时移动（均为上下左右4个方向之一移动），但每步结束之后任何两个ghost不能占用同一个位置，也不能在一步之内交换位置。\n<!--more-->\n\n# 链接\n题目链接：[Uva1601-The Morning after Halloween](https://vjudge.net/problem/UVA-1601)\n参考链接：[crazysillynerd's blog](https://blog.csdn.net/crazysillynerd/article/details/42562959)\n\n# 题解\n总的状态数为$256^3$。另外每次转移时需要$5^3$枚举每一个ghost的下一个位置（上下左右+不动）。如果这样直接BFS的话，肯定会超时。于是要进行优化，第一次接触这类问题的优化方法，感谢博主[crazysillynerd](https://blog.csdn.net/crazysillynerd/article/details/42562959)，讲解的很清晰。\n首先是尽量避免搜索不合法的走法。题目条件“任何一个2\\*2子网格中至少有一个障碍格”说明了有很多格子都是障碍，可转移的状态很多都是不合法的。每次都压到队列里然后不合法再排除就会浪费很多时间。以这里为优化点，可以**把迷宫图转换成图，用邻接表保存起来**，这样搜索的时候就只走可以走的点，而不是临时判断5种方案是否合法。\n其次在查重上。因为任何一个2\\*2的子网格中至少有一个障碍格，所有最多有256 \\* 75%的格子即不超过200个格子可以走。**首先把坐标(x，y)，映射到一个整型数上，（这个整型数相当于把16*16的网格拉伸成一维之后原坐标点此时的数组下标，但是排除了'#'的格子）。然后建立一个数组vis[200][200][200]用来查重。**\n最后考虑ghost的数量不同的问题。在建图的时候把多余的不存在的ghost**放到一个孤立的点中，然后使其起始位置和目标位置相同**，这样就避免了需要根据情况动态调整的麻烦。\n总体思路：**输入->建图->BFS**\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed  2 Jan 07:17:12 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 20;\nint w, h, n;\nchar d[maxn][maxn];\nint s[3], t[3];\nint cnt;\nint x[200], y[200], id[maxn][maxn];;\nbool vis[200][200][200];\nvector<int> G[200];\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\nint ans;\nstruct Pos{\n    Pos(int a = 0, int b = 0, int c = 0, int dis = 0):a(a), b(b), c(c), dis(dis){}\n    int a, b, c;\n    int dis;\n};\n\nvoid bfs(){\n    queue<Pos> que;\n    que.push(Pos(s[0], s[1], s[2], 0));\n    vis[s[0]][s[1]][s[2]] = 1;\n\n    while(!que.empty()){\n        Pos u = que.front();\n        que.pop();\n        if(u.a == t[0] && u.b == t[1] && u.c == t[2]){\n            ans = u.dis;\n            break;\n        }\n        for(int i = 0; i < (int)G[u.a].size(); i++){\n            for(int j = 0; j < (int)G[u.b].size(); j++){\n                for(int k = 0; k < (int)G[u.c].size(); k++){\n                    int p1 = G[u.a][i], p2 = G[u.b][j], p3 = G[u.c][k];\n\n                    //check conflict\n                    if(vis[p1][p2][p3]) continue;\n                    if(p1 == p2 || p1 == p3 || p2 == p3) continue;\n                    if(p1 == u.b && p2 == u.a) continue;\n                    if(p1 == u.c && p3 == u.a) continue;\n                    if(p2 == u.c && p3 == u.b) continue;\n\n                    que.push(Pos(p1, p2, p3, u.dis + 1));\n                    vis[p1][p2][p3] = 1; \n                }\n            }\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> w >> h >> n){\n        if(w == 0 && h == 0 && n == 0) break;\n        getchar();\n        cnt = 0;\n        memset(id, -1, sizeof(id));\n        memset(vis, 0, sizeof(vis));\n        for(int i = 0; i < 200; i++){\n            G[i].clear();\n        }\n\n        for(int i = 0; i < h; i++){\n            fgets(d[i], maxn, stdin);\n        }\n\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(d[i][j] != '#'){\n                    x[cnt] = i, y[cnt] = j, id[i][j] = cnt;\n                    if(islower(d[i][j])) s[d[i][j] - 'a'] = cnt;\n                    if(isupper(d[i][j])) t[d[i][j] - 'A'] = cnt;\n                    cnt++;\n                }\n            }\n        }\n\n        for(int i = 0; i < cnt; i++){\n            for(int dir = 0; dir < 5; dir++){\n                int nx = x[i] + dx[dir], ny = y[i] + dy[dir];\n                //\"Outermost cells of a map are walls\" means we don't need to check out-of-bound\n                if(d[nx][ny] != '#') G[i].push_back(id[nx][ny]);\n            }\n        }\n\n        //add fake nodes\n        if(n <= 2){\n            G[cnt].push_back(cnt);\n            s[2] = t[2] = cnt;\n            cnt++;\n        } \n        if(n <= 1){\n            G[cnt].push_back(cnt);\n            s[1] = t[1] = cnt;\n            cnt++;\n        }\n\n        ans = -1;\n        bfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n# 双向BFS解法\n参考链接：[phlsheji's blog](https://www.cnblogs.com/bhlsheji/p/4804022.html)\n参考连接：[crazysillynerd](https://blog.csdn.net/crazysillynerd/article/details/42681579)\n\n双向BFS是利用两个队列。一个队列保存从起点开始向后搜索的状态，另一个保存从终点开始向前搜索的状态，**双向BFS主要是区分每一个格子是从起点开始搜索到的还是从终点开始搜索到的**，每一个经过的格子结点保存到达该格子经过的步数，这样两边出现相交，两个方向的步数相加就是最终结果。\n*双向BFS的效率会高一些。*\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed  2 Jan 07:17:12 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 20;\nint w, h, n;\nchar d[maxn][maxn];\nint s[3], t[3];\nint cnt;\nint x[200], y[200], id[maxn][maxn];;\nint vis[200][200][200];\nint dis_s[200][200][200], dis_t[200][200][200];\nvector<int> G[200];\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\nint ans;\nstruct Pos{\n    Pos(int a = 0, int b = 0, int c = 0):a(a), b(b), c(c){}\n    int a, b, c;\n};\n\nvoid adv_bfs(){\n    queue<Pos> que_s;\n    que_s.push(Pos(s[0], s[1], s[2]));\n    vis[s[0]][s[1]][s[2]] = 1;\n    dis_s[s[0]][s[1]][s[2]] = 0;\n    queue<Pos> que_t;\n    que_t.push(Pos(t[0], t[1], t[2]));\n    vis[t[0]][t[1]][t[2]] = 2;\n    dis_t[t[0]][t[1]][t[2]] = 0;\n\n    while(!que_s.empty() || !que_t.empty()){\n        if(!que_s.empty()){\n            Pos u = que_s.front();\n            que_s.pop();\n            if(vis[u.a][u.b][u.c] == 2){\n                ans = dis_s[u.a][u.b][u.c] + dis_t[u.a][u.b][u.c];\n                return;\n            }\n\n            for(int i = 0; i < (int)G[u.a].size(); i++){\n                for(int j = 0; j < (int)G[u.b].size(); j++){\n                    for(int k = 0; k < (int)G[u.c].size(); k++){\n                        int p1 = G[u.a][i], p2 = G[u.b][j], p3 = G[u.c][k];\n                        //check conflict\n                        if(vis[p1][p2][p3] == 1) continue;\n                        if(p1 == p2 || p1 == p3 || p2 == p3) continue;\n                        if(p1 == u.b && p2 == u.a) continue;\n                        if(p1 == u.c && p3 == u.a) continue;\n                        if(p2 == u.c && p3 == u.b) continue;\n\n                        dis_s[p1][p2][p3] = dis_s[u.a][u.b][u.c] + 1;\n\n                        if(vis[p1][p2][p3] == 2){\n                            ans = dis_s[p1][p2][p3] + dis_t[p1][p2][p3];\n                            return;\n                        }\n                        else if(vis[p1][p2][p3] == 0){\n                            vis[p1][p2][p3] = 1;\n                            que_s.push(Pos(p1, p2, p3));\n                        }\n                    }\n                }\n            }\n        }\n\n        if(!que_t.empty()){\n            Pos v = que_t.front();\n            que_t.pop();\n            if(vis[v.a][v.b][v.c] == 1){\n                ans = dis_t[v.a][v.b][v.c] + dis_s[v.a][v.b][v.c];\n                return;\n            }\n\n            for(int i = 0; i < (int)G[v.a].size(); i++){\n                for(int j = 0; j < (int)G[v.b].size(); j++){\n                    for(int k = 0; k < (int)G[v.c].size(); k++){\n                        int p1 = G[v.a][i], p2 = G[v.b][j], p3 = G[v.c][k];\n                        //check conflict\n                        if(vis[p1][p2][p3] == 2) continue;\n                        if(p1 == p2 || p1 == p3 || p2 == p3) continue;\n                        if(p1 == v.b && p2 == v.a) continue;\n                        if(p1 == v.c && p3 == v.a) continue;\n                        if(p2 == v.c && p3 == v.b) continue;\n\n                        dis_t[p1][p2][p3] = dis_t[v.a][v.b][v.c] + 1;\n\n                        if(vis[p1][p2][p3] == 1){\n                            ans = dis_t[p1][p2][p3] + dis_s[p1][p2][p3];\n                            return;\n                        }\n                        else if(vis[p1][p2][p3] == 0){\n                            vis[p1][p2][p3] = 2;\n                            que_t.push(Pos(p1, p2, p3));\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> w >> h >> n){\n        if(w == 0 && h == 0 && n == 0) break;\n        getchar();\n        cnt = 0;\n        memset(id, -1, sizeof(id));\n        memset(vis, 0, sizeof(vis));\n        memset(dis_s, 0, sizeof(dis_s));\n        memset(dis_t, 0, sizeof(dis_t));\n        for(int i = 0; i < 200; i++){\n            G[i].clear();\n        }\n\n        for(int i = 0; i < h; i++){\n            fgets(d[i], maxn, stdin);\n        }\n\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(d[i][j] != '#'){\n                    x[cnt] = i, y[cnt] = j, id[i][j] = cnt;\n                    if(islower(d[i][j])) s[d[i][j] - 'a'] = cnt;\n                    if(isupper(d[i][j])) t[d[i][j] - 'A'] = cnt;\n                    cnt++;\n                }\n            }\n        }\n\n        for(int i = 0; i < cnt; i++){\n            for(int dir = 0; dir < 5; dir++){\n                int nx = x[i] + dx[dir], ny = y[i] + dy[dir];\n                //\"Outermost cells of a map are walls\" means we don't need to check out-of-bound\n                if(d[nx][ny] != '#') G[i].push_back(id[nx][ny]);\n            }\n        }\n\n        //add fake nodes\n        if(n <= 2){\n            G[cnt].push_back(cnt);\n            s[2] = t[2] = cnt;\n            cnt++;\n        } \n        if(n <= 1){\n            G[cnt].push_back(cnt);\n            s[1] = t[1] = cnt;\n            cnt++;\n        }\n        \n        ans = -1;\n        adv_bfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n","source":"_posts/Uva1601-The-Morning-after-Halloween.md","raw":"---\ntitle: Uva1601-The Morning after Halloween-建图+BFS状态搜索/双向BFS\ndate: 2019-01-02 10:02:57\ncategories:\n- ACM\n- BFS\ntags:\n- 建图\n- 双向BFS\n---\n卡了两天，中间曾一度自闭...(●°u°●)​ 」。不过理解了之后发现确实是好题。\n$w \\times h，（w, h <= 16）$的网格上有$n（n <= 3）$个小写字母（代表ghost）。要求把它们分别移动到对应的大写字母里。每步可以有多个ghost同时移动（均为上下左右4个方向之一移动），但每步结束之后任何两个ghost不能占用同一个位置，也不能在一步之内交换位置。\n<!--more-->\n\n# 链接\n题目链接：[Uva1601-The Morning after Halloween](https://vjudge.net/problem/UVA-1601)\n参考链接：[crazysillynerd's blog](https://blog.csdn.net/crazysillynerd/article/details/42562959)\n\n# 题解\n总的状态数为$256^3$。另外每次转移时需要$5^3$枚举每一个ghost的下一个位置（上下左右+不动）。如果这样直接BFS的话，肯定会超时。于是要进行优化，第一次接触这类问题的优化方法，感谢博主[crazysillynerd](https://blog.csdn.net/crazysillynerd/article/details/42562959)，讲解的很清晰。\n首先是尽量避免搜索不合法的走法。题目条件“任何一个2\\*2子网格中至少有一个障碍格”说明了有很多格子都是障碍，可转移的状态很多都是不合法的。每次都压到队列里然后不合法再排除就会浪费很多时间。以这里为优化点，可以**把迷宫图转换成图，用邻接表保存起来**，这样搜索的时候就只走可以走的点，而不是临时判断5种方案是否合法。\n其次在查重上。因为任何一个2\\*2的子网格中至少有一个障碍格，所有最多有256 \\* 75%的格子即不超过200个格子可以走。**首先把坐标(x，y)，映射到一个整型数上，（这个整型数相当于把16*16的网格拉伸成一维之后原坐标点此时的数组下标，但是排除了'#'的格子）。然后建立一个数组vis[200][200][200]用来查重。**\n最后考虑ghost的数量不同的问题。在建图的时候把多余的不存在的ghost**放到一个孤立的点中，然后使其起始位置和目标位置相同**，这样就避免了需要根据情况动态调整的麻烦。\n总体思路：**输入->建图->BFS**\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed  2 Jan 07:17:12 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 20;\nint w, h, n;\nchar d[maxn][maxn];\nint s[3], t[3];\nint cnt;\nint x[200], y[200], id[maxn][maxn];;\nbool vis[200][200][200];\nvector<int> G[200];\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\nint ans;\nstruct Pos{\n    Pos(int a = 0, int b = 0, int c = 0, int dis = 0):a(a), b(b), c(c), dis(dis){}\n    int a, b, c;\n    int dis;\n};\n\nvoid bfs(){\n    queue<Pos> que;\n    que.push(Pos(s[0], s[1], s[2], 0));\n    vis[s[0]][s[1]][s[2]] = 1;\n\n    while(!que.empty()){\n        Pos u = que.front();\n        que.pop();\n        if(u.a == t[0] && u.b == t[1] && u.c == t[2]){\n            ans = u.dis;\n            break;\n        }\n        for(int i = 0; i < (int)G[u.a].size(); i++){\n            for(int j = 0; j < (int)G[u.b].size(); j++){\n                for(int k = 0; k < (int)G[u.c].size(); k++){\n                    int p1 = G[u.a][i], p2 = G[u.b][j], p3 = G[u.c][k];\n\n                    //check conflict\n                    if(vis[p1][p2][p3]) continue;\n                    if(p1 == p2 || p1 == p3 || p2 == p3) continue;\n                    if(p1 == u.b && p2 == u.a) continue;\n                    if(p1 == u.c && p3 == u.a) continue;\n                    if(p2 == u.c && p3 == u.b) continue;\n\n                    que.push(Pos(p1, p2, p3, u.dis + 1));\n                    vis[p1][p2][p3] = 1; \n                }\n            }\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> w >> h >> n){\n        if(w == 0 && h == 0 && n == 0) break;\n        getchar();\n        cnt = 0;\n        memset(id, -1, sizeof(id));\n        memset(vis, 0, sizeof(vis));\n        for(int i = 0; i < 200; i++){\n            G[i].clear();\n        }\n\n        for(int i = 0; i < h; i++){\n            fgets(d[i], maxn, stdin);\n        }\n\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(d[i][j] != '#'){\n                    x[cnt] = i, y[cnt] = j, id[i][j] = cnt;\n                    if(islower(d[i][j])) s[d[i][j] - 'a'] = cnt;\n                    if(isupper(d[i][j])) t[d[i][j] - 'A'] = cnt;\n                    cnt++;\n                }\n            }\n        }\n\n        for(int i = 0; i < cnt; i++){\n            for(int dir = 0; dir < 5; dir++){\n                int nx = x[i] + dx[dir], ny = y[i] + dy[dir];\n                //\"Outermost cells of a map are walls\" means we don't need to check out-of-bound\n                if(d[nx][ny] != '#') G[i].push_back(id[nx][ny]);\n            }\n        }\n\n        //add fake nodes\n        if(n <= 2){\n            G[cnt].push_back(cnt);\n            s[2] = t[2] = cnt;\n            cnt++;\n        } \n        if(n <= 1){\n            G[cnt].push_back(cnt);\n            s[1] = t[1] = cnt;\n            cnt++;\n        }\n\n        ans = -1;\n        bfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n# 双向BFS解法\n参考链接：[phlsheji's blog](https://www.cnblogs.com/bhlsheji/p/4804022.html)\n参考连接：[crazysillynerd](https://blog.csdn.net/crazysillynerd/article/details/42681579)\n\n双向BFS是利用两个队列。一个队列保存从起点开始向后搜索的状态，另一个保存从终点开始向前搜索的状态，**双向BFS主要是区分每一个格子是从起点开始搜索到的还是从终点开始搜索到的**，每一个经过的格子结点保存到达该格子经过的步数，这样两边出现相交，两个方向的步数相加就是最终结果。\n*双向BFS的效率会高一些。*\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed  2 Jan 07:17:12 CST 2019\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 20;\nint w, h, n;\nchar d[maxn][maxn];\nint s[3], t[3];\nint cnt;\nint x[200], y[200], id[maxn][maxn];;\nint vis[200][200][200];\nint dis_s[200][200][200], dis_t[200][200][200];\nvector<int> G[200];\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\nint ans;\nstruct Pos{\n    Pos(int a = 0, int b = 0, int c = 0):a(a), b(b), c(c){}\n    int a, b, c;\n};\n\nvoid adv_bfs(){\n    queue<Pos> que_s;\n    que_s.push(Pos(s[0], s[1], s[2]));\n    vis[s[0]][s[1]][s[2]] = 1;\n    dis_s[s[0]][s[1]][s[2]] = 0;\n    queue<Pos> que_t;\n    que_t.push(Pos(t[0], t[1], t[2]));\n    vis[t[0]][t[1]][t[2]] = 2;\n    dis_t[t[0]][t[1]][t[2]] = 0;\n\n    while(!que_s.empty() || !que_t.empty()){\n        if(!que_s.empty()){\n            Pos u = que_s.front();\n            que_s.pop();\n            if(vis[u.a][u.b][u.c] == 2){\n                ans = dis_s[u.a][u.b][u.c] + dis_t[u.a][u.b][u.c];\n                return;\n            }\n\n            for(int i = 0; i < (int)G[u.a].size(); i++){\n                for(int j = 0; j < (int)G[u.b].size(); j++){\n                    for(int k = 0; k < (int)G[u.c].size(); k++){\n                        int p1 = G[u.a][i], p2 = G[u.b][j], p3 = G[u.c][k];\n                        //check conflict\n                        if(vis[p1][p2][p3] == 1) continue;\n                        if(p1 == p2 || p1 == p3 || p2 == p3) continue;\n                        if(p1 == u.b && p2 == u.a) continue;\n                        if(p1 == u.c && p3 == u.a) continue;\n                        if(p2 == u.c && p3 == u.b) continue;\n\n                        dis_s[p1][p2][p3] = dis_s[u.a][u.b][u.c] + 1;\n\n                        if(vis[p1][p2][p3] == 2){\n                            ans = dis_s[p1][p2][p3] + dis_t[p1][p2][p3];\n                            return;\n                        }\n                        else if(vis[p1][p2][p3] == 0){\n                            vis[p1][p2][p3] = 1;\n                            que_s.push(Pos(p1, p2, p3));\n                        }\n                    }\n                }\n            }\n        }\n\n        if(!que_t.empty()){\n            Pos v = que_t.front();\n            que_t.pop();\n            if(vis[v.a][v.b][v.c] == 1){\n                ans = dis_t[v.a][v.b][v.c] + dis_s[v.a][v.b][v.c];\n                return;\n            }\n\n            for(int i = 0; i < (int)G[v.a].size(); i++){\n                for(int j = 0; j < (int)G[v.b].size(); j++){\n                    for(int k = 0; k < (int)G[v.c].size(); k++){\n                        int p1 = G[v.a][i], p2 = G[v.b][j], p3 = G[v.c][k];\n                        //check conflict\n                        if(vis[p1][p2][p3] == 2) continue;\n                        if(p1 == p2 || p1 == p3 || p2 == p3) continue;\n                        if(p1 == v.b && p2 == v.a) continue;\n                        if(p1 == v.c && p3 == v.a) continue;\n                        if(p2 == v.c && p3 == v.b) continue;\n\n                        dis_t[p1][p2][p3] = dis_t[v.a][v.b][v.c] + 1;\n\n                        if(vis[p1][p2][p3] == 1){\n                            ans = dis_t[p1][p2][p3] + dis_s[p1][p2][p3];\n                            return;\n                        }\n                        else if(vis[p1][p2][p3] == 0){\n                            vis[p1][p2][p3] = 2;\n                            que_t.push(Pos(p1, p2, p3));\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> w >> h >> n){\n        if(w == 0 && h == 0 && n == 0) break;\n        getchar();\n        cnt = 0;\n        memset(id, -1, sizeof(id));\n        memset(vis, 0, sizeof(vis));\n        memset(dis_s, 0, sizeof(dis_s));\n        memset(dis_t, 0, sizeof(dis_t));\n        for(int i = 0; i < 200; i++){\n            G[i].clear();\n        }\n\n        for(int i = 0; i < h; i++){\n            fgets(d[i], maxn, stdin);\n        }\n\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(d[i][j] != '#'){\n                    x[cnt] = i, y[cnt] = j, id[i][j] = cnt;\n                    if(islower(d[i][j])) s[d[i][j] - 'a'] = cnt;\n                    if(isupper(d[i][j])) t[d[i][j] - 'A'] = cnt;\n                    cnt++;\n                }\n            }\n        }\n\n        for(int i = 0; i < cnt; i++){\n            for(int dir = 0; dir < 5; dir++){\n                int nx = x[i] + dx[dir], ny = y[i] + dy[dir];\n                //\"Outermost cells of a map are walls\" means we don't need to check out-of-bound\n                if(d[nx][ny] != '#') G[i].push_back(id[nx][ny]);\n            }\n        }\n\n        //add fake nodes\n        if(n <= 2){\n            G[cnt].push_back(cnt);\n            s[2] = t[2] = cnt;\n            cnt++;\n        } \n        if(n <= 1){\n            G[cnt].push_back(cnt);\n            s[1] = t[1] = cnt;\n            cnt++;\n        }\n        \n        ans = -1;\n        adv_bfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n","slug":"Uva1601-The-Morning-after-Halloween","published":1,"updated":"2021-04-21T03:30:14.770Z","_id":"ck0uh6nry007rh8vn9cnrcdzp","comments":1,"layout":"post","photos":[],"link":""},{"title":"光栅化渲染(3)-光栅化","date":"2019-08-15T02:25:47.000Z","_content":"\n![rasterization](/rasterization.png)\n\n　　*通过检测图像中的像素是否处在投影后的三角形中，来赋予像素相应的颜色的属性，是光栅化算法的主要思路。*\n<!--more-->\n\n# 光栅化\n　　为了实现一个简易的光栅化效果（在屏幕上画出一个三角形），我们需要解决两个问题：\n- 首先要找到所有落在三角形投影范围内的像素。\n- 为以上位置的像素赋予相应的颜色。\n\n　　*Edge Function*可以很好的解决第一个问题，快速判断一个像素是否在三角投影区域内。第二个问题也被成为*shading*（着色）。\n\n# The Edge Function\n　　Edge Function 由 Juan Pineda 在 1988 年发表的一篇名为 *A parallel Algorithm for Polygon Rasterization* 的论文中提出。\n　　三角形的一边可以看作是分割二维平面的一条线(Figure 1)，Pineda 的方法的主要思路是找到一个方程，用它来测试任一给定点 $P(x, y)$ 处于分割线的哪一侧：\n- 当点 $P$ 位于分割线的左侧时，方程返回一个负值。\n- 当点 $P$ 位于分割线的右侧时，方程返回一个正值。\n- 当点 $P$ 正好位于分割线之上时，方程返回0。\n\n![figure 1](/figure1.png)\n<center>Figure 1</center>\n\n　　于是我们可以发现分别以三角形的三条边作为分割线的话，若某一点 $P(x, y)$ 经过Edge Function测试全为正，即点 $P(x, y)$ **全部位于三角形三边的右侧**，那么就可以确定这一点位于三角形内部。\n　　*需要注意三角形三边的方向，按照顺时针定义，即三边分别为 v0->v1，v1->v2，v2->v0。*\n\n![figure 2](/figure2.png)\n<center>Figure 2</center>\n\n　　了解了Edge Function的设计思路，下面给出它的公式（关于边$V0->V1$）：\n\n$$\nE_{01}(P)=(P.x-V0.x)\\*(V1.y-V0.y)-(P.y-V0.y)\\*(V1.x-V0.x)\n$$\n\n　　事实上这也是向量 $(P-v0)$ 和 $(V1-V0)$ **叉积**的大小值，可以用**行列式矩阵**表示：\n\n$$\n\\left[\n    \\begin{matrix}\n        P.x-V0.x & V1.x-V0.x \\\\\\\\\n        P.y-V0.y & V1.y-V0.y\n    \\end{matrix}\n\\right]\n$$\n\n　　*不难理解，Edge Function的结果的正负性和向量叉积值的正负性是一致的。*\n　　所以判断某一像素是否位于投影三角形内，只需检测由像素中心坐标 $P(x, y)$ 和三角形三边所定义的三个Edge Function的正负性。\n\n$$\nE_{01}(P)=(P.x-V0.x)\\*(V1.y-V0.y)-(P.y-V0.y)\\*(V1.x-V0.x) \\\\\\\\\nE_{12}(P)=(P.x-V1.x)\\*(V2.y-V1.y)-(P.y-V1.y)\\*(V2.x-V1.x) \\\\\\\\\nE_{20}(P)=(P.x-V2.x)\\*(V0.y-V2.y)-(P.y-V2.y)\\*(V0.x-V2.x)\n$$\n\n![figure 3](/figure3.gif)\n<center>Figure 3</center>\n\n# 重心坐标\n　　通常我们只能对三角形的三个顶点定义颜色等属性，那么如何确定三角形内部任意一点的颜色？(Figure 4)\n\n![figure 4](/figure4.png)\n<center>Figure 4</center>\n\n　　假设 $P=\\lambda_{0} \\* V0 + \\lambda_{1} \\* V1 + \\lambda_{2} \\* V2$，且满足 $\\lambda_{0} + \\lambda_{1} + \\lambda_{2} = 1$ 那么 $(\\lambda_{0},\\lambda_{1},\\lambda_{2})$ 就是 $P$ 的重心坐标。它可以表示位于三角形内部（及边界）上的任意一点。\n　　于是我们可以借助重心坐标来对三角形内任意一点进行插值，以获得其颜色 $C_P$ 等其它由顶点定义的属性：\n\n$$\nC_P=\\lambda_{0} \\* C_{V0} + \\lambda_{1} \\* C_{V1} + \\lambda_{2} \\* C_{V2}\n$$\n\n## 如何获得任意一点的重心坐标\n　　在三角形情形中，重心坐标也叫面积坐标，因为 $P$ 点关于 $\\Delta ABC$ 的重心坐标和 $\\Delta PBC, \\Delta PCA, \\Delta PAB$ 的面积成比例。证明如下。\n　　如图(Figure 4)，设 $\\Delta ABC$ 三个顶点和原点构成的向量分别为 $pmb{\\vec{a}}, \\pmb{\\vec{b}}, \\pmb{\\vec{c}}$，$P$ 点和原点构成的向量为 $\\pmb{\\vec{p}}$。$\\Delta PBC, \\Delta PCA, \\Delta PAB$ 面积之比为 $\\lambda_{0}:\\lambda_{1}:\\lambda_{2}$，且 $\\lambda_{0} + \\lambda_{1} + \\lambda_{2}=1$，设射线 $AP$ 与 $BC$ 交于点 $D$，点 $D$ 和原点构成的向量为 $\\pmb{\\vec{d}}$，\n\n![figure 5](/figure5.png)\n<center>Figure 5</center>\n\n　　则：\n\n$$\nBD:DC=\\lambda_{2}:\\lambda_{1}, 从而\\quad \\pmb{\\vec{d}}=\\cfrac{\\lambda_{1}\\pmb{\\vec{b}}+\\lambda_{2}\\pmb{\\vec{c}}}{\\lambda_{1}+\\lambda_{2}} \\\\\\\\\nAP:PD=(\\lambda_{1}+\\lambda_{2}):\\lambda_{0}, 故\\quad \\pmb{\\vec{p}}=\\cfrac{(\\lambda_{1}+\\lambda_{2})\\pmb{\\vec{d}}+\\lambda_{0}\\pmb{\\vec{a}}}{\\lambda_{0}+\\lambda_{1}+\\lambda_{2}} \\\\\\\\\n\\pmb{\\vec{p}}=\\lambda_{0}\\pmb{\\vec{a}}+\\lambda_{1}\\pmb{\\vec{b}}+\\lambda_{2}\\pmb{\\vec{c}}\n$$\n\n　　而 $\\Delta PBC, \\Delta PCA, \\Delta PAB$ 的面积又正好等于 $P$ 点和 $\\Delta ABC$ 顶点构成的向量与 $\\Delta ABC$ 三边构成的向量的**叉积的值的一半。**\n　　叉积值已通过 Edge Function 得到，所以重心坐标：\n\n$$\n\\lambda_{0}=\\cfrac{Area(V1,V2,P)}{Area(V0,V1,V2)}=\\cfrac{E_{12}(P)/2}{E_{12}(V0)/2}=\\cfrac{E_{12}(P)}{E_{12}(V0)} \\\\\\\\\n\\lambda_{1}=\\cfrac{Area(V2,V0,P)}{Area(V0,V1,V2)}=\\cfrac{E_{20}(P)/2}{E_{20}(V1)/2}=\\cfrac{E_{20}(P)}{E_{20}(V1)} \\\\\\\\\n\\lambda_{2}=\\cfrac{Area(V0,V1,P)}{Area(V0,V1,V2)}=\\cfrac{E_{01}(P)/2}{E_{01}(V2)/2}=\\cfrac{E_{01}(P)}{E_{01}(V2)}\n$$\n\n## 计算优化\n\n$$\nlambda_{0} + lambda_{1} + lambda_{2} = 1 \\\\\\\\\nP = lambda_{0} \\* V0 + lambda_{1} \\* V1 + lambda_{2} \\* V2\n$$\n\n　　两公式联立消去 $\\lambda_{0}$ 得：\n\n$$\nP=V0 + lambda_{1} \\* (V1-V0) + lambda_{2} \\* (V2-V0)\n$$\n\n　　$V1-V0$ 和 $V2-V0$ 可以提前计算出来，这样就把计算由三次乘法和两次加法简化到了两次乘法和两次加法。**GPU采用了这种优化策略。**\n\n# 拓展\n　　在某些特殊情况下，一个像素可能同时落在两个投影三角形区域内，Figure 6 中的红色像素点显示了这种情况。\n\n![figure 6](/figure6.png)\n<center>Figure 6</center>\n\n　　**top-left rule** (Figure 7) 可以用来避免这种重复光栅化三角形边界像素的情况。\n\n![figure 7](/figure7.png)\n<center>Figure 7</center>\n\n　　由图可知：\n- **top edge** 指的是满足向量 $V[(x+1)\\%3] - V[x], x=0,1,2$ 的 $y$ 坐标等于 $0$，且 $x$ 坐标大于 $0$ 的边。\n- **left edge** 指的是满足向量　$V[(x+1)\\%3]-V[x], x=0,1,2$ 的 $y$ 坐标大于 $0$ 的边。\n\n\n　　**需要特别注意的是，本节都是建立在三角形三边按顺时针方向定义的前提下讨论的。**\n\n# 实例\n　　给定光栅化坐标系下的三角形的三个顶点以及顶点的颜色，渲染出这个三角形。\n\n## 代码\n```C++\n#include <iostream>\n#include <fstream>\n#include <cstring>\n\nstruct Vec2{\n    float x, y;\n    Vec2(float x = 0.0, float y = 0.0): x(x), y(y){}\n};\n\nstruct Vec3{\n    float x, y, z;\n    Vec3(float x = 0.0, float y = 0.0, float z = 0.0): x(x), y(y), z(z){}\n};\n\nstruct Rgb{\n    unsigned char r, g, b;\n    Rgb(unsigned char r = 0, unsigned char g = 0, unsigned char b = 0): r(r), g(g), b(b){}\n};\n\nfloat edgeFunction(Vec2 &a, Vec2 &b, Vec2 &c){\n    return (c.x - a.x)*(b.y - a.y) - (c.y - a.y)*(b.x - a.x);\n}\n\nbool top_left(const Vec2 &v){\n    if((v.y == 0 && v.x > 0) || v.y > 0) return true;\n    else return false;\n}\n\nint main(){\n    Vec2 v0(491.407, 411.407); \n    Vec2 v1(148.593, 68.5928); \n    Vec2 v2(148.593, 411.407); \n    Vec3 c0(1, 0, 0); \n    Vec3 c1(0, 1, 0); \n    Vec3 c2(0, 0, 1);\n\n    const uint32_t w = 512;\n    const uint32_t h = 512;\n\n    Rgb framebuffer[w][h];\n    memset(framebuffer, 0, sizeof(framebuffer));\n\n    float area = edgeFunction(v0, v1, v2);\n\n    for(uint32_t j = 0; j < h; j++){\n        for(uint32_t i = 0; i < w; i++){\n            Vec2 p(i + 0.5, j + 0.5);\n            float w0 = edgeFunction(v1, v2, p);\n            float w1 = edgeFunction(v2, v0, p);\n            float w2 = edgeFunction(v0, v1, p);\n\n            if(w0 >= 0 && w1 >= 0 && w2 >= 0){\n                //top-left judge\n                if(w0 == 0 && !top_left(Vec2(v2.x - v1.x, v2.y - v1.y))) continue;\n                if(w1 == 0 && !top_left(Vec2(v0.x - v2.x, v0.y - v2.y))) continue;\n                if(w2 == 0 && !top_left(Vec2(v1.x - v0.x, v1.y - v0.y))) continue;\n\n                w0 /= area;\n                w1 /= area;\n                w2 /= area;\n                float r = w0 * c0.x + w1 * c1.x + w2 * c2.x;\n                float g = w0 * c0.y + w1 * c1.y + w2 * c2.y;\n                float b = w0 * c0.z + w1 * c1.z + w2 * c2.z;\n                framebuffer[j][i].r = (unsigned char)(r * 255);\n                framebuffer[j][i].g = (unsigned char)(g * 255);\n                framebuffer[j][i].b = (unsigned char)(b * 255);\n            }\n        }\n    }\n\n    std::ofstream ofs;\n    ofs.open(\"./raster2d.ppm\");\n       ofs << \"P6\\n\" << w << \" \" << h << \"\\n255\\n\";\n    ofs.write((char *)framebuffer, sizeof(framebuffer));\n    ofs.close(); \n\n    return 0;\n}\n```\n\n## 结果\n\n![result](/result.png)\n<center>result</center>\n\n# 参考链接\n\n[Scratchapixel-The Rasterization Stage](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage)\n[维基百科-重心坐标](https://www.wikiwand.com/zh-hans/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87)","source":"_posts/光栅化渲染-3-光栅化.md","raw":"---\ntitle: 光栅化渲染(3)-光栅化\ndate: 2019-08-15 10:25:47\ncategories:\n- Computer Graphics\n- 光栅化渲染\ntags:\n---\n\n![rasterization](/rasterization.png)\n\n　　*通过检测图像中的像素是否处在投影后的三角形中，来赋予像素相应的颜色的属性，是光栅化算法的主要思路。*\n<!--more-->\n\n# 光栅化\n　　为了实现一个简易的光栅化效果（在屏幕上画出一个三角形），我们需要解决两个问题：\n- 首先要找到所有落在三角形投影范围内的像素。\n- 为以上位置的像素赋予相应的颜色。\n\n　　*Edge Function*可以很好的解决第一个问题，快速判断一个像素是否在三角投影区域内。第二个问题也被成为*shading*（着色）。\n\n# The Edge Function\n　　Edge Function 由 Juan Pineda 在 1988 年发表的一篇名为 *A parallel Algorithm for Polygon Rasterization* 的论文中提出。\n　　三角形的一边可以看作是分割二维平面的一条线(Figure 1)，Pineda 的方法的主要思路是找到一个方程，用它来测试任一给定点 $P(x, y)$ 处于分割线的哪一侧：\n- 当点 $P$ 位于分割线的左侧时，方程返回一个负值。\n- 当点 $P$ 位于分割线的右侧时，方程返回一个正值。\n- 当点 $P$ 正好位于分割线之上时，方程返回0。\n\n![figure 1](/figure1.png)\n<center>Figure 1</center>\n\n　　于是我们可以发现分别以三角形的三条边作为分割线的话，若某一点 $P(x, y)$ 经过Edge Function测试全为正，即点 $P(x, y)$ **全部位于三角形三边的右侧**，那么就可以确定这一点位于三角形内部。\n　　*需要注意三角形三边的方向，按照顺时针定义，即三边分别为 v0->v1，v1->v2，v2->v0。*\n\n![figure 2](/figure2.png)\n<center>Figure 2</center>\n\n　　了解了Edge Function的设计思路，下面给出它的公式（关于边$V0->V1$）：\n\n$$\nE_{01}(P)=(P.x-V0.x)\\*(V1.y-V0.y)-(P.y-V0.y)\\*(V1.x-V0.x)\n$$\n\n　　事实上这也是向量 $(P-v0)$ 和 $(V1-V0)$ **叉积**的大小值，可以用**行列式矩阵**表示：\n\n$$\n\\left[\n    \\begin{matrix}\n        P.x-V0.x & V1.x-V0.x \\\\\\\\\n        P.y-V0.y & V1.y-V0.y\n    \\end{matrix}\n\\right]\n$$\n\n　　*不难理解，Edge Function的结果的正负性和向量叉积值的正负性是一致的。*\n　　所以判断某一像素是否位于投影三角形内，只需检测由像素中心坐标 $P(x, y)$ 和三角形三边所定义的三个Edge Function的正负性。\n\n$$\nE_{01}(P)=(P.x-V0.x)\\*(V1.y-V0.y)-(P.y-V0.y)\\*(V1.x-V0.x) \\\\\\\\\nE_{12}(P)=(P.x-V1.x)\\*(V2.y-V1.y)-(P.y-V1.y)\\*(V2.x-V1.x) \\\\\\\\\nE_{20}(P)=(P.x-V2.x)\\*(V0.y-V2.y)-(P.y-V2.y)\\*(V0.x-V2.x)\n$$\n\n![figure 3](/figure3.gif)\n<center>Figure 3</center>\n\n# 重心坐标\n　　通常我们只能对三角形的三个顶点定义颜色等属性，那么如何确定三角形内部任意一点的颜色？(Figure 4)\n\n![figure 4](/figure4.png)\n<center>Figure 4</center>\n\n　　假设 $P=\\lambda_{0} \\* V0 + \\lambda_{1} \\* V1 + \\lambda_{2} \\* V2$，且满足 $\\lambda_{0} + \\lambda_{1} + \\lambda_{2} = 1$ 那么 $(\\lambda_{0},\\lambda_{1},\\lambda_{2})$ 就是 $P$ 的重心坐标。它可以表示位于三角形内部（及边界）上的任意一点。\n　　于是我们可以借助重心坐标来对三角形内任意一点进行插值，以获得其颜色 $C_P$ 等其它由顶点定义的属性：\n\n$$\nC_P=\\lambda_{0} \\* C_{V0} + \\lambda_{1} \\* C_{V1} + \\lambda_{2} \\* C_{V2}\n$$\n\n## 如何获得任意一点的重心坐标\n　　在三角形情形中，重心坐标也叫面积坐标，因为 $P$ 点关于 $\\Delta ABC$ 的重心坐标和 $\\Delta PBC, \\Delta PCA, \\Delta PAB$ 的面积成比例。证明如下。\n　　如图(Figure 4)，设 $\\Delta ABC$ 三个顶点和原点构成的向量分别为 $pmb{\\vec{a}}, \\pmb{\\vec{b}}, \\pmb{\\vec{c}}$，$P$ 点和原点构成的向量为 $\\pmb{\\vec{p}}$。$\\Delta PBC, \\Delta PCA, \\Delta PAB$ 面积之比为 $\\lambda_{0}:\\lambda_{1}:\\lambda_{2}$，且 $\\lambda_{0} + \\lambda_{1} + \\lambda_{2}=1$，设射线 $AP$ 与 $BC$ 交于点 $D$，点 $D$ 和原点构成的向量为 $\\pmb{\\vec{d}}$，\n\n![figure 5](/figure5.png)\n<center>Figure 5</center>\n\n　　则：\n\n$$\nBD:DC=\\lambda_{2}:\\lambda_{1}, 从而\\quad \\pmb{\\vec{d}}=\\cfrac{\\lambda_{1}\\pmb{\\vec{b}}+\\lambda_{2}\\pmb{\\vec{c}}}{\\lambda_{1}+\\lambda_{2}} \\\\\\\\\nAP:PD=(\\lambda_{1}+\\lambda_{2}):\\lambda_{0}, 故\\quad \\pmb{\\vec{p}}=\\cfrac{(\\lambda_{1}+\\lambda_{2})\\pmb{\\vec{d}}+\\lambda_{0}\\pmb{\\vec{a}}}{\\lambda_{0}+\\lambda_{1}+\\lambda_{2}} \\\\\\\\\n\\pmb{\\vec{p}}=\\lambda_{0}\\pmb{\\vec{a}}+\\lambda_{1}\\pmb{\\vec{b}}+\\lambda_{2}\\pmb{\\vec{c}}\n$$\n\n　　而 $\\Delta PBC, \\Delta PCA, \\Delta PAB$ 的面积又正好等于 $P$ 点和 $\\Delta ABC$ 顶点构成的向量与 $\\Delta ABC$ 三边构成的向量的**叉积的值的一半。**\n　　叉积值已通过 Edge Function 得到，所以重心坐标：\n\n$$\n\\lambda_{0}=\\cfrac{Area(V1,V2,P)}{Area(V0,V1,V2)}=\\cfrac{E_{12}(P)/2}{E_{12}(V0)/2}=\\cfrac{E_{12}(P)}{E_{12}(V0)} \\\\\\\\\n\\lambda_{1}=\\cfrac{Area(V2,V0,P)}{Area(V0,V1,V2)}=\\cfrac{E_{20}(P)/2}{E_{20}(V1)/2}=\\cfrac{E_{20}(P)}{E_{20}(V1)} \\\\\\\\\n\\lambda_{2}=\\cfrac{Area(V0,V1,P)}{Area(V0,V1,V2)}=\\cfrac{E_{01}(P)/2}{E_{01}(V2)/2}=\\cfrac{E_{01}(P)}{E_{01}(V2)}\n$$\n\n## 计算优化\n\n$$\nlambda_{0} + lambda_{1} + lambda_{2} = 1 \\\\\\\\\nP = lambda_{0} \\* V0 + lambda_{1} \\* V1 + lambda_{2} \\* V2\n$$\n\n　　两公式联立消去 $\\lambda_{0}$ 得：\n\n$$\nP=V0 + lambda_{1} \\* (V1-V0) + lambda_{2} \\* (V2-V0)\n$$\n\n　　$V1-V0$ 和 $V2-V0$ 可以提前计算出来，这样就把计算由三次乘法和两次加法简化到了两次乘法和两次加法。**GPU采用了这种优化策略。**\n\n# 拓展\n　　在某些特殊情况下，一个像素可能同时落在两个投影三角形区域内，Figure 6 中的红色像素点显示了这种情况。\n\n![figure 6](/figure6.png)\n<center>Figure 6</center>\n\n　　**top-left rule** (Figure 7) 可以用来避免这种重复光栅化三角形边界像素的情况。\n\n![figure 7](/figure7.png)\n<center>Figure 7</center>\n\n　　由图可知：\n- **top edge** 指的是满足向量 $V[(x+1)\\%3] - V[x], x=0,1,2$ 的 $y$ 坐标等于 $0$，且 $x$ 坐标大于 $0$ 的边。\n- **left edge** 指的是满足向量　$V[(x+1)\\%3]-V[x], x=0,1,2$ 的 $y$ 坐标大于 $0$ 的边。\n\n\n　　**需要特别注意的是，本节都是建立在三角形三边按顺时针方向定义的前提下讨论的。**\n\n# 实例\n　　给定光栅化坐标系下的三角形的三个顶点以及顶点的颜色，渲染出这个三角形。\n\n## 代码\n```C++\n#include <iostream>\n#include <fstream>\n#include <cstring>\n\nstruct Vec2{\n    float x, y;\n    Vec2(float x = 0.0, float y = 0.0): x(x), y(y){}\n};\n\nstruct Vec3{\n    float x, y, z;\n    Vec3(float x = 0.0, float y = 0.0, float z = 0.0): x(x), y(y), z(z){}\n};\n\nstruct Rgb{\n    unsigned char r, g, b;\n    Rgb(unsigned char r = 0, unsigned char g = 0, unsigned char b = 0): r(r), g(g), b(b){}\n};\n\nfloat edgeFunction(Vec2 &a, Vec2 &b, Vec2 &c){\n    return (c.x - a.x)*(b.y - a.y) - (c.y - a.y)*(b.x - a.x);\n}\n\nbool top_left(const Vec2 &v){\n    if((v.y == 0 && v.x > 0) || v.y > 0) return true;\n    else return false;\n}\n\nint main(){\n    Vec2 v0(491.407, 411.407); \n    Vec2 v1(148.593, 68.5928); \n    Vec2 v2(148.593, 411.407); \n    Vec3 c0(1, 0, 0); \n    Vec3 c1(0, 1, 0); \n    Vec3 c2(0, 0, 1);\n\n    const uint32_t w = 512;\n    const uint32_t h = 512;\n\n    Rgb framebuffer[w][h];\n    memset(framebuffer, 0, sizeof(framebuffer));\n\n    float area = edgeFunction(v0, v1, v2);\n\n    for(uint32_t j = 0; j < h; j++){\n        for(uint32_t i = 0; i < w; i++){\n            Vec2 p(i + 0.5, j + 0.5);\n            float w0 = edgeFunction(v1, v2, p);\n            float w1 = edgeFunction(v2, v0, p);\n            float w2 = edgeFunction(v0, v1, p);\n\n            if(w0 >= 0 && w1 >= 0 && w2 >= 0){\n                //top-left judge\n                if(w0 == 0 && !top_left(Vec2(v2.x - v1.x, v2.y - v1.y))) continue;\n                if(w1 == 0 && !top_left(Vec2(v0.x - v2.x, v0.y - v2.y))) continue;\n                if(w2 == 0 && !top_left(Vec2(v1.x - v0.x, v1.y - v0.y))) continue;\n\n                w0 /= area;\n                w1 /= area;\n                w2 /= area;\n                float r = w0 * c0.x + w1 * c1.x + w2 * c2.x;\n                float g = w0 * c0.y + w1 * c1.y + w2 * c2.y;\n                float b = w0 * c0.z + w1 * c1.z + w2 * c2.z;\n                framebuffer[j][i].r = (unsigned char)(r * 255);\n                framebuffer[j][i].g = (unsigned char)(g * 255);\n                framebuffer[j][i].b = (unsigned char)(b * 255);\n            }\n        }\n    }\n\n    std::ofstream ofs;\n    ofs.open(\"./raster2d.ppm\");\n       ofs << \"P6\\n\" << w << \" \" << h << \"\\n255\\n\";\n    ofs.write((char *)framebuffer, sizeof(framebuffer));\n    ofs.close(); \n\n    return 0;\n}\n```\n\n## 结果\n\n![result](/result.png)\n<center>result</center>\n\n# 参考链接\n\n[Scratchapixel-The Rasterization Stage](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage)\n[维基百科-重心坐标](https://www.wikiwand.com/zh-hans/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87)","slug":"光栅化渲染-3-光栅化","published":1,"updated":"2021-04-21T03:30:14.780Z","_id":"ck0uh6ns0007vh8vnu0l312iw","comments":1,"layout":"post","photos":[],"link":""}],"PostAsset":[{"_id":"source/_posts/光栅化渲染-8-正交投影矩阵/projectionsexample.png","slug":"projectionsexample.png","post":"ck0uh6nm60029h8vnmu4qzv4v","modified":0,"renderable":0},{"_id":"source/_posts/Uva1343-The-Rotation-Game/game.png","slug":"game.png","post":"ck0uh6nlq0018h8vn7un4bbad","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-2-透视投影/perspective.png","slug":"perspective.png","post":"ck0uh6nm20021h8vnkgk9jnhm","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-7-渲染管线/figure1.png","slug":"figure1.png","post":"ck0uh6nm6002ah8vnr0xhpzta","modified":0,"renderable":0},{"_id":"source/_posts/哈希表/hash.png","slug":"hash.png","post":"ck0uh6nm8002dh8vnxpe9i5ks","modified":0,"renderable":0},{"_id":"source/_posts/HDU1016-Prime-Ring-Problem-DFS/dfs.png","slug":"dfs.png","post":"ck0uh6nl9000eh8vnhnu1jkv3","modified":0,"renderable":0},{"_id":"source/_posts/Learn-CMake-4-链接库文件/lena_color.png","slug":"lena_color.png","post":"ck0uh6nld000lh8vnvczi8hin","modified":0,"renderable":0},{"_id":"source/_posts/Maze/maze.png","slug":"maze.png","post":"ck0uh6nle000nh8vnxeoxx93g","modified":0,"renderable":0},{"_id":"source/_posts/PCA-主成分分析/pca.jpeg","slug":"pca.jpeg","post":"ck0uh6nlf000ph8vnp0w1bpjh","modified":0,"renderable":0},{"_id":"source/_posts/POJ1970-The-Game-DFS/Renju.png","slug":"Renju.png","post":"ck0uh6nlk000uh8vn8v7waa0i","modified":0,"renderable":0},{"_id":"source/_posts/Super-Mario/SuperMario.png","slug":"SuperMario.png","post":"ck0uh6nlk000vh8vn4ildy84z","modified":0,"renderable":0},{"_id":"source/_posts/Uva10562-Undraw the trees/tree.png","slug":"tree.png","post":"ck0uh6nlm0010h8vn822ze6s4","modified":0,"renderable":0},{"_id":"source/_posts/Rand-C-随机数/random.jpg","slug":"random.jpg","post":"ck0uh6nln0011h8vny6mmc66z","modified":0,"renderable":0},{"_id":"source/_posts/Uva11212-Editing-a-Book/prune.png","slug":"prune.png","post":"ck0uh6nlo0015h8vnnf3vvbpj","modified":0,"renderable":0},{"_id":"source/_posts/Uva12166-Equilibrium-Mobile/balance.png","slug":"balance.png","post":"ck0uh6nlr001bh8vn19lb8qlm","modified":0,"renderable":0},{"_id":"source/_posts/Uva1602-Lattice-Animals/pic.png","slug":"pic.png","post":"ck0uh6nls001dh8vnigphx4z6","modified":0,"renderable":0},{"_id":"source/_posts/Uva221-Urban-Elevations/building.png","slug":"building.png","post":"ck0uh6nls001eh8vnxfsa1bsb","modified":0,"renderable":0},{"_id":"source/_posts/Uva839-二叉树的递归处理/tree.png","slug":"tree.png","post":"ck0uh6nlv001lh8vngx9c3wn6","modified":0,"renderable":0},{"_id":"source/_posts/buildBinaryTree/BinaryTree.png","slug":"BinaryTree.png","post":"ck0uh6nlw001nh8vn780e30nv","modified":0,"renderable":0},{"_id":"source/_posts/倒水问题/fill.png","slug":"fill.png","post":"ck0uh6nm40025h8vnao2d17ha","modified":0,"renderable":0},{"_id":"source/_posts/二分查找以及lower-bound-upper-bound实现/BinarySearch.jpeg","slug":"BinarySearch.jpeg","post":"ck0uh6nm40026h8vnwg3ip6v2","modified":0,"renderable":0},{"_id":"source/_posts/八数码问题/EightDigital.png","slug":"EightDigital.png","post":"ck0uh6nm8002eh8vnzrf9lddc","modified":0,"renderable":0},{"_id":"source/_posts/循环小数化为分数的方法/wiki.png","slug":"wiki.png","post":"ck0uh6nma002gh8vnq6fmcb3r","modified":0,"renderable":0},{"_id":"source/_posts/欧拉回路/Elur.png","slug":"Elur.png","post":"ck0uh6nma002hh8vncvg47csd","modified":0,"renderable":0},{"_id":"source/_posts/Graph-Theory-The-shortest-path/gra.png","slug":"gra.png","post":"ck0uh6nl9000dh8vndniv2gcc","modified":0,"renderable":0},{"_id":"source/_posts/Graph-Theory-The-shortest-path/path.png","slug":"path.png","post":"ck0uh6nl9000dh8vndniv2gcc","modified":0,"renderable":0},{"_id":"source/_posts/HDU2050/line.jpg","slug":"line.jpg","post":"ck0uh6nlb000gh8vniktfm60z","modified":0,"renderable":0},{"_id":"source/_posts/HDU2050/res.gif","slug":"res.gif","post":"ck0uh6nlb000gh8vniktfm60z","modified":0,"renderable":0},{"_id":"source/_posts/Uva806-Spatial-Structures/1.png","slug":"1.png","post":"ck0uh6nlu001jh8vncplguoa8","modified":0,"renderable":0},{"_id":"source/_posts/Uva806-Spatial-Structures/2.png","slug":"2.png","post":"ck0uh6nlu001jh8vncplguoa8","modified":0,"renderable":0},{"_id":"source/_posts/tab-to-spaces/space.png","slug":"space.png","post":"ck0uh6nm1001yh8vnlquwag6f","modified":0,"renderable":0},{"_id":"source/_posts/tab-to-spaces/tab.png","slug":"tab.png","post":"ck0uh6nm1001yh8vnlquwag6f","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-8-正交投影矩阵/figure1.png","slug":"figure1.png","post":"ck0uh6nm60029h8vnmu4qzv4v","modified":0,"renderable":0},{"_id":"source/_posts/八皇后问题/diagonal.png","slug":"diagonal.png","post":"ck0uh6nm7002bh8vn4p9g55pl","modified":0,"renderable":0},{"_id":"source/_posts/八皇后问题/queen.png","slug":"queen.png","post":"ck0uh6nm7002bh8vn4p9g55pl","modified":0,"renderable":0},{"_id":"source/_posts/静态链接库-STATIC-和动态链接库-SHARED/shared.png","slug":"shared.png","post":"ck0uh6nm9002fh8vnvsx185iz","modified":0,"renderable":0},{"_id":"source/_posts/静态链接库-STATIC-和动态链接库-SHARED/static.png","slug":"static.png","post":"ck0uh6nm9002fh8vnvsx185iz","modified":0,"renderable":0},{"_id":"source/_posts/My-little-angel/moon1.jpg","slug":"moon1.jpg","post":"ck0uh6nlh000sh8vnk9ewij12","modified":0,"renderable":0},{"_id":"source/_posts/My-little-angel/qxy1.jpg","slug":"qxy1.jpg","post":"ck0uh6nlh000sh8vnk9ewij12","modified":0,"renderable":0},{"_id":"source/_posts/My-little-angel/together1.jpg","slug":"together1.jpg","post":"ck0uh6nlh000sh8vnk9ewij12","modified":0,"renderable":0},{"_id":"source/_posts/Linear algebra-Dot product/1.gif","slug":"1.gif","post":"ck0uh6nlf000qh8vnq32qs9xc","modified":0,"renderable":0},{"_id":"source/_posts/Linear algebra-Dot product/2.gif","slug":"2.gif","post":"ck0uh6nlf000qh8vnq32qs9xc","modified":0,"renderable":0},{"_id":"source/_posts/Linear algebra-Dot product/3.gif","slug":"3.gif","post":"ck0uh6nlf000qh8vnq32qs9xc","modified":0,"renderable":0},{"_id":"source/_posts/Uva1103-Ancient-Messages/1.png","slug":"1.png","post":"ck0uh6nln0012h8vndydzbugr","modified":0,"renderable":0},{"_id":"source/_posts/Uva1103-Ancient-Messages/2.png","slug":"2.png","post":"ck0uh6nln0012h8vndydzbugr","modified":0,"renderable":0},{"_id":"source/_posts/Uva1103-Ancient-Messages/hier.png","slug":"hier.png","post":"ck0uh6nln0012h8vndydzbugr","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-1-算法总述/discrete.png","slug":"discrete.png","post":"ck0uh6nm30022h8vniui90ik2","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-1-算法总述/figure1.png","slug":"figure1.png","post":"ck0uh6nm30022h8vniui90ik2","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-1-算法总述/figure2.jpg","slug":"figure2.jpg","post":"ck0uh6nm30022h8vniui90ik2","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-1-算法总述/figure3.png","slug":"figure3.png","post":"ck0uh6nm30022h8vniui90ik2","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-1-算法总述/figure4.png","slug":"figure4.png","post":"ck0uh6nm30022h8vniui90ik2","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-5-透视矫正/figure1.png","slug":"figure1.png","post":"ck0uh6nm50027h8vns1jragv9","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-5-透视矫正/figure2.png","slug":"figure2.png","post":"ck0uh6nm50027h8vns1jragv9","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-5-透视矫正/formula1.png","slug":"formula1.png","post":"ck0uh6nm50027h8vns1jragv9","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-5-透视矫正/formula2.png","slug":"formula2.png","post":"ck0uh6nm50027h8vns1jragv9","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-5-透视矫正/formula3.png","slug":"formula3.png","post":"ck0uh6nm50027h8vns1jragv9","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-2-透视投影/figure1.png","slug":"figure1.png","post":"ck0uh6nm20021h8vnkgk9jnhm","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-2-透视投影/figure2.png","slug":"figure2.png","post":"ck0uh6nm20021h8vnkgk9jnhm","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-2-透视投影/figure3.png","slug":"figure3.png","post":"ck0uh6nm20021h8vnkgk9jnhm","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-2-透视投影/figure4.png","slug":"figure4.png","post":"ck0uh6nm20021h8vnkgk9jnhm","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-2-透视投影/figure5.png","slug":"figure5.png","post":"ck0uh6nm20021h8vnkgk9jnhm","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-2-透视投影/visible.png","slug":"visible.png","post":"ck0uh6nm20021h8vnkgk9jnhm","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p1.png","slug":"p1.png","post":"ck0uh6nm20020h8vnws60suay","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p2.png","slug":"p2.png","post":"ck0uh6nm20020h8vnws60suay","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p3.png","slug":"p3.png","post":"ck0uh6nm20020h8vnws60suay","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p4.png","slug":"p4.png","post":"ck0uh6nm20020h8vnws60suay","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p5.png","slug":"p5.png","post":"ck0uh6nm20020h8vnws60suay","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p6.png","slug":"p6.png","post":"ck0uh6nm20020h8vnws60suay","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p7.png","slug":"p7.png","post":"ck0uh6nm20020h8vnws60suay","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p8.png","slug":"p8.png","post":"ck0uh6nm20020h8vnws60suay","modified":0,"renderable":0},{"_id":"source/_posts/vultr/p9.png","slug":"p9.png","post":"ck0uh6nm20020h8vnws60suay","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/equation1.png","slug":"equation1.png","post":"ck0uh6nm50028h8vn8u5ldgsa","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/equation2.png","slug":"equation2.png","post":"ck0uh6nm50028h8vn8u5ldgsa","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure1.png","slug":"figure1.png","post":"ck0uh6nm50028h8vn8u5ldgsa","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure2.png","slug":"figure2.png","post":"ck0uh6nm50028h8vn8u5ldgsa","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure3.png","slug":"figure3.png","post":"ck0uh6nm50028h8vn8u5ldgsa","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure4.png","slug":"figure4.png","post":"ck0uh6nm50028h8vn8u5ldgsa","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure5.png","slug":"figure5.png","post":"ck0uh6nm50028h8vn8u5ldgsa","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure6.png","slug":"figure6.png","post":"ck0uh6nm50028h8vn8u5ldgsa","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-6-透视投影矩阵/figure7.png","slug":"figure7.png","post":"ck0uh6nm50028h8vn8u5ldgsa","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-4-深度检测/depth.png","slug":"depth.png","post":"ck0uh6nm7002ch8vnic41bev6","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-4-深度检测/equation2.png","slug":"equation2.png","post":"ck0uh6nm7002ch8vnic41bev6","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-4-深度检测/equation4.png","slug":"equation4.png","post":"ck0uh6nm7002ch8vnic41bev6","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-4-深度检测/equation6.png","slug":"equation6.png","post":"ck0uh6nm7002ch8vnic41bev6","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-4-深度检测/equation7.png","slug":"equation7.png","post":"ck0uh6nm7002ch8vnic41bev6","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-4-深度检测/equation8.png","slug":"equation8.png","post":"ck0uh6nm7002ch8vnic41bev6","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-4-深度检测/figure1.png","slug":"figure1.png","post":"ck0uh6nm7002ch8vnic41bev6","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-4-深度检测/figure2.png","slug":"figure2.png","post":"ck0uh6nm7002ch8vnic41bev6","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-4-深度检测/simplify.png","slug":"simplify.png","post":"ck0uh6nm7002ch8vnic41bev6","modified":0,"renderable":0},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/Rudolf_Kalman.jpg","slug":"Rudolf_Kalman.jpg","post":"ck0uh6nrw007lh8vnrq8wr3t6","modified":0,"renderable":0},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/afterFilter.png","slug":"afterFilter.png","post":"ck0uh6nrw007lh8vnrq8wr3t6","modified":0,"renderable":0},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/g1.jpg","slug":"g1.jpg","post":"ck0uh6nrw007lh8vnrq8wr3t6","modified":0,"renderable":0},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/g2.jpg","slug":"g2.jpg","post":"ck0uh6nrw007lh8vnrq8wr3t6","modified":0,"renderable":0},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/g3.jpg","slug":"g3.jpg","post":"ck0uh6nrw007lh8vnrq8wr3t6","modified":0,"renderable":0},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/g4.jpg","slug":"g4.jpg","post":"ck0uh6nrw007lh8vnrq8wr3t6","modified":0,"renderable":0},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/g5.jpg","slug":"g5.jpg","post":"ck0uh6nrw007lh8vnrq8wr3t6","modified":0,"renderable":0},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/gauss.jpg","slug":"gauss.jpg","post":"ck0uh6nrw007lh8vnrq8wr3t6","modified":0,"renderable":0},{"_id":"source/_posts/Kalman-filter-卡尔曼滤波器/origin.png","slug":"origin.png","post":"ck0uh6nrw007lh8vnrq8wr3t6","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure1.png","slug":"figure1.png","post":"ck0uh6ns0007vh8vnu0l312iw","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure2.png","slug":"figure2.png","post":"ck0uh6ns0007vh8vnu0l312iw","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure3.gif","slug":"figure3.gif","post":"ck0uh6ns0007vh8vnu0l312iw","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure4.png","slug":"figure4.png","post":"ck0uh6ns0007vh8vnu0l312iw","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure5.png","slug":"figure5.png","post":"ck0uh6ns0007vh8vnu0l312iw","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure6.png","slug":"figure6.png","post":"ck0uh6ns0007vh8vnu0l312iw","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-3-光栅化/figure7.png","slug":"figure7.png","post":"ck0uh6ns0007vh8vnu0l312iw","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-3-光栅化/rasterization.png","slug":"rasterization.png","post":"ck0uh6ns0007vh8vnu0l312iw","modified":0,"renderable":0},{"_id":"source/_posts/光栅化渲染-3-光栅化/result.png","slug":"result.png","post":"ck0uh6ns0007vh8vnu0l312iw","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ck0uh6nl50007h8vnrxjrnlmg","category_id":"ck0uh6nos002oh8vnd8mr03qi","_id":"ck0uh6nrw007kh8vngvuixhop"},{"post_id":"ck0uh6nl8000bh8vn7cd0bcu1","category_id":"ck0uh6nou002sh8vnhjiddn8h","_id":"ck0uh6nrx007nh8vng58kqbvn"},{"post_id":"ck0uh6nl9000dh8vndniv2gcc","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6nry007qh8vn2xzf0op1"},{"post_id":"ck0uh6nla000fh8vncm8ql3q1","category_id":"ck0uh6now002yh8vnvgp9nn5u","_id":"ck0uh6ns0007uh8vn2o0cq2gs"},{"post_id":"ck0uh6nld000jh8vnogprhvu1","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6ns0007xh8vnpwstmzjz"},{"post_id":"ck0uh6nld000kh8vnzhbg0b05","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6ns10080h8vn8xhh5cor"},{"post_id":"ck0uh6nld000lh8vnvczi8hin","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6ns10082h8vngg6ou2kt"},{"post_id":"ck0uh6nle000mh8vniggb599t","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6ns10085h8vnqgmr76wc"},{"post_id":"ck0uh6nle000nh8vnxeoxx93g","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6ns20087h8vn84owmzb1"},{"post_id":"ck0uh6nlf000ph8vnp0w1bpjh","category_id":"ck0uh6nos002oh8vnd8mr03qi","_id":"ck0uh6ns2008ah8vn5g5e033d"},{"post_id":"ck0uh6nlf000qh8vnq32qs9xc","category_id":"ck0uh6nos002oh8vnd8mr03qi","_id":"ck0uh6ns2008ch8vnc10ygcqs"},{"post_id":"ck0uh6nlh000sh8vnk9ewij12","category_id":"ck0uh6now002yh8vnvgp9nn5u","_id":"ck0uh6ns3008fh8vny8vm5cln"},{"post_id":"ck0uh6nlk000vh8vn4ildy84z","category_id":"ck0uh6np6003rh8vn8xk4kpfm","_id":"ck0uh6ns3008hh8vnkl7loch8"},{"post_id":"ck0uh6nll000wh8vnquj6g7s4","category_id":"ck0uh6nou002sh8vnhjiddn8h","_id":"ck0uh6ns3008kh8vn1p2rcwu7"},{"post_id":"ck0uh6nln0011h8vny6mmc66z","category_id":"ck0uh6nou002sh8vnhjiddn8h","_id":"ck0uh6ns4008mh8vnup0mlslf"},{"post_id":"ck0uh6nlw001nh8vn780e30nv","category_id":"ck0uh6npl0059h8vnr9kuggoe","_id":"ck0uh6ns4008oh8vni0tusnkz"},{"post_id":"ck0uh6nlw001oh8vn1ahhv3rh","category_id":"ck0uh6np6003rh8vn8xk4kpfm","_id":"ck0uh6ns5008rh8vnhrp6lifu"},{"post_id":"ck0uh6nlx001ph8vnq4ox7lng","category_id":"ck0uh6now002yh8vnvgp9nn5u","_id":"ck0uh6ns5008th8vnnlf3tsl0"},{"post_id":"ck0uh6nly001rh8vnvsvtk9tb","category_id":"ck0uh6nou002sh8vnhjiddn8h","_id":"ck0uh6ns5008wh8vn38g58uyq"},{"post_id":"ck0uh6nly001sh8vn1yrurqu8","category_id":"ck0uh6nou002sh8vnhjiddn8h","_id":"ck0uh6ns6008yh8vnyignpa32"},{"post_id":"ck0uh6nlz001th8vn8wnkje12","category_id":"ck0uh6nou002sh8vnhjiddn8h","_id":"ck0uh6ns60091h8vngvjkfezd"},{"post_id":"ck0uh6nlz001uh8vnq9yzlica","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6ns60093h8vnud65fjgv"},{"post_id":"ck0uh6nm0001vh8vnsa40qt86","category_id":"ck0uh6npl0059h8vnr9kuggoe","_id":"ck0uh6ns70096h8vngwauh304"},{"post_id":"ck0uh6nm0001wh8vnwdp6nlem","category_id":"ck0uh6npr005rh8vnfn6dzun2","_id":"ck0uh6ns70098h8vnlajo3cr9"},{"post_id":"ck0uh6nm0001xh8vn5j8spxq1","category_id":"ck0uh6nou002sh8vnhjiddn8h","_id":"ck0uh6ns7009bh8vng3p660iy"},{"post_id":"ck0uh6nm1001yh8vnlquwag6f","category_id":"ck0uh6np6003rh8vn8xk4kpfm","_id":"ck0uh6ns7009dh8vntjow2fi9"},{"post_id":"ck0uh6nm1001zh8vneopgz0k5","category_id":"ck0uh6nou002sh8vnhjiddn8h","_id":"ck0uh6ns8009gh8vnf69x1kw5"},{"post_id":"ck0uh6nm20020h8vnws60suay","category_id":"ck0uh6np6003rh8vn8xk4kpfm","_id":"ck0uh6ns8009ih8vnzs154hcx"},{"post_id":"ck0uh6nm30023h8vnwpth2rln","category_id":"ck0uh6npl0059h8vnr9kuggoe","_id":"ck0uh6ns8009kh8vnc1zhwjf0"},{"post_id":"ck0uh6nm30024h8vntym945uw","category_id":"ck0uh6npl0059h8vnr9kuggoe","_id":"ck0uh6ns8009nh8vnm95d25ha"},{"post_id":"ck0uh6nm40025h8vnao2d17ha","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6ns9009ph8vnsb95asb5"},{"post_id":"ck0uh6nm40026h8vnwg3ip6v2","category_id":"ck0uh6npl0059h8vnr9kuggoe","_id":"ck0uh6ns9009sh8vnuu7yrurx"},{"post_id":"ck0uh6nm7002bh8vn4p9g55pl","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6ns9009uh8vnqyiw1zxp"},{"post_id":"ck0uh6nm8002dh8vnxpe9i5ks","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6nsa009xh8vnfmrw9k4p"},{"post_id":"ck0uh6nm8002eh8vnzrf9lddc","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6nsa009zh8vn9tjy57rd"},{"post_id":"ck0uh6nm9002fh8vnvsx185iz","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6nsa00a2h8vn9muzgfll"},{"post_id":"ck0uh6nma002gh8vnq6fmcb3r","category_id":"ck0uh6nos002oh8vnd8mr03qi","_id":"ck0uh6nsa00a4h8vnbhek3xtp"},{"post_id":"ck0uh6nma002hh8vncvg47csd","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6nsb00a7h8vnglh2k2t4"},{"post_id":"ck0uh6nky0001h8vnc9jr32e3","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsw00cnh8vni62z0o4b"},{"post_id":"ck0uh6nky0001h8vnc9jr32e3","category_id":"ck0uh6nrv007ih8vng07nunsl","_id":"ck0uh6nsw00coh8vns10c6q7r"},{"post_id":"ck0uh6nl30003h8vn4us8x1om","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsx00cph8vnqvaaxzx0"},{"post_id":"ck0uh6nl30003h8vn4us8x1om","category_id":"ck0uh6nrz007sh8vn3p7yj7qs","_id":"ck0uh6nsx00crh8vnjmwsivii"},{"post_id":"ck0uh6nl40005h8vnzpt4u3wv","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsx00csh8vnkpgdouc9"},{"post_id":"ck0uh6nl40005h8vnzpt4u3wv","category_id":"ck0uh6nrz007sh8vn3p7yj7qs","_id":"ck0uh6nsx00cuh8vn9sjyy76t"},{"post_id":"ck0uh6nl70009h8vn789jza64","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsx00cvh8vnbokuryn0"},{"post_id":"ck0uh6nl70009h8vn789jza64","category_id":"ck0uh6ns10083h8vnka6jk5xt","_id":"ck0uh6nsy00cxh8vns93ffaxq"},{"post_id":"ck0uh6nl9000eh8vnhnu1jkv3","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsy00cyh8vn4avwyjbu"},{"post_id":"ck0uh6nl9000eh8vnhnu1jkv3","category_id":"ck0uh6ns20088h8vn9kfaicgp","_id":"ck0uh6nsy00czh8vn0bmi9lep"},{"post_id":"ck0uh6nlb000gh8vniktfm60z","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsy00d0h8vnhk1if0pb"},{"post_id":"ck0uh6nlb000gh8vniktfm60z","category_id":"ck0uh6nrz007sh8vn3p7yj7qs","_id":"ck0uh6nsy00d1h8vnywew8na3"},{"post_id":"ck0uh6nlc000ih8vn42edf6vm","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsy00d2h8vnpjuzqr1q"},{"post_id":"ck0uh6nlc000ih8vn42edf6vm","category_id":"ck0uh6ns3008ih8vnlpzo025k","_id":"ck0uh6nsz00d3h8vnrdhrxxej"},{"post_id":"ck0uh6nlf000oh8vnbuefy5nk","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsz00d4h8vnt53hbk14"},{"post_id":"ck0uh6nlf000oh8vnbuefy5nk","category_id":"ck0uh6nrz007sh8vn3p7yj7qs","_id":"ck0uh6nsz00d5h8vnaim6v9v9"},{"post_id":"ck0uh6nlg000rh8vnesh7p6vn","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsz00d6h8vncbgq45e0"},{"post_id":"ck0uh6nlg000rh8vnesh7p6vn","category_id":"ck0uh6ns5008uh8vnseja906x","_id":"ck0uh6nsz00d7h8vnmy178qj8"},{"post_id":"ck0uh6nlj000th8vnf1o8isuf","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsz00d8h8vn8xkbilt8"},{"post_id":"ck0uh6nlj000th8vnf1o8isuf","category_id":"ck0uh6ns6008zh8vn9o0cpycg","_id":"ck0uh6nsz00d9h8vntm9avu5y"},{"post_id":"ck0uh6nlk000uh8vn8v7waa0i","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsz00dah8vnsluzf3ti"},{"post_id":"ck0uh6nlk000uh8vn8v7waa0i","category_id":"ck0uh6ns20088h8vn9kfaicgp","_id":"ck0uh6nsz00dbh8vn65fn22xc"},{"post_id":"ck0uh6nll000xh8vnce7verf5","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nsz00dch8vnq6s4cww4"},{"post_id":"ck0uh6nll000xh8vnce7verf5","category_id":"ck0uh6ns70099h8vnv9p6u7ps","_id":"ck0uh6nt000ddh8vnxgxzfk47"},{"post_id":"ck0uh6nlm000yh8vnqvc6hj01","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt000deh8vniknmk32j"},{"post_id":"ck0uh6nlm000yh8vnqvc6hj01","category_id":"ck0uh6ns7009eh8vnbbpbcq9k","_id":"ck0uh6nt000dfh8vndx0qcmdw"},{"post_id":"ck0uh6nlm000zh8vnjvrz8sxm","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt000dgh8vnhfrlfsp3"},{"post_id":"ck0uh6nlm000zh8vnjvrz8sxm","category_id":"ck0uh6ns8009lh8vnmdcrxec1","_id":"ck0uh6nt000dhh8vnet3iqtck"},{"post_id":"ck0uh6nlm0010h8vn822ze6s4","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt000dih8vnzu9d5f59"},{"post_id":"ck0uh6nlm0010h8vn822ze6s4","category_id":"ck0uh6ns7009eh8vnbbpbcq9k","_id":"ck0uh6nt000djh8vnx05g6m9w"},{"post_id":"ck0uh6nln0012h8vndydzbugr","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt000dkh8vnuztdtxmz"},{"post_id":"ck0uh6nln0012h8vndydzbugr","category_id":"ck0uh6ns20088h8vn9kfaicgp","_id":"ck0uh6nt000dlh8vnt6iu47lh"},{"post_id":"ck0uh6nlo0013h8vnlzl3v5iu","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt000dmh8vnp3ba7r0u"},{"post_id":"ck0uh6nlo0013h8vnlzl3v5iu","category_id":"ck0uh6nsa00a0h8vnuo60rt8q","_id":"ck0uh6nt000dnh8vnmt5rfuuz"},{"post_id":"ck0uh6nlo0014h8vn7z0u31dd","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt000doh8vn6g5ef0j2"},{"post_id":"ck0uh6nlo0014h8vn7z0u31dd","category_id":"ck0uh6ns70099h8vnv9p6u7ps","_id":"ck0uh6nt100dph8vnie0mfwg5"},{"post_id":"ck0uh6nlo0015h8vnnf3vvbpj","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt100dqh8vnxat69uvr"},{"post_id":"ck0uh6nlo0015h8vnnf3vvbpj","category_id":"ck0uh6nsb00a9h8vnvyhljy18","_id":"ck0uh6nt100drh8vnvog0syd8"},{"post_id":"ck0uh6nlp0016h8vndsasio9t","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt100dsh8vnt70k633t"},{"post_id":"ck0uh6nlp0016h8vndsasio9t","category_id":"ck0uh6ns20088h8vn9kfaicgp","_id":"ck0uh6nt100dth8vn6if1y1pj"},{"post_id":"ck0uh6nlp0017h8vni8zki75q","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt100duh8vnuhvsqecb"},{"post_id":"ck0uh6nlp0017h8vni8zki75q","category_id":"ck0uh6nsc00afh8vnrafzkr73","_id":"ck0uh6nt100dvh8vnzokbknsh"},{"post_id":"ck0uh6nlq0018h8vn7un4bbad","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt100dwh8vn9y3ndpxf"},{"post_id":"ck0uh6nlq0018h8vn7un4bbad","category_id":"ck0uh6nsb00a9h8vnvyhljy18","_id":"ck0uh6nt100dxh8vn721a7l2n"},{"post_id":"ck0uh6nlq0019h8vnupeq2qvi","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt100dyh8vn060fibo3"},{"post_id":"ck0uh6nlq0019h8vnupeq2qvi","category_id":"ck0uh6ns7009eh8vnbbpbcq9k","_id":"ck0uh6nt100dzh8vna92hj2mc"},{"post_id":"ck0uh6nlq001ah8vnh0czjkw2","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt100e0h8vn9jldjxfe"},{"post_id":"ck0uh6nlq001ah8vnh0czjkw2","category_id":"ck0uh6nsd00aph8vnbc01cfu7","_id":"ck0uh6nt200e1h8vnwirp2qrj"},{"post_id":"ck0uh6nlr001bh8vn19lb8qlm","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt200e2h8vne8t53lao"},{"post_id":"ck0uh6nlr001bh8vn19lb8qlm","category_id":"ck0uh6ns7009eh8vnbbpbcq9k","_id":"ck0uh6nt200e3h8vn11abtfcw"},{"post_id":"ck0uh6nlr001ch8vn3byo5f22","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt200e4h8vnbgh3fzva"},{"post_id":"ck0uh6nlr001ch8vn3byo5f22","category_id":"ck0uh6nse00avh8vnri0v22mz","_id":"ck0uh6nt200e5h8vnfiooc8xw"},{"post_id":"ck0uh6nls001dh8vnigphx4z6","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt200e6h8vngahe6rux"},{"post_id":"ck0uh6nls001dh8vnigphx4z6","category_id":"ck0uh6nse00avh8vnri0v22mz","_id":"ck0uh6nt200e7h8vn9bzy4dzt"},{"post_id":"ck0uh6nls001eh8vnxfsa1bsb","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt200e8h8vn91yzsnf0"},{"post_id":"ck0uh6nls001eh8vnxfsa1bsb","category_id":"ck0uh6nsf00b1h8vnomg6z4is","_id":"ck0uh6nt200e9h8vni2nw98ng"},{"post_id":"ck0uh6nls001fh8vn6fbz8mq5","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt200eah8vnd6iau2o5"},{"post_id":"ck0uh6nls001fh8vn6fbz8mq5","category_id":"ck0uh6nsf00b4h8vnbaj1g61v","_id":"ck0uh6nt200ebh8vnow8s2tji"},{"post_id":"ck0uh6nlt001gh8vnxwdqzdy4","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt200ech8vnqjk22en8"},{"post_id":"ck0uh6nlt001gh8vnxwdqzdy4","category_id":"ck0uh6nsb00a9h8vnvyhljy18","_id":"ck0uh6nt200edh8vnl2viy1vi"},{"post_id":"ck0uh6nlt001hh8vng8vo9a9h","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt200eeh8vnc7olyf6t"},{"post_id":"ck0uh6nlt001hh8vng8vo9a9h","category_id":"ck0uh6nse00avh8vnri0v22mz","_id":"ck0uh6nt200efh8vn5tnvlk3z"},{"post_id":"ck0uh6nlu001ih8vncjvz07f2","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt200egh8vnsu6rx5zk"},{"post_id":"ck0uh6nlu001ih8vncjvz07f2","category_id":"ck0uh6ns7009eh8vnbbpbcq9k","_id":"ck0uh6nt300ehh8vngnks2e4k"},{"post_id":"ck0uh6nlu001jh8vncplguoa8","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt300eih8vn4ogs9hy8"},{"post_id":"ck0uh6nlu001jh8vncplguoa8","category_id":"ck0uh6ns7009eh8vnbbpbcq9k","_id":"ck0uh6nt300ejh8vn3opn4y47"},{"post_id":"ck0uh6nlv001kh8vngvc08ozp","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt300ekh8vnr4pruy7r"},{"post_id":"ck0uh6nlv001kh8vngvc08ozp","category_id":"ck0uh6nse00avh8vnri0v22mz","_id":"ck0uh6nt300elh8vn6r4ap7y6"},{"post_id":"ck0uh6nlv001lh8vngx9c3wn6","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt300emh8vnu3iyzaof"},{"post_id":"ck0uh6nlv001lh8vngx9c3wn6","category_id":"ck0uh6ns7009eh8vnbbpbcq9k","_id":"ck0uh6nt300enh8vnfdzvuqhy"},{"post_id":"ck0uh6nlw001mh8vnhpnbkdq1","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt300eoh8vnp48mrdpy"},{"post_id":"ck0uh6nlw001mh8vnhpnbkdq1","category_id":"ck0uh6nsa00a0h8vnuo60rt8q","_id":"ck0uh6nt300eph8vnc5fqb996"},{"post_id":"ck0uh6nlx001qh8vnvxjruxxw","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt300eqh8vnykhcg38w"},{"post_id":"ck0uh6nlx001qh8vnvxjruxxw","category_id":"ck0uh6ns20088h8vn9kfaicgp","_id":"ck0uh6nt300erh8vnddgjb51m"},{"post_id":"ck0uh6nm20021h8vnkgk9jnhm","category_id":"ck0uh6npt0060h8vnsizr3zwp","_id":"ck0uh6nt300esh8vnl2qv86yi"},{"post_id":"ck0uh6nm20021h8vnkgk9jnhm","category_id":"ck0uh6nsk00bwh8vnfaw8vhw7","_id":"ck0uh6nt300eth8vnrxa7imgj"},{"post_id":"ck0uh6nm30022h8vniui90ik2","category_id":"ck0uh6npt0060h8vnsizr3zwp","_id":"ck0uh6nt300euh8vnbwig5rym"},{"post_id":"ck0uh6nm30022h8vniui90ik2","category_id":"ck0uh6nsk00bwh8vnfaw8vhw7","_id":"ck0uh6nt300evh8vnfd3ulkqp"},{"post_id":"ck0uh6nm50027h8vns1jragv9","category_id":"ck0uh6npt0060h8vnsizr3zwp","_id":"ck0uh6nt300ewh8vnt036iz6z"},{"post_id":"ck0uh6nm50027h8vns1jragv9","category_id":"ck0uh6nsk00bwh8vnfaw8vhw7","_id":"ck0uh6nt300exh8vn7mxt6kkb"},{"post_id":"ck0uh6nm50028h8vn8u5ldgsa","category_id":"ck0uh6npt0060h8vnsizr3zwp","_id":"ck0uh6nt400eyh8vnozy1rw2t"},{"post_id":"ck0uh6nm50028h8vn8u5ldgsa","category_id":"ck0uh6nsk00bwh8vnfaw8vhw7","_id":"ck0uh6nt400ezh8vnp5faca0k"},{"post_id":"ck0uh6nm60029h8vnmu4qzv4v","category_id":"ck0uh6npt0060h8vnsizr3zwp","_id":"ck0uh6nt400f0h8vnfo0l9y02"},{"post_id":"ck0uh6nm60029h8vnmu4qzv4v","category_id":"ck0uh6nsk00bwh8vnfaw8vhw7","_id":"ck0uh6nt400f1h8vnlevr6zm1"},{"post_id":"ck0uh6nm6002ah8vnr0xhpzta","category_id":"ck0uh6npt0060h8vnsizr3zwp","_id":"ck0uh6nt400f2h8vnvrce4xqx"},{"post_id":"ck0uh6nm6002ah8vnr0xhpzta","category_id":"ck0uh6nsk00bwh8vnfaw8vhw7","_id":"ck0uh6nt400f3h8vnwepwcnh3"},{"post_id":"ck0uh6nm7002ch8vnic41bev6","category_id":"ck0uh6npt0060h8vnsizr3zwp","_id":"ck0uh6nt400f4h8vnweoz5lzg"},{"post_id":"ck0uh6nm7002ch8vnic41bev6","category_id":"ck0uh6nsk00bwh8vnfaw8vhw7","_id":"ck0uh6nt400f5h8vn3o2bkaq3"},{"post_id":"ck0uh6nrw007lh8vnrq8wr3t6","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6nt400f6h8vnlb7l19yb"},{"post_id":"ck0uh6nrx007oh8vnoyacct5q","category_id":"ck0uh6nou002uh8vnmlbfam9j","_id":"ck0uh6nt400f7h8vn2ziglmsz"},{"post_id":"ck0uh6nry007rh8vn9cnrcdzp","category_id":"ck0uh6nof002ih8vn13n83wir","_id":"ck0uh6nt400f8h8vnzixawf3q"},{"post_id":"ck0uh6nry007rh8vn9cnrcdzp","category_id":"ck0uh6nse00avh8vnri0v22mz","_id":"ck0uh6nt400f9h8vnrre9402v"},{"post_id":"ck0uh6ns0007vh8vnu0l312iw","category_id":"ck0uh6npt0060h8vnsizr3zwp","_id":"ck0uh6nt400fah8vn2xfvbm44"},{"post_id":"ck0uh6ns0007vh8vnu0l312iw","category_id":"ck0uh6nsk00bwh8vnfaw8vhw7","_id":"ck0uh6nt400fbh8vnp2z52ivh"}],"PostTag":[{"post_id":"ck0uh6nky0001h8vnc9jr32e3","tag_id":"ck0uh6nop002jh8vn80hox5gn","_id":"ck0uh6nrw007jh8vnnrbc2u0r"},{"post_id":"ck0uh6nky0001h8vnc9jr32e3","tag_id":"ck0uh6noq002lh8vnxi3itw8j","_id":"ck0uh6nrx007mh8vnb93ohlbe"},{"post_id":"ck0uh6nl30003h8vn4us8x1om","tag_id":"ck0uh6nop002jh8vn80hox5gn","_id":"ck0uh6nry007ph8vnh43o7qif"},{"post_id":"ck0uh6nl40005h8vnzpt4u3wv","tag_id":"ck0uh6nop002jh8vn80hox5gn","_id":"ck0uh6ns0007th8vnhz27f4h2"},{"post_id":"ck0uh6nl50007h8vnrxjrnlmg","tag_id":"ck0uh6not002rh8vnjd14wo0s","_id":"ck0uh6ns0007wh8vnxer3z6w9"},{"post_id":"ck0uh6nl70009h8vn789jza64","tag_id":"ck0uh6nou002th8vnoyb6auk4","_id":"ck0uh6ns1007zh8vnmhhz5gz8"},{"post_id":"ck0uh6nl70009h8vn789jza64","tag_id":"ck0uh6nou002vh8vnjgh0q3qs","_id":"ck0uh6ns10081h8vn5xlxct2h"},{"post_id":"ck0uh6nl8000bh8vn7cd0bcu1","tag_id":"ck0uh6nov002xh8vngcnsrb5j","_id":"ck0uh6ns10084h8vn78pa4zcq"},{"post_id":"ck0uh6nl9000dh8vndniv2gcc","tag_id":"ck0uh6now002zh8vn11wypnxx","_id":"ck0uh6ns20086h8vnzx2qkehu"},{"post_id":"ck0uh6nl9000eh8vnhnu1jkv3","tag_id":"ck0uh6nox0031h8vnpsz4loms","_id":"ck0uh6ns20089h8vnfkv28h8a"},{"post_id":"ck0uh6nlb000gh8vniktfm60z","tag_id":"ck0uh6nox0033h8vnlcy9ijef","_id":"ck0uh6ns2008bh8vnxmrbbbwo"},{"post_id":"ck0uh6nlb000gh8vniktfm60z","tag_id":"ck0uh6noy0035h8vnbbdkwt7b","_id":"ck0uh6ns2008eh8vn9q4mf7kh"},{"post_id":"ck0uh6nlb000gh8vniktfm60z","tag_id":"ck0uh6noz0037h8vnqa7onv41","_id":"ck0uh6ns3008gh8vn7ibgeds4"},{"post_id":"ck0uh6nlb000gh8vniktfm60z","tag_id":"ck0uh6nop002jh8vn80hox5gn","_id":"ck0uh6ns3008jh8vn4irh9l6e"},{"post_id":"ck0uh6nlc000ih8vn42edf6vm","tag_id":"ck0uh6nox0033h8vnlcy9ijef","_id":"ck0uh6ns4008lh8vnopq2lcom"},{"post_id":"ck0uh6nlc000ih8vn42edf6vm","tag_id":"ck0uh6np1003dh8vn3io9nq74","_id":"ck0uh6ns4008nh8vn0yh06su5"},{"post_id":"ck0uh6nlc000ih8vn42edf6vm","tag_id":"ck0uh6np2003fh8vn0z3cgwa9","_id":"ck0uh6ns5008qh8vneacbw3zt"},{"post_id":"ck0uh6nld000jh8vnogprhvu1","tag_id":"ck0uh6np3003ih8vnnkekop4a","_id":"ck0uh6ns5008sh8vnirvxt14c"},{"post_id":"ck0uh6nld000kh8vnzhbg0b05","tag_id":"ck0uh6np3003ih8vnnkekop4a","_id":"ck0uh6ns5008vh8vn2mk7i47t"},{"post_id":"ck0uh6nld000lh8vnvczi8hin","tag_id":"ck0uh6np3003ih8vnnkekop4a","_id":"ck0uh6ns6008xh8vn50j5yan9"},{"post_id":"ck0uh6nle000mh8vniggb599t","tag_id":"ck0uh6np3003ih8vnnkekop4a","_id":"ck0uh6ns60090h8vnwwqpgg5j"},{"post_id":"ck0uh6nle000nh8vnxeoxx93g","tag_id":"ck0uh6np2003fh8vn0z3cgwa9","_id":"ck0uh6ns60092h8vnqbyjvezv"},{"post_id":"ck0uh6nlf000oh8vnbuefy5nk","tag_id":"ck0uh6np7003sh8vn46fd3rpn","_id":"ck0uh6ns60095h8vnzo0lyle3"},{"post_id":"ck0uh6nlf000ph8vnp0w1bpjh","tag_id":"ck0uh6np7003uh8vn8i0i4mhk","_id":"ck0uh6ns70097h8vnmj68507h"},{"post_id":"ck0uh6nlf000qh8vnq32qs9xc","tag_id":"ck0uh6np8003wh8vnvucx7ywm","_id":"ck0uh6ns7009ah8vn3i8xzrpt"},{"post_id":"ck0uh6nlf000qh8vnq32qs9xc","tag_id":"ck0uh6np8003yh8vntfb2fpvj","_id":"ck0uh6ns7009ch8vnfs8de40r"},{"post_id":"ck0uh6nlg000rh8vnesh7p6vn","tag_id":"ck0uh6np90040h8vnvcv8khm3","_id":"ck0uh6ns8009fh8vnqphsbdw1"},{"post_id":"ck0uh6nlg000rh8vnesh7p6vn","tag_id":"ck0uh6np90042h8vnow2vz813","_id":"ck0uh6ns8009hh8vn2yl82ulb"},{"post_id":"ck0uh6nlh000sh8vnk9ewij12","tag_id":"ck0uh6npa0044h8vnu0m6zx1o","_id":"ck0uh6ns8009jh8vnwcntpjgq"},{"post_id":"ck0uh6nlj000th8vnf1o8isuf","tag_id":"ck0uh6npa0046h8vnkrmtvp7i","_id":"ck0uh6ns8009mh8vnx1j7cot5"},{"post_id":"ck0uh6nlj000th8vnf1o8isuf","tag_id":"ck0uh6npb0049h8vntuxkvpd0","_id":"ck0uh6ns8009oh8vn2bus3aiy"},{"post_id":"ck0uh6nlk000uh8vn8v7waa0i","tag_id":"ck0uh6npa0046h8vnkrmtvp7i","_id":"ck0uh6ns9009rh8vnyarxw1t3"},{"post_id":"ck0uh6nlk000uh8vn8v7waa0i","tag_id":"ck0uh6nox0031h8vnpsz4loms","_id":"ck0uh6ns9009th8vnnchjhwj3"},{"post_id":"ck0uh6nlk000uh8vn8v7waa0i","tag_id":"ck0uh6npd004fh8vn2pu344q0","_id":"ck0uh6nsa009wh8vnzmrw5p48"},{"post_id":"ck0uh6nlk000vh8vn4ildy84z","tag_id":"ck0uh6npd004hh8vn7nx7vo8y","_id":"ck0uh6nsa009yh8vnslnmrdpw"},{"post_id":"ck0uh6nll000wh8vnquj6g7s4","tag_id":"ck0uh6npe004jh8vnirc4ktxv","_id":"ck0uh6nsa00a1h8vnl6rkmb7c"},{"post_id":"ck0uh6nll000xh8vnce7verf5","tag_id":"ck0uh6npe004lh8vn03jv41j1","_id":"ck0uh6nsa00a3h8vnbf9g77a0"},{"post_id":"ck0uh6nll000xh8vnce7verf5","tag_id":"ck0uh6nox0031h8vnpsz4loms","_id":"ck0uh6nsb00a6h8vni1rau6tx"},{"post_id":"ck0uh6nlm000yh8vnqvc6hj01","tag_id":"ck0uh6npf004ph8vnetu0lpud","_id":"ck0uh6nsb00a8h8vnfej8sn89"},{"post_id":"ck0uh6nlm000zh8vnjvrz8sxm","tag_id":"ck0uh6nox0031h8vnpsz4loms","_id":"ck0uh6nsb00aah8vnu8wcosuu"},{"post_id":"ck0uh6nlm000zh8vnjvrz8sxm","tag_id":"ck0uh6nph004th8vngz3kzeah","_id":"ck0uh6nsb00abh8vnfgafk5cg"},{"post_id":"ck0uh6nlm0010h8vn822ze6s4","tag_id":"ck0uh6nph004vh8vn03csk3h3","_id":"ck0uh6nsb00adh8vn9azvr8fm"},{"post_id":"ck0uh6nln0011h8vny6mmc66z","tag_id":"ck0uh6npi004yh8vn52mda4ai","_id":"ck0uh6nsc00aeh8vnkcjg12qd"},{"post_id":"ck0uh6nln0012h8vndydzbugr","tag_id":"ck0uh6nox0031h8vnpsz4loms","_id":"ck0uh6nsc00agh8vn5xkx225p"},{"post_id":"ck0uh6nln0012h8vndydzbugr","tag_id":"ck0uh6npj0052h8vnz5dp3l2g","_id":"ck0uh6nsc00ahh8vnw0hu001t"},{"post_id":"ck0uh6nlo0013h8vnlzl3v5iu","tag_id":"ck0uh6npk0054h8vngegse0xz","_id":"ck0uh6nsc00aih8vnozu7aa84"},{"post_id":"ck0uh6nlo0014h8vn7z0u31dd","tag_id":"ck0uh6npe004lh8vn03jv41j1","_id":"ck0uh6nsc00akh8vnojrm6x7q"},{"post_id":"ck0uh6nlo0015h8vnnf3vvbpj","tag_id":"ck0uh6npl0058h8vndplbegqa","_id":"ck0uh6nsc00alh8vnrp3kgafl"},{"post_id":"ck0uh6nlp0016h8vndsasio9t","tag_id":"ck0uh6nox0031h8vnpsz4loms","_id":"ck0uh6nsd00anh8vn2tm5nl4h"},{"post_id":"ck0uh6nlp0016h8vndsasio9t","tag_id":"ck0uh6npm005ch8vnp1jqdkc7","_id":"ck0uh6nsd00aoh8vn0znclrp0"},{"post_id":"ck0uh6nlp0017h8vni8zki75q","tag_id":"ck0uh6npn005eh8vn34muzouq","_id":"ck0uh6nsd00aqh8vnhw3u0ury"},{"post_id":"ck0uh6nlp0017h8vni8zki75q","tag_id":"ck0uh6npe004jh8vnirc4ktxv","_id":"ck0uh6nsd00arh8vna2uc5j7s"},{"post_id":"ck0uh6nlq0019h8vnupeq2qvi","tag_id":"ck0uh6nph004vh8vn03csk3h3","_id":"ck0uh6nse00ath8vnlvz8komv"},{"post_id":"ck0uh6nlq0019h8vnupeq2qvi","tag_id":"ck0uh6np2003fh8vn0z3cgwa9","_id":"ck0uh6nse00auh8vnydneuxmy"},{"post_id":"ck0uh6nlq001ah8vnh0czjkw2","tag_id":"ck0uh6npp005mh8vnkp2dli2g","_id":"ck0uh6nse00awh8vnqnkttft7"},{"post_id":"ck0uh6nlq001ah8vnh0czjkw2","tag_id":"ck0uh6npq005oh8vnjqb7xn6x","_id":"ck0uh6nse00axh8vnejavwzyb"},{"post_id":"ck0uh6nlr001bh8vn19lb8qlm","tag_id":"ck0uh6nop002jh8vn80hox5gn","_id":"ck0uh6nsf00azh8vnx6e4nygc"},{"post_id":"ck0uh6nlr001bh8vn19lb8qlm","tag_id":"ck0uh6nph004vh8vn03csk3h3","_id":"ck0uh6nsf00b0h8vn6y0oyzel"},{"post_id":"ck0uh6nlr001ch8vn3byo5f22","tag_id":"ck0uh6np2003fh8vn0z3cgwa9","_id":"ck0uh6nsf00b2h8vn465foap0"},{"post_id":"ck0uh6nls001dh8vnigphx4z6","tag_id":"ck0uh6nps005wh8vnxgzk6ixt","_id":"ck0uh6nsf00b3h8vnhdpvzb2a"},{"post_id":"ck0uh6nls001dh8vnigphx4z6","tag_id":"ck0uh6npt005yh8vn0q58ybys","_id":"ck0uh6nsf00b5h8vn3qywtcav"},{"post_id":"ck0uh6nls001eh8vnxfsa1bsb","tag_id":"ck0uh6npt0061h8vno3ts6g29","_id":"ck0uh6nsf00b6h8vnngshysi6"},{"post_id":"ck0uh6nls001fh8vn6fbz8mq5","tag_id":"ck0uh6npt0063h8vnk306d2ba","_id":"ck0uh6nsg00b7h8vnxxsjdp7v"},{"post_id":"ck0uh6nlt001gh8vnxwdqzdy4","tag_id":"ck0uh6npu0065h8vno0cjit03","_id":"ck0uh6nsg00b9h8vnpd317gnc"},{"post_id":"ck0uh6nlt001hh8vng8vo9a9h","tag_id":"ck0uh6np2003fh8vn0z3cgwa9","_id":"ck0uh6nsh00bah8vn4lt5t5ix"},{"post_id":"ck0uh6nlu001ih8vncjvz07f2","tag_id":"ck0uh6nph004vh8vn03csk3h3","_id":"ck0uh6nsh00bch8vnrvh57haw"},{"post_id":"ck0uh6nlu001ih8vncjvz07f2","tag_id":"ck0uh6nox0031h8vnpsz4loms","_id":"ck0uh6nsh00bdh8vneyv2rnjw"},{"post_id":"ck0uh6nlu001jh8vncplguoa8","tag_id":"ck0uh6npw006dh8vnk015qvow","_id":"ck0uh6nsi00bfh8vnto9fk92z"},{"post_id":"ck0uh6nlv001kh8vngvc08ozp","tag_id":"ck0uh6np2003fh8vn0z3cgwa9","_id":"ck0uh6nsi00bgh8vnuhkf4itr"},{"post_id":"ck0uh6nlv001lh8vngx9c3wn6","tag_id":"ck0uh6nph004vh8vn03csk3h3","_id":"ck0uh6nsi00bih8vnhew3gb6f"},{"post_id":"ck0uh6nlv001lh8vngx9c3wn6","tag_id":"ck0uh6nox0031h8vnpsz4loms","_id":"ck0uh6nsi00bjh8vnks5m0uqp"},{"post_id":"ck0uh6nlw001mh8vnhpnbkdq1","tag_id":"ck0uh6npk0054h8vngegse0xz","_id":"ck0uh6nsj00blh8vnyk64aep0"},{"post_id":"ck0uh6nlw001nh8vn780e30nv","tag_id":"ck0uh6npz006nh8vnczw6l1uy","_id":"ck0uh6nsj00bmh8vnu5ock4fb"},{"post_id":"ck0uh6nlw001oh8vn1ahhv3rh","tag_id":"ck0uh6nq0006ph8vn94m7d4zx","_id":"ck0uh6nsj00boh8vno0l3wihs"},{"post_id":"ck0uh6nlw001oh8vn1ahhv3rh","tag_id":"ck0uh6nq1006rh8vn2a8dbhq9","_id":"ck0uh6nsj00bph8vnn2a1jbcq"},{"post_id":"ck0uh6nlw001oh8vn1ahhv3rh","tag_id":"ck0uh6np8003wh8vnvucx7ywm","_id":"ck0uh6nsk00brh8vn6ex7figr"},{"post_id":"ck0uh6nlx001ph8vnq4ox7lng","tag_id":"ck0uh6nq3006vh8vnzhtwsc8e","_id":"ck0uh6nsk00bsh8vnwsnhkdkv"},{"post_id":"ck0uh6nlx001ph8vnq4ox7lng","tag_id":"ck0uh6np8003wh8vnvucx7ywm","_id":"ck0uh6nsk00buh8vnv8dcp6g3"},{"post_id":"ck0uh6nlx001qh8vnvxjruxxw","tag_id":"ck0uh6nox0031h8vnpsz4loms","_id":"ck0uh6nsk00bvh8vng6mdegla"},{"post_id":"ck0uh6nly001rh8vnvsvtk9tb","tag_id":"ck0uh6nov002xh8vngcnsrb5j","_id":"ck0uh6nsl00bxh8vn8k5f8n98"},{"post_id":"ck0uh6nly001sh8vn1yrurqu8","tag_id":"ck0uh6nq40070h8vn97uzmev8","_id":"ck0uh6nsl00byh8vn6vqqp9kd"},{"post_id":"ck0uh6nlz001th8vn8wnkje12","tag_id":"ck0uh6nq40071h8vnvnovg090","_id":"ck0uh6nsl00c0h8vnb6g4mqix"},{"post_id":"ck0uh6nlz001uh8vnq9yzlica","tag_id":"ck0uh6noz0037h8vnqa7onv41","_id":"ck0uh6nsl00c1h8vn1yqfc64l"},{"post_id":"ck0uh6nm0001vh8vnsa40qt86","tag_id":"ck0uh6nq50073h8vno4sch20d","_id":"ck0uh6nsm00c3h8vnmhb54vxn"},{"post_id":"ck0uh6nm0001xh8vn5j8spxq1","tag_id":"ck0uh6nq50074h8vnm43afhd5","_id":"ck0uh6nsm00c4h8vne7nr2hah"},{"post_id":"ck0uh6nm1001yh8vnlquwag6f","tag_id":"ck0uh6nq50075h8vn4h0mbals","_id":"ck0uh6nsm00c6h8vnieccxddw"},{"post_id":"ck0uh6nm1001zh8vneopgz0k5","tag_id":"ck0uh6np8003wh8vnvucx7ywm","_id":"ck0uh6nsm00c7h8vnk8kljk2r"},{"post_id":"ck0uh6nm20020h8vnws60suay","tag_id":"ck0uh6nq60077h8vnys4keg02","_id":"ck0uh6nsm00c9h8vnvdb6bvew"},{"post_id":"ck0uh6nm20021h8vnkgk9jnhm","tag_id":"ck0uh6nq60078h8vno9p5umif","_id":"ck0uh6nsn00cah8vnqimyrplo"},{"post_id":"ck0uh6nm30022h8vniui90ik2","tag_id":"ck0uh6nq60079h8vn7ji1jyue","_id":"ck0uh6nsn00cch8vnfp4fj097"},{"post_id":"ck0uh6nm30023h8vnwpth2rln","tag_id":"ck0uh6nq6007ah8vnfs1d7ckj","_id":"ck0uh6nsn00cdh8vnonq0cxe7"},{"post_id":"ck0uh6nm30024h8vntym945uw","tag_id":"ck0uh6nph004vh8vn03csk3h3","_id":"ck0uh6nsn00cfh8vnsjnns8d4"},{"post_id":"ck0uh6nm40025h8vnao2d17ha","tag_id":"ck0uh6nq7007ch8vnbita7s5c","_id":"ck0uh6nsn00cgh8vnubnqhnhs"},{"post_id":"ck0uh6nm40026h8vnwg3ip6v2","tag_id":"ck0uh6nq7007dh8vnmdmqempp","_id":"ck0uh6nso00chh8vnzany5dzp"},{"post_id":"ck0uh6nm8002dh8vnxpe9i5ks","tag_id":"ck0uh6nq7007eh8vnb4i513eh","_id":"ck0uh6nso00cih8vnvceun1ya"},{"post_id":"ck0uh6nm9002fh8vnvsx185iz","tag_id":"ck0uh6nq7007fh8vnsyoz2vui","_id":"ck0uh6nso00cjh8vnepy157nt"},{"post_id":"ck0uh6nma002gh8vnq6fmcb3r","tag_id":"ck0uh6nq7007gh8vnwe5a3kv5","_id":"ck0uh6nso00ckh8vn10cttxp8"},{"post_id":"ck0uh6nma002hh8vncvg47csd","tag_id":"ck0uh6npe004lh8vn03jv41j1","_id":"ck0uh6nso00clh8vn7yn86ss2"},{"post_id":"ck0uh6nrw007lh8vnrq8wr3t6","tag_id":"ck0uh6nsw00cmh8vngpqu3nep","_id":"ck0uh6ntj00fch8vn92sfeu06"},{"post_id":"ck0uh6nrx007oh8vnoyacct5q","tag_id":"ck0uh6nsx00cqh8vnu1k68w1m","_id":"ck0uh6ntj00fdh8vn3sufph8e"},{"post_id":"ck0uh6nry007rh8vn9cnrcdzp","tag_id":"ck0uh6nsx00cth8vn8dalbg7l","_id":"ck0uh6ntk00feh8vnbf7od4nt"},{"post_id":"ck0uh6nry007rh8vn9cnrcdzp","tag_id":"ck0uh6nsy00cwh8vn7apbyzhp","_id":"ck0uh6ntk00ffh8vni4v9xhkb"}],"Tag":[{"name":"思维","_id":"ck0uh6nop002jh8vn80hox5gn"},{"name":"贪心","_id":"ck0uh6noq002lh8vnxi3itw8j"},{"name":"Covariance","_id":"ck0uh6not002rh8vnjd14wo0s"},{"name":"前缀和","_id":"ck0uh6nou002th8vnoyb6auk4"},{"name":"后缀和","_id":"ck0uh6nou002vh8vnjgh0q3qs"},{"name":"C语言","_id":"ck0uh6nov002xh8vngcnsrb5j"},{"name":"图论","_id":"ck0uh6now002zh8vn11wypnxx"},{"name":"DFS","_id":"ck0uh6nox0031h8vnpsz4loms"},{"name":"HDU","_id":"ck0uh6nox0033h8vnlcy9ijef"},{"name":"线切割平面","_id":"ck0uh6noy0035h8vnbbdkwt7b"},{"name":"math","_id":"ck0uh6noz0037h8vnqa7onv41"},{"name":"状态压缩DP","_id":"ck0uh6np1003dh8vn3io9nq74"},{"name":"BFS","_id":"ck0uh6np2003fh8vn0z3cgwa9"},{"name":"CMake","_id":"ck0uh6np3003ih8vnnkekop4a"},{"name":"逆向思维","_id":"ck0uh6np7003sh8vn46fd3rpn"},{"name":"PCA","_id":"ck0uh6np7003uh8vn8i0i4mhk"},{"name":"总结","_id":"ck0uh6np8003wh8vnvucx7ywm"},{"name":"Liner algebra","_id":"ck0uh6np8003yh8vntfb2fpvj"},{"name":"DP","_id":"ck0uh6np90040h8vnvcv8khm3"},{"name":"01背包","_id":"ck0uh6np90042h8vnow2vz813"},{"name":"Lover","_id":"ck0uh6npa0044h8vnu0m6zx1o"},{"name":"POJ","_id":"ck0uh6npa0046h8vnkrmtvp7i"},{"name":"线段树","_id":"ck0uh6npb0049h8vntuxkvpd0"},{"name":"迷宫问题","_id":"ck0uh6npd004fh8vn2pu344q0"},{"name":"Game","_id":"ck0uh6npd004hh8vn7nx7vo8y"},{"name":"STL","_id":"ck0uh6npe004jh8vnirc4ktxv"},{"name":"欧拉路","_id":"ck0uh6npe004lh8vn03jv41j1"},{"name":"树","_id":"ck0uh6npf004ph8vnetu0lpud"},{"name":"拓扑排序","_id":"ck0uh6nph004th8vngz3kzeah"},{"name":"二叉树","_id":"ck0uh6nph004vh8vn03csk3h3"},{"name":"Random","_id":"ck0uh6npi004yh8vn52mda4ai"},{"name":"全局思维","_id":"ck0uh6npj0052h8vnz5dp3l2g"},{"name":"暴力枚举","_id":"ck0uh6npk0054h8vngegse0xz"},{"name":"迭代加深","_id":"ck0uh6npl0058h8vndplbegqa"},{"name":"全局思想","_id":"ck0uh6npm005ch8vnp1jqdkc7"},{"name":"stack","_id":"ck0uh6npn005eh8vn34muzouq"},{"name":"链表","_id":"ck0uh6npp005mh8vnkp2dli2g"},{"name":"栈","_id":"ck0uh6npq005oh8vnjqb7xn6x"},{"name":"搜索","_id":"ck0uh6nps005wh8vnxgzk6ixt"},{"name":"仿射变换","_id":"ck0uh6npt005yh8vn0q58ybys"},{"name":"离散化","_id":"ck0uh6npt0061h8vno3ts6g29"},{"name":"Stack","_id":"ck0uh6npt0063h8vnk306d2ba"},{"name":"IDA*","_id":"ck0uh6npu0065h8vno0cjit03"},{"name":"四分树","_id":"ck0uh6npw006dh8vnk015qvow"},{"name":"Binary Tree","_id":"ck0uh6npz006nh8vnczw6l1uy"},{"name":"mathjax","_id":"ck0uh6nq0006ph8vn94m7d4zx"},{"name":"hexo插入数学公式","_id":"ck0uh6nq1006rh8vn2a8dbhq9"},{"name":"生活","_id":"ck0uh6nq3006vh8vnzhtwsc8e"},{"name":"排列","_id":"ck0uh6nq40070h8vn97uzmev8"},{"name":"C++","_id":"ck0uh6nq40071h8vnvnovg090"},{"name":"线段树单点更新","_id":"ck0uh6nq50073h8vno4sch20d"},{"name":"字符串","_id":"ck0uh6nq50074h8vnm43afhd5"},{"name":"python","_id":"ck0uh6nq50075h8vn4h0mbals"},{"name":"vultr服务器搭建","_id":"ck0uh6nq60077h8vnys4keg02"},{"name":"rasterization","_id":"ck0uh6nq60078h8vno9p5umif"},{"name":"Rasterization","_id":"ck0uh6nq60079h8vn7ji1jyue"},{"name":"线段树区间更新","_id":"ck0uh6nq6007ah8vnfs1d7ckj"},{"name":"状态转移","_id":"ck0uh6nq7007ch8vnbita7s5c"},{"name":"Binary Search","_id":"ck0uh6nq7007dh8vnmdmqempp"},{"name":"Hash","_id":"ck0uh6nq7007eh8vnb4i513eh"},{"name":"Link Library","_id":"ck0uh6nq7007fh8vnsyoz2vui"},{"name":"Math","_id":"ck0uh6nq7007gh8vnwe5a3kv5"},{"name":"Kalman filter","_id":"ck0uh6nsw00cmh8vngpqu3nep"},{"name":"迭代加深搜索","_id":"ck0uh6nsx00cqh8vnu1k68w1m"},{"name":"建图","_id":"ck0uh6nsx00cth8vn8dalbg7l"},{"name":"双向BFS","_id":"ck0uh6nsy00cwh8vn7apbyzhp"}]}}