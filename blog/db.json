{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/user.jpg","path":"images/user.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/Picture1.png","path":"images/Picture1.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/user2.png","path":"images/user2.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1521962313000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1521962313000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1521962313000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1521962313000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1521962313000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1521962313000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1521962313000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1521962313000},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1521962313000},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1521962313000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1521962313000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1521962313000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1521962313000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1521962313000},{"_id":"themes/next/_config.yml","hash":"e3f57d058291926908c918644e9cb938cc073373","modified":1542111490881},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1521962313000},{"_id":"source/_posts/CodeForces-478C.md","hash":"6a781a3ab3a4d3d25c72a2ce4b3b4b3da8d9f03f","modified":1544792870770},{"_id":"source/_posts/Codeforces-498Div3-C.md","hash":"af8936b71d10d9b2d9358bf4185a6b9d35c2be42","modified":1544793034542},{"_id":"source/about/index.md","hash":"3ebd04672d0a84fa7380f3ae3a7aea48f08c07cc","modified":1523175241342},{"_id":"source/_posts/Graph-Theory-The-shortest-path.md","hash":"a710250c65289ed88b2a847f870a3404c5cade7a","modified":1542110880226},{"_id":"source/_posts/CodeForces-569A.md","hash":"1aaa85c31c8254d4a64783f6d524ae0918a3cc1e","modified":1544792858278},{"_id":"source/_posts/HDU1016-Prime-Ring-Problem-DFS.md","hash":"0dd3fc302bfe91d48132742bdc6d31b5ea92bdbb","modified":1544792919122},{"_id":"source/_posts/HDU4856-Tunnels.md","hash":"a4abcd540d3d9b905fa0e6015506c644ba089689","modified":1544794041540},{"_id":"source/_posts/HDU2050.md","hash":"d1ae6e55d07f552816ead6dcd431de8382f66472","modified":1544794139580},{"_id":"source/_posts/Linear algebra-Dot product.md","hash":"736c612e327cb0fcb17e805762db432b312f63c0","modified":1542110706991},{"_id":"source/_posts/HDU5092.md","hash":"51ba3808c7917621d95edbbd6090a5a1af11a383","modified":1528201686754},{"_id":"source/_posts/C语言编译连接过程以及-h和-c文件解析.md","hash":"88e08a534c745acc737dfef716c07d10e4c32594","modified":1543795071208},{"_id":"source/_posts/POJ1970-The-Game-DFS.md","hash":"a72ff45276828e5617281cf99e6df542d4e4e143","modified":1544792894958},{"_id":"source/_posts/POJ2481.md","hash":"262b23a2f799eb67a86e975798f3d0e7673ef48a","modified":1544794099052},{"_id":"source/_posts/STL-cmp.md","hash":"3060ebf45e0d6b1bc25edb05cdc244d36457e5a9","modified":1542110561143},{"_id":"source/_posts/Super-Mario.md","hash":"e3c85ba8c83d0c7842c505c8dd1e72234ba9cfa6","modified":1543769615337},{"_id":"source/_posts/Uva10129-Play-on-Words.md","hash":"1174c4cdd8a6564cbf97ae51fa3eb5559b8a639e","modified":1544792582438},{"_id":"source/_posts/Uva10305-Ordering-Tasks.md","hash":"f9964d663d3da713d2d2e362dc4fdc6ef6fb361d","modified":1544792611046},{"_id":"source/_posts/Uva10410-Tree-Reconstruction.md","hash":"8d090a8fe887953435da061567e93905fa1f0c9f","modified":1544792451918},{"_id":"source/_posts/My-little-angel.md","hash":"89c0b7592c49b6ec6d048dc6b68e37a5bf098e64","modified":1539664487071},{"_id":"source/_posts/Uva1103-Ancient-Messages.md","hash":"f85df84f9bf808a467b2282090f74968ce2da606","modified":1544792660882},{"_id":"source/_posts/Uva11059-Maximum-Product.md","hash":"c750cd69625cd412619c8d4ff0693bf115d65378","modified":1545319169118},{"_id":"source/_posts/Uva11853-Painball.md","hash":"f1e4033b7d17c4d32788f27ebe57ed6331bda331","modified":1544792487874},{"_id":"source/_posts/Uva12096-The-SetStack-Computer-STL.md","hash":"868be0142fa6922aeee88d8d2c29a900967a9088","modified":1544793007354},{"_id":"source/_posts/Uva12118-Inspetor-s-Dilemma.md","hash":"653934f3dd07d50961188298a4ba3543bcca6c7f","modified":1545046406373},{"_id":"source/_posts/Uva12166-Equilibrium-Mobile.md","hash":"cf630a0fa73439df137928c3fdd52aa47ab05968","modified":1544792351578},{"_id":"source/_posts/Nowcoder-Fourth-G.md","hash":"d4f9535a1d3ccc8124f6dda7b90c2e5df37c65d2","modified":1544793707179},{"_id":"source/_posts/Uva127-Accordian-Patience.md","hash":"88b0cd5ce562c1bb123a0bc266bc6a11d7ac538a","modified":1544792340118},{"_id":"source/_posts/Uva1599-Ideal-Path.md","hash":"0ebe17e6ef301600d805cc866d15246a10621983","modified":1544792504590},{"_id":"source/_posts/Uva1600-Patrol-Robot.md","hash":"376c1fbd6ebfdafca4901158db791e4b7b9dcef6","modified":1544792358202},{"_id":"source/_posts/Uva221-Urban-Elevations.md","hash":"ff68c91da2624b9534ef241fbb40d47f6e9ee941","modified":1544792535566},{"_id":"source/_posts/Uva548-二叉树构建-DFS.md","hash":"5337aad4dca9090f7c2ef3994a986893cd26e822","modified":1544792745202},{"_id":"source/_posts/Uva673-Parentheses-Balance.md","hash":"f6a2e3d8d7906264fbbf5c093b750eeae9a0e8ad","modified":1544792315362},{"_id":"source/_posts/Nowcoder-Third-A.md","hash":"db51e3cdeffdbfb30ee675bb5f09afca7bbe2ed6","modified":1544793094266},{"_id":"source/_posts/Uva806-Spatial-Structures.md","hash":"10c5f54f2ad0df95b66db6352f89fb13c90c3e3e","modified":1544792345498},{"_id":"source/_posts/Uva816-Abbott-s-Revenge-BFS.md","hash":"7bfe81db96b6051839adaf7de8c64903cad3398b","modified":1544792642610},{"_id":"source/_posts/Uva839-二叉树的递归处理.md","hash":"b10d989adf2c7a9e721f06592063506aa878ff81","modified":1544792699866},{"_id":"source/_posts/extern-外部变量.md","hash":"c663618ea90af11abf702284cbad28cd0b6592db","modified":1543795172435},{"_id":"source/_posts/hexo-mathjax.md","hash":"091cbe4ac1063cef0b1813669a3222b238cbc777","modified":1533829630373},{"_id":"source/_posts/new start point.md","hash":"297ab49aab35d308f618255fd55de969998f0a95","modified":1533830493268},{"_id":"source/_posts/new-keyword.md","hash":"f54366fe092110fb58ac538ac27cb465a53b6d1e","modified":1543893414415},{"_id":"source/_posts/next-permutation解析.md","hash":"574c96086ee75d74b5a1cc398cabf8c2e0d376b5","modified":1545103326536},{"_id":"source/_posts/pick-numbers.md","hash":"4e9417dbe14ec0c7f6e0d91a5767047c179f0d15","modified":1544792950690},{"_id":"source/_posts/quick-matrix.md","hash":"619f7b89a7f5d41ea61c0d11a70fc202505b6150","modified":1533829859904},{"_id":"source/_posts/Uva122-二叉树构建与层次遍历.md","hash":"d5fa119dff6fcf15641eaba5454698430a6bdc3a","modified":1544792788782},{"_id":"source/_posts/Uva725-Division.md","hash":"fb0f30ea7f4028426a668fc0ba264dca9079162f","modified":1545048609651},{"_id":"source/_posts/segtree-template.md","hash":"eb14472c24bb1f08a46b2bb87aea15de871c18f7","modified":1542110792426},{"_id":"source/_posts/segtree-intval.md","hash":"b96e40866232bed58753f6efbd2264c7050d6571","modified":1542110805834},{"_id":"source/_posts/sscanf-sprintf.md","hash":"734f0ab664e611e68955e0056ba3f62382e49f3a","modified":1542110526527},{"_id":"source/_posts/stringstream.md","hash":"9dfc5658e8cc3e11cae3efa169ad2c267b85fba5","modified":1542110536803},{"_id":"source/_posts/vultr.md","hash":"4147407957171b4750332d30093075efdacf53f1","modified":1533829685746},{"_id":"source/_posts/八皇后问题.md","hash":"04de94304c21a30ce1222047d7c064de24773619","modified":1545321601272},{"_id":"source/_posts/二叉树中序和后序遍历-层序和先序遍历.md","hash":"cea94fa7201a21b2d74955160661e64a3126da59","modified":1542110776722},{"_id":"source/_posts/欧拉回路.md","hash":"11152079e35695c49d8a54eb8d0c131ab94557e4","modified":1542110889318},{"_id":"source/_posts/循环小数化为分数的方法.md","hash":"b487d3e539fcb43f11b5cd18e08effe361db3782","modified":1544372815672},{"_id":"source/_posts/Uva10562-Undraw the trees.md","hash":"5677887569046de706dc10f736ffc756b4e8e5dd","modified":1544792561054},{"_id":"source/_posts/tab-to-spaces.md","hash":"55dd2bdfca8c57e0131d4ed11092c4168e8e5cb2","modified":1533829950793},{"_id":"source/commonweal/index.md","hash":"423894f3e9d10b9bbfae31c42cb31f5c3cec81a2","modified":1523179153090},{"_id":"source/categories/index.md","hash":"76f4447e0e8f274e0255fa038aa97656425eae07","modified":1523175315982},{"_id":"source/schedule/index.md","hash":"73d7ca6fb2a4d82bc89a489befdb0b066599178b","modified":1523179037727},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1521962313000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1521962313000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1521962313000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1521962313000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1521962313000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1521962313000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1521962313000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1521962313000},{"_id":"source/sitemap/index.md","hash":"f18cfe801086a113dff7f6862d85c7e2d6727e46","modified":1523179132866},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1521962313000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1521962313000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1521962313000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1521962313000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1521962313000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1521962313000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1521962313000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1521962313000},{"_id":"source/tags/index.md","hash":"b23dc9c86fb565af015f51a741bf0c9f890a87fc","modified":1523121942983},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1521962313000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1521962313000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1521962313000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1521962313000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1521962313000},{"_id":"source/links/index.md","hash":"c702b6d1bde8020ae93198b29f1833ef39f549bf","modified":1539401235022},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1521962313000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1521962313000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1521962313000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1521962313000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1521962313000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1521962313000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1521962313000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1521962313000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"b1570210fd580f456685ffcb1c6452c69e1463bb","modified":1539398977924},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1521962313000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1521962313000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1521962313000},{"_id":"source/_posts/Graph-Theory-The-shortest-path/gra.png","hash":"c2a7946e9e78ad6264a4a6d6b581d06160604bfe","modified":1536325837191},{"_id":"source/_posts/Graph-Theory-The-shortest-path/path.png","hash":"b20559aca988d5aaefc0931e513b4fc808c5be21","modified":1536326076832},{"_id":"source/_posts/HDU2050/res.gif","hash":"163a87523482ba25a73787e59a0b13ecfb736053","modified":1523247099713},{"_id":"source/_posts/HDU2050/line.jpg","hash":"0b614039e05df58510f6979466289f7ac7190b5f","modified":1523244954809},{"_id":"source/_posts/HDU1016-Prime-Ring-Problem-DFS/dfs.png","hash":"bfaf09def97b165527bb22bad63dfe38109bdd64","modified":1534088537000},{"_id":"source/_posts/My-little-angel/moon1.jpg","hash":"c57a51bb30e1ec204f4fb3c01783b8f2e87a1bbd","modified":1528606062541},{"_id":"source/_posts/My-little-angel/together1.jpg","hash":"1783fb05e6a210c1c2de23c413b9fb466c44c03a","modified":1528606083038},{"_id":"source/_posts/POJ1970-The-Game-DFS/Renju.png","hash":"e478edf969416be8f2fda647b3336271dbb13b6a","modified":1534247440000},{"_id":"source/_posts/Super-Mario/SuperMario.png","hash":"b063b297ce5044d523ae0c3d2ea4c408cefe5848","modified":1543768077000},{"_id":"source/_posts/Uva1103-Ancient-Messages/1.png","hash":"49e92896091c97e432582ca738cdd415dfbaef3a","modified":1540736296000},{"_id":"source/_posts/Uva10562-Undraw the trees/tree.png","hash":"51cf513829497a8d98dc1e0f7ade6d8dc407adfd","modified":1542066007000},{"_id":"source/_posts/Uva12166-Equilibrium-Mobile/balance.png","hash":"f4529422d6cf9010363875a87318e6ec8cb45083","modified":1543891644000},{"_id":"source/_posts/Uva221-Urban-Elevations/building.png","hash":"5be5290e6f5974f919f3525d5d85f215d2b2dcd9","modified":1542161407000},{"_id":"source/_posts/Uva1103-Ancient-Messages/2.png","hash":"66e6e3e8aa6456456ff9794274edf1dacb72219c","modified":1540736317000},{"_id":"source/_posts/Uva806-Spatial-Structures/2.png","hash":"ad1edffc72af5cec0649f0b5e93a48a19d9d9acf","modified":1543927991000},{"_id":"source/_posts/Uva839-二叉树的递归处理/tree.png","hash":"ccee240e1b924dd7cca49828c69e0cf78742a7e3","modified":1537628562000},{"_id":"source/_posts/tab-to-spaces/space.png","hash":"e1202e8eb89c5c09f5e3eb1e4a72be772c4790b6","modified":1528775921000},{"_id":"source/_posts/Uva806-Spatial-Structures/1.png","hash":"3374b72597b7048bb95a6af65ba72f10699f86a8","modified":1543927968000},{"_id":"source/_posts/vultr/p1.png","hash":"595bda0f3e72f314db02d09c378298daf0840657","modified":1523619807000},{"_id":"source/_posts/tab-to-spaces/tab.png","hash":"30312fc2dabd01c3540693ea57af6ea0a11c9fe2","modified":1528775840000},{"_id":"source/_posts/vultr/p2.png","hash":"c797e71775de0c707e10ec8f765a154b37f27197","modified":1523620056000},{"_id":"source/_posts/vultr/p3.png","hash":"67dbd2c65a2c47e6ae09f22051629da1a6c5fdd1","modified":1523620317000},{"_id":"source/_posts/vultr/p7.png","hash":"da388ae09f2db520f71e2348bf8a4883adb2666a","modified":1523623834000},{"_id":"source/_posts/vultr/p5.png","hash":"a7c6230253b7b12375ea294a6386473479cd7d26","modified":1523620767000},{"_id":"source/_posts/vultr/p8.png","hash":"2f5ce1e7aa48769570589a1a15948f1364753a67","modified":1523625511000},{"_id":"source/_posts/八皇后问题/queen.png","hash":"6ab1bc094e22cb34ec02d3dcd9f3c70efe233479","modified":1545319578000},{"_id":"source/_posts/循环小数化为分数的方法/wiki.png","hash":"1b5ec94305a72471f51e90d9bd1d71e44983a983","modified":1544371101000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1521962313000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1521962313000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1521962313000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1521962313000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1521962313000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1521962313000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1521962313000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1521962313000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1521962313000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1521962313000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1521962313000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1521962313000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1521962313000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1521962313000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1521962313000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1521962313000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments.swig","hash":"01f548c83370793dc91e905a12d693687b423a3e","modified":1539598782130},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1521962313000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1521962313000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1521962313000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1521962313000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1521962313000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1521962313000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1521962313000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1521962313000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1521962313000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1521962313000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1521962313000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1521962313000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1521962313000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1521962313000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1521962313000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1521962313000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1521962313000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1521962313000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1521962313000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1521962313000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1521962313000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1521962313000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1521962313000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1521962313000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1521962313000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1521962313000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1521962313000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1521962313000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1521962313000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1521962313000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1521962313000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1521962313000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1521962313000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1521962313000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1521962313000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1521962313000},{"_id":"source/_posts/My-little-angel/qxy1.jpg","hash":"29c0b85aa8bd9e32c8b239b78ae5f571e8375bd9","modified":1528599176588},{"_id":"source/_posts/Uva1103-Ancient-Messages/hier.png","hash":"9fc1f550a328d3a0f44bec5cd4655935db1fe9d0","modified":1540734611000},{"_id":"source/_posts/vultr/p9.png","hash":"7a099d33cc7ac17bc5e233121d135e46af0549b5","modified":1523625737000},{"_id":"source/_posts/vultr/p4.png","hash":"2ee46cf520c7d0585db4245c9586829f5173e680","modified":1523620362000},{"_id":"source/_posts/八皇后问题/diagonal.png","hash":"4963cc964d96d85438ef74780aafd357f2c198f4","modified":1545321148000},{"_id":"source/_posts/欧拉回路/Elur.png","hash":"ddc21e3cbc1ffa51606a7a521fad01c798d6ad47","modified":1541336292000},{"_id":"source/_posts/vultr/p6.png","hash":"47f4048062363375bb49809ceb19a67b5c659bf3","modified":1523621592467},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521962313000},{"_id":"themes/next/source/images/user.jpg","hash":"16b0e60948516954e1f9834e2d593c1deb0ffec4","modified":1490872143020},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1521962313000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1521962313000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1521962313000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1521962313000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1521962313000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1521962313000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1521962313000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1521962313000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1521962313000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1521962313000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1521962313000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1521962313000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1521962313000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1521962313000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1521962313000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1521962313000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1521962313000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1521962313000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1521962313000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1521962313000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1521962313000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1521962313000},{"_id":"themes/next/source/images/Picture1.png","hash":"94067d9a4021d24612d7dad597c915d07d0056c0","modified":1523193407424},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1521962313000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1521962313000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1521962313000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1521962313000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1521962313000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1521962313000},{"_id":"themes/next/source/images/user2.png","hash":"5a825078a61886e5bf8f40244b0c0d3acef801ee","modified":1523193518284},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1521962313000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1521962313000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1521962313000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1521962313000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1521962313000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1521962313000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1521962313000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ede111d4778342166088146723675305ef8f596b","modified":1539664618000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1521962313000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1521962313000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1521962313000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1521962313000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1521962313000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1521962313000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1521962313000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1521962313000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1521962313000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1521962313000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1521962313000},{"_id":"source/_posts/Linear algebra-Dot product/1.gif","hash":"a037ce119aca35cd7188ef70334ba9b06dc81d31","modified":1540452693000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1521962313000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1521962313000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1521962313000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1521962313000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1521962313000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1521962313000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1521962313000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1521962313000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1521962313000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1521962313000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1521962313000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1521962313000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1521962313000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1521962313000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1521962313000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1521962313000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1521962313000},{"_id":"source/_posts/Linear algebra-Dot product/3.gif","hash":"fc991a2c97761dcc611775a0ed1bd3bcf31c6435","modified":1540455837969},{"_id":"source/_posts/Linear algebra-Dot product/2.gif","hash":"bb118b39f653f5c4b63c9947450608f8049641d4","modified":1540455183360},{"_id":"public/about/index.html","hash":"45992c27efa6fd35d5b6d79c0c8d848df5140386","modified":1545321648558},{"_id":"public/commonweal/index.html","hash":"28b27545e35540ccd37981c40a3b8cbf0c7f3b06","modified":1545321648559},{"_id":"public/categories/index.html","hash":"04c641231e6a102f7fe597e8a0454ade5e199e35","modified":1545321648559},{"_id":"public/schedule/index.html","hash":"0a5f844ebccfc5ffbaf4f5e5ee35f8ac3f6332d8","modified":1545321648560},{"_id":"public/sitemap/index.html","hash":"6f2ac047614f82b17457549d34cf1d32a4ece23c","modified":1545321648560},{"_id":"public/tags/index.html","hash":"29af992b24ee980592220726106908f820e1b089","modified":1545321648560},{"_id":"public/links/index.html","hash":"508a8d98b47161fdc18ee5a46dde8a84c7d91358","modified":1545321648561},{"_id":"public/2018/12/18/next-permutation解析/index.html","hash":"7a5c77d2f978a281c228c844300f8f59afaf633d","modified":1545321648561},{"_id":"public/2018/12/17/Uva11059-Maximum-Product/index.html","hash":"992a2621d3b60809652c4b402eb7725b7d7a66b0","modified":1545321648561},{"_id":"public/2018/12/17/Uva725-Division/index.html","hash":"59eb19883e72fca73a36c7e0d4439fc49d3aeff0","modified":1545321648561},{"_id":"public/2018/12/17/Uva12118-Inspetor-s-Dilemma/index.html","hash":"4269cf083f1d1a9bc5efb291f8384f9bec665ee6","modified":1545321648561},{"_id":"public/2018/12/14/Uva10410-Tree-Reconstruction/index.html","hash":"bdc78b132b6b7dca1d0da6cf9a721172c0de925d","modified":1545321648561},{"_id":"public/2018/12/12/Uva127-Accordian-Patience/index.html","hash":"9fc93e3b78859428617a5a13dfac41baa7d2d5bb","modified":1545321648561},{"_id":"public/2018/12/09/循环小数化为分数的方法/index.html","hash":"62f8ef16cd493415e011ed695398dd75a48984e4","modified":1545321648561},{"_id":"public/2018/12/04/Uva806-Spatial-Structures/index.html","hash":"5b50558c6d2a51a46ab4f9ab8d52d300cbde52d4","modified":1545321648561},{"_id":"public/2018/12/04/Uva12166-Equilibrium-Mobile/index.html","hash":"6ccbdcbba1fbce808f0a1afdbab522863b3f7e15","modified":1545321648561},{"_id":"public/2018/12/03/Uva1600-Patrol-Robot/index.html","hash":"f19d7ef9f33788fa21c0b77d4d3d0ffe5ad33928","modified":1545321648561},{"_id":"public/2018/12/03/extern-外部变量/index.html","hash":"f102dfea56fc2bcd6e834f12cb038cc61bf7c42c","modified":1545321648561},{"_id":"public/2018/12/03/Super-Mario/index.html","hash":"4c2052fbcd2041c3548c60f9377b921eeada55cb","modified":1545321648562},{"_id":"public/2018/12/02/C语言编译连接过程以及-h和-c文件解析/index.html","hash":"5055726dcad546d7df934b0fc3f9a91152a31430","modified":1545321648562},{"_id":"public/2018/11/27/Uva673-Parentheses-Balance/index.html","hash":"704e5ce0f5ac21c6b7278390729992a374d25ff5","modified":1545321648562},{"_id":"public/2018/11/20/Uva11853-Painball/index.html","hash":"b8cfbace2a77dfb9117dffe66f1188219561159e","modified":1545321648562},{"_id":"public/2018/11/18/Uva1599-Ideal-Path/index.html","hash":"25f29298712879985f22181a49f72b595440609e","modified":1545321648562},{"_id":"public/2018/11/14/Uva221-Urban-Elevations/index.html","hash":"0649c2c9ea9c9c199d742dff5df3ace8e59e9cea","modified":1545321648562},{"_id":"public/2018/11/13/Uva10562-Undraw the trees/index.html","hash":"c13188250b6a988249d2d542539542d37891d4f1","modified":1545321648562},{"_id":"public/2018/11/12/Uva10129-Play-on-Words/index.html","hash":"f1dd0516271284c0fdb40579136b4517bbe4f359","modified":1545321648562},{"_id":"public/2018/11/04/欧拉回路/index.html","hash":"f6885c12844b6c5018f46c3c10d67c32d997050f","modified":1545321648562},{"_id":"public/2018/11/04/Uva10305-Ordering-Tasks/index.html","hash":"74417222f4b22fc2294c785451a24aabc06ffb47","modified":1545321648562},{"_id":"public/2018/11/01/Uva816-Abbott-s-Revenge-BFS/index.html","hash":"1a32af4e0167e323637be03aeac1d3e79ae1e37f","modified":1545321648562},{"_id":"public/2018/10/28/Uva1103-Ancient-Messages/index.html","hash":"3b5ec3ee80062697cc7224dba1521a41136b51b9","modified":1545321648562},{"_id":"public/2018/10/24/Linear algebra-Dot product/index.html","hash":"3aadc4b5167b065b62ba87de85ce82ac78503f7c","modified":1545321648562},{"_id":"public/2018/09/22/Uva839-二叉树的递归处理/index.html","hash":"531678edf0d0b7fc7ecfe0bdf06381593efc0d00","modified":1545321648562},{"_id":"public/2018/09/22/Uva548-二叉树构建-DFS/index.html","hash":"d0561955f84652afd92ddd25c1526d15e55723d4","modified":1545321648562},{"_id":"public/2018/09/22/二叉树中序和后序遍历-层序和先序遍历/index.html","hash":"c32d8b0750c0f82db7ca5740f8d57a0e4f7381fa","modified":1545321648562},{"_id":"public/2018/09/21/Uva122-二叉树构建与层次遍历/index.html","hash":"d9dc1534fb2e780f07ad704a72a8a947330daca7","modified":1545321648563},{"_id":"public/2018/09/20/new-keyword/index.html","hash":"64932a73563fbcf4fe9e12f48b7191606d69deb6","modified":1545321648563},{"_id":"public/2018/09/15/sscanf-sprintf/index.html","hash":"58a50bec0e3b4de3def2d8c97ddd0388fa9ff9de","modified":1545321648563},{"_id":"public/2018/09/07/Graph-Theory-The-shortest-path/index.html","hash":"976b04509dbc28bf3c3503d08dabaefed5c98f0a","modified":1545321648563},{"_id":"public/2018/08/28/CodeForces-569A/index.html","hash":"7d478f328e42e1aeed6becac7b00a8b1b402f5d8","modified":1545321648563},{"_id":"public/2018/08/28/CodeForces-478C/index.html","hash":"ae0fb5302f7c9ca3c55d3f8cbbfabaf358c13850","modified":1545321648563},{"_id":"public/2018/08/14/POJ1970-The-Game-DFS/index.html","hash":"a56d51db640586d66d62d799ba0e26f350a45a51","modified":1545321648563},{"_id":"public/2018/08/12/HDU1016-Prime-Ring-Problem-DFS/index.html","hash":"11e3aa6cbba43283741bd904fdcad129d7970bc2","modified":1545321648563},{"_id":"public/2018/08/11/pick-numbers/index.html","hash":"027973d2e143067277ecef4c75b32ab72066ec3d","modified":1545321648563},{"_id":"public/2018/08/09/Uva12096-The-SetStack-Computer-STL/index.html","hash":"6f4b6f3463ecfae8e93989eccc73a45ae3fb03de","modified":1545321648563},{"_id":"public/2018/08/08/stringstream/index.html","hash":"9d8ceae12dfcaf06de8feb2e9387e9a7da63a28d","modified":1545321648563},{"_id":"public/2018/08/07/STL-cmp/index.html","hash":"5bbed635825801fce0bba44d2b75a75c6f5f0c0d","modified":1545321648563},{"_id":"public/2018/07/31/Codeforces-498Div3-C/index.html","hash":"74b933e6e71a432bf340f4d99ad8e34c4f86d4de","modified":1545321648563},{"_id":"public/2018/07/29/Nowcoder-Fourth-G/index.html","hash":"1d49b1112f63f8f3bd5fa361bfab977bed8c9fe3","modified":1545321648563},{"_id":"public/2018/07/26/Nowcoder-Third-A/index.html","hash":"1b9a2961601082573d8bcf951e00933e77905b41","modified":1545321648563},{"_id":"public/2018/06/12/tab-to-spaces/index.html","hash":"5d7317e000f55585ae839e7337e969a952946ecb","modified":1545321648564},{"_id":"public/2018/06/10/My-little-angel/index.html","hash":"7e52bf8a83de636e42f17c003f534edc3a903848","modified":1545321648564},{"_id":"public/2018/06/05/HDU5092/index.html","hash":"bef1e3a9db89a7f631711063c3df11c2172adbe6","modified":1545321648564},{"_id":"public/2018/05/16/HDU4856-Tunnels/index.html","hash":"b95cf6dc83abf7d6c46c26dacafd7ce6d2d01574","modified":1545321648564},{"_id":"public/2018/05/14/quick-matrix/index.html","hash":"dcda30f2d7ab0dd9d53202d831cea916ecedceaa","modified":1545321648564},{"_id":"public/2018/05/08/segtree-intval/index.html","hash":"b6982cbac54abf7110a79abf0310bbc1d3805e18","modified":1545321648564},{"_id":"public/2018/05/06/segtree-template/index.html","hash":"4be551de5a2bfc86fdb46476512e4ae0d0334d4a","modified":1545321648564},{"_id":"public/2018/04/22/POJ2481/index.html","hash":"3a34a642502525a361361fc7df5682f218a5a24e","modified":1545321648564},{"_id":"public/2018/04/13/vultr/index.html","hash":"76226b56b7ccd275897d670e7eb3ef64e42ed368","modified":1545321648564},{"_id":"public/2018/04/09/hexo-mathjax/index.html","hash":"b6a68f526a53b5f7b1088135b8a37dab1291374d","modified":1545321648564},{"_id":"public/2018/04/09/HDU2050/index.html","hash":"6d414ebc4af12b77690bd60fb433f736517da482","modified":1545321648564},{"_id":"public/2018/04/08/new start point/index.html","hash":"a1ce2d05ee284a4b848dc6ff469f4f2a4b70665e","modified":1545321648564},{"_id":"public/archives/index.html","hash":"0739d52df406f1e4d32b0958ca605f749ef17084","modified":1545321648564},{"_id":"public/archives/page/2/index.html","hash":"b4a84d1ae179efc9487d5feb59966442c7463fe8","modified":1545321648564},{"_id":"public/archives/page/3/index.html","hash":"1f8b98f72c31068dab0ed9214848bd34d13d6420","modified":1545321648564},{"_id":"public/archives/page/4/index.html","hash":"ae5e5a3cbefd0b7d51e1d6633d227a24113d7ac5","modified":1545321648564},{"_id":"public/archives/page/5/index.html","hash":"5f4887472876c620085906cba67d997f70b5641b","modified":1545321648565},{"_id":"public/archives/page/6/index.html","hash":"df9b80844a91dd5fd8ca67e28864c198e5f1f11c","modified":1545321648565},{"_id":"public/archives/2018/index.html","hash":"71f5a94c4047cd765df47dfaa9fe127c5818f176","modified":1545321648565},{"_id":"public/archives/2018/page/2/index.html","hash":"ea18df12105ed0e15b37becf69e3c11fc83d76cd","modified":1545321648565},{"_id":"public/archives/2018/page/3/index.html","hash":"2c4b8178cde8f08b51ef53623c06b8254398ebf7","modified":1545321648565},{"_id":"public/archives/2018/page/4/index.html","hash":"09c4a8925dbb02b69f920fd549ef61bc5c940116","modified":1545321648565},{"_id":"public/archives/2018/page/5/index.html","hash":"102061b899cacb5ddd306ba3b0dad8191fbced14","modified":1545321648565},{"_id":"public/archives/2018/page/6/index.html","hash":"92e07648dc68bbc471b9d52094cd68648fe54edf","modified":1545321648565},{"_id":"public/archives/2018/04/index.html","hash":"2a2872fc64bcd626e85c94543dfbd697a8997ec9","modified":1545321648565},{"_id":"public/archives/2018/05/index.html","hash":"711fdaca7c91fa114b6650c71cef7a4985245e0a","modified":1545321648565},{"_id":"public/archives/2018/06/index.html","hash":"5ede7526b6b0c6b14487dd38c01ca73538a4e25c","modified":1545321648565},{"_id":"public/archives/2018/07/index.html","hash":"9fdfee3aad65eb50cb2341f5d82237a665ff9e28","modified":1545321648565},{"_id":"public/archives/2018/08/index.html","hash":"bde79f7b4c3a320f76e1121bd2b89cfe08d4a390","modified":1545321648565},{"_id":"public/archives/2018/09/index.html","hash":"5f7097b338d33b5e0abb1d46242abe816994e62e","modified":1545321648565},{"_id":"public/archives/2018/10/index.html","hash":"5fe28c1d2661f8ed6de2102e8de616bf3170e4e4","modified":1545321648565},{"_id":"public/archives/2018/11/index.html","hash":"0bf743640d2023b0b576ba4dcc643745be971dac","modified":1545321648565},{"_id":"public/archives/2018/12/index.html","hash":"bff6024ab1660d6341cac7e34e0f8e20b4472f9f","modified":1545321648565},{"_id":"public/archives/2018/12/page/2/index.html","hash":"fc6b0a3c2539449cd84ae6e86108ff407fe29e1c","modified":1545321648566},{"_id":"public/categories/ACM/index.html","hash":"afad82c79eb941d40529ec102c98cf5fba0903f5","modified":1545321648566},{"_id":"public/categories/ACM/page/2/index.html","hash":"912f1ceb1bb73a8ef8601d7c66890d4ac477a637","modified":1545321648566},{"_id":"public/categories/ACM/page/3/index.html","hash":"20919be167f18097daca331d2023d223f88e0e19","modified":1545321648566},{"_id":"public/categories/ACM/page/4/index.html","hash":"72a69d5153ede514e24a4913ff05aa40777c20f3","modified":1545321648566},{"_id":"public/categories/ACM/思维/index.html","hash":"7cb8b68bd756c31185731151208a99cb39bd7ecb","modified":1545321648566},{"_id":"public/categories/ACM/前缀和/index.html","hash":"33b59eef2f536efbde6dffb060478ff9392ef5b9","modified":1545321648566},{"_id":"public/categories/Summary/index.html","hash":"c4eda7d23ed044f2fc5dbbfbbd69a6d2630581ce","modified":1545321648566},{"_id":"public/categories/ACM/DFS/index.html","hash":"1b85fb14a01e74b5c2c3a4e8f723321ae533a8e9","modified":1545321648566},{"_id":"public/categories/ACM/动态规划/index.html","hash":"7a4133e87e8c1ea1bbe22cad01419c8c0e4247c9","modified":1545321648566},{"_id":"public/categories/Math/index.html","hash":"aa183be7a130d0135052a21bfaefa67466b39689","modified":1545321648566},{"_id":"public/categories/ACM/线段树/index.html","hash":"59680db56712c2406e6119c914a2bc8258a7a9c4","modified":1545321648566},{"_id":"public/categories/C/index.html","hash":"3be955c0541fcca027b57e7d2b5d6fc0f228bde6","modified":1545321648566},{"_id":"public/categories/Messy-article/index.html","hash":"5dc76daee9646b7c147eae7bbe1960daaf14f325","modified":1545321648566},{"_id":"public/categories/ACM/欧拉路/index.html","hash":"f458f4f630409b8ec117388614fa64ef572e110e","modified":1545321648566},{"_id":"public/categories/ACM/拓扑排序/index.html","hash":"c84e7fad81e8b0a556da489780f20ecdb578f562","modified":1545321648566},{"_id":"public/categories/Diary/index.html","hash":"3124a4be914ea4c0f462ebbea0d04be45f735db9","modified":1545321648566},{"_id":"public/categories/ACM/暴力枚举/index.html","hash":"68e9fe0666e0e4b4c29eee8aa03cf03cecda55ac","modified":1545321648566},{"_id":"public/categories/ACM/map/index.html","hash":"fe3db7414f6a8ad9e57e790b1c6ac0efaab53845","modified":1545321648567},{"_id":"public/categories/ACM/树/index.html","hash":"027b570e8b67e248c2af9b90972382db1c9fd710","modified":1545321648567},{"_id":"public/categories/ACM/链表/index.html","hash":"23f44b5a114eb10e1870c6158e4d3c14f6f84e9f","modified":1545321648567},{"_id":"public/categories/ACM/BFS/index.html","hash":"a981b3fd8bb63bed374a70efb95aff42d8c641d2","modified":1545321648567},{"_id":"public/categories/ACM/栈/index.html","hash":"6f3c21022f3583f9078804f3f2a66dffb1734b8f","modified":1545321648567},{"_id":"public/categories/ACM/离散化/index.html","hash":"af243150f9f8485c48f80c6041c314aa0609be25","modified":1545321648567},{"_id":"public/categories/ACM/背包/index.html","hash":"328ce471fc0de46a67e73e57977f003d4d1c2aa1","modified":1545321648567},{"_id":"public/categories/Template/index.html","hash":"c629c7938548eee2b1c61616300f058d78de0e0b","modified":1545321648567},{"_id":"public/index.html","hash":"86f14c2a810e25081dfc4b45e350212be6cb2a13","modified":1545321648567},{"_id":"public/page/2/index.html","hash":"cf2272035ef575444c2a08559124a24b88a5e9de","modified":1545321648567},{"_id":"public/page/3/index.html","hash":"5e2da9701c7a98a59bb83a1e79b8f2bbd78947d7","modified":1545321648567},{"_id":"public/page/4/index.html","hash":"b23b8c70693dda0d829fff104084e297d6a10cc3","modified":1545321648567},{"_id":"public/page/5/index.html","hash":"fb673fcb35039c6493e4e91f980d674d8a1ec231","modified":1545321648567},{"_id":"public/page/6/index.html","hash":"d1f77abd8e5314532250c55b6ea06ad3b32f2244","modified":1545321648567},{"_id":"public/tags/思维/index.html","hash":"d95f1d464a971a1d3265f7bb5cfc20607dbfda9d","modified":1545321648567},{"_id":"public/tags/前缀和/index.html","hash":"2120857e740ff77d49c07eb02e867cd4edbd4f92","modified":1545321648567},{"_id":"public/tags/后缀和/index.html","hash":"4691dbc7877e1f9911c1dd5d5ba2c972706effa5","modified":1545321648568},{"_id":"public/tags/图论/index.html","hash":"1550e1a1df7d3421e9a6624a224840746dfcf950","modified":1545321648568},{"_id":"public/tags/DFS/index.html","hash":"110bdc9799488001fd9a6ae96e1f56bd7ad62ce7","modified":1545321648568},{"_id":"public/tags/HDU/index.html","hash":"5e3e5a20b7b39c756787372f8f24a9ec533743ca","modified":1545321648568},{"_id":"public/tags/状态压缩DP/index.html","hash":"172964b46545a36db028b3623071df1ea1672d71","modified":1545321648568},{"_id":"public/tags/BFS/index.html","hash":"993f85a3c44bc2a174d62141e5085ff6f2776663","modified":1545321648568},{"_id":"public/tags/总结/index.html","hash":"61a5417baef1bbf094aa372ff415afd05ee7ba72","modified":1545321648568},{"_id":"public/tags/Liner-algebra/index.html","hash":"752acb934c26f689572b247a76ea0b4f73d84688","modified":1545321648568},{"_id":"public/tags/C语言/index.html","hash":"42eb19a5c7745a8fb5e6015b6cd037790afc6104","modified":1545321648568},{"_id":"public/tags/POJ/index.html","hash":"b578ba4af12d14768622ba17b6ee6f29f4ee22e6","modified":1545321648568},{"_id":"public/tags/迷宫问题/index.html","hash":"0309b24c13f88306f590331eecd1ebd882b4ea62","modified":1545321648568},{"_id":"public/tags/线切割平面/index.html","hash":"2798db699f26dc5931a896c3bfc1f41602224d89","modified":1545321648568},{"_id":"public/tags/math/index.html","hash":"3a7d3441d82d31fb43cd27e0ba1d73e50cac0cb3","modified":1545321648568},{"_id":"public/tags/线段树/index.html","hash":"1db1b4593f3fbfac7933fca209a7baa1e5f463c2","modified":1545321648568},{"_id":"public/tags/STL/index.html","hash":"73ad6c54625a255a72a5e13f8eb18e19859141b1","modified":1545321648568},{"_id":"public/tags/Game/index.html","hash":"df8c9f0bce85edc6e3e38b19cbde190209211684","modified":1545321648568},{"_id":"public/tags/欧拉路/index.html","hash":"2eb8f5b3a0f03fe2b408f61df9e814bf8df21b76","modified":1545321648568},{"_id":"public/tags/拓扑排序/index.html","hash":"f588ee000a09f6e8c6fd9ab05caffda7b664c71e","modified":1545321648568},{"_id":"public/tags/Lover/index.html","hash":"7ce9c67675ce094b48f3f1b185b4bdc7e8256198","modified":1545321648568},{"_id":"public/tags/全局思维/index.html","hash":"f9f87a6084a6f4962eb94c5596d5b9d85b0ae9d3","modified":1545321648568},{"_id":"public/tags/暴力枚举/index.html","hash":"a4d6f8b06fe2c97fa5686a9ffa0c7d8a6c10ddc4","modified":1545321648569},{"_id":"public/tags/全局思想/index.html","hash":"3f4eea0ad76558c0f60f9fa8ad2d5dab46061fb2","modified":1545321648569},{"_id":"public/tags/stack/index.html","hash":"ac6efd6c581614db0ec7cfc631085af66e922b13","modified":1545321648569},{"_id":"public/tags/二叉树/index.html","hash":"1a746498eff45884f57059b002e34a11bb7d2bb2","modified":1545321648569},{"_id":"public/tags/逆向思维/index.html","hash":"c39e568eeb7f58c7fc8adc8069f3bce0aa17d94f","modified":1545321648569},{"_id":"public/tags/链表/index.html","hash":"b283d404f2bb6970fd0f1cdd43eeebec98f2ee42","modified":1545321648569},{"_id":"public/tags/栈/index.html","hash":"5deff88baceb4cda4c85e0059d5aa281b514617a","modified":1545321648569},{"_id":"public/tags/Stack/index.html","hash":"30eba9aaa9b17f90a7b2468e0ee3d88ad408dda0","modified":1545321648569},{"_id":"public/tags/离散化/index.html","hash":"6f6c583d42738ee38bc5ecdaf0d51242a0ff8edb","modified":1545321648570},{"_id":"public/tags/DP/index.html","hash":"34dfcb772301012c14afe1bb0fd200f9336c5f6e","modified":1545321648570},{"_id":"public/tags/01背包/index.html","hash":"8bfdb476c8139aabc3512fc67b700720f37d6953","modified":1545321648570},{"_id":"public/tags/四分树/index.html","hash":"3267e2fcce4301caea88b24d5ae704194d16779e","modified":1545321648570},{"_id":"public/tags/mathjax/index.html","hash":"b313c14d86351c37e39cae8bde16ec0560938830","modified":1545321648570},{"_id":"public/tags/hexo插入数学公式/index.html","hash":"947ce3b6512468b4cff277206beb89c7cfd5414c","modified":1545321648570},{"_id":"public/tags/树/index.html","hash":"f5f01c27d78f0f1f09dcb5573d42bdf884273b98","modified":1545321648570},{"_id":"public/tags/C/index.html","hash":"7a1698fab99e01f099ac2d3517f17ca19359d344","modified":1545321648570},{"_id":"public/tags/排列/index.html","hash":"59b09b30ddcf545e5f1142e9916b7c024744e583","modified":1545321648570},{"_id":"public/tags/生活/index.html","hash":"6f166514024f9b439ad2b04d85ee538baa3155dc","modified":1545321648570},{"_id":"public/tags/线段树单点更新/index.html","hash":"e4ef25b25a87afe41fdb2a3be264da80ab3f135e","modified":1545321648570},{"_id":"public/tags/线段树区间更新/index.html","hash":"5ede80c4adc5b27f13311ee3b45a1331187112e7","modified":1545321648570},{"_id":"public/tags/字符串/index.html","hash":"dae1a1e83becd03143ddac0b6425211263af7914","modified":1545321648571},{"_id":"public/tags/vultr服务器搭建/index.html","hash":"1d85bfc8776c415afff69db9600fbad8221588ec","modified":1545321648571},{"_id":"public/tags/Math/index.html","hash":"2afe45230743b73621de2b9efe0d1811b680a3e2","modified":1545321648571},{"_id":"public/tags/python/index.html","hash":"be283206b82a367de1f42490bb0e942166513d25","modified":1545321648571},{"_id":"public/2018/12/20/八皇后问题/index.html","hash":"b792c362763260f98dcc47e4999a310ba4a68f71","modified":1545321648585},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1545321648593},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1545321648593},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1545321648593},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1545321648593},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1545321648593},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1545321648594},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1545321648594},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1545321648594},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1545321648594},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1545321648594},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1545321648594},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545321648594},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1545321648594},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1545321648594},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1545321648594},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545321648594},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1545321648594},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1545321648594},{"_id":"public/images/user.jpg","hash":"16b0e60948516954e1f9834e2d593c1deb0ffec4","modified":1545321648594},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1545321648594},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1545321648594},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1545321648594},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1545321648594},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1545321648594},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1545321648594},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1545321648595},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1545321648595},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1545321648595},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1545321648595},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1545321648595},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1545321648595},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1545321648595},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1545321648595},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1545321648595},{"_id":"public/2018/08/12/HDU1016-Prime-Ring-Problem-DFS/dfs.png","hash":"bfaf09def97b165527bb22bad63dfe38109bdd64","modified":1545321648595},{"_id":"public/2018/08/14/POJ1970-The-Game-DFS/Renju.png","hash":"e478edf969416be8f2fda647b3336271dbb13b6a","modified":1545321648595},{"_id":"public/2018/12/03/Super-Mario/SuperMario.png","hash":"b063b297ce5044d523ae0c3d2ea4c408cefe5848","modified":1545321648595},{"_id":"public/2018/12/04/Uva12166-Equilibrium-Mobile/balance.png","hash":"f4529422d6cf9010363875a87318e6ec8cb45083","modified":1545321648595},{"_id":"public/2018/11/14/Uva221-Urban-Elevations/building.png","hash":"5be5290e6f5974f919f3525d5d85f215d2b2dcd9","modified":1545321648595},{"_id":"public/2018/09/22/Uva839-二叉树的递归处理/tree.png","hash":"ccee240e1b924dd7cca49828c69e0cf78742a7e3","modified":1545321648595},{"_id":"public/2018/11/13/Uva10562-Undraw the trees/tree.png","hash":"51cf513829497a8d98dc1e0f7ade6d8dc407adfd","modified":1545321648595},{"_id":"public/2018/12/09/循环小数化为分数的方法/wiki.png","hash":"1b5ec94305a72471f51e90d9bd1d71e44983a983","modified":1545321648595},{"_id":"public/2018/09/07/Graph-Theory-The-shortest-path/gra.png","hash":"c2a7946e9e78ad6264a4a6d6b581d06160604bfe","modified":1545321648595},{"_id":"public/2018/09/07/Graph-Theory-The-shortest-path/path.png","hash":"b20559aca988d5aaefc0931e513b4fc808c5be21","modified":1545321648596},{"_id":"public/2018/04/09/HDU2050/line.jpg","hash":"0b614039e05df58510f6979466289f7ac7190b5f","modified":1545321648596},{"_id":"public/2018/04/09/HDU2050/res.gif","hash":"163a87523482ba25a73787e59a0b13ecfb736053","modified":1545321648596},{"_id":"public/2018/12/04/Uva806-Spatial-Structures/1.png","hash":"3374b72597b7048bb95a6af65ba72f10699f86a8","modified":1545321648596},{"_id":"public/2018/12/04/Uva806-Spatial-Structures/2.png","hash":"ad1edffc72af5cec0649f0b5e93a48a19d9d9acf","modified":1545321648596},{"_id":"public/2018/06/12/tab-to-spaces/space.png","hash":"e1202e8eb89c5c09f5e3eb1e4a72be772c4790b6","modified":1545321648596},{"_id":"public/2018/06/12/tab-to-spaces/tab.png","hash":"30312fc2dabd01c3540693ea57af6ea0a11c9fe2","modified":1545321648596},{"_id":"public/2018/06/10/My-little-angel/moon1.jpg","hash":"c57a51bb30e1ec204f4fb3c01783b8f2e87a1bbd","modified":1545321648596},{"_id":"public/2018/06/10/My-little-angel/together1.jpg","hash":"1783fb05e6a210c1c2de23c413b9fb466c44c03a","modified":1545321648596},{"_id":"public/2018/10/28/Uva1103-Ancient-Messages/1.png","hash":"49e92896091c97e432582ca738cdd415dfbaef3a","modified":1545321648596},{"_id":"public/2018/10/28/Uva1103-Ancient-Messages/2.png","hash":"66e6e3e8aa6456456ff9794274edf1dacb72219c","modified":1545321648596},{"_id":"public/2018/04/13/vultr/p1.png","hash":"595bda0f3e72f314db02d09c378298daf0840657","modified":1545321648596},{"_id":"public/2018/04/13/vultr/p2.png","hash":"c797e71775de0c707e10ec8f765a154b37f27197","modified":1545321648596},{"_id":"public/2018/04/13/vultr/p3.png","hash":"67dbd2c65a2c47e6ae09f22051629da1a6c5fdd1","modified":1545321648596},{"_id":"public/2018/04/13/vultr/p5.png","hash":"a7c6230253b7b12375ea294a6386473479cd7d26","modified":1545321648597},{"_id":"public/2018/04/13/vultr/p8.png","hash":"2f5ce1e7aa48769570589a1a15948f1364753a67","modified":1545321648597},{"_id":"public/2018/04/13/vultr/p7.png","hash":"da388ae09f2db520f71e2348bf8a4883adb2666a","modified":1545321648597},{"_id":"public/2018/12/20/八皇后问题/queen.png","hash":"6ab1bc094e22cb34ec02d3dcd9f3c70efe233479","modified":1545321648597},{"_id":"public/images/user2.png","hash":"5a825078a61886e5bf8f40244b0c0d3acef801ee","modified":1545321649534},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1545321649536},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1545321649537},{"_id":"public/2018/11/04/欧拉回路/Elur.png","hash":"ddc21e3cbc1ffa51606a7a521fad01c798d6ad47","modified":1545321649537},{"_id":"public/2018/06/10/My-little-angel/qxy1.jpg","hash":"29c0b85aa8bd9e32c8b239b78ae5f571e8375bd9","modified":1545321649537},{"_id":"public/2018/10/28/Uva1103-Ancient-Messages/hier.png","hash":"9fc1f550a328d3a0f44bec5cd4655935db1fe9d0","modified":1545321649538},{"_id":"public/2018/04/13/vultr/p4.png","hash":"2ee46cf520c7d0585db4245c9586829f5173e680","modified":1545321649538},{"_id":"public/2018/04/13/vultr/p6.png","hash":"47f4048062363375bb49809ceb19a67b5c659bf3","modified":1545321649538},{"_id":"public/2018/04/13/vultr/p9.png","hash":"7a099d33cc7ac17bc5e233121d135e46af0549b5","modified":1545321649538},{"_id":"public/2018/12/20/八皇后问题/diagonal.png","hash":"4963cc964d96d85438ef74780aafd357f2c198f4","modified":1545321649538},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1545321649555},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1545321649556},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1545321649556},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1545321649556},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1545321649556},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1545321649556},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1545321649556},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1545321649556},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1545321649557},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1545321649557},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1545321649557},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1545321649557},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1545321649557},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1545321649557},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1545321649557},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1545321649557},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1545321649557},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1545321649557},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1545321649557},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1545321649557},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1545321649557},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1545321649558},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1545321649558},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1545321649558},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1545321649558},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1545321649558},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1545321649558},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1545321649558},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1545321649558},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1545321649558},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1545321649558},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1545321649558},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1545321649558},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1545321649558},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1545321649558},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1545321649559},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1545321649559},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1545321649559},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1545321649559},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1545321649559},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1545321649559},{"_id":"public/css/main.css","hash":"3afeef7fb40606ee6fbc5c228ec2c7a7e4e334d6","modified":1545321649559},{"_id":"public/images/Picture1.png","hash":"94067d9a4021d24612d7dad597c915d07d0056c0","modified":1545321649559},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1545321649559},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1545321649559},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1545321649559},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1545321649561},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1545321649561},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1545321649561},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1545321649561},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1545321649561},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1545321649561},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1545321649561},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1545321649561},{"_id":"public/2018/10/24/Linear algebra-Dot product/1.gif","hash":"a037ce119aca35cd7188ef70334ba9b06dc81d31","modified":1545321649561},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1545321649562},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1545321649562},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1545321649573},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1545321649573},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1545321649578},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1545321649578},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1545321649579},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1545321649580},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1545321649580},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1545321649580},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1545321649580},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1545321649580},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1545321649586},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1545321649586},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1545321649587},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1545321649589},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1545321649594},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1545321649596},{"_id":"public/2018/10/24/Linear algebra-Dot product/3.gif","hash":"fc991a2c97761dcc611775a0ed1bd3bcf31c6435","modified":1545321649597},{"_id":"public/2018/10/24/Linear algebra-Dot product/2.gif","hash":"bb118b39f653f5c4b63c9947450608f8049641d4","modified":1545321649598},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1545321649601},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1545321649606},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1545321649608}],"Category":[{"name":"ACM","_id":"cjpwslrfy0003b8ou7na3kcre"},{"name":"思维","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrg40008b8oug2lchr1p"},{"name":"前缀和","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrg5000ab8oupcphkwzw"},{"name":"Summary","_id":"cjpwslrgo000jb8oudxyv7zw3"},{"name":"DFS","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrme000wb8ouy8597y9g"},{"name":"动态规划","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrmm0013b8ouuuwdlie7"},{"name":"Math","_id":"cjpwslrmr001ab8oul1ob0kap"},{"name":"线段树","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrmw001hb8ouvbwr7z4r"},{"name":"C++","_id":"cjpwslrmz001nb8ouny1unkw0"},{"name":"Messy article","_id":"cjpwslrn2001wb8ou2oal69xt"},{"name":"欧拉路","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrn50023b8oufd7gm84v"},{"name":"拓扑排序","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrn9002cb8ou4sj3fpw0"},{"name":"Diary","_id":"cjpwslrnc002jb8our9bl6w8t"},{"name":"暴力枚举","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrng002qb8oucjjufqdd"},{"name":"map","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrnm002zb8oufbyjusq9"},{"name":"树","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrnr0038b8outyy0s90h"},{"name":"链表","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrnw003gb8oudqp8rf7z"},{"name":"BFS","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrnz003pb8ouinnw3076"},{"name":"栈","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrof004eb8outmn0prte"},{"name":"离散化","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrok004nb8ou7aok9lob"},{"name":"背包","parent":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslroo004vb8ouqldtr9c3"},{"name":"Template","_id":"cjpwslroy005jb8ounfp8ffhg"}],"Data":[],"Page":[{"title":"about","date":"2018-04-08T08:12:48.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-04-08 16:12:48\ntype: \"about\"\n---\n","updated":"2018-04-08T08:14:01.342Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjpwslrfv0001b8ou2p8kmwtr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"commonweal","date":"2018-04-08T09:18:33.000Z","type":"commonweal","_content":"","source":"commonweal/index.md","raw":"---\ntitle: commonweal\ndate: 2018-04-08 17:18:33\ntype: \"commonweal\"\n---\n","updated":"2018-04-08T09:19:13.090Z","path":"commonweal/index.html","comments":1,"layout":"page","_id":"cjpwslrm5000rb8ou2kk70rw7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2018-04-08T08:14:39.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-04-08 16:14:39\ntype: \"categories\"\n---\n","updated":"2018-04-08T08:15:15.982Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjpwslrm9000tb8ousnzmcrq2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"schedule","date":"2018-04-08T09:15:03.000Z","type":"schedule","_content":"","source":"schedule/index.md","raw":"---\ntitle: schedule\ndate: 2018-04-08 17:15:03\ntype: \"schedule\"\n---\n","updated":"2018-04-08T09:17:17.727Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"cjpwslrme000xb8ouie7g09vf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"sitemap","date":"2018-04-08T09:18:19.000Z","type":"sitemap","_content":"","source":"sitemap/index.md","raw":"---\ntitle: sitemap\ndate: 2018-04-08 17:18:19\ntype: \"sitemap\"\n---\n","updated":"2018-04-08T09:18:52.866Z","path":"sitemap/index.html","comments":1,"layout":"page","_id":"cjpwslrmh000zb8oug08vjuqi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-04-07T17:23:59.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-04-08 01:23:59\ntype: \"tags\"\n---\n","updated":"2018-04-07T17:25:42.983Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjpwslrmm0012b8ounzo9oe1b","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Friends","date":"2018-10-13T02:47:36.000Z","_content":"| Links    | Notes    |\n| :------: | :------: |\n| [Bowen's Blog](http://www.bowen-blog.com/) | 徐阿卞大佬 |\n","source":"links/index.md","raw":"---\ntitle: Friends\ndate: 2018-10-13 10:47:36\n---\n| Links    | Notes    |\n| :------: | :------: |\n| [Bowen's Blog](http://www.bowen-blog.com/) | 徐阿卞大佬 |\n","updated":"2018-10-13T03:27:15.022Z","path":"links/index.html","comments":1,"layout":"page","_id":"cjpwslrmo0016b8ou0aqt2pf4","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Links</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><a href=\"http://www.bowen-blog.com/\" target=\"_blank\" rel=\"noopener\">Bowen’s Blog</a></td>\n<td style=\"text-align:center\">徐阿卞大佬</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Links</th>\n<th style=\"text-align:center\">Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><a href=\"http://www.bowen-blog.com/\" target=\"_blank\" rel=\"noopener\">Bowen’s Blog</a></td>\n<td style=\"text-align:center\">徐阿卞大佬</td>\n</tr>\n</tbody>\n</table>\n"}],"Post":[{"title":"CodeForces-478C-Table Decorations","date":"2018-08-28T06:21:27.000Z","_content":"水题，然而自己WA了orz，看到了一种很有意思的解法。\n[参考连接](http://codeforces.com/blog/entry/18619)\n<!--more-->\n## 链接\n[CodeForces-478C-Table Decorations](http://codeforces.com/problemset/problem/478/C)\n## 题目描述\n给定红黄蓝三种气球的数量，要求每个桌子上放三个气球，且三个气球的颜色不能完全相同，求这些气球最多可以装饰几张桌子。\n## 题解\n假定三种气球的数量分别为``a[0]，a[1]，a[2]``，且已按大小排好序，``a[0] <= a[1] <= a[2]``。\n有两种情况:\n+ ``2 * (a[0] + a[1]) <=  a[2]``。这种情况下可以每取一个``a[0]``取两个``a[2]``组成三气球或者每取一个``a[1]``取两个``a[2]``组成三气球，即取球集合为``(1，0，2)``和``(0，1，2)``。答案为``a[0] + a[1]``。\n+ ``2*(a[0] + a[1]) > a[2]``。这种情况下我们从``a[2]``中取两个气球同时从``max(a[0]，a[1])``中取一个气球，直到``a[2] <= max(a[0]，a[1])``。这时满足``max(a[0]，a[1]) - a[2] <= 1``和``max(a[0]，a[1]) - min(a[0]，a[1]) <= 1``。接下来的按集合``(1，1，1)``继续取球。**可以发现这种取法最后剩余球的数量一定是** ``(a[0]+a[1]+a[2]) mod 3``，**除去剩余的这些球(数量小于3)，其它球每三个装饰一张桌子，所以针对这种情况我们直接可以用** ``(a[0]+a[1]+a[2]) div 3`` **来得到最终结果。**\n\n真是神解orz。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 28 Aug 14:12:13 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long d[5];\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    for(int i = 0; i < 3; i++)\n        cin >> d[i];\n    sort(d, d + 3);\n    long long ans;\n    if(2 * (d[0] + d[1]) <= d[2])\n        ans = d[0] + d[1];\n    else \n        ans = (d[0] + d[1] + d[2]) / 3;\n    cout << ans << endl;\n    \n    return 0;\n}\n```\n","source":"_posts/CodeForces-478C.md","raw":"---\ntitle: CodeForces-478C-Table Decorations\ndate: 2018-08-28 14:21:27\ncategories:\n- ACM\n- 思维\ntags:\n- 思维\n---\n水题，然而自己WA了orz，看到了一种很有意思的解法。\n[参考连接](http://codeforces.com/blog/entry/18619)\n<!--more-->\n## 链接\n[CodeForces-478C-Table Decorations](http://codeforces.com/problemset/problem/478/C)\n## 题目描述\n给定红黄蓝三种气球的数量，要求每个桌子上放三个气球，且三个气球的颜色不能完全相同，求这些气球最多可以装饰几张桌子。\n## 题解\n假定三种气球的数量分别为``a[0]，a[1]，a[2]``，且已按大小排好序，``a[0] <= a[1] <= a[2]``。\n有两种情况:\n+ ``2 * (a[0] + a[1]) <=  a[2]``。这种情况下可以每取一个``a[0]``取两个``a[2]``组成三气球或者每取一个``a[1]``取两个``a[2]``组成三气球，即取球集合为``(1，0，2)``和``(0，1，2)``。答案为``a[0] + a[1]``。\n+ ``2*(a[0] + a[1]) > a[2]``。这种情况下我们从``a[2]``中取两个气球同时从``max(a[0]，a[1])``中取一个气球，直到``a[2] <= max(a[0]，a[1])``。这时满足``max(a[0]，a[1]) - a[2] <= 1``和``max(a[0]，a[1]) - min(a[0]，a[1]) <= 1``。接下来的按集合``(1，1，1)``继续取球。**可以发现这种取法最后剩余球的数量一定是** ``(a[0]+a[1]+a[2]) mod 3``，**除去剩余的这些球(数量小于3)，其它球每三个装饰一张桌子，所以针对这种情况我们直接可以用** ``(a[0]+a[1]+a[2]) div 3`` **来得到最终结果。**\n\n真是神解orz。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 28 Aug 14:12:13 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long d[5];\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    for(int i = 0; i < 3; i++)\n        cin >> d[i];\n    sort(d, d + 3);\n    long long ans;\n    if(2 * (d[0] + d[1]) <= d[2])\n        ans = d[0] + d[1];\n    else \n        ans = (d[0] + d[1] + d[2]) / 3;\n    cout << ans << endl;\n    \n    return 0;\n}\n```\n","slug":"CodeForces-478C","published":1,"updated":"2018-12-14T13:07:50.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrfp0000b8ou5zrin4p3","content":"<p>水题，然而自己WA了orz，看到了一种很有意思的解法。<br><a href=\"http://codeforces.com/blog/entry/18619\" target=\"_blank\" rel=\"noopener\">参考连接</a><br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/problemset/problem/478/C\" target=\"_blank\" rel=\"noopener\">CodeForces-478C-Table Decorations</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定红黄蓝三种气球的数量，要求每个桌子上放三个气球，且三个气球的颜色不能完全相同，求这些气球最多可以装饰几张桌子。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>假定三种气球的数量分别为<code>a[0]，a[1]，a[2]</code>，且已按大小排好序，<code>a[0] &lt;= a[1] &lt;= a[2]</code>。<br>有两种情况:</p>\n<ul>\n<li><code>2 * (a[0] + a[1]) &lt;=  a[2]</code>。这种情况下可以每取一个<code>a[0]</code>取两个<code>a[2]</code>组成三气球或者每取一个<code>a[1]</code>取两个<code>a[2]</code>组成三气球，即取球集合为<code>(1，0，2)</code>和<code>(0，1，2)</code>。答案为<code>a[0] + a[1]</code>。</li>\n<li><code>2*(a[0] + a[1]) &gt; a[2]</code>。这种情况下我们从<code>a[2]</code>中取两个气球同时从<code>max(a[0]，a[1])</code>中取一个气球，直到<code>a[2] &lt;= max(a[0]，a[1])</code>。这时满足<code>max(a[0]，a[1]) - a[2] &lt;= 1</code>和<code>max(a[0]，a[1]) - min(a[0]，a[1]) &lt;= 1</code>。接下来的按集合<code>(1，1，1)</code>继续取球。<strong>可以发现这种取法最后剩余球的数量一定是</strong> <code>(a[0]+a[1]+a[2]) mod 3</code>，<strong>除去剩余的这些球(数量小于3)，其它球每三个装饰一张桌子，所以针对这种情况我们直接可以用</strong> <code>(a[0]+a[1]+a[2]) div 3</code> <strong>来得到最终结果。</strong></li>\n</ul>\n<p>真是神解orz。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 28 Aug 14:12:13 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d[<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; d[i];</span><br><span class=\"line\">    sort(d, d + <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">2</span> * (d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>]) &lt;= d[<span class=\"number\">2</span>])</span><br><span class=\"line\">        ans = d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        ans = (d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>] + d[<span class=\"number\">2</span>]) / <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>水题，然而自己WA了orz，看到了一种很有意思的解法。<br><a href=\"http://codeforces.com/blog/entry/18619\" target=\"_blank\" rel=\"noopener\">参考连接</a><br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/problemset/problem/478/C\" target=\"_blank\" rel=\"noopener\">CodeForces-478C-Table Decorations</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定红黄蓝三种气球的数量，要求每个桌子上放三个气球，且三个气球的颜色不能完全相同，求这些气球最多可以装饰几张桌子。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>假定三种气球的数量分别为<code>a[0]，a[1]，a[2]</code>，且已按大小排好序，<code>a[0] &lt;= a[1] &lt;= a[2]</code>。<br>有两种情况:</p>\n<ul>\n<li><code>2 * (a[0] + a[1]) &lt;=  a[2]</code>。这种情况下可以每取一个<code>a[0]</code>取两个<code>a[2]</code>组成三气球或者每取一个<code>a[1]</code>取两个<code>a[2]</code>组成三气球，即取球集合为<code>(1，0，2)</code>和<code>(0，1，2)</code>。答案为<code>a[0] + a[1]</code>。</li>\n<li><code>2*(a[0] + a[1]) &gt; a[2]</code>。这种情况下我们从<code>a[2]</code>中取两个气球同时从<code>max(a[0]，a[1])</code>中取一个气球，直到<code>a[2] &lt;= max(a[0]，a[1])</code>。这时满足<code>max(a[0]，a[1]) - a[2] &lt;= 1</code>和<code>max(a[0]，a[1]) - min(a[0]，a[1]) &lt;= 1</code>。接下来的按集合<code>(1，1，1)</code>继续取球。<strong>可以发现这种取法最后剩余球的数量一定是</strong> <code>(a[0]+a[1]+a[2]) mod 3</code>，<strong>除去剩余的这些球(数量小于3)，其它球每三个装饰一张桌子，所以针对这种情况我们直接可以用</strong> <code>(a[0]+a[1]+a[2]) div 3</code> <strong>来得到最终结果。</strong></li>\n</ul>\n<p>真是神解orz。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 28 Aug 14:12:13 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d[<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; d[i];</span><br><span class=\"line\">    sort(d, d + <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">2</span> * (d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>]) &lt;= d[<span class=\"number\">2</span>])</span><br><span class=\"line\">        ans = d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">        ans = (d[<span class=\"number\">0</span>] + d[<span class=\"number\">1</span>] + d[<span class=\"number\">2</span>]) / <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Codeforces-#498Div3-C-前&&后缀和","date":"2018-07-31T15:08:57.000Z","_content":"好题，虽然比较简单，但是觉得这道题的解题思路挺棒的，用到了前缀和，后缀和以及思路的转换．解出来之后还是很开心的，嚯嚯嚯（一个只能做做Div3的小菜鸡|･ω･｀)）\n<!-- more -->\n## 链接\n[Codeforces-#498Div3-C](http://codeforces.com/contest/1006/problem/C)\n## 题解\n题目大意：给定n个整数（范围1~1e9）,要求把这n个整数划分为连续的三段，使得第一段的数的总和与第三段的数的总和相等且要求这个总和尽量大．\n思路：\n因为n的范围是1~2e5，而且又涉及求和，所以应该可以比较自然的想到前缀和，题目又要求是前后两段的总和相等所以后缀和也要统计一下．接下来就要考虑什么时候两端的和相等且最大了，因为第一段和第三段长度不定，所以相当于是两个变量，想到它们的长度变化其实可以归一到第二段数据的长度变化，这样的话复杂度变为O(n)，就可以通过了．具体做法是对于1~n这n个数据，初始化第二段数据区间为[2, n - 1], 然后判断此时第一段和第三段数据和的大小关系，因为已经统计了前缀和和后缀和，所以这部分复杂度是O(1)．如果第一段数据和等于第三段数据和则记录这个数据和同时缩小第二段数据的区间，变为[3, n - 2]，继续判断，看是否还有更大的数据和满足条件；如果第一段数据和大于第三段数据和则保持第二段区间左端点不变收缩右端点，即变为[2, n - 2];同样的如果第一段数据和小于第三段数据和则保持第二段区间右端点不变，左端点收缩，即变为[3, n - 2];以此类推，直到第二段区间消失，此时最后一次记录的数据和即为结果．\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint d[maxn];\nint n;\nlong long psum[maxn], bsum[maxn];\nvector<long long> vec;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", d + i);\n        if(i == 0) psum[i] = d[i];\n        else psum[i] = psum[i - 1] + d[i];\n    }\n    for(int i = n - 1; i >= 0; i--){\n        if(i == n - 1) bsum[i] = d[i];\n        else bsum[i] = bsum[i + 1] + d[i];\n    }\n\n    int i, j;\n    for(i = 0, j = n - 1; i < n;){\n        if(i >= j) break;\n        if(psum[i] == bsum[j]){\n            vec.push_back(psum[i]);\n            i++;\n            j--;\n        }\n        else if(psum[i] < bsum[j]) i++;\n        else if(psum[i] > bsum[j]) j--;\n    }\n    if(vec.size() != 0) printf(\"%lld\\n\", vec[vec.size() - 1]);\n    else printf(\"0\\n\");\n    return 0;\n}\n```","source":"_posts/Codeforces-498Div3-C.md","raw":"---\ntitle: 'Codeforces-#498Div3-C-前&&后缀和'\ndate: 2018-07-31 23:08:57\ncategories:\n- ACM\n- 前缀和\ntags:\n- 前缀和\n- 后缀和\n---\n好题，虽然比较简单，但是觉得这道题的解题思路挺棒的，用到了前缀和，后缀和以及思路的转换．解出来之后还是很开心的，嚯嚯嚯（一个只能做做Div3的小菜鸡|･ω･｀)）\n<!-- more -->\n## 链接\n[Codeforces-#498Div3-C](http://codeforces.com/contest/1006/problem/C)\n## 题解\n题目大意：给定n个整数（范围1~1e9）,要求把这n个整数划分为连续的三段，使得第一段的数的总和与第三段的数的总和相等且要求这个总和尽量大．\n思路：\n因为n的范围是1~2e5，而且又涉及求和，所以应该可以比较自然的想到前缀和，题目又要求是前后两段的总和相等所以后缀和也要统计一下．接下来就要考虑什么时候两端的和相等且最大了，因为第一段和第三段长度不定，所以相当于是两个变量，想到它们的长度变化其实可以归一到第二段数据的长度变化，这样的话复杂度变为O(n)，就可以通过了．具体做法是对于1~n这n个数据，初始化第二段数据区间为[2, n - 1], 然后判断此时第一段和第三段数据和的大小关系，因为已经统计了前缀和和后缀和，所以这部分复杂度是O(1)．如果第一段数据和等于第三段数据和则记录这个数据和同时缩小第二段数据的区间，变为[3, n - 2]，继续判断，看是否还有更大的数据和满足条件；如果第一段数据和大于第三段数据和则保持第二段区间左端点不变收缩右端点，即变为[2, n - 2];同样的如果第一段数据和小于第三段数据和则保持第二段区间右端点不变，左端点收缩，即变为[3, n - 2];以此类推，直到第二段区间消失，此时最后一次记录的数据和即为结果．\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint d[maxn];\nint n;\nlong long psum[maxn], bsum[maxn];\nvector<long long> vec;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", d + i);\n        if(i == 0) psum[i] = d[i];\n        else psum[i] = psum[i - 1] + d[i];\n    }\n    for(int i = n - 1; i >= 0; i--){\n        if(i == n - 1) bsum[i] = d[i];\n        else bsum[i] = bsum[i + 1] + d[i];\n    }\n\n    int i, j;\n    for(i = 0, j = n - 1; i < n;){\n        if(i >= j) break;\n        if(psum[i] == bsum[j]){\n            vec.push_back(psum[i]);\n            i++;\n            j--;\n        }\n        else if(psum[i] < bsum[j]) i++;\n        else if(psum[i] > bsum[j]) j--;\n    }\n    if(vec.size() != 0) printf(\"%lld\\n\", vec[vec.size() - 1]);\n    else printf(\"0\\n\");\n    return 0;\n}\n```","slug":"Codeforces-498Div3-C","published":1,"updated":"2018-12-14T13:10:34.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrfw0002b8ouu66rw5vs","content":"<p>好题，虽然比较简单，但是觉得这道题的解题思路挺棒的，用到了前缀和，后缀和以及思路的转换．解出来之后还是很开心的，嚯嚯嚯（一个只能做做Div3的小菜鸡|･ω･｀)）<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/contest/1006/problem/C\" target=\"_blank\" rel=\"noopener\">Codeforces-#498Div3-C</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意：给定n个整数（范围1~1e9）,要求把这n个整数划分为连续的三段，使得第一段的数的总和与第三段的数的总和相等且要求这个总和尽量大．<br>思路：<br>因为n的范围是1~2e5，而且又涉及求和，所以应该可以比较自然的想到前缀和，题目又要求是前后两段的总和相等所以后缀和也要统计一下．接下来就要考虑什么时候两端的和相等且最大了，因为第一段和第三段长度不定，所以相当于是两个变量，想到它们的长度变化其实可以归一到第二段数据的长度变化，这样的话复杂度变为O(n)，就可以通过了．具体做法是对于1~n这n个数据，初始化第二段数据区间为[2, n - 1], 然后判断此时第一段和第三段数据和的大小关系，因为已经统计了前缀和和后缀和，所以这部分复杂度是O(1)．如果第一段数据和等于第三段数据和则记录这个数据和同时缩小第二段数据的区间，变为[3, n - 2]，继续判断，看是否还有更大的数据和满足条件；如果第一段数据和大于第三段数据和则保持第二段区间左端点不变收缩右端点，即变为[2, n - 2];同样的如果第一段数据和小于第三段数据和则保持第二段区间右端点不变，左端点收缩，即变为[3, n - 2];以此类推，直到第二段区间消失，此时最后一次记录的数据和即为结果．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">2e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> psum[maxn], bsum[maxn];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, d + i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) psum[i] = d[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> psum[i] = psum[i - <span class=\"number\">1</span>] + d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == n - <span class=\"number\">1</span>) bsum[i] = d[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> bsum[i] = bsum[i + <span class=\"number\">1</span>] + d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>, j = n - <span class=\"number\">1</span>; i &lt; n;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt;= j) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(psum[i] == bsum[j])&#123;</span><br><span class=\"line\">            vec.push_back(psum[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(psum[i] &lt; bsum[j]) i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(psum[i] &gt; bsum[j]) j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vec.size() != <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, vec[vec.size() - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>好题，虽然比较简单，但是觉得这道题的解题思路挺棒的，用到了前缀和，后缀和以及思路的转换．解出来之后还是很开心的，嚯嚯嚯（一个只能做做Div3的小菜鸡|･ω･｀)）<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/contest/1006/problem/C\" target=\"_blank\" rel=\"noopener\">Codeforces-#498Div3-C</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意：给定n个整数（范围1~1e9）,要求把这n个整数划分为连续的三段，使得第一段的数的总和与第三段的数的总和相等且要求这个总和尽量大．<br>思路：<br>因为n的范围是1~2e5，而且又涉及求和，所以应该可以比较自然的想到前缀和，题目又要求是前后两段的总和相等所以后缀和也要统计一下．接下来就要考虑什么时候两端的和相等且最大了，因为第一段和第三段长度不定，所以相当于是两个变量，想到它们的长度变化其实可以归一到第二段数据的长度变化，这样的话复杂度变为O(n)，就可以通过了．具体做法是对于1~n这n个数据，初始化第二段数据区间为[2, n - 1], 然后判断此时第一段和第三段数据和的大小关系，因为已经统计了前缀和和后缀和，所以这部分复杂度是O(1)．如果第一段数据和等于第三段数据和则记录这个数据和同时缩小第二段数据的区间，变为[3, n - 2]，继续判断，看是否还有更大的数据和满足条件；如果第一段数据和大于第三段数据和则保持第二段区间左端点不变收缩右端点，即变为[2, n - 2];同样的如果第一段数据和小于第三段数据和则保持第二段区间右端点不变，左端点收缩，即变为[3, n - 2];以此类推，直到第二段区间消失，此时最后一次记录的数据和即为结果．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">2e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> psum[maxn], bsum[maxn];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, d + i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) psum[i] = d[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> psum[i] = psum[i - <span class=\"number\">1</span>] + d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == n - <span class=\"number\">1</span>) bsum[i] = d[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> bsum[i] = bsum[i + <span class=\"number\">1</span>] + d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>, j = n - <span class=\"number\">1</span>; i &lt; n;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt;= j) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(psum[i] == bsum[j])&#123;</span><br><span class=\"line\">            vec.push_back(psum[i]);</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(psum[i] &lt; bsum[j]) i++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(psum[i] &gt; bsum[j]) j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vec.size() != <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, vec[vec.size() - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"0\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Graph Theory-The shortest path","date":"2018-09-07T11:57:58.000Z","_content":"$Bellman-Ford、SPFA、Dijkstra$这些单源最短路算法自己一直都在用，但有时候只是需要的时候拿出来当板子敲上去，没有什么深刻的理解，今天花了一下午把这些算法的原理和一些细节基本搞通了，总结一下。\n<!--more-->\n$PS：Floyd-Warshall$多源最短路算法受限于自己对DP的理解，还没有完全搞明白= =，之后再来填坑。\n*Bellman-Ford代码、Dijkstra理解和代码部分参考自《挑战程序设计竞赛》。*\n## 限制和复杂度\n$Bellman-Ford$：不含负圈（可判断出）。运行时间：$O(|V|\\*|E|)$。\n$SPFA$：不含负圈（可判断出）。运行时间：$O(k\\*|E|)$，一般情况下$(k <<|V|)$，可以认为近似线性。\n$Dijkstra$：不含负权边。运行时间：$O(|E|\\*|log|V|)$（优先队列实现）\n## Bellman-Ford\n$Bellman-Ford$算法思想是更新所有的边，每条边都更新$|V|-1$次，由于多余的更新操作是无害的，所有算法可以求得最短路，但同时不可避免的有复杂度冗余的问题。\n先说一下为什么是更新$|V|-1$次：\n首先每一个节点$v$都有一条相对于起点$s$的最短路，因为最短路是简单路径不包含环（如果是负环，最短路不存在；如果是正环，去掉后变短；如果是零环，去掉后不变），所以节点总数为$|V|$的情况下最长的那条最短路的长度不会超过$|V|-1$，又因为每更新一次都必然会确定最短路径上的一条线段，所以最多只需要更新$|V|-1$次，反之，如果更新次数超过$|V|-1$次则说明图中有负环最短路不存在，可以利用这一点来判断图中是否有负环。\n关于“每更新一次都必然会确定最短路径上的一条线段“的进一步解释：\n![graph](/gra.png)\n以上图为例，假设上图中的最长的一条最短路为$A->F$的最短路\n![path](/path.png)\n从原点$A$开始出发，每次进行所有边的更新，第一次更新结束后$A->B$的最短路确定，第二次更新结束后$A->C$的最短路确定，以此类推四次后这条最长的最短路确定。因为这条最短路是最长的，所以在它确定时其它较短的最短路也肯定已经确定。所以在至多$|V|-1$次更新后$Bellman-Ford$算法可以找到任意一条最短路。\n\n$Bellman-Ford$代码：\n```C++\n//从顶点from指向顶点to的权值为cost的边\nstruct edge{\n    int from;\n    int to;\n    int cost;\n};\n\nedge es[MAX_E]; //边\n\nint d[MAX_V];   //最短距离\nint V, E;       //顶点数和边数\n\n//求解从顶点s出发到所有点的最短距离\nvoid short_path(int s){\n    fill(d, d + V, INF);\n    d[s] = 0;\n    while(true){\n        bool update = false;\n        for(int i = 0; i < E; i++){\n            edge e = es[i];\n            if(d[e.from] != INF && d[e.to] > d[e.from] + e.cost){\n                d[e.to] = d[e.from] + e.cost;\n                update = true;\n            }\n        }\n        if(!update) break;\n    }\n}\n```\n## SPFA\n$SPFA$算法可以用一句话概括：”只有被更新了的节点才有资格更新其它节点“。因为如果一个节点自身没有被更新的话，那用它更新与它相邻的其它节点也不会产生新的结果。它用队列来维护那些被更新了节点。值得注意的是虽然一般情况来说$SPFA$的复杂度接近线性，但它不稳定，可以构造出特殊的图使得SPFA的复杂度变为和$Bellman-Ford$一样。\n\n$SPFA$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\n\nvector<edge> G[MAX_V];  //邻接表\n\nint d[MAX_V];\nbool vis[MAX_V];\n\nvoid spfa(int s) \n{\n    queue<int> q;\n    memset(vis, 0, sizeof(vis));\n    fill(d, d + V, INF);\n    d[s] = 0;\n    q.push(s);\n    vis[s] = true;\n    while (!q.empty()) \n    {\n        int v = q.front(); \n        q.pop(); \n        vis[v] = false;\n        for(int i = 0; i < G[v].size(); i++)\n        {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) \n            {\n                d[e.to] = d[v] + e.cost;\n                if (!vis[e.to])\n                {\n                    vis[e.to] = true;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n}\n```\n## Dijkstra\n考虑没有负边的情况。在$Bellman-Ford$算法中，如果$d[i]$还不是最短距离的话，那么即使进行$d[j]=d[i]+l(i, j)$的更新，$d[j]$也不会变成最短距离。而且，即使$d[i]$没有变化，每一次循环也要检查一遍从$i$出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改：\n1. 找到最短距离已经确定的顶点，从它出发更新相邻的顶点的最短距离。\n2. 此后不需要再关心$1$中的”最短距离已经确定的顶点“。\n\n在$1$和$2$中提到的”最短距离已经确定的顶点“要怎么得到是问题的关键。在最开始时，只有起点的最短距离是确定的。而在尚未使用过的顶点中，距离$d[i]$最小的顶点就是已经确定的顶点。这是因为由于不存在负边，所以$d[i]$不会在之后的更新中变小。\n\n$Dijkstra$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s){\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d, d + V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;    //v点的距离已被更新为更小的值，队列中的值丢弃\n        for(int i = 0; i < G[v].size(); i++){\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost){\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n```\n","source":"_posts/Graph-Theory-The-shortest-path.md","raw":"---\ntitle: Graph Theory-The shortest path\ndate: 2018-09-07 19:57:58\ncategories:\n- Summary\ntags:\n- 图论\n---\n$Bellman-Ford、SPFA、Dijkstra$这些单源最短路算法自己一直都在用，但有时候只是需要的时候拿出来当板子敲上去，没有什么深刻的理解，今天花了一下午把这些算法的原理和一些细节基本搞通了，总结一下。\n<!--more-->\n$PS：Floyd-Warshall$多源最短路算法受限于自己对DP的理解，还没有完全搞明白= =，之后再来填坑。\n*Bellman-Ford代码、Dijkstra理解和代码部分参考自《挑战程序设计竞赛》。*\n## 限制和复杂度\n$Bellman-Ford$：不含负圈（可判断出）。运行时间：$O(|V|\\*|E|)$。\n$SPFA$：不含负圈（可判断出）。运行时间：$O(k\\*|E|)$，一般情况下$(k <<|V|)$，可以认为近似线性。\n$Dijkstra$：不含负权边。运行时间：$O(|E|\\*|log|V|)$（优先队列实现）\n## Bellman-Ford\n$Bellman-Ford$算法思想是更新所有的边，每条边都更新$|V|-1$次，由于多余的更新操作是无害的，所有算法可以求得最短路，但同时不可避免的有复杂度冗余的问题。\n先说一下为什么是更新$|V|-1$次：\n首先每一个节点$v$都有一条相对于起点$s$的最短路，因为最短路是简单路径不包含环（如果是负环，最短路不存在；如果是正环，去掉后变短；如果是零环，去掉后不变），所以节点总数为$|V|$的情况下最长的那条最短路的长度不会超过$|V|-1$，又因为每更新一次都必然会确定最短路径上的一条线段，所以最多只需要更新$|V|-1$次，反之，如果更新次数超过$|V|-1$次则说明图中有负环最短路不存在，可以利用这一点来判断图中是否有负环。\n关于“每更新一次都必然会确定最短路径上的一条线段“的进一步解释：\n![graph](/gra.png)\n以上图为例，假设上图中的最长的一条最短路为$A->F$的最短路\n![path](/path.png)\n从原点$A$开始出发，每次进行所有边的更新，第一次更新结束后$A->B$的最短路确定，第二次更新结束后$A->C$的最短路确定，以此类推四次后这条最长的最短路确定。因为这条最短路是最长的，所以在它确定时其它较短的最短路也肯定已经确定。所以在至多$|V|-1$次更新后$Bellman-Ford$算法可以找到任意一条最短路。\n\n$Bellman-Ford$代码：\n```C++\n//从顶点from指向顶点to的权值为cost的边\nstruct edge{\n    int from;\n    int to;\n    int cost;\n};\n\nedge es[MAX_E]; //边\n\nint d[MAX_V];   //最短距离\nint V, E;       //顶点数和边数\n\n//求解从顶点s出发到所有点的最短距离\nvoid short_path(int s){\n    fill(d, d + V, INF);\n    d[s] = 0;\n    while(true){\n        bool update = false;\n        for(int i = 0; i < E; i++){\n            edge e = es[i];\n            if(d[e.from] != INF && d[e.to] > d[e.from] + e.cost){\n                d[e.to] = d[e.from] + e.cost;\n                update = true;\n            }\n        }\n        if(!update) break;\n    }\n}\n```\n## SPFA\n$SPFA$算法可以用一句话概括：”只有被更新了的节点才有资格更新其它节点“。因为如果一个节点自身没有被更新的话，那用它更新与它相邻的其它节点也不会产生新的结果。它用队列来维护那些被更新了节点。值得注意的是虽然一般情况来说$SPFA$的复杂度接近线性，但它不稳定，可以构造出特殊的图使得SPFA的复杂度变为和$Bellman-Ford$一样。\n\n$SPFA$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\n\nvector<edge> G[MAX_V];  //邻接表\n\nint d[MAX_V];\nbool vis[MAX_V];\n\nvoid spfa(int s) \n{\n    queue<int> q;\n    memset(vis, 0, sizeof(vis));\n    fill(d, d + V, INF);\n    d[s] = 0;\n    q.push(s);\n    vis[s] = true;\n    while (!q.empty()) \n    {\n        int v = q.front(); \n        q.pop(); \n        vis[v] = false;\n        for(int i = 0; i < G[v].size(); i++)\n        {\n            edge e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) \n            {\n                d[e.to] = d[v] + e.cost;\n                if (!vis[e.to])\n                {\n                    vis[e.to] = true;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n}\n```\n## Dijkstra\n考虑没有负边的情况。在$Bellman-Ford$算法中，如果$d[i]$还不是最短距离的话，那么即使进行$d[j]=d[i]+l(i, j)$的更新，$d[j]$也不会变成最短距离。而且，即使$d[i]$没有变化，每一次循环也要检查一遍从$i$出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改：\n1. 找到最短距离已经确定的顶点，从它出发更新相邻的顶点的最短距离。\n2. 此后不需要再关心$1$中的”最短距离已经确定的顶点“。\n\n在$1$和$2$中提到的”最短距离已经确定的顶点“要怎么得到是问题的关键。在最开始时，只有起点的最短距离是确定的。而在尚未使用过的顶点中，距离$d[i]$最小的顶点就是已经确定的顶点。这是因为由于不存在负边，所以$d[i]$不会在之后的更新中变小。\n\n$Dijkstra$代码：\n```C++\nstruct edge{\n    int to;\n    int cost;\n};\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nvoid dijkstra(int s){\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d, d + V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;    //v点的距离已被更新为更小的值，队列中的值丢弃\n        for(int i = 0; i < G[v].size(); i++){\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost){\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n```\n","slug":"Graph-Theory-The-shortest-path","published":1,"updated":"2018-11-13T12:08:00.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrgm000hb8ou8gn1nnul","content":"<p>$Bellman-Ford、SPFA、Dijkstra$这些单源最短路算法自己一直都在用，但有时候只是需要的时候拿出来当板子敲上去，没有什么深刻的理解，今天花了一下午把这些算法的原理和一些细节基本搞通了，总结一下。<br><a id=\"more\"></a><br>$PS：Floyd-Warshall$多源最短路算法受限于自己对DP的理解，还没有完全搞明白= =，之后再来填坑。<br><em>Bellman-Ford代码、Dijkstra理解和代码部分参考自《挑战程序设计竞赛》。</em></p>\n<h2 id=\"限制和复杂度\"><a href=\"#限制和复杂度\" class=\"headerlink\" title=\"限制和复杂度\"></a>限制和复杂度</h2><p>$Bellman-Ford$：不含负圈（可判断出）。运行时间：$O(|V|*|E|)$。<br>$SPFA$：不含负圈（可判断出）。运行时间：$O(k*|E|)$，一般情况下$(k &lt;&lt;|V|)$，可以认为近似线性。<br>$Dijkstra$：不含负权边。运行时间：$O(|E|*|log|V|)$（优先队列实现）</p>\n<h2 id=\"Bellman-Ford\"><a href=\"#Bellman-Ford\" class=\"headerlink\" title=\"Bellman-Ford\"></a>Bellman-Ford</h2><p>$Bellman-Ford$算法思想是更新所有的边，每条边都更新$|V|-1$次，由于多余的更新操作是无害的，所有算法可以求得最短路，但同时不可避免的有复杂度冗余的问题。<br>先说一下为什么是更新$|V|-1$次：<br>首先每一个节点$v$都有一条相对于起点$s$的最短路，因为最短路是简单路径不包含环（如果是负环，最短路不存在；如果是正环，去掉后变短；如果是零环，去掉后不变），所以节点总数为$|V|$的情况下最长的那条最短路的长度不会超过$|V|-1$，又因为每更新一次都必然会确定最短路径上的一条线段，所以最多只需要更新$|V|-1$次，反之，如果更新次数超过$|V|-1$次则说明图中有负环最短路不存在，可以利用这一点来判断图中是否有负环。<br>关于“每更新一次都必然会确定最短路径上的一条线段“的进一步解释：<br><img src=\"/2018/09/07/Graph-Theory-The-shortest-path/gra.png\" alt=\"graph\"><br>以上图为例，假设上图中的最长的一条最短路为$A-&gt;F$的最短路<br><img src=\"/2018/09/07/Graph-Theory-The-shortest-path/path.png\" alt=\"path\"><br>从原点$A$开始出发，每次进行所有边的更新，第一次更新结束后$A-&gt;B$的最短路确定，第二次更新结束后$A-&gt;C$的最短路确定，以此类推四次后这条最长的最短路确定。因为这条最短路是最长的，所以在它确定时其它较短的最短路也肯定已经确定。所以在至多$|V|-1$次更新后$Bellman-Ford$算法可以找到任意一条最短路。</p>\n<p>$Bellman-Ford$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从顶点from指向顶点to的权值为cost的边</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">edge es[MAX_E]; <span class=\"comment\">//边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];   <span class=\"comment\">//最短距离</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> V, E;       <span class=\"comment\">//顶点数和边数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求解从顶点s出发到所有点的最短距离</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">short_path</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span></span>&#123;</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> update = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; E; i++)&#123;</span><br><span class=\"line\">            edge e = es[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[e.from] != INF &amp;&amp; d[e.to] &gt; d[e.from] + e.cost)&#123;</span><br><span class=\"line\">                d[e.to] = d[e.from] + e.cost;</span><br><span class=\"line\">                update = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!update) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"SPFA\"><a href=\"#SPFA\" class=\"headerlink\" title=\"SPFA\"></a>SPFA</h2><p>$SPFA$算法可以用一句话概括：”只有被更新了的节点才有资格更新其它节点“。因为如果一个节点自身没有被更新的话，那用它更新与它相邻的其它节点也不会产生新的结果。它用队列来维护那些被更新了节点。值得注意的是虽然一般情况来说$SPFA$的复杂度接近线性，但它不稳定，可以构造出特殊的图使得SPFA的复杂度变为和$Bellman-Ford$一样。</p>\n<p>$SPFA$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;edge&gt; G[MAX_V];  <span class=\"comment\">//邻接表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[MAX_V];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    q.push(s);</span><br><span class=\"line\">    vis[s] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = q.front(); </span><br><span class=\"line\">        q.pop(); </span><br><span class=\"line\">        vis[v] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[v].size(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            edge e = G[v][i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (d[e.to] &gt; d[v] + e.cost) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                d[e.to] = d[v] + e.cost;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!vis[e.to])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    vis[e.to] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    q.push(e.to);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra\"></a>Dijkstra</h2><p>考虑没有负边的情况。在$Bellman-Ford$算法中，如果$d[i]$还不是最短距离的话，那么即使进行$d[j]=d[i]+l(i, j)$的更新，$d[j]$也不会变成最短距离。而且，即使$d[i]$没有变化，每一次循环也要检查一遍从$i$出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改：</p>\n<ol>\n<li>找到最短距离已经确定的顶点，从它出发更新相邻的顶点的最短距离。</li>\n<li>此后不需要再关心$1$中的”最短距离已经确定的顶点“。</li>\n</ol>\n<p>在$1$和$2$中提到的”最短距离已经确定的顶点“要怎么得到是问题的关键。在最开始时，只有起点的最短距离是确定的。而在尚未使用过的顶点中，距离$d[i]$最小的顶点就是已经确定的顶点。这是因为由于不存在负边，所以$d[i]$不会在之后的更新中变小。</p>\n<p>$Dijkstra$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> V;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;edge&gt; G[MAX_V];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;P, <span class=\"built_in\">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    que.push(P(<span class=\"number\">0</span>, s));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        P p = que.top();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = p.second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[v] &lt; p.first) <span class=\"keyword\">continue</span>;    <span class=\"comment\">//v点的距离已被更新为更小的值，队列中的值丢弃</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class=\"line\">            edge e = G[v][i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[e.to] &gt; d[v] + e.cost)&#123;</span><br><span class=\"line\">                d[e.to] = d[v] + e.cost;</span><br><span class=\"line\">                que.push(P(d[e.to], e.to));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>$Bellman-Ford、SPFA、Dijkstra$这些单源最短路算法自己一直都在用，但有时候只是需要的时候拿出来当板子敲上去，没有什么深刻的理解，今天花了一下午把这些算法的原理和一些细节基本搞通了，总结一下。<br></p>","more":"<br>$PS：Floyd-Warshall$多源最短路算法受限于自己对DP的理解，还没有完全搞明白= =，之后再来填坑。<br><em>Bellman-Ford代码、Dijkstra理解和代码部分参考自《挑战程序设计竞赛》。</em><p></p>\n<h2 id=\"限制和复杂度\"><a href=\"#限制和复杂度\" class=\"headerlink\" title=\"限制和复杂度\"></a>限制和复杂度</h2><p>$Bellman-Ford$：不含负圈（可判断出）。运行时间：$O(|V|*|E|)$。<br>$SPFA$：不含负圈（可判断出）。运行时间：$O(k*|E|)$，一般情况下$(k &lt;&lt;|V|)$，可以认为近似线性。<br>$Dijkstra$：不含负权边。运行时间：$O(|E|*|log|V|)$（优先队列实现）</p>\n<h2 id=\"Bellman-Ford\"><a href=\"#Bellman-Ford\" class=\"headerlink\" title=\"Bellman-Ford\"></a>Bellman-Ford</h2><p>$Bellman-Ford$算法思想是更新所有的边，每条边都更新$|V|-1$次，由于多余的更新操作是无害的，所有算法可以求得最短路，但同时不可避免的有复杂度冗余的问题。<br>先说一下为什么是更新$|V|-1$次：<br>首先每一个节点$v$都有一条相对于起点$s$的最短路，因为最短路是简单路径不包含环（如果是负环，最短路不存在；如果是正环，去掉后变短；如果是零环，去掉后不变），所以节点总数为$|V|$的情况下最长的那条最短路的长度不会超过$|V|-1$，又因为每更新一次都必然会确定最短路径上的一条线段，所以最多只需要更新$|V|-1$次，反之，如果更新次数超过$|V|-1$次则说明图中有负环最短路不存在，可以利用这一点来判断图中是否有负环。<br>关于“每更新一次都必然会确定最短路径上的一条线段“的进一步解释：<br><img src=\"/2018/09/07/Graph-Theory-The-shortest-path/gra.png\" alt=\"graph\"><br>以上图为例，假设上图中的最长的一条最短路为$A-&gt;F$的最短路<br><img src=\"/2018/09/07/Graph-Theory-The-shortest-path/path.png\" alt=\"path\"><br>从原点$A$开始出发，每次进行所有边的更新，第一次更新结束后$A-&gt;B$的最短路确定，第二次更新结束后$A-&gt;C$的最短路确定，以此类推四次后这条最长的最短路确定。因为这条最短路是最长的，所以在它确定时其它较短的最短路也肯定已经确定。所以在至多$|V|-1$次更新后$Bellman-Ford$算法可以找到任意一条最短路。</p>\n<p>$Bellman-Ford$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从顶点from指向顶点to的权值为cost的边</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">edge es[MAX_E]; <span class=\"comment\">//边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];   <span class=\"comment\">//最短距离</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> V, E;       <span class=\"comment\">//顶点数和边数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求解从顶点s出发到所有点的最短距离</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">short_path</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span></span>&#123;</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> update = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; E; i++)&#123;</span><br><span class=\"line\">            edge e = es[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[e.from] != INF &amp;&amp; d[e.to] &gt; d[e.from] + e.cost)&#123;</span><br><span class=\"line\">                d[e.to] = d[e.from] + e.cost;</span><br><span class=\"line\">                update = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!update) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"SPFA\"><a href=\"#SPFA\" class=\"headerlink\" title=\"SPFA\"></a>SPFA</h2><p>$SPFA$算法可以用一句话概括：”只有被更新了的节点才有资格更新其它节点“。因为如果一个节点自身没有被更新的话，那用它更新与它相邻的其它节点也不会产生新的结果。它用队列来维护那些被更新了节点。值得注意的是虽然一般情况来说$SPFA$的复杂度接近线性，但它不稳定，可以构造出特殊的图使得SPFA的复杂度变为和$Bellman-Ford$一样。</p>\n<p>$SPFA$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;edge&gt; G[MAX_V];  <span class=\"comment\">//邻接表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[MAX_V];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">spfa</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    q.push(s);</span><br><span class=\"line\">    vis[s] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = q.front(); </span><br><span class=\"line\">        q.pop(); </span><br><span class=\"line\">        vis[v] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[v].size(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            edge e = G[v][i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (d[e.to] &gt; d[v] + e.cost) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                d[e.to] = d[v] + e.cost;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!vis[e.to])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    vis[e.to] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    q.push(e.to);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra\"></a>Dijkstra</h2><p>考虑没有负边的情况。在$Bellman-Ford$算法中，如果$d[i]$还不是最短距离的话，那么即使进行$d[j]=d[i]+l(i, j)$的更新，$d[j]$也不会变成最短距离。而且，即使$d[i]$没有变化，每一次循环也要检查一遍从$i$出发的所有边。这显然是很浪费时间的。因此可以对算法做如下修改：</p>\n<ol>\n<li>找到最短距离已经确定的顶点，从它出发更新相邻的顶点的最短距离。</li>\n<li>此后不需要再关心$1$中的”最短距离已经确定的顶点“。</li>\n</ol>\n<p>在$1$和$2$中提到的”最短距离已经确定的顶点“要怎么得到是问题的关键。在最开始时，只有起点的最短距离是确定的。而在尚未使用过的顶点中，距离$d[i]$最小的顶点就是已经确定的顶点。这是因为由于不存在负边，所以$d[i]$不会在之后的更新中变小。</p>\n<p>$Dijkstra$代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> V;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;edge&gt; G[MAX_V];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAX_V];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;P, <span class=\"built_in\">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class=\"line\">    fill(d, d + V, INF);</span><br><span class=\"line\">    d[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    que.push(P(<span class=\"number\">0</span>, s));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        P p = que.top();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = p.second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[v] &lt; p.first) <span class=\"keyword\">continue</span>;    <span class=\"comment\">//v点的距离已被更新为更小的值，队列中的值丢弃</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class=\"line\">            edge e = G[v][i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[e.to] &gt; d[v] + e.cost)&#123;</span><br><span class=\"line\">                d[e.to] = d[v] + e.cost;</span><br><span class=\"line\">                que.push(P(d[e.to], e.to));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"CodeForces-569A-Music","date":"2018-08-28T07:15:59.000Z","_content":"也是一道思维题，理解了题意就很简单，但是自己理解题意费了好长时间，，还好最后AC了，背景故事蛮有意思的2333.\n<!--more-->\n## 链接\n[CodeForces-569A-Music](http://codeforces.com/problemset/problem/569/A)\n## 题意\n下载一首时长为$T$的歌，首先下载$S$秒，然后边下载边播放，播放到还未下载的位置就立即返回歌的开头重新播放，求需要返回几次才能最终完整听完这首歌。歌的下载速率为每经过$q$秒下载$q - 1$秒的歌。\n## 题解\n一开始没有理解歌的下载速率的问题，是每经过$q$秒直接得到$q - 1$秒的歌，还是在$q$秒内一直在下载，最后累计得到$q-1$秒的歌，看了样例后发现是第二种，（好像也第二种也更符合实际）。平均每秒的下载速率是$(q-1)/q$，这不是一个整数，甚至很可能是无理数，那结果很可能就不精确了，尤其是最后刚好下载完也刚刚听完的那种情况，会多算或者少算一次，所以不能求出平均下载速率然后来模拟计算。\n然后想到了一种思路，因为听的速率是大于下载的速率的，所以考虑最开始下载的$S$秒，求出这$S$秒被消耗完的时间$t$，$$t = \\frac{S}{1 - \\frac{q - 1}{q}}$$化简得$$t = S * q$$同时$t$也表示在这一时刻，听歌的进度正好赶上了下载的速度，此时判断$t$是否大于等于$T$，若大于等于则表示歌已下载完成，否则需返回歌的开头重新播放（此时的$S$更新为$t$，因为已下载的进度现在是$t$）。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 27 Aug 13:48:09 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long T, S, q;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    cin >> T >> S >> q;\n    while(1){\n        if(S * q >= T) break;\n        else{\n            S = S * q;\n            cnt++;\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}\n```","source":"_posts/CodeForces-569A.md","raw":"---\ntitle: 'CodeForces-569A-Music'\ndate: 2018-08-28 15:15:59\ncategories:\n- ACM\n- 思维\ntags:\n- 思维\n---\n也是一道思维题，理解了题意就很简单，但是自己理解题意费了好长时间，，还好最后AC了，背景故事蛮有意思的2333.\n<!--more-->\n## 链接\n[CodeForces-569A-Music](http://codeforces.com/problemset/problem/569/A)\n## 题意\n下载一首时长为$T$的歌，首先下载$S$秒，然后边下载边播放，播放到还未下载的位置就立即返回歌的开头重新播放，求需要返回几次才能最终完整听完这首歌。歌的下载速率为每经过$q$秒下载$q - 1$秒的歌。\n## 题解\n一开始没有理解歌的下载速率的问题，是每经过$q$秒直接得到$q - 1$秒的歌，还是在$q$秒内一直在下载，最后累计得到$q-1$秒的歌，看了样例后发现是第二种，（好像也第二种也更符合实际）。平均每秒的下载速率是$(q-1)/q$，这不是一个整数，甚至很可能是无理数，那结果很可能就不精确了，尤其是最后刚好下载完也刚刚听完的那种情况，会多算或者少算一次，所以不能求出平均下载速率然后来模拟计算。\n然后想到了一种思路，因为听的速率是大于下载的速率的，所以考虑最开始下载的$S$秒，求出这$S$秒被消耗完的时间$t$，$$t = \\frac{S}{1 - \\frac{q - 1}{q}}$$化简得$$t = S * q$$同时$t$也表示在这一时刻，听歌的进度正好赶上了下载的速度，此时判断$t$是否大于等于$T$，若大于等于则表示歌已下载完成，否则需返回歌的开头重新播放（此时的$S$更新为$t$，因为已下载的进度现在是$t$）。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 27 Aug 13:48:09 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long T, S, q;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    cin >> T >> S >> q;\n    while(1){\n        if(S * q >= T) break;\n        else{\n            S = S * q;\n            cnt++;\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}\n```","slug":"CodeForces-569A","published":1,"updated":"2018-12-14T13:07:38.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrgn000ib8ouv7o0x58t","content":"<p>也是一道思维题，理解了题意就很简单，但是自己理解题意费了好长时间，，还好最后AC了，背景故事蛮有意思的2333.<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/problemset/problem/569/A\" target=\"_blank\" rel=\"noopener\">CodeForces-569A-Music</a></p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>下载一首时长为$T$的歌，首先下载$S$秒，然后边下载边播放，播放到还未下载的位置就立即返回歌的开头重新播放，求需要返回几次才能最终完整听完这首歌。歌的下载速率为每经过$q$秒下载$q - 1$秒的歌。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一开始没有理解歌的下载速率的问题，是每经过$q$秒直接得到$q - 1$秒的歌，还是在$q$秒内一直在下载，最后累计得到$q-1$秒的歌，看了样例后发现是第二种，（好像也第二种也更符合实际）。平均每秒的下载速率是$(q-1)/q$，这不是一个整数，甚至很可能是无理数，那结果很可能就不精确了，尤其是最后刚好下载完也刚刚听完的那种情况，会多算或者少算一次，所以不能求出平均下载速率然后来模拟计算。<br>然后想到了一种思路，因为听的速率是大于下载的速率的，所以考虑最开始下载的$S$秒，求出这$S$秒被消耗完的时间$t$，$$t = \\frac{S}{1 - \\frac{q - 1}{q}}$$化简得$$t = S * q$$同时$t$也表示在这一时刻，听歌的进度正好赶上了下载的速度，此时判断$t$是否大于等于$T$，若大于等于则表示歌已下载完成，否则需返回歌的开头重新播放（此时的$S$更新为$t$，因为已下载的进度现在是$t$）。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon 27 Aug 13:48:09 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> T, S, q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; T &gt;&gt; S &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S * q &gt;= T) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            S = S * q;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; cnt &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>也是一道思维题，理解了题意就很简单，但是自己理解题意费了好长时间，，还好最后AC了，背景故事蛮有意思的2333.<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://codeforces.com/problemset/problem/569/A\" target=\"_blank\" rel=\"noopener\">CodeForces-569A-Music</a></p>\n<h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>下载一首时长为$T$的歌，首先下载$S$秒，然后边下载边播放，播放到还未下载的位置就立即返回歌的开头重新播放，求需要返回几次才能最终完整听完这首歌。歌的下载速率为每经过$q$秒下载$q - 1$秒的歌。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一开始没有理解歌的下载速率的问题，是每经过$q$秒直接得到$q - 1$秒的歌，还是在$q$秒内一直在下载，最后累计得到$q-1$秒的歌，看了样例后发现是第二种，（好像也第二种也更符合实际）。平均每秒的下载速率是$(q-1)/q$，这不是一个整数，甚至很可能是无理数，那结果很可能就不精确了，尤其是最后刚好下载完也刚刚听完的那种情况，会多算或者少算一次，所以不能求出平均下载速率然后来模拟计算。<br>然后想到了一种思路，因为听的速率是大于下载的速率的，所以考虑最开始下载的$S$秒，求出这$S$秒被消耗完的时间$t$，$$t = \\frac{S}{1 - \\frac{q - 1}{q}}$$化简得$$t = S * q$$同时$t$也表示在这一时刻，听歌的进度正好赶上了下载的速度，此时判断$t$是否大于等于$T$，若大于等于则表示歌已下载完成，否则需返回歌的开头重新播放（此时的$S$更新为$t$，因为已下载的进度现在是$t$）。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon 27 Aug 13:48:09 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> T, S, q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; T &gt;&gt; S &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S * q &gt;= T) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            S = S * q;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; cnt &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"HDU1016-Prime Ring Problem-DFS","date":"2018-08-12T15:16:27.000Z","_content":"渐渐对深搜类的题有了自信, 虽然还只能做一些简单的题, 但是感觉还不错٩('ω')و .\n题目描述：由$1-n$这$n$个自然数组成一个环,要求任意相邻两数之和为素数, 按顺序输出这些数.\n<!-- more -->\n## 链接\n[HDU1016-Prime Ring Problem](http://acm.hdu.edu.cn/showproblem.php?pid=1016)\n## 原题\nA ring is compose of $n$ circles as shown in diagram. Put natural number $1, 2,...,n$ into each circle separately, and the sum of numbers in two adjacent circles should be a prime.\nNote: the number of first circle should always be 1.\n![example](/dfs.png)\n## 题解\nDFS遍历每一种情况.\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 12 Aug 22:10:25 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n;\nvector<int> vec;\nbool vis[maxn];\n\nvoid ans_print(){\n    int cnt = 1;\n    for(auto x : vec){\n        if(cnt == 1) cout << x;\n        else cout << \" \" << x;\n        cnt++;\n    }\n    cout << endl;\n}\n\nbool is_prime(int x){\n    if(x < 2) return false;\n    int tmp = sqrt(x);\n    for(int i = 2; i <= tmp; i++){\n        if(!(x % i)) return false;\n    }\n    return true;\n}\n\nvoid dfs(int dep){\n    if(dep == n - 1){\n        for(int i = 2; i <= n; i++){\n            if(!vis[i] && is_prime(i + vec[dep - 1]) && is_prime(i + 1)){\n                vec.push_back(i);\n                ans_print();\n                vec.pop_back();\n            }\n        }\n        return;\n    }\n    for(int i = 2; i <= n; i++){\n        if(!vis[i] && is_prime(i + vec[dep - 1])){\n            vec.push_back(i);\n            vis[i] = 1;\n            dfs(dep + 1);\n            vec.pop_back();\n            vis[i] = 0;\n        }\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    while(cin >> n){\n        vec.clear();\n        memset(vis, 0, sizeof(0));\n        printf(\"Case %d:\\n\", cnt++);\n        vec.push_back(1);\n        vis[1] = 1;\n        dfs(1);\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/HDU1016-Prime-Ring-Problem-DFS.md","raw":"---\ntitle: HDU1016-Prime Ring Problem-DFS\ndate: 2018-08-12 23:16:27\ncategories:\n- ACM\n- DFS\ntags:\n- DFS\n---\n渐渐对深搜类的题有了自信, 虽然还只能做一些简单的题, 但是感觉还不错٩('ω')و .\n题目描述：由$1-n$这$n$个自然数组成一个环,要求任意相邻两数之和为素数, 按顺序输出这些数.\n<!-- more -->\n## 链接\n[HDU1016-Prime Ring Problem](http://acm.hdu.edu.cn/showproblem.php?pid=1016)\n## 原题\nA ring is compose of $n$ circles as shown in diagram. Put natural number $1, 2,...,n$ into each circle separately, and the sum of numbers in two adjacent circles should be a prime.\nNote: the number of first circle should always be 1.\n![example](/dfs.png)\n## 题解\nDFS遍历每一种情况.\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 12 Aug 22:10:25 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n;\nvector<int> vec;\nbool vis[maxn];\n\nvoid ans_print(){\n    int cnt = 1;\n    for(auto x : vec){\n        if(cnt == 1) cout << x;\n        else cout << \" \" << x;\n        cnt++;\n    }\n    cout << endl;\n}\n\nbool is_prime(int x){\n    if(x < 2) return false;\n    int tmp = sqrt(x);\n    for(int i = 2; i <= tmp; i++){\n        if(!(x % i)) return false;\n    }\n    return true;\n}\n\nvoid dfs(int dep){\n    if(dep == n - 1){\n        for(int i = 2; i <= n; i++){\n            if(!vis[i] && is_prime(i + vec[dep - 1]) && is_prime(i + 1)){\n                vec.push_back(i);\n                ans_print();\n                vec.pop_back();\n            }\n        }\n        return;\n    }\n    for(int i = 2; i <= n; i++){\n        if(!vis[i] && is_prime(i + vec[dep - 1])){\n            vec.push_back(i);\n            vis[i] = 1;\n            dfs(dep + 1);\n            vec.pop_back();\n            vis[i] = 0;\n        }\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    while(cin >> n){\n        vec.clear();\n        memset(vis, 0, sizeof(0));\n        printf(\"Case %d:\\n\", cnt++);\n        vec.push_back(1);\n        vis[1] = 1;\n        dfs(1);\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n","slug":"HDU1016-Prime-Ring-Problem-DFS","published":1,"updated":"2018-12-14T13:08:39.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrm3000qb8oulspat00t","content":"<p>渐渐对深搜类的题有了自信, 虽然还只能做一些简单的题, 但是感觉还不错٩(‘ω’)و .<br>题目描述：由$1-n$这$n$个自然数组成一个环,要求任意相邻两数之和为素数, 按顺序输出这些数.<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1016\" target=\"_blank\" rel=\"noopener\">HDU1016-Prime Ring Problem</a></p>\n<h2 id=\"原题\"><a href=\"#原题\" class=\"headerlink\" title=\"原题\"></a>原题</h2><p>A ring is compose of $n$ circles as shown in diagram. Put natural number $1, 2,…,n$ into each circle separately, and the sum of numbers in two adjacent circles should be a prime.<br>Note: the number of first circle should always be 1.<br><img src=\"/2018/08/12/HDU1016-Prime-Ring-Problem-DFS/dfs.png\" alt=\"example\"></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>DFS遍历每一种情况.</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun 12 Aug 22:10:25 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ans_print</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : vec)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt == <span class=\"number\">1</span>) <span class=\"built_in\">cout</span> &lt;&lt; x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; x;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_prime</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"built_in\">sqrt</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= tmp; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(x % i)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep == n - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[i] &amp;&amp; is_prime(i + vec[dep - <span class=\"number\">1</span>]) &amp;&amp; is_prime(i + <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                vec.push_back(i);</span><br><span class=\"line\">                ans_print();</span><br><span class=\"line\">                vec.pop_back();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i] &amp;&amp; is_prime(i + vec[dep - <span class=\"number\">1</span>]))&#123;</span><br><span class=\"line\">            vec.push_back(i);</span><br><span class=\"line\">            vis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(dep + <span class=\"number\">1</span>);</span><br><span class=\"line\">            vec.pop_back();</span><br><span class=\"line\">            vis[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d:\\n\"</span>, cnt++);</span><br><span class=\"line\">        vec.push_back(<span class=\"number\">1</span>);</span><br><span class=\"line\">        vis[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dfs(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>渐渐对深搜类的题有了自信, 虽然还只能做一些简单的题, 但是感觉还不错٩(‘ω’)و .<br>题目描述：由$1-n$这$n$个自然数组成一个环,要求任意相邻两数之和为素数, 按顺序输出这些数.<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1016\" target=\"_blank\" rel=\"noopener\">HDU1016-Prime Ring Problem</a></p>\n<h2 id=\"原题\"><a href=\"#原题\" class=\"headerlink\" title=\"原题\"></a>原题</h2><p>A ring is compose of $n$ circles as shown in diagram. Put natural number $1, 2,…,n$ into each circle separately, and the sum of numbers in two adjacent circles should be a prime.<br>Note: the number of first circle should always be 1.<br><img src=\"/2018/08/12/HDU1016-Prime-Ring-Problem-DFS/dfs.png\" alt=\"example\"></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>DFS遍历每一种情况.</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun 12 Aug 22:10:25 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ans_print</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : vec)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt == <span class=\"number\">1</span>) <span class=\"built_in\">cout</span> &lt;&lt; x;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; x;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_prime</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"built_in\">sqrt</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= tmp; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(x % i)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep == n - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[i] &amp;&amp; is_prime(i + vec[dep - <span class=\"number\">1</span>]) &amp;&amp; is_prime(i + <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                vec.push_back(i);</span><br><span class=\"line\">                ans_print();</span><br><span class=\"line\">                vec.pop_back();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i] &amp;&amp; is_prime(i + vec[dep - <span class=\"number\">1</span>]))&#123;</span><br><span class=\"line\">            vec.push_back(i);</span><br><span class=\"line\">            vis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(dep + <span class=\"number\">1</span>);</span><br><span class=\"line\">            vec.pop_back();</span><br><span class=\"line\">            vis[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Case %d:\\n\"</span>, cnt++);</span><br><span class=\"line\">        vec.push_back(<span class=\"number\">1</span>);</span><br><span class=\"line\">        vis[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dfs(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"HDU4856-Tunnels-BFS+状态压缩DP","date":"2018-05-16T06:03:19.000Z","_content":"最近的几场训练赛做题的时候发现自己对搜索类、动态规划类的题有些恐惧，导致这些类型的题比赛时基本做不出来。仔细想了一下，是自己的递归部分理解的就不够透彻，导致搜索写不出来，动态规划就更无从下手。之前也找了很多递归理解的文章去看，也做了一些递归的题，但是效果不佳。意识到网上的资料对于递归的理解一般会拿经典的斐波那契数列或汉诺塔来举例，这对于递归的理解确实是有帮助的，但是对于锻炼搜索思维的效果不是太有效，于是决定先恶补一部分搜索类的题。\n这道题是准备西安邀请赛时打的模拟赛做到的题，知识点主要用到了BFS和状态压缩DP，可以当做旅行商问题来做，但是最后不返回起点。由于自己DP比较差，所以搞懂这道题还是花了挺长时间。状态压缩DP部分的实现代码参考大白。\n\nPs：在最后会贴几个自己觉得看到的对递归和动态规划理解比较有帮助的文章链接。\n<!-- more -->\n## 题目链接\n[HDU4856-Tunnels](http://acm.hdu.edu.cn/showproblem.php?pid=4856)\n## 题目描述\n一张城市网格图，城市中有m条快速通道，可以从图中任意位置出发，求访问完所有快速通道所用的最少时间，忽略在快速通道内的时间。\n## 题解\n因为在快速通道内的时间是不计的所以只要到达了一个快速通道的入口就相当于访问完了这一条通道，所以可以构造一张$m×m$的邻接表，其中$d[i][j]$表示从第$i$个通道的出口到第$j$个通道的入口的距离，这一部分直接用BFS就能实现，接下来就可以用旅行商问题的解法求解不重复的访问完所有通道所用的时间。\n有两个与旅行商问题不同需要注意的地方：\n**最后不返回起点**\n**起点位置任意，也就是可以将任意一个通道的入口作为起点**\n解决方法详见代码。\n##代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 18;\nconst int maxm = 18;\nconst int inf = 0x3f3f3f3f;\nchar mp[maxn][maxn];\ntypedef pair<int, int> P;\nP in[maxm];\nP out[maxm];\nint n, m;\nint d[maxn][maxn];\nint sx, sy;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint dis[maxm][maxm];\nint dp[1 <<  maxm][maxm];\n\n//状态压缩DP\nvoid dpsolve(){\n    for(int S = 0; S < 1 << m; S++){\n        fill(dp[S], dp[S] + m, inf);\n    }\n    for(int i = 0; i < m; i++){\n        dp[(1 << m) - 1][i] = 0;//因为起点未定，所以终点在任意一个通道都可以\n    }\n    for(int S = (1 << m) - 2; S >= 0; S--){\n        for(int v = 0; v < m; v++){\n            for(int u = 0; u < m; u++){\n                if(!(S >> u & 1)){\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + dis[v][u]);\n                }\n            }\n        }\n    }\n    int res = inf;\n    for(int i = 0; i < m; i++){\n        res = min(res, dp[1 << i][i]);//判断以不同通道为起点的情况下，哪种用时最短\n    }\n    if(res == inf) printf(\"%d\\n\", -1);\n    else printf(\"%d\\n\", res);\n}\n\n//bfs搜索确定两两通道之间最小距离\nvoid bfs(int sx, int sy){\n    queue<P> que;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            d[i][j] = inf;\n        }\n    }\n    d[sx][sy] = 0;\n    que.push(P(sx, sy));\n\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < n && mp[nx][ny] != '#' && d[nx][ny] == inf){\n\n                d[nx][ny] = d[p.first][p.second] + 1;\n                que.push(P(nx, ny));\n            }\n        }\n\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif // ONLINE_JUDGE\n    while(~scanf(\"%d%d\", &n, &m)){\n        for(int i = 0; i < n; i++){\n            scanf(\"%s\", mp[i]);\n        }\n        for(int i = 0; i < m; i++){\n            scanf(\"%d%d%d%d\", &in[i].first, &in[i].second, &out[i].first, &out[i].second);\n        }\n        //构建邻接表\n        for(int i = 0; i < m; i++){\n            bfs(out[i].first - 1, out[i].second - 1);\n            for(int j = 0; j < m; j++){\n                if(i == j) dis[i][j] = 0;\n                else dis[i][j] = d[in[j].first - 1][in[j].second - 1];\n            }\n        }\n\n        dpsolve();\n    }\n    return 0;\n}\n```\n## 关于递归、动态规划理解的文章链接\n[写递归函数的正确思维方法](https://blog.csdn.net/vagrxie/article/details/8470798)\n[递归算法详解](https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/)\n[怎么更好地终极理解递归算法](https://blog.csdn.net/StruggleShu/article/details/51051140)\n[如何有效地理解程序中的递归](https://blog.csdn.net/qq_34773981/article/details/79225588)\n\n[一道题看清动态规划的前世今生（一）](http://www.importnew.com/27323.html)\n[一道题看清动态规划的前世今生（二）](http://www.importnew.com/27444.html)\n\n最后对这些文章的博主表示感谢！\n","source":"_posts/HDU4856-Tunnels.md","raw":"---\ntitle: HDU4856-Tunnels-BFS+状态压缩DP\ndate: 2018-05-16 14:03:19\ncategories:\n- ACM\n- 动态规划\ntags:\n- HDU\n- 状态压缩DP\n- BFS\n---\n最近的几场训练赛做题的时候发现自己对搜索类、动态规划类的题有些恐惧，导致这些类型的题比赛时基本做不出来。仔细想了一下，是自己的递归部分理解的就不够透彻，导致搜索写不出来，动态规划就更无从下手。之前也找了很多递归理解的文章去看，也做了一些递归的题，但是效果不佳。意识到网上的资料对于递归的理解一般会拿经典的斐波那契数列或汉诺塔来举例，这对于递归的理解确实是有帮助的，但是对于锻炼搜索思维的效果不是太有效，于是决定先恶补一部分搜索类的题。\n这道题是准备西安邀请赛时打的模拟赛做到的题，知识点主要用到了BFS和状态压缩DP，可以当做旅行商问题来做，但是最后不返回起点。由于自己DP比较差，所以搞懂这道题还是花了挺长时间。状态压缩DP部分的实现代码参考大白。\n\nPs：在最后会贴几个自己觉得看到的对递归和动态规划理解比较有帮助的文章链接。\n<!-- more -->\n## 题目链接\n[HDU4856-Tunnels](http://acm.hdu.edu.cn/showproblem.php?pid=4856)\n## 题目描述\n一张城市网格图，城市中有m条快速通道，可以从图中任意位置出发，求访问完所有快速通道所用的最少时间，忽略在快速通道内的时间。\n## 题解\n因为在快速通道内的时间是不计的所以只要到达了一个快速通道的入口就相当于访问完了这一条通道，所以可以构造一张$m×m$的邻接表，其中$d[i][j]$表示从第$i$个通道的出口到第$j$个通道的入口的距离，这一部分直接用BFS就能实现，接下来就可以用旅行商问题的解法求解不重复的访问完所有通道所用的时间。\n有两个与旅行商问题不同需要注意的地方：\n**最后不返回起点**\n**起点位置任意，也就是可以将任意一个通道的入口作为起点**\n解决方法详见代码。\n##代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 18;\nconst int maxm = 18;\nconst int inf = 0x3f3f3f3f;\nchar mp[maxn][maxn];\ntypedef pair<int, int> P;\nP in[maxm];\nP out[maxm];\nint n, m;\nint d[maxn][maxn];\nint sx, sy;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint dis[maxm][maxm];\nint dp[1 <<  maxm][maxm];\n\n//状态压缩DP\nvoid dpsolve(){\n    for(int S = 0; S < 1 << m; S++){\n        fill(dp[S], dp[S] + m, inf);\n    }\n    for(int i = 0; i < m; i++){\n        dp[(1 << m) - 1][i] = 0;//因为起点未定，所以终点在任意一个通道都可以\n    }\n    for(int S = (1 << m) - 2; S >= 0; S--){\n        for(int v = 0; v < m; v++){\n            for(int u = 0; u < m; u++){\n                if(!(S >> u & 1)){\n                    dp[S][v] = min(dp[S][v], dp[S | 1 << u][u] + dis[v][u]);\n                }\n            }\n        }\n    }\n    int res = inf;\n    for(int i = 0; i < m; i++){\n        res = min(res, dp[1 << i][i]);//判断以不同通道为起点的情况下，哪种用时最短\n    }\n    if(res == inf) printf(\"%d\\n\", -1);\n    else printf(\"%d\\n\", res);\n}\n\n//bfs搜索确定两两通道之间最小距离\nvoid bfs(int sx, int sy){\n    queue<P> que;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            d[i][j] = inf;\n        }\n    }\n    d[sx][sy] = 0;\n    que.push(P(sx, sy));\n\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = p.first + dx[i];\n            int ny = p.second + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < n && mp[nx][ny] != '#' && d[nx][ny] == inf){\n\n                d[nx][ny] = d[p.first][p.second] + 1;\n                que.push(P(nx, ny));\n            }\n        }\n\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif // ONLINE_JUDGE\n    while(~scanf(\"%d%d\", &n, &m)){\n        for(int i = 0; i < n; i++){\n            scanf(\"%s\", mp[i]);\n        }\n        for(int i = 0; i < m; i++){\n            scanf(\"%d%d%d%d\", &in[i].first, &in[i].second, &out[i].first, &out[i].second);\n        }\n        //构建邻接表\n        for(int i = 0; i < m; i++){\n            bfs(out[i].first - 1, out[i].second - 1);\n            for(int j = 0; j < m; j++){\n                if(i == j) dis[i][j] = 0;\n                else dis[i][j] = d[in[j].first - 1][in[j].second - 1];\n            }\n        }\n\n        dpsolve();\n    }\n    return 0;\n}\n```\n## 关于递归、动态规划理解的文章链接\n[写递归函数的正确思维方法](https://blog.csdn.net/vagrxie/article/details/8470798)\n[递归算法详解](https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/)\n[怎么更好地终极理解递归算法](https://blog.csdn.net/StruggleShu/article/details/51051140)\n[如何有效地理解程序中的递归](https://blog.csdn.net/qq_34773981/article/details/79225588)\n\n[一道题看清动态规划的前世今生（一）](http://www.importnew.com/27323.html)\n[一道题看清动态规划的前世今生（二）](http://www.importnew.com/27444.html)\n\n最后对这些文章的博主表示感谢！\n","slug":"HDU4856-Tunnels","published":1,"updated":"2018-12-14T13:27:21.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrm8000sb8ouy8nmc4t7","content":"<p>最近的几场训练赛做题的时候发现自己对搜索类、动态规划类的题有些恐惧，导致这些类型的题比赛时基本做不出来。仔细想了一下，是自己的递归部分理解的就不够透彻，导致搜索写不出来，动态规划就更无从下手。之前也找了很多递归理解的文章去看，也做了一些递归的题，但是效果不佳。意识到网上的资料对于递归的理解一般会拿经典的斐波那契数列或汉诺塔来举例，这对于递归的理解确实是有帮助的，但是对于锻炼搜索思维的效果不是太有效，于是决定先恶补一部分搜索类的题。<br>这道题是准备西安邀请赛时打的模拟赛做到的题，知识点主要用到了BFS和状态压缩DP，可以当做旅行商问题来做，但是最后不返回起点。由于自己DP比较差，所以搞懂这道题还是花了挺长时间。状态压缩DP部分的实现代码参考大白。</p>\n<p>Ps：在最后会贴几个自己觉得看到的对递归和动态规划理解比较有帮助的文章链接。<br><a id=\"more\"></a></p>\n<h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4856\" target=\"_blank\" rel=\"noopener\">HDU4856-Tunnels</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>一张城市网格图，城市中有m条快速通道，可以从图中任意位置出发，求访问完所有快速通道所用的最少时间，忽略在快速通道内的时间。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为在快速通道内的时间是不计的所以只要到达了一个快速通道的入口就相当于访问完了这一条通道，所以可以构造一张$m×m$的邻接表，其中$d[i][j]$表示从第$i$个通道的出口到第$j$个通道的入口的距离，这一部分直接用BFS就能实现，接下来就可以用旅行商问题的解法求解不重复的访问完所有通道所用的时间。<br>有两个与旅行商问题不同需要注意的地方：<br><strong>最后不返回起点</strong><br><strong>起点位置任意，也就是可以将任意一个通道的入口作为起点</strong><br>解决方法详见代码。</p>\n<p>##代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxm = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> mp[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\">P in[maxm];</span><br><span class=\"line\">P out[maxm];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sx, sy;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxm][maxm];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">1</span> &lt;&lt;  maxm][maxm];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//状态压缩DP</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dpsolve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> S = <span class=\"number\">0</span>; S &lt; <span class=\"number\">1</span> &lt;&lt; m; S++)&#123;</span><br><span class=\"line\">        fill(dp[S], dp[S] + m, inf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">        dp[(<span class=\"number\">1</span> &lt;&lt; m) - <span class=\"number\">1</span>][i] = <span class=\"number\">0</span>;<span class=\"comment\">//因为起点未定，所以终点在任意一个通道都可以</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> S = (<span class=\"number\">1</span> &lt;&lt; m) - <span class=\"number\">2</span>; S &gt;= <span class=\"number\">0</span>; S--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v = <span class=\"number\">0</span>; v &lt; m; v++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> u = <span class=\"number\">0</span>; u &lt; m; u++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!(S &gt;&gt; u &amp; <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                    dp[S][v] = min(dp[S][v], dp[S | <span class=\"number\">1</span> &lt;&lt; u][u] + dis[v][u]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = inf;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">        res = min(res, dp[<span class=\"number\">1</span> &lt;&lt; i][i]);<span class=\"comment\">//判断以不同通道为起点的情况下，哪种用时最短</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(res == inf) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, res);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//bfs搜索确定两两通道之间最小距离</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> sx, <span class=\"keyword\">int</span> sy)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;P&gt; que;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">            d[i][j] = inf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    d[sx][sy] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    que.push(P(sx, sy));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        P p = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nx = p.first + dx[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ny = p.second + dy[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; n &amp;&amp; mp[nx][ny] != <span class=\"string\">'#'</span> &amp;&amp; d[nx][ny] == inf)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                d[nx][ny] = d[p.first][p.second] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                que.push(P(nx, ny));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// ONLINE_JUDGE</span></span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, mp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>, &amp;in[i].first, &amp;in[i].second, &amp;out[i].first, &amp;out[i].second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//构建邻接表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            bfs(out[i].first - <span class=\"number\">1</span>, out[i].second - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == j) dis[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> dis[i][j] = d[in[j].first - <span class=\"number\">1</span>][in[j].second - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        dpsolve();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关于递归、动态规划理解的文章链接\"><a href=\"#关于递归、动态规划理解的文章链接\" class=\"headerlink\" title=\"关于递归、动态规划理解的文章链接\"></a>关于递归、动态规划理解的文章链接</h2><p><a href=\"https://blog.csdn.net/vagrxie/article/details/8470798\" target=\"_blank\" rel=\"noopener\">写递归函数的正确思维方法</a><br><a href=\"https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/\" target=\"_blank\" rel=\"noopener\">递归算法详解</a><br><a href=\"https://blog.csdn.net/StruggleShu/article/details/51051140\" target=\"_blank\" rel=\"noopener\">怎么更好地终极理解递归算法</a><br><a href=\"https://blog.csdn.net/qq_34773981/article/details/79225588\" target=\"_blank\" rel=\"noopener\">如何有效地理解程序中的递归</a></p>\n<p><a href=\"http://www.importnew.com/27323.html\" target=\"_blank\" rel=\"noopener\">一道题看清动态规划的前世今生（一）</a><br><a href=\"http://www.importnew.com/27444.html\" target=\"_blank\" rel=\"noopener\">一道题看清动态规划的前世今生（二）</a></p>\n<p>最后对这些文章的博主表示感谢！</p>\n","site":{"data":{}},"excerpt":"<p>最近的几场训练赛做题的时候发现自己对搜索类、动态规划类的题有些恐惧，导致这些类型的题比赛时基本做不出来。仔细想了一下，是自己的递归部分理解的就不够透彻，导致搜索写不出来，动态规划就更无从下手。之前也找了很多递归理解的文章去看，也做了一些递归的题，但是效果不佳。意识到网上的资料对于递归的理解一般会拿经典的斐波那契数列或汉诺塔来举例，这对于递归的理解确实是有帮助的，但是对于锻炼搜索思维的效果不是太有效，于是决定先恶补一部分搜索类的题。<br>这道题是准备西安邀请赛时打的模拟赛做到的题，知识点主要用到了BFS和状态压缩DP，可以当做旅行商问题来做，但是最后不返回起点。由于自己DP比较差，所以搞懂这道题还是花了挺长时间。状态压缩DP部分的实现代码参考大白。</p>\n<p>Ps：在最后会贴几个自己觉得看到的对递归和动态规划理解比较有帮助的文章链接。<br></p>","more":"<p></p>\n<h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=4856\" target=\"_blank\" rel=\"noopener\">HDU4856-Tunnels</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>一张城市网格图，城市中有m条快速通道，可以从图中任意位置出发，求访问完所有快速通道所用的最少时间，忽略在快速通道内的时间。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为在快速通道内的时间是不计的所以只要到达了一个快速通道的入口就相当于访问完了这一条通道，所以可以构造一张$m×m$的邻接表，其中$d[i][j]$表示从第$i$个通道的出口到第$j$个通道的入口的距离，这一部分直接用BFS就能实现，接下来就可以用旅行商问题的解法求解不重复的访问完所有通道所用的时间。<br>有两个与旅行商问题不同需要注意的地方：<br><strong>最后不返回起点</strong><br><strong>起点位置任意，也就是可以将任意一个通道的入口作为起点</strong><br>解决方法详见代码。</p>\n<p>##代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxm = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> mp[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\">P in[maxm];</span><br><span class=\"line\">P out[maxm];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sx, sy;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxm][maxm];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">1</span> &lt;&lt;  maxm][maxm];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//状态压缩DP</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dpsolve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> S = <span class=\"number\">0</span>; S &lt; <span class=\"number\">1</span> &lt;&lt; m; S++)&#123;</span><br><span class=\"line\">        fill(dp[S], dp[S] + m, inf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">        dp[(<span class=\"number\">1</span> &lt;&lt; m) - <span class=\"number\">1</span>][i] = <span class=\"number\">0</span>;<span class=\"comment\">//因为起点未定，所以终点在任意一个通道都可以</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> S = (<span class=\"number\">1</span> &lt;&lt; m) - <span class=\"number\">2</span>; S &gt;= <span class=\"number\">0</span>; S--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v = <span class=\"number\">0</span>; v &lt; m; v++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> u = <span class=\"number\">0</span>; u &lt; m; u++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!(S &gt;&gt; u &amp; <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                    dp[S][v] = min(dp[S][v], dp[S | <span class=\"number\">1</span> &lt;&lt; u][u] + dis[v][u]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = inf;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">        res = min(res, dp[<span class=\"number\">1</span> &lt;&lt; i][i]);<span class=\"comment\">//判断以不同通道为起点的情况下，哪种用时最短</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(res == inf) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, res);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//bfs搜索确定两两通道之间最小距离</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"keyword\">int</span> sx, <span class=\"keyword\">int</span> sy)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;P&gt; que;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">            d[i][j] = inf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    d[sx][sy] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    que.push(P(sx, sy));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        P p = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nx = p.first + dx[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ny = p.second + dy[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; n &amp;&amp; mp[nx][ny] != <span class=\"string\">'#'</span> &amp;&amp; d[nx][ny] == inf)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                d[nx][ny] = d[p.first][p.second] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                que.push(P(nx, ny));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// ONLINE_JUDGE</span></span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, mp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>, &amp;in[i].first, &amp;in[i].second, &amp;out[i].first, &amp;out[i].second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//构建邻接表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            bfs(out[i].first - <span class=\"number\">1</span>, out[i].second - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == j) dis[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> dis[i][j] = d[in[j].first - <span class=\"number\">1</span>][in[j].second - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        dpsolve();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关于递归、动态规划理解的文章链接\"><a href=\"#关于递归、动态规划理解的文章链接\" class=\"headerlink\" title=\"关于递归、动态规划理解的文章链接\"></a>关于递归、动态规划理解的文章链接</h2><p><a href=\"https://blog.csdn.net/vagrxie/article/details/8470798\" target=\"_blank\" rel=\"noopener\">写递归函数的正确思维方法</a><br><a href=\"https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/\" target=\"_blank\" rel=\"noopener\">递归算法详解</a><br><a href=\"https://blog.csdn.net/StruggleShu/article/details/51051140\" target=\"_blank\" rel=\"noopener\">怎么更好地终极理解递归算法</a><br><a href=\"https://blog.csdn.net/qq_34773981/article/details/79225588\" target=\"_blank\" rel=\"noopener\">如何有效地理解程序中的递归</a></p>\n<p><a href=\"http://www.importnew.com/27323.html\" target=\"_blank\" rel=\"noopener\">一道题看清动态规划的前世今生（一）</a><br><a href=\"http://www.importnew.com/27444.html\" target=\"_blank\" rel=\"noopener\">一道题看清动态规划的前世今生（二）</a></p>\n<p>最后对这些文章的博主表示感谢！</p>"},{"title":"hdu-5092","date":"2018-06-05T12:28:06.000Z","_content":"","source":"_posts/HDU5092.md","raw":"---\ntitle: hdu-5092\ndate: 2018-06-05 20:28:06\ncategories:\ntags:\n---\n","slug":"HDU5092","published":1,"updated":"2018-06-05T12:28:06.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrmc000vb8oucjtunaw4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"直观理解线性代数-点积","date":"2018-10-24T13:56:50.000Z","_content":"我们都知道两个向量 $\\vec{a}$，$\\vec{b}$ 的点积可以想象为 $\\vec{a}$ 朝 $\\vec{b}$ 方向上的投影长度乘以 $\\vec{b}$ 的长度。其中结果的正负代表方向，两个向量成锐角则大于$0$，成钝角则小于$0$。\n可是为什么可以这样做呢，这要从线性代数的本质说起。致敬[3Blue1Brown](http://www.3blue1brown.com/)，一个热爱数学，并教你如何从直观上去理解数学的团队，将只停留在数值运算和公式的线性代数推进到可视化几何直观的领悟上，在B站上可以找到搬运的系列视频[线性代数的本质](https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8)。\n<!-- more -->\n```\n卡尔文：你知道吗，我觉得数学不是一门科学，而是一种宗教\n霍布斯：一种宗教？\n卡尔文：是啊。这些公式就像奇迹一般。你取出两个数，把它们相加时，它们神奇地成为了一个全新\n的数！没人能说清这到底是怎么发生的。你要么完全相信，要么完全不信。\n```\n## 点积与投影\n视频里关于点积和投影对应的那一部分个人觉得不太好理解，自己也花了挺久才理解，在这里记录一下，并提供一种理解方式。\n***以下图片均来自3Blue1Brown发布的线性代数的本质系列视频，直接来源为[Go Further的博客](https://charlesliuyx.github.io/2017/10/06/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/#%E7%82%B9%E7%A7%AF%E4%B8%8E%E5%AF%B9%E5%81%B6%E6%80%A7)***\n\n**首先来看点积的运算：**\n两个维数相同的向量做点积，就是把他们对应坐标相乘再相加。\n<div style=\"width: 300px; margin: auto\">\n    ![1.gif](/1.gif)\n</div>\n我们假设图中的两个向量分别为 $\\vec{a}$ 和 $\\vec{b}$， 我们可以发现点积的运算和将向量 $\\vec{a}$ 转置为 $1*4$ 的矩阵再和 $\\vec{b}$ 做相乘的结果是一样的。从这里入手我们来分析一下矩阵相乘和投影的关系。\n**投影：**\n任取坐标系中的一条直线作为投影直线，同时在这条直线上取一个单位向量 $\\vec{u}$，设它的坐标为$(u_x，u_y)$。\n<div style=\"width: 500px; margin: auto\">\n    ![2.gif](/2.gif)\n</div>\n投影是一种线性变换，矩阵的意义就是表示线性变换，所以这个二维空间中的任意一个向量在这条直线上的投影变换都可以用一个矩阵表示出来，至于这个矩阵是什么，我们只需要考虑基向量的变换。(***至于为什么矩阵的意义是线性变换以及为什么用矩阵描述一个变换只需要考虑基向量的变换请移步[线性代数的本质](https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8)***)\n<div style=\"width: 500px; margin: auto\">\n    ![3.gif](/3.gif)\n</div>\n上图运用对称性得到基向量 $\\vec{i}$ 和 $\\vec{j}$ 在直线上的投影分别为$u_x$ 和 $u_y$，所以这个投影变换的矩阵也就是\n$$\n \\begin{bmatrix}\n   u_x & u_y\n  \\end{bmatrix}\n$$\n所以二维空间中任一向量 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 在单位向量 $\\vec{u}$ 所在直线上的投影值为\n$$\n \\left[\n \\begin{matrix}\n   u_x & u_y\n  \\end{matrix}\n  \\right]\n  \\left[\n  \\begin{matrix}\n   x \\\\\\\\\n   y\n  \\end{matrix}\n  \\right]\n$$\n**把矩阵$\\begin{bmatrix} u_x & u_y \\end{bmatrix}$转置一下，就变成了点积的定义，这也就是为什么向量的点积可以和几何投影对应起来。**\n\n上面是以单位向量 $\\vec{u}$ 为例，如果 $\\vec{u}$ 不是单位向量怎么理解呢？\n其实也很简单，把 $\\vec{u}$ 归一化成单位向量 $\\vec{u_0}$，前面提取出一个系数 $c$，这个系数也就是 $\\vec{u}$ 的长度。那么空间中任意向量 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 和 $\\vec{u}$ 的点积可以先看做 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 和 $\\vec{u_0}$ 的点积，也就是上面的投影过程，最后再乘以 $c$，也就是 $\\vec{u}$ 的长度。\n完美对应。","source":"_posts/Linear algebra-Dot product.md","raw":"---\ntitle: 直观理解线性代数-点积\ndate: 2018-10-24 21:56:50\ncategories:\n- Math\ntags:\n- 总结\n- Liner algebra\n---\n我们都知道两个向量 $\\vec{a}$，$\\vec{b}$ 的点积可以想象为 $\\vec{a}$ 朝 $\\vec{b}$ 方向上的投影长度乘以 $\\vec{b}$ 的长度。其中结果的正负代表方向，两个向量成锐角则大于$0$，成钝角则小于$0$。\n可是为什么可以这样做呢，这要从线性代数的本质说起。致敬[3Blue1Brown](http://www.3blue1brown.com/)，一个热爱数学，并教你如何从直观上去理解数学的团队，将只停留在数值运算和公式的线性代数推进到可视化几何直观的领悟上，在B站上可以找到搬运的系列视频[线性代数的本质](https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8)。\n<!-- more -->\n```\n卡尔文：你知道吗，我觉得数学不是一门科学，而是一种宗教\n霍布斯：一种宗教？\n卡尔文：是啊。这些公式就像奇迹一般。你取出两个数，把它们相加时，它们神奇地成为了一个全新\n的数！没人能说清这到底是怎么发生的。你要么完全相信，要么完全不信。\n```\n## 点积与投影\n视频里关于点积和投影对应的那一部分个人觉得不太好理解，自己也花了挺久才理解，在这里记录一下，并提供一种理解方式。\n***以下图片均来自3Blue1Brown发布的线性代数的本质系列视频，直接来源为[Go Further的博客](https://charlesliuyx.github.io/2017/10/06/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/#%E7%82%B9%E7%A7%AF%E4%B8%8E%E5%AF%B9%E5%81%B6%E6%80%A7)***\n\n**首先来看点积的运算：**\n两个维数相同的向量做点积，就是把他们对应坐标相乘再相加。\n<div style=\"width: 300px; margin: auto\">\n    ![1.gif](/1.gif)\n</div>\n我们假设图中的两个向量分别为 $\\vec{a}$ 和 $\\vec{b}$， 我们可以发现点积的运算和将向量 $\\vec{a}$ 转置为 $1*4$ 的矩阵再和 $\\vec{b}$ 做相乘的结果是一样的。从这里入手我们来分析一下矩阵相乘和投影的关系。\n**投影：**\n任取坐标系中的一条直线作为投影直线，同时在这条直线上取一个单位向量 $\\vec{u}$，设它的坐标为$(u_x，u_y)$。\n<div style=\"width: 500px; margin: auto\">\n    ![2.gif](/2.gif)\n</div>\n投影是一种线性变换，矩阵的意义就是表示线性变换，所以这个二维空间中的任意一个向量在这条直线上的投影变换都可以用一个矩阵表示出来，至于这个矩阵是什么，我们只需要考虑基向量的变换。(***至于为什么矩阵的意义是线性变换以及为什么用矩阵描述一个变换只需要考虑基向量的变换请移步[线性代数的本质](https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8)***)\n<div style=\"width: 500px; margin: auto\">\n    ![3.gif](/3.gif)\n</div>\n上图运用对称性得到基向量 $\\vec{i}$ 和 $\\vec{j}$ 在直线上的投影分别为$u_x$ 和 $u_y$，所以这个投影变换的矩阵也就是\n$$\n \\begin{bmatrix}\n   u_x & u_y\n  \\end{bmatrix}\n$$\n所以二维空间中任一向量 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 在单位向量 $\\vec{u}$ 所在直线上的投影值为\n$$\n \\left[\n \\begin{matrix}\n   u_x & u_y\n  \\end{matrix}\n  \\right]\n  \\left[\n  \\begin{matrix}\n   x \\\\\\\\\n   y\n  \\end{matrix}\n  \\right]\n$$\n**把矩阵$\\begin{bmatrix} u_x & u_y \\end{bmatrix}$转置一下，就变成了点积的定义，这也就是为什么向量的点积可以和几何投影对应起来。**\n\n上面是以单位向量 $\\vec{u}$ 为例，如果 $\\vec{u}$ 不是单位向量怎么理解呢？\n其实也很简单，把 $\\vec{u}$ 归一化成单位向量 $\\vec{u_0}$，前面提取出一个系数 $c$，这个系数也就是 $\\vec{u}$ 的长度。那么空间中任意向量 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 和 $\\vec{u}$ 的点积可以先看做 $\\begin{bmatrix} x \\\\\\\\ y \\end{bmatrix}$ 和 $\\vec{u_0}$ 的点积，也就是上面的投影过程，最后再乘以 $c$，也就是 $\\vec{u}$ 的长度。\n完美对应。","slug":"Linear algebra-Dot product","published":1,"updated":"2018-11-13T12:05:06.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrmf000yb8ou9kwqd76w","content":"<p>我们都知道两个向量 $\\vec{a}$，$\\vec{b}$ 的点积可以想象为 $\\vec{a}$ 朝 $\\vec{b}$ 方向上的投影长度乘以 $\\vec{b}$ 的长度。其中结果的正负代表方向，两个向量成锐角则大于$0$，成钝角则小于$0$。<br>可是为什么可以这样做呢，这要从线性代数的本质说起。致敬<a href=\"http://www.3blue1brown.com/\" target=\"_blank\" rel=\"noopener\">3Blue1Brown</a>，一个热爱数学，并教你如何从直观上去理解数学的团队，将只停留在数值运算和公式的线性代数推进到可视化几何直观的领悟上，在B站上可以找到搬运的系列视频<a href=\"https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8\" target=\"_blank\" rel=\"noopener\">线性代数的本质</a>。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">卡尔文：你知道吗，我觉得数学不是一门科学，而是一种宗教</span><br><span class=\"line\">霍布斯：一种宗教？</span><br><span class=\"line\">卡尔文：是啊。这些公式就像奇迹一般。你取出两个数，把它们相加时，它们神奇地成为了一个全新</span><br><span class=\"line\">的数！没人能说清这到底是怎么发生的。你要么完全相信，要么完全不信。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"点积与投影\"><a href=\"#点积与投影\" class=\"headerlink\" title=\"点积与投影\"></a>点积与投影</h2><p>视频里关于点积和投影对应的那一部分个人觉得不太好理解，自己也花了挺久才理解，在这里记录一下，并提供一种理解方式。<br><strong><em>以下图片均来自3Blue1Brown发布的线性代数的本质系列视频，直接来源为<a href=\"https://charlesliuyx.github.io/2017/10/06/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/#%E7%82%B9%E7%A7%AF%E4%B8%8E%E5%AF%B9%E5%81%B6%E6%80%A7\" target=\"_blank\" rel=\"noopener\">Go Further的博客</a></em></strong></p>\n<p><strong>首先来看点积的运算：</strong><br>两个维数相同的向量做点积，就是把他们对应坐标相乘再相加。</p>\n<p><div style=\"width: 300px; margin: auto\"><br>    <img src=\"/2018/10/24/Linear algebra-Dot product/1.gif\" alt=\"1.gif\"><br></div><br>我们假设图中的两个向量分别为 $\\vec{a}$ 和 $\\vec{b}$， 我们可以发现点积的运算和将向量 $\\vec{a}$ 转置为 $1*4$ 的矩阵再和 $\\vec{b}$ 做相乘的结果是一样的。从这里入手我们来分析一下矩阵相乘和投影的关系。<br><strong>投影：</strong><br>任取坐标系中的一条直线作为投影直线，同时在这条直线上取一个单位向量 $\\vec{u}$，设它的坐标为$(u_x，u_y)$。</p>\n<p><div style=\"width: 500px; margin: auto\"><br>    <img src=\"/2018/10/24/Linear algebra-Dot product/2.gif\" alt=\"2.gif\"><br></div><br>投影是一种线性变换，矩阵的意义就是表示线性变换，所以这个二维空间中的任意一个向量在这条直线上的投影变换都可以用一个矩阵表示出来，至于这个矩阵是什么，我们只需要考虑基向量的变换。(<strong><em>至于为什么矩阵的意义是线性变换以及为什么用矩阵描述一个变换只需要考虑基向量的变换请移步<a href=\"https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8\" target=\"_blank\" rel=\"noopener\">线性代数的本质</a></em></strong>)</p>\n<p><div style=\"width: 500px; margin: auto\"><br>    <img src=\"/2018/10/24/Linear algebra-Dot product/3.gif\" alt=\"3.gif\"><br></div><br>上图运用对称性得到基向量 $\\vec{i}$ 和 $\\vec{j}$ 在直线上的投影分别为$u_x$ 和 $u_y$，所以这个投影变换的矩阵也就是<br>$$<br> \\begin{bmatrix}<br>   u_x &amp; u_y<br>  \\end{bmatrix}<br>$$<br>所以二维空间中任一向量 $\\begin{bmatrix} x \\\\ y \\end{bmatrix}$ 在单位向量 $\\vec{u}$ 所在直线上的投影值为<br>$$<br> \\left[<br> \\begin{matrix}<br>   u_x &amp; u_y<br>  \\end{matrix}<br>  \\right]<br>  \\left[<br>  \\begin{matrix}<br>   x \\\\<br>   y<br>  \\end{matrix}<br>  \\right]<br>$$<br><strong>把矩阵$\\begin{bmatrix} u_x &amp; u_y \\end{bmatrix}$转置一下，就变成了点积的定义，这也就是为什么向量的点积可以和几何投影对应起来。</strong></p>\n<p>上面是以单位向量 $\\vec{u}$ 为例，如果 $\\vec{u}$ 不是单位向量怎么理解呢？<br>其实也很简单，把 $\\vec{u}$ 归一化成单位向量 $\\vec{u_0}$，前面提取出一个系数 $c$，这个系数也就是 $\\vec{u}$ 的长度。那么空间中任意向量 $\\begin{bmatrix} x \\\\ y \\end{bmatrix}$ 和 $\\vec{u}$ 的点积可以先看做 $\\begin{bmatrix} x \\\\ y \\end{bmatrix}$ 和 $\\vec{u_0}$ 的点积，也就是上面的投影过程，最后再乘以 $c$，也就是 $\\vec{u}$ 的长度。<br>完美对应。</p>\n","site":{"data":{}},"excerpt":"<p>我们都知道两个向量 $\\vec{a}$，$\\vec{b}$ 的点积可以想象为 $\\vec{a}$ 朝 $\\vec{b}$ 方向上的投影长度乘以 $\\vec{b}$ 的长度。其中结果的正负代表方向，两个向量成锐角则大于$0$，成钝角则小于$0$。<br>可是为什么可以这样做呢，这要从线性代数的本质说起。致敬<a href=\"http://www.3blue1brown.com/\" target=\"_blank\" rel=\"noopener\">3Blue1Brown</a>，一个热爱数学，并教你如何从直观上去理解数学的团队，将只停留在数值运算和公式的线性代数推进到可视化几何直观的领悟上，在B站上可以找到搬运的系列视频<a href=\"https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8\" target=\"_blank\" rel=\"noopener\">线性代数的本质</a>。<br></p>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">卡尔文：你知道吗，我觉得数学不是一门科学，而是一种宗教</span><br><span class=\"line\">霍布斯：一种宗教？</span><br><span class=\"line\">卡尔文：是啊。这些公式就像奇迹一般。你取出两个数，把它们相加时，它们神奇地成为了一个全新</span><br><span class=\"line\">的数！没人能说清这到底是怎么发生的。你要么完全相信，要么完全不信。</span><br></pre></td></tr></table></figure><p></p>\n<h2 id=\"点积与投影\"><a href=\"#点积与投影\" class=\"headerlink\" title=\"点积与投影\"></a>点积与投影</h2><p>视频里关于点积和投影对应的那一部分个人觉得不太好理解，自己也花了挺久才理解，在这里记录一下，并提供一种理解方式。<br><strong><em>以下图片均来自3Blue1Brown发布的线性代数的本质系列视频，直接来源为<a href=\"https://charlesliuyx.github.io/2017/10/06/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/#%E7%82%B9%E7%A7%AF%E4%B8%8E%E5%AF%B9%E5%81%B6%E6%80%A7\" target=\"_blank\" rel=\"noopener\">Go Further的博客</a></em></strong></p>\n<p><strong>首先来看点积的运算：</strong><br>两个维数相同的向量做点积，就是把他们对应坐标相乘再相加。</p>\n<p><div style=\"width: 300px; margin: auto\"><br>    <img src=\"/2018/10/24/Linear algebra-Dot product/1.gif\" alt=\"1.gif\"><br></div><br>我们假设图中的两个向量分别为 $\\vec{a}$ 和 $\\vec{b}$， 我们可以发现点积的运算和将向量 $\\vec{a}$ 转置为 $1*4$ 的矩阵再和 $\\vec{b}$ 做相乘的结果是一样的。从这里入手我们来分析一下矩阵相乘和投影的关系。<br><strong>投影：</strong><br>任取坐标系中的一条直线作为投影直线，同时在这条直线上取一个单位向量 $\\vec{u}$，设它的坐标为$(u_x，u_y)$。</p>\n<p><div style=\"width: 500px; margin: auto\"><br>    <img src=\"/2018/10/24/Linear algebra-Dot product/2.gif\" alt=\"2.gif\"><br></div><br>投影是一种线性变换，矩阵的意义就是表示线性变换，所以这个二维空间中的任意一个向量在这条直线上的投影变换都可以用一个矩阵表示出来，至于这个矩阵是什么，我们只需要考虑基向量的变换。(<strong><em>至于为什么矩阵的意义是线性变换以及为什么用矩阵描述一个变换只需要考虑基向量的变换请移步<a href=\"https://www.bilibili.com/video/av5977466/?spm_id_from=333.788.videocard.8\" target=\"_blank\" rel=\"noopener\">线性代数的本质</a></em></strong>)</p>\n<p><div style=\"width: 500px; margin: auto\"><br>    <img src=\"/2018/10/24/Linear algebra-Dot product/3.gif\" alt=\"3.gif\"><br></div><br>上图运用对称性得到基向量 $\\vec{i}$ 和 $\\vec{j}$ 在直线上的投影分别为$u_x$ 和 $u_y$，所以这个投影变换的矩阵也就是<br>$$<br> \\begin{bmatrix}<br>   u_x &amp; u_y<br>  \\end{bmatrix}<br>$$<br>所以二维空间中任一向量 $\\begin{bmatrix} x \\\\ y \\end{bmatrix}$ 在单位向量 $\\vec{u}$ 所在直线上的投影值为<br>$$<br> \\left[<br> \\begin{matrix}<br>   u_x &amp; u_y<br>  \\end{matrix}<br>  \\right]<br>  \\left[<br>  \\begin{matrix}<br>   x \\\\<br>   y<br>  \\end{matrix}<br>  \\right]<br>$$<br><strong>把矩阵$\\begin{bmatrix} u_x &amp; u_y \\end{bmatrix}$转置一下，就变成了点积的定义，这也就是为什么向量的点积可以和几何投影对应起来。</strong></p>\n<p>上面是以单位向量 $\\vec{u}$ 为例，如果 $\\vec{u}$ 不是单位向量怎么理解呢？<br>其实也很简单，把 $\\vec{u}$ 归一化成单位向量 $\\vec{u_0}$，前面提取出一个系数 $c$，这个系数也就是 $\\vec{u}$ 的长度。那么空间中任意向量 $\\begin{bmatrix} x \\\\ y \\end{bmatrix}$ 和 $\\vec{u}$ 的点积可以先看做 $\\begin{bmatrix} x \\\\ y \\end{bmatrix}$ 和 $\\vec{u_0}$ 的点积，也就是上面的投影过程，最后再乘以 $c$，也就是 $\\vec{u}$ 的长度。<br>完美对应。</p>"},{"title":"C语言编译器工作原理以及.h和.c文件解析","date":"2018-12-02T04:41:00.000Z","_content":"在进行多文件编程的时候，虽然很多IDE都可以帮我们完成预处理、编译、链接等过程，但深入理解编译器的这几个过程可以避免很多\"undefined\"，\"undeclared\"以及\"redefined\"的问题。而比较好的实践方式是自己写Makefile（IDE实际上完成的就是帮我们弄清文件依赖关系，然后生成一个Makefile，调用编译器去编译链接生成可执行文件）。\n<!--more-->\n## 参考链接\n[C语言中.h和.c文件解析（很精彩）](https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html)\n[Purpose of #ifndef and #define](https://community.arduboy.com/t/purpose-of-ifndef-and-define/3592/2)\n\n## 编译器工作原理\n1.预处理阶段：\n实际上是处理的是\"define\"，\"include\"等宏命令，进行宏替换。例如#include \"xx.h\"实际意思是把当前这一行删掉，把xx.h中的内容原封不动的插入在当前行位置。\n\n2.编译阶段：\n**以.c文件为基本单位进行**，也就是说如果项目中一个.c文件都没有，那么项目无法编译。这一阶段为所有.c文件中的变量、函数分配空间，并将各个全局变量、函数进行符号描述，编译、汇编成二进制码从而生成.o目标文件。\n**需要注意的是这个过程并不关心变量的具体定义和函数的具体实现，只要存在变量和函数的相关声明就可以使得编译通过。**因为只要知道了变量/函数的类型和名字，编译器就知道了该如何使用这个变量/函数。\n\n3.链接阶段:\n**以.o文件为基本单位进行**，主要的工作是重定位各个目标文件的函数、变量。这个过程主要是为上一个编译过程中变量和函数的声明找到他们具体的定义和实现。\n\n*下面是一个具体的解释例子：*\n\nadd.h文件\n```C\n#ifndef _ADD_H\n#define _ADD_H\n\nint add(int a, int b);\n\n#endif\n```\n\nadd.c文件\n```C\n#include \"add.h\"\n\nint add(int a, int b){\n    return a + b;\n}\n```\n\nmain.c文件\n```C\n#include <stdio.h>\n#include \"add.h\"\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n\n1.预处理阶段：编译器会把main.c和add.c中的``#include \"add.h\"``替换成add.h中的全部内容。\n2.编译阶段：为main.c和add.c中的各变量和函数分配内存空间并汇编成目标文件。可以发现在main.c中并没有关于add函数的实现只有由``#include \"add.h\"``替换成的这个函数的声明，但这并不影响编译过程的进行。\n3.链接阶段：经过编译后生成了main.o和add.o文件。因为main.o中用到了add函数但没有它的具体实现，所以编译器会去其它.o文件中寻找该函数的具体实现。在这个例子中.o提供了add函数的具体实现，链接过程顺利进行，生成可执行文件。\n\n**Ps.关于add.h中#ifndef、#define和#endif的解释：**它们的作用是防止头文件在一个.c文件中被重复包含。\n\n*一个具体的例子：*\n\na.h文件\n```C\nstruct Node{\n    int a;\n    int b;\n};\n```\n\nb.h文件\n```C\n#include \"a.h\"\n```\n\nc.h文件\n```C\n#include \"a.h\"\n```\n\nmain.c文件\n```C\n#include <stdio.h>\n#include \"b.h\"\n#include \"c.h\"\n\nint main(){\n    print(\"hello\\n\");\n    return 0;\n}\n```\na.h中有结构体struct Node的定义，b.h和c.h都包含了a.h，main.c中又包含了b.h和c.h这两个头文件。这会导致a.h中的内容被两次复制到main.c中，产生struct Node的重复重复定义错误，而如果a.h遵循下面的格式：\n```C\n#ifndef _A_H\n#define _A_H\n\nstruct Node{\n    int a;\n    int b;\n};\n\n#endif\n```\n那么a.h在main.c中只会被替换一次，这样就避免了头文件的重复包含。\n\n## .h和.c文件解析\n**一般情况下我们在.h文件中进行变量、函数和宏的声明，在.c文件中进行变量和函数的具体实现。**\n但这只是我们默认的一种规范的做法，实际上我们舍弃.h文件，在.c文件中包含变量、函数的声明以及实现也没有问题，但如果在其它.c文件中用#include去包含这个.c文件就会出现问题。\n\n*具体例子：*\n\nadd.c文件\n```C\nint add(int a, int b);\n\nint add(int a, int b){\n    return a + b;\n}\n```\n\nmain.c文件\n```C\n#include \"add.c\"\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n链接过程会出现add函数重复定义的错误，因为编译后生成的main.o和add.o中都含有add函数的具体实现。这种情况下可以对main.c做如下修改:\n```C\nint add(int a, int b);\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n这样编译后生成的main.o文件中便不再包含add函数的实现，而只包含声明。但是如果add.c中的函数很多，以及调用这些函数的.c文件也很多，这样在每个.c文件中手动挨个添加这些函数的声明会十分不方便，**而可以理解为.h文件就是为了声明函数和变量方便而创建的**，因为这样把所有的变量、函数声明都写在.h中，其它.c文件只需要#include相应的.h文件就好。\n\n## 问答专区\n```\nQ：ifndef后面的标识必须是_ADD_H这种头文件名大写加下划线的形式吗？\nA：不必，你可以自定义，这只是一种习惯性写法，因为一个工程中头文件名是不会重复的，所以这样定义的话标识也不会重复。\n\nQ：工程中可以没有.h文件吗？\nA：可以，只是如上所说这样会有很多不方便。\n\nQ：.h文件必须和相应的.c文件同名吗？\nA：不必，但是通常我们都这样做，因为比较这样比较清晰。\n\nQ：头文件必须是.h后缀吗？\nA：不必，因为头文件只是其中的内容被#include宏命令替换，所以.txt、.doc等作为头文件的后缀都可以，但我们习惯用.h作为头文件后缀。\n\nQ：.c文件必须包含自己的.h文件吗？\nA：不一定，在最初解释编译器工作原理的例子中add.c就可以不包含add.h文件，因为add.h中只是对add函数的声明，而add.c不需要这个声明也可以编译通过。\n```","source":"_posts/C语言编译连接过程以及-h和-c文件解析.md","raw":"---\ntitle: C语言编译器工作原理以及.h和.c文件解析\ndate: 2018-12-02 12:41:00\ncategories:\n- Summary\ntags:\n- C语言\n---\n在进行多文件编程的时候，虽然很多IDE都可以帮我们完成预处理、编译、链接等过程，但深入理解编译器的这几个过程可以避免很多\"undefined\"，\"undeclared\"以及\"redefined\"的问题。而比较好的实践方式是自己写Makefile（IDE实际上完成的就是帮我们弄清文件依赖关系，然后生成一个Makefile，调用编译器去编译链接生成可执行文件）。\n<!--more-->\n## 参考链接\n[C语言中.h和.c文件解析（很精彩）](https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html)\n[Purpose of #ifndef and #define](https://community.arduboy.com/t/purpose-of-ifndef-and-define/3592/2)\n\n## 编译器工作原理\n1.预处理阶段：\n实际上是处理的是\"define\"，\"include\"等宏命令，进行宏替换。例如#include \"xx.h\"实际意思是把当前这一行删掉，把xx.h中的内容原封不动的插入在当前行位置。\n\n2.编译阶段：\n**以.c文件为基本单位进行**，也就是说如果项目中一个.c文件都没有，那么项目无法编译。这一阶段为所有.c文件中的变量、函数分配空间，并将各个全局变量、函数进行符号描述，编译、汇编成二进制码从而生成.o目标文件。\n**需要注意的是这个过程并不关心变量的具体定义和函数的具体实现，只要存在变量和函数的相关声明就可以使得编译通过。**因为只要知道了变量/函数的类型和名字，编译器就知道了该如何使用这个变量/函数。\n\n3.链接阶段:\n**以.o文件为基本单位进行**，主要的工作是重定位各个目标文件的函数、变量。这个过程主要是为上一个编译过程中变量和函数的声明找到他们具体的定义和实现。\n\n*下面是一个具体的解释例子：*\n\nadd.h文件\n```C\n#ifndef _ADD_H\n#define _ADD_H\n\nint add(int a, int b);\n\n#endif\n```\n\nadd.c文件\n```C\n#include \"add.h\"\n\nint add(int a, int b){\n    return a + b;\n}\n```\n\nmain.c文件\n```C\n#include <stdio.h>\n#include \"add.h\"\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n\n1.预处理阶段：编译器会把main.c和add.c中的``#include \"add.h\"``替换成add.h中的全部内容。\n2.编译阶段：为main.c和add.c中的各变量和函数分配内存空间并汇编成目标文件。可以发现在main.c中并没有关于add函数的实现只有由``#include \"add.h\"``替换成的这个函数的声明，但这并不影响编译过程的进行。\n3.链接阶段：经过编译后生成了main.o和add.o文件。因为main.o中用到了add函数但没有它的具体实现，所以编译器会去其它.o文件中寻找该函数的具体实现。在这个例子中.o提供了add函数的具体实现，链接过程顺利进行，生成可执行文件。\n\n**Ps.关于add.h中#ifndef、#define和#endif的解释：**它们的作用是防止头文件在一个.c文件中被重复包含。\n\n*一个具体的例子：*\n\na.h文件\n```C\nstruct Node{\n    int a;\n    int b;\n};\n```\n\nb.h文件\n```C\n#include \"a.h\"\n```\n\nc.h文件\n```C\n#include \"a.h\"\n```\n\nmain.c文件\n```C\n#include <stdio.h>\n#include \"b.h\"\n#include \"c.h\"\n\nint main(){\n    print(\"hello\\n\");\n    return 0;\n}\n```\na.h中有结构体struct Node的定义，b.h和c.h都包含了a.h，main.c中又包含了b.h和c.h这两个头文件。这会导致a.h中的内容被两次复制到main.c中，产生struct Node的重复重复定义错误，而如果a.h遵循下面的格式：\n```C\n#ifndef _A_H\n#define _A_H\n\nstruct Node{\n    int a;\n    int b;\n};\n\n#endif\n```\n那么a.h在main.c中只会被替换一次，这样就避免了头文件的重复包含。\n\n## .h和.c文件解析\n**一般情况下我们在.h文件中进行变量、函数和宏的声明，在.c文件中进行变量和函数的具体实现。**\n但这只是我们默认的一种规范的做法，实际上我们舍弃.h文件，在.c文件中包含变量、函数的声明以及实现也没有问题，但如果在其它.c文件中用#include去包含这个.c文件就会出现问题。\n\n*具体例子：*\n\nadd.c文件\n```C\nint add(int a, int b);\n\nint add(int a, int b){\n    return a + b;\n}\n```\n\nmain.c文件\n```C\n#include \"add.c\"\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n链接过程会出现add函数重复定义的错误，因为编译后生成的main.o和add.o中都含有add函数的具体实现。这种情况下可以对main.c做如下修改:\n```C\nint add(int a, int b);\n\nint main(){\n    int a = 1, b = 2;\n    int ans = add(a, b);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n```\n这样编译后生成的main.o文件中便不再包含add函数的实现，而只包含声明。但是如果add.c中的函数很多，以及调用这些函数的.c文件也很多，这样在每个.c文件中手动挨个添加这些函数的声明会十分不方便，**而可以理解为.h文件就是为了声明函数和变量方便而创建的**，因为这样把所有的变量、函数声明都写在.h中，其它.c文件只需要#include相应的.h文件就好。\n\n## 问答专区\n```\nQ：ifndef后面的标识必须是_ADD_H这种头文件名大写加下划线的形式吗？\nA：不必，你可以自定义，这只是一种习惯性写法，因为一个工程中头文件名是不会重复的，所以这样定义的话标识也不会重复。\n\nQ：工程中可以没有.h文件吗？\nA：可以，只是如上所说这样会有很多不方便。\n\nQ：.h文件必须和相应的.c文件同名吗？\nA：不必，但是通常我们都这样做，因为比较这样比较清晰。\n\nQ：头文件必须是.h后缀吗？\nA：不必，因为头文件只是其中的内容被#include宏命令替换，所以.txt、.doc等作为头文件的后缀都可以，但我们习惯用.h作为头文件后缀。\n\nQ：.c文件必须包含自己的.h文件吗？\nA：不一定，在最初解释编译器工作原理的例子中add.c就可以不包含add.h文件，因为add.h中只是对add函数的声明，而add.c不需要这个声明也可以编译通过。\n```","slug":"C语言编译连接过程以及-h和-c文件解析","published":1,"updated":"2018-12-02T23:57:51.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrmk0010b8ou94wu09fu","content":"<p>在进行多文件编程的时候，虽然很多IDE都可以帮我们完成预处理、编译、链接等过程，但深入理解编译器的这几个过程可以避免很多”undefined”，”undeclared”以及”redefined”的问题。而比较好的实践方式是自己写Makefile（IDE实际上完成的就是帮我们弄清文件依赖关系，然后生成一个Makefile，调用编译器去编译链接生成可执行文件）。<br><a id=\"more\"></a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html\" target=\"_blank\" rel=\"noopener\">C语言中.h和.c文件解析（很精彩）</a><br><a href=\"https://community.arduboy.com/t/purpose-of-ifndef-and-define/3592/2\" target=\"_blank\" rel=\"noopener\">Purpose of #ifndef and #define</a></p>\n<h2 id=\"编译器工作原理\"><a href=\"#编译器工作原理\" class=\"headerlink\" title=\"编译器工作原理\"></a>编译器工作原理</h2><p>1.预处理阶段：<br>实际上是处理的是”define”，”include”等宏命令，进行宏替换。例如#include “xx.h”实际意思是把当前这一行删掉，把xx.h中的内容原封不动的插入在当前行位置。</p>\n<p>2.编译阶段：<br><strong>以.c文件为基本单位进行</strong>，也就是说如果项目中一个.c文件都没有，那么项目无法编译。这一阶段为所有.c文件中的变量、函数分配空间，并将各个全局变量、函数进行符号描述，编译、汇编成二进制码从而生成.o目标文件。<br><strong>需要注意的是这个过程并不关心变量的具体定义和函数的具体实现，只要存在变量和函数的相关声明就可以使得编译通过。</strong>因为只要知道了变量/函数的类型和名字，编译器就知道了该如何使用这个变量/函数。</p>\n<p>3.链接阶段:<br><strong>以.o文件为基本单位进行</strong>，主要的工作是重定位各个目标文件的函数、变量。这个过程主要是为上一个编译过程中变量和函数的声明找到他们具体的定义和实现。</p>\n<p><em>下面是一个具体的解释例子：</em></p>\n<p>add.h文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _ADD_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _ADD_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>add.c文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"add.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>main.c文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"add.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = add(a, b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.预处理阶段：编译器会把main.c和add.c中的<code>#include &quot;add.h&quot;</code>替换成add.h中的全部内容。<br>2.编译阶段：为main.c和add.c中的各变量和函数分配内存空间并汇编成目标文件。可以发现在main.c中并没有关于add函数的实现只有由<code>#include &quot;add.h&quot;</code>替换成的这个函数的声明，但这并不影响编译过程的进行。<br>3.链接阶段：经过编译后生成了main.o和add.o文件。因为main.o中用到了add函数但没有它的具体实现，所以编译器会去其它.o文件中寻找该函数的具体实现。在这个例子中.o提供了add函数的具体实现，链接过程顺利进行，生成可执行文件。</p>\n<p><strong>Ps.关于add.h中#ifndef、#define和#endif的解释：</strong>它们的作用是防止头文件在一个.c文件中被重复包含。</p>\n<p><em>一个具体的例子：</em></p>\n<p>a.h文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>b.h文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br></pre></td></tr></table></figure></p>\n<p>c.h文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br></pre></td></tr></table></figure></p>\n<p>main.c文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"c.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    print(<span class=\"string\">\"hello\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>a.h中有结构体struct Node的定义，b.h和c.h都包含了a.h，main.c中又包含了b.h和c.h这两个头文件。这会导致a.h中的内容被两次复制到main.c中，产生struct Node的重复重复定义错误，而如果a.h遵循下面的格式：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _A_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>那么a.h在main.c中只会被替换一次，这样就避免了头文件的重复包含。</p>\n<h2 id=\"h和-c文件解析\"><a href=\"#h和-c文件解析\" class=\"headerlink\" title=\".h和.c文件解析\"></a>.h和.c文件解析</h2><p><strong>一般情况下我们在.h文件中进行变量、函数和宏的声明，在.c文件中进行变量和函数的具体实现。</strong><br>但这只是我们默认的一种规范的做法，实际上我们舍弃.h文件，在.c文件中包含变量、函数的声明以及实现也没有问题，但如果在其它.c文件中用#include去包含这个.c文件就会出现问题。</p>\n<p><em>具体例子：</em></p>\n<p>add.c文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>main.c文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"add.c\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = add(a, b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>链接过程会出现add函数重复定义的错误，因为编译后生成的main.o和add.o中都含有add函数的具体实现。这种情况下可以对main.c做如下修改:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = add(a, b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样编译后生成的main.o文件中便不再包含add函数的实现，而只包含声明。但是如果add.c中的函数很多，以及调用这些函数的.c文件也很多，这样在每个.c文件中手动挨个添加这些函数的声明会十分不方便，<strong>而可以理解为.h文件就是为了声明函数和变量方便而创建的</strong>，因为这样把所有的变量、函数声明都写在.h中，其它.c文件只需要#include相应的.h文件就好。</p>\n<h2 id=\"问答专区\"><a href=\"#问答专区\" class=\"headerlink\" title=\"问答专区\"></a>问答专区</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q：ifndef后面的标识必须是_ADD_H这种头文件名大写加下划线的形式吗？</span><br><span class=\"line\">A：不必，你可以自定义，这只是一种习惯性写法，因为一个工程中头文件名是不会重复的，所以这样定义的话标识也不会重复。</span><br><span class=\"line\"></span><br><span class=\"line\">Q：工程中可以没有.h文件吗？</span><br><span class=\"line\">A：可以，只是如上所说这样会有很多不方便。</span><br><span class=\"line\"></span><br><span class=\"line\">Q：.h文件必须和相应的.c文件同名吗？</span><br><span class=\"line\">A：不必，但是通常我们都这样做，因为比较这样比较清晰。</span><br><span class=\"line\"></span><br><span class=\"line\">Q：头文件必须是.h后缀吗？</span><br><span class=\"line\">A：不必，因为头文件只是其中的内容被#include宏命令替换，所以.txt、.doc等作为头文件的后缀都可以，但我们习惯用.h作为头文件后缀。</span><br><span class=\"line\"></span><br><span class=\"line\">Q：.c文件必须包含自己的.h文件吗？</span><br><span class=\"line\">A：不一定，在最初解释编译器工作原理的例子中add.c就可以不包含add.h文件，因为add.h中只是对add函数的声明，而add.c不需要这个声明也可以编译通过。</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在进行多文件编程的时候，虽然很多IDE都可以帮我们完成预处理、编译、链接等过程，但深入理解编译器的这几个过程可以避免很多”undefined”，”undeclared”以及”redefined”的问题。而比较好的实践方式是自己写Makefile（IDE实际上完成的就是帮我们弄清文件依赖关系，然后生成一个Makefile，调用编译器去编译链接生成可执行文件）。<br></p>","more":"<p></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html\" target=\"_blank\" rel=\"noopener\">C语言中.h和.c文件解析（很精彩）</a><br><a href=\"https://community.arduboy.com/t/purpose-of-ifndef-and-define/3592/2\" target=\"_blank\" rel=\"noopener\">Purpose of #ifndef and #define</a></p>\n<h2 id=\"编译器工作原理\"><a href=\"#编译器工作原理\" class=\"headerlink\" title=\"编译器工作原理\"></a>编译器工作原理</h2><p>1.预处理阶段：<br>实际上是处理的是”define”，”include”等宏命令，进行宏替换。例如#include “xx.h”实际意思是把当前这一行删掉，把xx.h中的内容原封不动的插入在当前行位置。</p>\n<p>2.编译阶段：<br><strong>以.c文件为基本单位进行</strong>，也就是说如果项目中一个.c文件都没有，那么项目无法编译。这一阶段为所有.c文件中的变量、函数分配空间，并将各个全局变量、函数进行符号描述，编译、汇编成二进制码从而生成.o目标文件。<br><strong>需要注意的是这个过程并不关心变量的具体定义和函数的具体实现，只要存在变量和函数的相关声明就可以使得编译通过。</strong>因为只要知道了变量/函数的类型和名字，编译器就知道了该如何使用这个变量/函数。</p>\n<p>3.链接阶段:<br><strong>以.o文件为基本单位进行</strong>，主要的工作是重定位各个目标文件的函数、变量。这个过程主要是为上一个编译过程中变量和函数的声明找到他们具体的定义和实现。</p>\n<p><em>下面是一个具体的解释例子：</em></p>\n<p>add.h文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _ADD_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _ADD_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>add.c文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"add.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>main.c文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"add.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = add(a, b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.预处理阶段：编译器会把main.c和add.c中的<code>#include &quot;add.h&quot;</code>替换成add.h中的全部内容。<br>2.编译阶段：为main.c和add.c中的各变量和函数分配内存空间并汇编成目标文件。可以发现在main.c中并没有关于add函数的实现只有由<code>#include &quot;add.h&quot;</code>替换成的这个函数的声明，但这并不影响编译过程的进行。<br>3.链接阶段：经过编译后生成了main.o和add.o文件。因为main.o中用到了add函数但没有它的具体实现，所以编译器会去其它.o文件中寻找该函数的具体实现。在这个例子中.o提供了add函数的具体实现，链接过程顺利进行，生成可执行文件。</p>\n<p><strong>Ps.关于add.h中#ifndef、#define和#endif的解释：</strong>它们的作用是防止头文件在一个.c文件中被重复包含。</p>\n<p><em>一个具体的例子：</em></p>\n<p>a.h文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>b.h文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br></pre></td></tr></table></figure></p>\n<p>c.h文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br></pre></td></tr></table></figure></p>\n<p>main.c文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"c.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    print(<span class=\"string\">\"hello\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>a.h中有结构体struct Node的定义，b.h和c.h都包含了a.h，main.c中又包含了b.h和c.h这两个头文件。这会导致a.h中的内容被两次复制到main.c中，产生struct Node的重复重复定义错误，而如果a.h遵循下面的格式：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _A_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>那么a.h在main.c中只会被替换一次，这样就避免了头文件的重复包含。</p>\n<h2 id=\"h和-c文件解析\"><a href=\"#h和-c文件解析\" class=\"headerlink\" title=\".h和.c文件解析\"></a>.h和.c文件解析</h2><p><strong>一般情况下我们在.h文件中进行变量、函数和宏的声明，在.c文件中进行变量和函数的具体实现。</strong><br>但这只是我们默认的一种规范的做法，实际上我们舍弃.h文件，在.c文件中包含变量、函数的声明以及实现也没有问题，但如果在其它.c文件中用#include去包含这个.c文件就会出现问题。</p>\n<p><em>具体例子：</em></p>\n<p>add.c文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>main.c文件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"add.c\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = add(a, b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>链接过程会出现add函数重复定义的错误，因为编译后生成的main.o和add.o中都含有add函数的具体实现。这种情况下可以对main.c做如下修改:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = add(a, b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, ans);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样编译后生成的main.o文件中便不再包含add函数的实现，而只包含声明。但是如果add.c中的函数很多，以及调用这些函数的.c文件也很多，这样在每个.c文件中手动挨个添加这些函数的声明会十分不方便，<strong>而可以理解为.h文件就是为了声明函数和变量方便而创建的</strong>，因为这样把所有的变量、函数声明都写在.h中，其它.c文件只需要#include相应的.h文件就好。</p>\n<h2 id=\"问答专区\"><a href=\"#问答专区\" class=\"headerlink\" title=\"问答专区\"></a>问答专区</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q：ifndef后面的标识必须是_ADD_H这种头文件名大写加下划线的形式吗？</span><br><span class=\"line\">A：不必，你可以自定义，这只是一种习惯性写法，因为一个工程中头文件名是不会重复的，所以这样定义的话标识也不会重复。</span><br><span class=\"line\"></span><br><span class=\"line\">Q：工程中可以没有.h文件吗？</span><br><span class=\"line\">A：可以，只是如上所说这样会有很多不方便。</span><br><span class=\"line\"></span><br><span class=\"line\">Q：.h文件必须和相应的.c文件同名吗？</span><br><span class=\"line\">A：不必，但是通常我们都这样做，因为比较这样比较清晰。</span><br><span class=\"line\"></span><br><span class=\"line\">Q：头文件必须是.h后缀吗？</span><br><span class=\"line\">A：不必，因为头文件只是其中的内容被#include宏命令替换，所以.txt、.doc等作为头文件的后缀都可以，但我们习惯用.h作为头文件后缀。</span><br><span class=\"line\"></span><br><span class=\"line\">Q：.c文件必须包含自己的.h文件吗？</span><br><span class=\"line\">A：不一定，在最初解释编译器工作原理的例子中add.c就可以不包含add.h文件，因为add.h中只是对add函数的声明，而add.c不需要这个声明也可以编译通过。</span><br></pre></td></tr></table></figure>"},{"title":"POJ1970-The Game-DFS","date":"2018-08-14T11:39:48.000Z","_content":"在一个$19×19$的棋盘上有一局五子棋的棋局，要求判断是白棋获胜还是黑棋获胜，并输出获胜一方获胜棋子部分的最左上一个棋子的位置．\n相比其它迷宫问题稍微变化了一点点，多了一个方向因素，通过这道题对迷宫问题和DFS有了更进一步的理解．\n<!-- more -->\n## 链接\n[POJ1970-The Game](http://poj.org/problem?id=1970)\n## 原题描述\nA game of Renju is played on a 19*19 board by two players. One player uses black stones and the other uses white stones. The game begins in an empty board and two players alternate in placing black stones and white stones. Black always goes first. There are 19 horizontal lines and 19 vertical lines in the board and the stones are placed on the intersections of the lines. \nHorizontal lines are marked 1, 2, ..., 19 from up to down and vertical lines are marked 1, 2, ..., 19 from left to right. \n![example](/Renju.png)\nThe objective of this game is to put five stones of the same color consecutively along a horizontal, vertical, or diagonal line. So, black wins in the above figure. But, a player does not win the game if more than five stones of the same color were put consecutively. \nGiven a configuration of the game, write a program to determine whether white has won or black has won or nobody has won yet. There will be no input data where the black and the white both win at the same time. Also there will be no input data where the white or the black wins in more than one place. \n## 题解\n相比于其它迷宫问题的搜索，这个问题要求每一次DFS始终沿一个方向进行搜索判断，判断出一方的某一个方向上的棋子个数等于5时该方获胜，所以在DFS函数上加上一个控制方向的参数，并把方向的选择放在DFS外部（main函数中）．还有一个需要注意的地方是连续棋子个数大于5的情况不算获胜．\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 14 Aug 17:36:47 CST 2018\n *\n */\n \n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nint d[25][25];\nint t;\n/**/\n//搜索方向为向下，向右，右斜上，右斜下（方便获得最左上的棋子坐标）\nint dx[4] = {1, 0, -1, 1};\nint dy[4] = {0, 1, 1, 1};\n/**/\nint cnt = 0;\n\n//参数k为方向参数\nvoid dfs(int x, int y, int k){\n    cnt++;\n    int nx = x + dx[k], ny = y + dy[k];\n    if(nx >= 1 && nx <= 19 && ny >= 1 && ny <= 19 && d[nx][ny] == d[x][y])\n        dfs(nx, ny, k);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        int leftx = 0, lefty = 0;\n        int win = 0;\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                cin >> d[i][j];\n                //cout << d[i][j] << \" \";\n            }\n            //cout << endl;\n        }\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                if(!d[i][j]) continue;\n                for(int k = 0; k < 4; k++){\n                    cnt = 0;\n                    dfs(i, j, k);\n                    if(cnt == 5){\n                        int xx = i - dx[k], yy = j - dy[k];\n                        //判断是否连续棋子个数大于5\n                        if(xx >= 1 && xx <= 19 && yy >= 1 && yy <= 19){\n                            if(d[xx][yy] != d[i][j]){\n                                win = d[i][j], leftx = i, lefty = j;\n                                break;\n                            }\n                        }\n                        else{\n                            win = d[i][j], leftx = i, lefty = j;\n                            break;\n                        }\n                    }\n                }\n                if(win) break;\n            }\n            if(win) break;\n        }\n        cout << win << endl;\n        if(win) cout << leftx << \" \" << lefty << endl;\n    }\n    \n    return 0;\n}\n```","source":"_posts/POJ1970-The-Game-DFS.md","raw":"---\ntitle: POJ1970-The Game-DFS\ndate: 2018-08-14 19:39:48\ncategories:\n- ACM\n- DFS\ntags:\n- POJ\n- DFS\n- 迷宫问题\n---\n在一个$19×19$的棋盘上有一局五子棋的棋局，要求判断是白棋获胜还是黑棋获胜，并输出获胜一方获胜棋子部分的最左上一个棋子的位置．\n相比其它迷宫问题稍微变化了一点点，多了一个方向因素，通过这道题对迷宫问题和DFS有了更进一步的理解．\n<!-- more -->\n## 链接\n[POJ1970-The Game](http://poj.org/problem?id=1970)\n## 原题描述\nA game of Renju is played on a 19*19 board by two players. One player uses black stones and the other uses white stones. The game begins in an empty board and two players alternate in placing black stones and white stones. Black always goes first. There are 19 horizontal lines and 19 vertical lines in the board and the stones are placed on the intersections of the lines. \nHorizontal lines are marked 1, 2, ..., 19 from up to down and vertical lines are marked 1, 2, ..., 19 from left to right. \n![example](/Renju.png)\nThe objective of this game is to put five stones of the same color consecutively along a horizontal, vertical, or diagonal line. So, black wins in the above figure. But, a player does not win the game if more than five stones of the same color were put consecutively. \nGiven a configuration of the game, write a program to determine whether white has won or black has won or nobody has won yet. There will be no input data where the black and the white both win at the same time. Also there will be no input data where the white or the black wins in more than one place. \n## 题解\n相比于其它迷宫问题的搜索，这个问题要求每一次DFS始终沿一个方向进行搜索判断，判断出一方的某一个方向上的棋子个数等于5时该方获胜，所以在DFS函数上加上一个控制方向的参数，并把方向的选择放在DFS外部（main函数中）．还有一个需要注意的地方是连续棋子个数大于5的情况不算获胜．\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 14 Aug 17:36:47 CST 2018\n *\n */\n \n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nint d[25][25];\nint t;\n/**/\n//搜索方向为向下，向右，右斜上，右斜下（方便获得最左上的棋子坐标）\nint dx[4] = {1, 0, -1, 1};\nint dy[4] = {0, 1, 1, 1};\n/**/\nint cnt = 0;\n\n//参数k为方向参数\nvoid dfs(int x, int y, int k){\n    cnt++;\n    int nx = x + dx[k], ny = y + dy[k];\n    if(nx >= 1 && nx <= 19 && ny >= 1 && ny <= 19 && d[nx][ny] == d[x][y])\n        dfs(nx, ny, k);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        int leftx = 0, lefty = 0;\n        int win = 0;\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                cin >> d[i][j];\n                //cout << d[i][j] << \" \";\n            }\n            //cout << endl;\n        }\n        for(int i = 1; i <= 19; i++){\n            for(int j = 1; j <= 19; j++){\n                if(!d[i][j]) continue;\n                for(int k = 0; k < 4; k++){\n                    cnt = 0;\n                    dfs(i, j, k);\n                    if(cnt == 5){\n                        int xx = i - dx[k], yy = j - dy[k];\n                        //判断是否连续棋子个数大于5\n                        if(xx >= 1 && xx <= 19 && yy >= 1 && yy <= 19){\n                            if(d[xx][yy] != d[i][j]){\n                                win = d[i][j], leftx = i, lefty = j;\n                                break;\n                            }\n                        }\n                        else{\n                            win = d[i][j], leftx = i, lefty = j;\n                            break;\n                        }\n                    }\n                }\n                if(win) break;\n            }\n            if(win) break;\n        }\n        cout << win << endl;\n        if(win) cout << leftx << \" \" << lefty << endl;\n    }\n    \n    return 0;\n}\n```","slug":"POJ1970-The-Game-DFS","published":1,"updated":"2018-12-14T13:08:14.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrmn0015b8ouioynz3lo","content":"<p>在一个$19×19$的棋盘上有一局五子棋的棋局，要求判断是白棋获胜还是黑棋获胜，并输出获胜一方获胜棋子部分的最左上一个棋子的位置．<br>相比其它迷宫问题稍微变化了一点点，多了一个方向因素，通过这道题对迷宫问题和DFS有了更进一步的理解．<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://poj.org/problem?id=1970\" target=\"_blank\" rel=\"noopener\">POJ1970-The Game</a></p>\n<h2 id=\"原题描述\"><a href=\"#原题描述\" class=\"headerlink\" title=\"原题描述\"></a>原题描述</h2><p>A game of Renju is played on a 19*19 board by two players. One player uses black stones and the other uses white stones. The game begins in an empty board and two players alternate in placing black stones and white stones. Black always goes first. There are 19 horizontal lines and 19 vertical lines in the board and the stones are placed on the intersections of the lines.<br>Horizontal lines are marked 1, 2, …, 19 from up to down and vertical lines are marked 1, 2, …, 19 from left to right.<br><img src=\"/2018/08/14/POJ1970-The-Game-DFS/Renju.png\" alt=\"example\"><br>The objective of this game is to put five stones of the same color consecutively along a horizontal, vertical, or diagonal line. So, black wins in the above figure. But, a player does not win the game if more than five stones of the same color were put consecutively.<br>Given a configuration of the game, write a program to determine whether white has won or black has won or nobody has won yet. There will be no input data where the black and the white both win at the same time. Also there will be no input data where the white or the black wins in more than one place. </p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>相比于其它迷宫问题的搜索，这个问题要求每一次DFS始终沿一个方向进行搜索判断，判断出一方的某一个方向上的棋子个数等于5时该方获胜，所以在DFS函数上加上一个控制方向的参数，并把方向的选择放在DFS外部（main函数中）．还有一个需要注意的地方是连续棋子个数大于5的情况不算获胜．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 14 Aug 17:36:47 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[<span class=\"number\">25</span>][<span class=\"number\">25</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"comment\">//搜索方向为向下，向右，右斜上，右斜下（方便获得最左上的棋子坐标）</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//参数k为方向参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nx = x + dx[k], ny = y + dy[k];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">1</span> &amp;&amp; nx &lt;= <span class=\"number\">19</span> &amp;&amp; ny &gt;= <span class=\"number\">1</span> &amp;&amp; ny &lt;= <span class=\"number\">19</span> &amp;&amp; d[nx][ny] == d[x][y])</span><br><span class=\"line\">        dfs(nx, ny, k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftx = <span class=\"number\">0</span>, lefty = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> win = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">19</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">19</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cin</span> &gt;&gt; d[i][j];</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; d[i][j] &lt;&lt; \" \";</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">19</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">19</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!d[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; k++)&#123;</span><br><span class=\"line\">                    cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    dfs(i, j, k);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(cnt == <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> xx = i - dx[k], yy = j - dy[k];</span><br><span class=\"line\">                        <span class=\"comment\">//判断是否连续棋子个数大于5</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(xx &gt;= <span class=\"number\">1</span> &amp;&amp; xx &lt;= <span class=\"number\">19</span> &amp;&amp; yy &gt;= <span class=\"number\">1</span> &amp;&amp; yy &lt;= <span class=\"number\">19</span>)&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(d[xx][yy] != d[i][j])&#123;</span><br><span class=\"line\">                                win = d[i][j], leftx = i, lefty = j;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            win = d[i][j], leftx = i, lefty = j;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(win) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(win) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; win &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(win) <span class=\"built_in\">cout</span> &lt;&lt; leftx &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; lefty &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在一个$19×19$的棋盘上有一局五子棋的棋局，要求判断是白棋获胜还是黑棋获胜，并输出获胜一方获胜棋子部分的最左上一个棋子的位置．<br>相比其它迷宫问题稍微变化了一点点，多了一个方向因素，通过这道题对迷宫问题和DFS有了更进一步的理解．<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://poj.org/problem?id=1970\" target=\"_blank\" rel=\"noopener\">POJ1970-The Game</a></p>\n<h2 id=\"原题描述\"><a href=\"#原题描述\" class=\"headerlink\" title=\"原题描述\"></a>原题描述</h2><p>A game of Renju is played on a 19*19 board by two players. One player uses black stones and the other uses white stones. The game begins in an empty board and two players alternate in placing black stones and white stones. Black always goes first. There are 19 horizontal lines and 19 vertical lines in the board and the stones are placed on the intersections of the lines.<br>Horizontal lines are marked 1, 2, …, 19 from up to down and vertical lines are marked 1, 2, …, 19 from left to right.<br><img src=\"/2018/08/14/POJ1970-The-Game-DFS/Renju.png\" alt=\"example\"><br>The objective of this game is to put five stones of the same color consecutively along a horizontal, vertical, or diagonal line. So, black wins in the above figure. But, a player does not win the game if more than five stones of the same color were put consecutively.<br>Given a configuration of the game, write a program to determine whether white has won or black has won or nobody has won yet. There will be no input data where the black and the white both win at the same time. Also there will be no input data where the white or the black wins in more than one place. </p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>相比于其它迷宫问题的搜索，这个问题要求每一次DFS始终沿一个方向进行搜索判断，判断出一方的某一个方向上的棋子个数等于5时该方获胜，所以在DFS函数上加上一个控制方向的参数，并把方向的选择放在DFS外部（main函数中）．还有一个需要注意的地方是连续棋子个数大于5的情况不算获胜．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 14 Aug 17:36:47 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[<span class=\"number\">25</span>][<span class=\"number\">25</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"comment\">//搜索方向为向下，向右，右斜上，右斜下（方便获得最左上的棋子坐标）</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//参数k为方向参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nx = x + dx[k], ny = y + dy[k];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">1</span> &amp;&amp; nx &lt;= <span class=\"number\">19</span> &amp;&amp; ny &gt;= <span class=\"number\">1</span> &amp;&amp; ny &lt;= <span class=\"number\">19</span> &amp;&amp; d[nx][ny] == d[x][y])</span><br><span class=\"line\">        dfs(nx, ny, k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftx = <span class=\"number\">0</span>, lefty = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> win = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">19</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">19</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cin</span> &gt;&gt; d[i][j];</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; d[i][j] &lt;&lt; \" \";</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">19</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= <span class=\"number\">19</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!d[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; k++)&#123;</span><br><span class=\"line\">                    cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    dfs(i, j, k);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(cnt == <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> xx = i - dx[k], yy = j - dy[k];</span><br><span class=\"line\">                        <span class=\"comment\">//判断是否连续棋子个数大于5</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(xx &gt;= <span class=\"number\">1</span> &amp;&amp; xx &lt;= <span class=\"number\">19</span> &amp;&amp; yy &gt;= <span class=\"number\">1</span> &amp;&amp; yy &lt;= <span class=\"number\">19</span>)&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(d[xx][yy] != d[i][j])&#123;</span><br><span class=\"line\">                                win = d[i][j], leftx = i, lefty = j;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            win = d[i][j], leftx = i, lefty = j;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(win) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(win) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; win &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(win) <span class=\"built_in\">cout</span> &lt;&lt; leftx &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; lefty &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"HDU2050-线切割平面问题-思维+简单dp","date":"2018-04-09T02:42:54.000Z","_content":"和队友一块做这道题，队友们几乎秒杀，而自己想了很久也没有推导出一个清晰的规律...看了[vinacky的线切割平面问题](https://blog.csdn.net/vinacky/article/details/8958326)这篇博客后才豁然开朗,个人感觉一道很好的思维题。\n题目描述就是求n条折线可以分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成七部分。\n![example](/line.jpg)\n<!-- more -->\n## 链接\n[HDU2050](http://acm.hdu.edu.cn/showproblem.php?pid=2050)\n## 题解\n### 直线切割平面\n首先考虑向平面添加直线(简化思维)后的平面分割情况：\n(下面假设新添加的直线与已有直线均相交)\n当平面上没有直线时，有一个平面；\n有１条直线时，没有节点，多出１部分，共２个平面；\n有２条直线时，多了１个节点，多出２部分，共４个平面；\n有３条直线时，多了２个节点，多出３部分，共７个平面；\n...\n至此我们便可以直观的思考一下是什么导致了平面的分割，当添加第i条直线时，因为我们总可以使它和前i-1条直线都相交，所以共有i-1个交点，也即第i条直线被分割成了i段，对每一段来说，它都将自己所在的平面重新分割为两部分。所以添加了第i条直线后，最多可以重新多分割出i个平面。\n所以原始的１个平面,\n添加１条直线后平面数为1+1;\n添加２条直线后平面数为1+1+2;\n添加３条直线后平面数为1+1+2+3；\n...\n得到添加n条直线后的平面数公式：$res = 1 + 1 + 2 + 3 + ... + n = \\frac{n(n+1)}{2} + 1$\n### V型折线切割平面\nV型折线切割平面可以看做同时添加了两条相交直线，但是稍有不同的是，这两条直线的交点有一侧平面合并了,因此而产生的影响是减少了两个平面。\n\n我们仍然可以保证添加的折线与其他折线均有交点，所以添加第i条V型折线时，增加的平面数为：$2\\*i - 1 + 2\\*i - 2$\n得到添加n条折线后的平面数公式：$$res = 1 + (1 + 2) + (3 + 4) + ... + (2n - 1 + 2n) = \\frac{2n(2n + 1)}{2} + 1 - 2n$$\n于是可以公式直接求解，也可以dp求解\n## 代码\n下面给出dp求解代码\n``` C++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nconst int maxn = 1e4 + 7;\nint n;\nlong long dp[maxn] = {1, 2, 7};\n\nint main(){\n    int c;\n    scanf(\"%d\", &c);\n    while(c--){\n    scanf(\"%d\", &n);\n        for(int i = 3; i <= n; i++){\n            dp[i] = dp[i - 1] + ２ * i - 1 + 2 * i - 2;\n        }\n        printf(\"%lld\\n\", dp[n]);\n        \n    }\n    return 0;\n\n}\n```","source":"_posts/HDU2050.md","raw":"---\ntitle: HDU2050-线切割平面问题-思维+简单dp\ndate: 2018-04-09 10:42:54\ncategories:\n- ACM\n- 思维\ntags:\n- HDU\n- 线切割平面\n- math\n- 思维\n---\n和队友一块做这道题，队友们几乎秒杀，而自己想了很久也没有推导出一个清晰的规律...看了[vinacky的线切割平面问题](https://blog.csdn.net/vinacky/article/details/8958326)这篇博客后才豁然开朗,个人感觉一道很好的思维题。\n题目描述就是求n条折线可以分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成七部分。\n![example](/line.jpg)\n<!-- more -->\n## 链接\n[HDU2050](http://acm.hdu.edu.cn/showproblem.php?pid=2050)\n## 题解\n### 直线切割平面\n首先考虑向平面添加直线(简化思维)后的平面分割情况：\n(下面假设新添加的直线与已有直线均相交)\n当平面上没有直线时，有一个平面；\n有１条直线时，没有节点，多出１部分，共２个平面；\n有２条直线时，多了１个节点，多出２部分，共４个平面；\n有３条直线时，多了２个节点，多出３部分，共７个平面；\n...\n至此我们便可以直观的思考一下是什么导致了平面的分割，当添加第i条直线时，因为我们总可以使它和前i-1条直线都相交，所以共有i-1个交点，也即第i条直线被分割成了i段，对每一段来说，它都将自己所在的平面重新分割为两部分。所以添加了第i条直线后，最多可以重新多分割出i个平面。\n所以原始的１个平面,\n添加１条直线后平面数为1+1;\n添加２条直线后平面数为1+1+2;\n添加３条直线后平面数为1+1+2+3；\n...\n得到添加n条直线后的平面数公式：$res = 1 + 1 + 2 + 3 + ... + n = \\frac{n(n+1)}{2} + 1$\n### V型折线切割平面\nV型折线切割平面可以看做同时添加了两条相交直线，但是稍有不同的是，这两条直线的交点有一侧平面合并了,因此而产生的影响是减少了两个平面。\n\n我们仍然可以保证添加的折线与其他折线均有交点，所以添加第i条V型折线时，增加的平面数为：$2\\*i - 1 + 2\\*i - 2$\n得到添加n条折线后的平面数公式：$$res = 1 + (1 + 2) + (3 + 4) + ... + (2n - 1 + 2n) = \\frac{2n(2n + 1)}{2} + 1 - 2n$$\n于是可以公式直接求解，也可以dp求解\n## 代码\n下面给出dp求解代码\n``` C++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\nconst int maxn = 1e4 + 7;\nint n;\nlong long dp[maxn] = {1, 2, 7};\n\nint main(){\n    int c;\n    scanf(\"%d\", &c);\n    while(c--){\n    scanf(\"%d\", &n);\n        for(int i = 3; i <= n; i++){\n            dp[i] = dp[i - 1] + ２ * i - 1 + 2 * i - 2;\n        }\n        printf(\"%lld\\n\", dp[n]);\n        \n    }\n    return 0;\n\n}\n```","slug":"HDU2050","published":1,"updated":"2018-12-14T13:28:59.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrmq0017b8ou7t6erf0o","content":"<p>和队友一块做这道题，队友们几乎秒杀，而自己想了很久也没有推导出一个清晰的规律…看了<a href=\"https://blog.csdn.net/vinacky/article/details/8958326\" target=\"_blank\" rel=\"noopener\">vinacky的线切割平面问题</a>这篇博客后才豁然开朗,个人感觉一道很好的思维题。<br>题目描述就是求n条折线可以分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成七部分。<br><img src=\"/2018/04/09/HDU2050/line.jpg\" alt=\"example\"><br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2050\" target=\"_blank\" rel=\"noopener\">HDU2050</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><h3 id=\"直线切割平面\"><a href=\"#直线切割平面\" class=\"headerlink\" title=\"直线切割平面\"></a>直线切割平面</h3><p>首先考虑向平面添加直线(简化思维)后的平面分割情况：<br>(下面假设新添加的直线与已有直线均相交)<br>当平面上没有直线时，有一个平面；<br>有１条直线时，没有节点，多出１部分，共２个平面；<br>有２条直线时，多了１个节点，多出２部分，共４个平面；<br>有３条直线时，多了２个节点，多出３部分，共７个平面；<br>…<br>至此我们便可以直观的思考一下是什么导致了平面的分割，当添加第i条直线时，因为我们总可以使它和前i-1条直线都相交，所以共有i-1个交点，也即第i条直线被分割成了i段，对每一段来说，它都将自己所在的平面重新分割为两部分。所以添加了第i条直线后，最多可以重新多分割出i个平面。<br>所以原始的１个平面,<br>添加１条直线后平面数为1+1;<br>添加２条直线后平面数为1+1+2;<br>添加３条直线后平面数为1+1+2+3；<br>…<br>得到添加n条直线后的平面数公式：$res = 1 + 1 + 2 + 3 + … + n = \\frac{n(n+1)}{2} + 1$</p>\n<h3 id=\"V型折线切割平面\"><a href=\"#V型折线切割平面\" class=\"headerlink\" title=\"V型折线切割平面\"></a>V型折线切割平面</h3><p>V型折线切割平面可以看做同时添加了两条相交直线，但是稍有不同的是，这两条直线的交点有一侧平面合并了,因此而产生的影响是减少了两个平面。</p>\n<p>我们仍然可以保证添加的折线与其他折线均有交点，所以添加第i条V型折线时，增加的平面数为：$2*i - 1 + 2*i - 2$<br>得到添加n条折线后的平面数公式：$$res = 1 + (1 + 2) + (3 + 4) + … + (2n - 1 + 2n) = \\frac{2n(2n + 1)}{2} + 1 - 2n$$<br>于是可以公式直接求解，也可以dp求解</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>下面给出dp求解代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e4</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[maxn] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;c);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c--)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + ２ * i - <span class=\"number\">1</span> + <span class=\"number\">2</span> * i - <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, dp[n]);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>和队友一块做这道题，队友们几乎秒杀，而自己想了很久也没有推导出一个清晰的规律…看了<a href=\"https://blog.csdn.net/vinacky/article/details/8958326\" target=\"_blank\" rel=\"noopener\">vinacky的线切割平面问题</a>这篇博客后才豁然开朗,个人感觉一道很好的思维题。<br>题目描述就是求n条折线可以分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成七部分。<br><img src=\"/2018/04/09/HDU2050/line.jpg\" alt=\"example\"><br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2050\" target=\"_blank\" rel=\"noopener\">HDU2050</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><h3 id=\"直线切割平面\"><a href=\"#直线切割平面\" class=\"headerlink\" title=\"直线切割平面\"></a>直线切割平面</h3><p>首先考虑向平面添加直线(简化思维)后的平面分割情况：<br>(下面假设新添加的直线与已有直线均相交)<br>当平面上没有直线时，有一个平面；<br>有１条直线时，没有节点，多出１部分，共２个平面；<br>有２条直线时，多了１个节点，多出２部分，共４个平面；<br>有３条直线时，多了２个节点，多出３部分，共７个平面；<br>…<br>至此我们便可以直观的思考一下是什么导致了平面的分割，当添加第i条直线时，因为我们总可以使它和前i-1条直线都相交，所以共有i-1个交点，也即第i条直线被分割成了i段，对每一段来说，它都将自己所在的平面重新分割为两部分。所以添加了第i条直线后，最多可以重新多分割出i个平面。<br>所以原始的１个平面,<br>添加１条直线后平面数为1+1;<br>添加２条直线后平面数为1+1+2;<br>添加３条直线后平面数为1+1+2+3；<br>…<br>得到添加n条直线后的平面数公式：$res = 1 + 1 + 2 + 3 + … + n = \\frac{n(n+1)}{2} + 1$</p>\n<h3 id=\"V型折线切割平面\"><a href=\"#V型折线切割平面\" class=\"headerlink\" title=\"V型折线切割平面\"></a>V型折线切割平面</h3><p>V型折线切割平面可以看做同时添加了两条相交直线，但是稍有不同的是，这两条直线的交点有一侧平面合并了,因此而产生的影响是减少了两个平面。</p>\n<p>我们仍然可以保证添加的折线与其他折线均有交点，所以添加第i条V型折线时，增加的平面数为：$2*i - 1 + 2*i - 2$<br>得到添加n条折线后的平面数公式：$$res = 1 + (1 + 2) + (3 + 4) + … + (2n - 1 + 2n) = \\frac{2n(2n + 1)}{2} + 1 - 2n$$<br>于是可以公式直接求解，也可以dp求解</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>下面给出dp求解代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e4</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[maxn] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;c);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(c--)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + ２ * i - <span class=\"number\">1</span> + <span class=\"number\">2</span> * i - <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, dp[n]);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"POJ2481-线段树单点更新","date":"2018-04-22T08:51:50.000Z","_content":"最近刚刚开始做线段树相关的题目，很艰难...依照现在的理解其实线段树的题的暴力求解思路比较容易想到，但是暴力求解的时间复杂度一般肯会超，而线段树也正是这样一种通过区间更新来解决大量输入数据问题、降低时间复杂度的高级数据结构。线段树的关键是确定每个节点维护的是什么数据，以及以什么参数为依据进行区间的查询。\n被POJ上的这道题卡了很久，一开始是思路问题，后来是一些细节问题，总之还是熟练度不高...\n[参考博客链接](http://111qqz.com/2015/08/poj2481/)\n<!-- more -->\n## 题目链接\n[POJ2481](http://poj.org/problem?id=2481)\n## 题目描述\n共有N头牛，每头牛对应一个进食区间[$S$,$E$], 对两头牛$i$,$j$来说，假设它们对应的区间分别为[$S\\_i$,$E\\_i$]和[$S\\_j$,$E\\_j$]，如果满足$S\\_i<=S\\_j，E\\_j<=E\\_i$且$E\\_i-S\\_i>E\\_j-S\\_j$,那么我们可以说牛$i$要比牛$j$强壮。\n现对于每头牛来说计算比它强壮的牛的数量。\n## 题解\n先对区间进行排序，右端点降序为第一关键字，左端点升序为第二关键字。这样进行处理后第$i$个区间的右端点一定小于前$i-1$个区间的右端点了，那么只要进行左端点的判决就可以了，具体做法为：\n每次处理一个区间后都将该区间的左端点更新到线段树中（插入后相对应叶节点数值+1，插入前为0）。\n那么当我们查询第$i$个区间时其实也就是查询线段树中从1到$i-1$的区间内左端点的标记个数。\n**于是线段树每个节点维护的就是以该节点为根节点的子树所代表的区间中左端点的个数，而进行区间查询依据的参数也就是每个区间的左端点。**\n*需要注意的问题*:\n**两个区间重合时的情况要特殊处理，这种情况不算在内，做法可以是对排好序的每个区间进行处理前先检查它是否和上一查询区间重合，若重合则直接将上一区间的查询结果赋予该区间，并将该区间对应的左端点在线段树中再次更新（再次加1）,而后跳过该区间的查询。**详见代码：\n## 代码\n关于线段树的实现部分基于《挑战程序设计竞赛》一书中的实现模板，也可参考其它实现模板，形成自己的书写习惯。\n``` C++\n//#include <bits/stdc++.h> //POJ上大部分题不支持该头文件\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1 << 18;\ntypedef struct node{\n    int vl;\n    int vr;\n    int id;\n} nod;\nnod a[maxn];\nint d[2 * maxn];\nint n, pn;\nint ans[maxn];\n//排序部分\nbool cmp(const nod& a, const nod& b){\n    if(a.vr == b.vr) \n        return a.vl < b.vl;\n    else\n        return a.vr > b.vr;\n}\n//初始化\nvoid init(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n    for(int i = 0; i < 2 * n - 1; i++){\n        d[i] = 0;\n    }\n}\n//查询操作\nint query(int a, int b, int k, int l, int r){\n    if(a <= l && b >= r) return d[k];\n    if(b <= l) return 0;\n    else{\n        int res1 = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        int res2 = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return res1 + res2;\n    }\n}\n//更新操作\nvoid update(int k){\n    k += n - 1;\n    d[k] += 1;\n    while(k > 0){\n        k = (k - 1) / 2;\n        d[k] = d[2 *k + 1] + d[2 * k + 2];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int t1, t2;\n    while(~scanf(\"%d\", &n)){\n        memset(ans, 0, sizeof(ans));\n        memset(d, 0, sizeof(d));\n\t    if(n == 0) break;\n\t    for(int i = 0; i < n; i++){\n            scanf(\"%d%d\", &t1, &t2);\n            a[i].vl = t1;\n            a[i].vr = t2;\n            a[i].id = i;\n        }\n        sort(a, a + n, cmp);\n        pn = n;\n        init(n);\n        for(int i = 0; i < pn; i++){\n            //if内为判断重合区间部分\n            if(i >= 1 && a[i].vl == a[i - 1].vl && a[i].vr == a[i - 1].vr){\n                ans[a[i].id] = ans[a[i - 1].id];\n                update(a[i].vl);\n                continue;\n            }\n            ans[a[i].id] = query(0, a[i].vl + 1, 0, 0, n);\n            update(a[i].vl);\n\t\t\t\n        }\n        for(int i = 0; i < pn; i++){\n            printf(\"%d%c\", ans[i], i < pn - 1 ? ' ' : '\\n');\n        }\n    }\n\t\n    return 0;\n}\n```","source":"_posts/POJ2481.md","raw":"---\ntitle: POJ2481-线段树单点更新\ndate: 2018-04-22 16:51:50\ncategories: \n- ACM\n- 线段树\ntags:\n- POJ\n- 线段树\n---\n最近刚刚开始做线段树相关的题目，很艰难...依照现在的理解其实线段树的题的暴力求解思路比较容易想到，但是暴力求解的时间复杂度一般肯会超，而线段树也正是这样一种通过区间更新来解决大量输入数据问题、降低时间复杂度的高级数据结构。线段树的关键是确定每个节点维护的是什么数据，以及以什么参数为依据进行区间的查询。\n被POJ上的这道题卡了很久，一开始是思路问题，后来是一些细节问题，总之还是熟练度不高...\n[参考博客链接](http://111qqz.com/2015/08/poj2481/)\n<!-- more -->\n## 题目链接\n[POJ2481](http://poj.org/problem?id=2481)\n## 题目描述\n共有N头牛，每头牛对应一个进食区间[$S$,$E$], 对两头牛$i$,$j$来说，假设它们对应的区间分别为[$S\\_i$,$E\\_i$]和[$S\\_j$,$E\\_j$]，如果满足$S\\_i<=S\\_j，E\\_j<=E\\_i$且$E\\_i-S\\_i>E\\_j-S\\_j$,那么我们可以说牛$i$要比牛$j$强壮。\n现对于每头牛来说计算比它强壮的牛的数量。\n## 题解\n先对区间进行排序，右端点降序为第一关键字，左端点升序为第二关键字。这样进行处理后第$i$个区间的右端点一定小于前$i-1$个区间的右端点了，那么只要进行左端点的判决就可以了，具体做法为：\n每次处理一个区间后都将该区间的左端点更新到线段树中（插入后相对应叶节点数值+1，插入前为0）。\n那么当我们查询第$i$个区间时其实也就是查询线段树中从1到$i-1$的区间内左端点的标记个数。\n**于是线段树每个节点维护的就是以该节点为根节点的子树所代表的区间中左端点的个数，而进行区间查询依据的参数也就是每个区间的左端点。**\n*需要注意的问题*:\n**两个区间重合时的情况要特殊处理，这种情况不算在内，做法可以是对排好序的每个区间进行处理前先检查它是否和上一查询区间重合，若重合则直接将上一区间的查询结果赋予该区间，并将该区间对应的左端点在线段树中再次更新（再次加1）,而后跳过该区间的查询。**详见代码：\n## 代码\n关于线段树的实现部分基于《挑战程序设计竞赛》一书中的实现模板，也可参考其它实现模板，形成自己的书写习惯。\n``` C++\n//#include <bits/stdc++.h> //POJ上大部分题不支持该头文件\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1 << 18;\ntypedef struct node{\n    int vl;\n    int vr;\n    int id;\n} nod;\nnod a[maxn];\nint d[2 * maxn];\nint n, pn;\nint ans[maxn];\n//排序部分\nbool cmp(const nod& a, const nod& b){\n    if(a.vr == b.vr) \n        return a.vl < b.vl;\n    else\n        return a.vr > b.vr;\n}\n//初始化\nvoid init(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n    for(int i = 0; i < 2 * n - 1; i++){\n        d[i] = 0;\n    }\n}\n//查询操作\nint query(int a, int b, int k, int l, int r){\n    if(a <= l && b >= r) return d[k];\n    if(b <= l) return 0;\n    else{\n        int res1 = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        int res2 = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return res1 + res2;\n    }\n}\n//更新操作\nvoid update(int k){\n    k += n - 1;\n    d[k] += 1;\n    while(k > 0){\n        k = (k - 1) / 2;\n        d[k] = d[2 *k + 1] + d[2 * k + 2];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int t1, t2;\n    while(~scanf(\"%d\", &n)){\n        memset(ans, 0, sizeof(ans));\n        memset(d, 0, sizeof(d));\n\t    if(n == 0) break;\n\t    for(int i = 0; i < n; i++){\n            scanf(\"%d%d\", &t1, &t2);\n            a[i].vl = t1;\n            a[i].vr = t2;\n            a[i].id = i;\n        }\n        sort(a, a + n, cmp);\n        pn = n;\n        init(n);\n        for(int i = 0; i < pn; i++){\n            //if内为判断重合区间部分\n            if(i >= 1 && a[i].vl == a[i - 1].vl && a[i].vr == a[i - 1].vr){\n                ans[a[i].id] = ans[a[i - 1].id];\n                update(a[i].vl);\n                continue;\n            }\n            ans[a[i].id] = query(0, a[i].vl + 1, 0, 0, n);\n            update(a[i].vl);\n\t\t\t\n        }\n        for(int i = 0; i < pn; i++){\n            printf(\"%d%c\", ans[i], i < pn - 1 ? ' ' : '\\n');\n        }\n    }\n\t\n    return 0;\n}\n```","slug":"POJ2481","published":1,"updated":"2018-12-14T13:28:19.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrms001bb8ou4gary5ii","content":"<p>最近刚刚开始做线段树相关的题目，很艰难…依照现在的理解其实线段树的题的暴力求解思路比较容易想到，但是暴力求解的时间复杂度一般肯会超，而线段树也正是这样一种通过区间更新来解决大量输入数据问题、降低时间复杂度的高级数据结构。线段树的关键是确定每个节点维护的是什么数据，以及以什么参数为依据进行区间的查询。<br>被POJ上的这道题卡了很久，一开始是思路问题，后来是一些细节问题，总之还是熟练度不高…<br><a href=\"http://111qqz.com/2015/08/poj2481/\" target=\"_blank\" rel=\"noopener\">参考博客链接</a><br><a id=\"more\"></a></p>\n<h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"http://poj.org/problem?id=2481\" target=\"_blank\" rel=\"noopener\">POJ2481</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>共有N头牛，每头牛对应一个进食区间[$S$,$E$], 对两头牛$i$,$j$来说，假设它们对应的区间分别为[$S_i$,$E_i$]和[$S_j$,$E_j$]，如果满足$S_i&lt;=S_j，E_j&lt;=E_i$且$E_i-S_i&gt;E_j-S_j$,那么我们可以说牛$i$要比牛$j$强壮。<br>现对于每头牛来说计算比它强壮的牛的数量。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>先对区间进行排序，右端点降序为第一关键字，左端点升序为第二关键字。这样进行处理后第$i$个区间的右端点一定小于前$i-1$个区间的右端点了，那么只要进行左端点的判决就可以了，具体做法为：<br>每次处理一个区间后都将该区间的左端点更新到线段树中（插入后相对应叶节点数值+1，插入前为0）。<br>那么当我们查询第$i$个区间时其实也就是查询线段树中从1到$i-1$的区间内左端点的标记个数。<br><strong>于是线段树每个节点维护的就是以该节点为根节点的子树所代表的区间中左端点的个数，而进行区间查询依据的参数也就是每个区间的左端点。</strong><br><em>需要注意的问题</em>:<br><strong>两个区间重合时的情况要特殊处理，这种情况不算在内，做法可以是对排好序的每个区间进行处理前先检查它是否和上一查询区间重合，若重合则直接将上一区间的查询结果赋予该区间，并将该区间对应的左端点在线段树中再次更新（再次加1）,而后跳过该区间的查询。</strong>详见代码：</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>关于线段树的实现部分基于《挑战程序设计竞赛》一书中的实现模板，也可参考其它实现模板，形成自己的书写习惯。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt; //POJ上大部分题不支持该头文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> vr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">&#125; nod;</span><br><span class=\"line\">nod a[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[<span class=\"number\">2</span> * maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, pn;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans[maxn];</span><br><span class=\"line\"><span class=\"comment\">//排序部分</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> nod&amp; a, <span class=\"keyword\">const</span> nod&amp; b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.vr == b.vr) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.vl &lt; b.vl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.vr &gt; b.vr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> _n)</span></span>&#123;</span><br><span class=\"line\">    n = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &lt; _n) n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span> * n - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        d[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//查询操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a &lt;= l &amp;&amp; b &gt;= r) <span class=\"keyword\">return</span> d[k];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b &lt;= l) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res1 = query(a, b, <span class=\"number\">2</span> * k + <span class=\"number\">1</span>, l, (l + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res2 = query(a, b, <span class=\"number\">2</span> * k + <span class=\"number\">2</span>, (l + r) / <span class=\"number\">2</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res1 + res2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//更新操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    k += n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    d[k] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        k = (k - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        d[k] = d[<span class=\"number\">2</span> *k + <span class=\"number\">1</span>] + d[<span class=\"number\">2</span> * k + <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t1, t2;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(ans, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(ans));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;t1, &amp;t2);</span><br><span class=\"line\">            a[i].vl = t1;</span><br><span class=\"line\">            a[i].vr = t2;</span><br><span class=\"line\">            a[i].id = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(a, a + n, cmp);</span><br><span class=\"line\">        pn = n;</span><br><span class=\"line\">        init(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pn; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//if内为判断重合区间部分</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= <span class=\"number\">1</span> &amp;&amp; a[i].vl == a[i - <span class=\"number\">1</span>].vl &amp;&amp; a[i].vr == a[i - <span class=\"number\">1</span>].vr)&#123;</span><br><span class=\"line\">                ans[a[i].id] = ans[a[i - <span class=\"number\">1</span>].id];</span><br><span class=\"line\">                update(a[i].vl);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans[a[i].id] = query(<span class=\"number\">0</span>, a[i].vl + <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n);</span><br><span class=\"line\">            update(a[i].vl);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pn; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d%c\"</span>, ans[i], i &lt; pn - <span class=\"number\">1</span> ? <span class=\"string\">' '</span> : <span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>最近刚刚开始做线段树相关的题目，很艰难…依照现在的理解其实线段树的题的暴力求解思路比较容易想到，但是暴力求解的时间复杂度一般肯会超，而线段树也正是这样一种通过区间更新来解决大量输入数据问题、降低时间复杂度的高级数据结构。线段树的关键是确定每个节点维护的是什么数据，以及以什么参数为依据进行区间的查询。<br>被POJ上的这道题卡了很久，一开始是思路问题，后来是一些细节问题，总之还是熟练度不高…<br><a href=\"http://111qqz.com/2015/08/poj2481/\" target=\"_blank\" rel=\"noopener\">参考博客链接</a><br></p>","more":"<p></p>\n<h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h2><p><a href=\"http://poj.org/problem?id=2481\" target=\"_blank\" rel=\"noopener\">POJ2481</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>共有N头牛，每头牛对应一个进食区间[$S$,$E$], 对两头牛$i$,$j$来说，假设它们对应的区间分别为[$S_i$,$E_i$]和[$S_j$,$E_j$]，如果满足$S_i&lt;=S_j，E_j&lt;=E_i$且$E_i-S_i&gt;E_j-S_j$,那么我们可以说牛$i$要比牛$j$强壮。<br>现对于每头牛来说计算比它强壮的牛的数量。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>先对区间进行排序，右端点降序为第一关键字，左端点升序为第二关键字。这样进行处理后第$i$个区间的右端点一定小于前$i-1$个区间的右端点了，那么只要进行左端点的判决就可以了，具体做法为：<br>每次处理一个区间后都将该区间的左端点更新到线段树中（插入后相对应叶节点数值+1，插入前为0）。<br>那么当我们查询第$i$个区间时其实也就是查询线段树中从1到$i-1$的区间内左端点的标记个数。<br><strong>于是线段树每个节点维护的就是以该节点为根节点的子树所代表的区间中左端点的个数，而进行区间查询依据的参数也就是每个区间的左端点。</strong><br><em>需要注意的问题</em>:<br><strong>两个区间重合时的情况要特殊处理，这种情况不算在内，做法可以是对排好序的每个区间进行处理前先检查它是否和上一查询区间重合，若重合则直接将上一区间的查询结果赋予该区间，并将该区间对应的左端点在线段树中再次更新（再次加1）,而后跳过该区间的查询。</strong>详见代码：</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>关于线段树的实现部分基于《挑战程序设计竞赛》一书中的实现模板，也可参考其它实现模板，形成自己的书写习惯。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt; //POJ上大部分题不支持该头文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> vr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">&#125; nod;</span><br><span class=\"line\">nod a[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[<span class=\"number\">2</span> * maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, pn;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans[maxn];</span><br><span class=\"line\"><span class=\"comment\">//排序部分</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> nod&amp; a, <span class=\"keyword\">const</span> nod&amp; b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.vr == b.vr) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.vl &lt; b.vl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.vr &gt; b.vr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> _n)</span></span>&#123;</span><br><span class=\"line\">    n = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &lt; _n) n *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span> * n - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        d[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//查询操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a &lt;= l &amp;&amp; b &gt;= r) <span class=\"keyword\">return</span> d[k];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b &lt;= l) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res1 = query(a, b, <span class=\"number\">2</span> * k + <span class=\"number\">1</span>, l, (l + r) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res2 = query(a, b, <span class=\"number\">2</span> * k + <span class=\"number\">2</span>, (l + r) / <span class=\"number\">2</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res1 + res2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//更新操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    k += n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    d[k] += <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        k = (k - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        d[k] = d[<span class=\"number\">2</span> *k + <span class=\"number\">1</span>] + d[<span class=\"number\">2</span> * k + <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t1, t2;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(ans, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(ans));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;t1, &amp;t2);</span><br><span class=\"line\">            a[i].vl = t1;</span><br><span class=\"line\">            a[i].vr = t2;</span><br><span class=\"line\">            a[i].id = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(a, a + n, cmp);</span><br><span class=\"line\">        pn = n;</span><br><span class=\"line\">        init(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pn; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//if内为判断重合区间部分</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= <span class=\"number\">1</span> &amp;&amp; a[i].vl == a[i - <span class=\"number\">1</span>].vl &amp;&amp; a[i].vr == a[i - <span class=\"number\">1</span>].vr)&#123;</span><br><span class=\"line\">                ans[a[i].id] = ans[a[i - <span class=\"number\">1</span>].id];</span><br><span class=\"line\">                update(a[i].vl);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans[a[i].id] = query(<span class=\"number\">0</span>, a[i].vl + <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, n);</span><br><span class=\"line\">            update(a[i].vl);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pn; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d%c\"</span>, ans[i], i &lt; pn - <span class=\"number\">1</span> ? <span class=\"string\">' '</span> : <span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"STL中自定义比较函数和重载运算符总结","date":"2018-08-07T14:13:16.000Z","_content":"之前一直搞不太懂自定义比较函数和重载运算符的概念，只会依葫芦画瓢的实现功能，渐渐的觉得这样不太好，虽然细节是魔鬼，但有些东西还是搞明白一点比较好。部分内容转载自[Ohazyi Zone's blog](https://www.ohazyi.com/c_cmp/)\n<!-- more -->\n## sort\n### 自定义比较函数\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool cmp(const node& a, const node& b){\n    return a.x > b.x //对x降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n, cmp);\n    return 0;\n}\n```\n注：自定义比较函数的形式同样也适用于pair类型数据排序。\n### 重载运算符<\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x; //重载为降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n);\n    return 0;\n}\n```\n注：由于sort默认less(升序),所以重载'<'运算符。重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n\n## priority_queue\n### 重载运算符< (运算符重载函数放到结构体外)\n```C++\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x //less默认大顶堆，改为小顶堆\n}\n\n//bool operator >(const node& a, const node& b){\n//    return a.x < b.x //greater默认小顶堆，改为大顶堆\n//}\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同样重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n### 重载运算符< (运算符重载函数放到结构体内)\n```C++\nstruct node{\n    int x, y;\n    bool operator <(node a) const { //必须加const\n        return x > a.x;\n    }\n    //bool operator >(node a) const { //必须加const\n    //    return x < a.x;\n    //}\n};\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同上。\n### 自定义比较函数\n```C++\nstruct node{\n    int x, y;\n};\n\nstruct cmp1{\n    bool operator()(node a, node b){\n        return a.x > b.x; //小顶堆\n    }\n}\n\nstruct cmp2{\n    bool operator()(node a, node b){\n        return a.x < b.x; //大顶堆\n    }\n}\n\nint main(){\n    priority_queue<node, vector<node>, cmp1> que1; //小顶堆\n    priority_queue<node, vector<node>, cmp2> que2; //大顶堆\n    return 0;\n}\n```\n注：同样适用于pair类型数据排序。\n## 其它\n```C++\nset<int, greater<int> > st; //按照从大到小，默认是less<int>\ntypedef pair <int,int> P;\nset<P> st; //按照pair的第一个元素来排，第一个相等的话按第二个来排\nset<P, greater<P> > st;//按照从大到小的greater来排\n```\n注：set、map的自定义比较函数和重载运算符与优先队列priority_queue类似。","source":"_posts/STL-cmp.md","raw":"---\ntitle: STL中自定义比较函数和重载运算符总结\ndate: 2018-08-07 22:13:16\ncategories:\n- C++\ntags:\n- STL\n---\n之前一直搞不太懂自定义比较函数和重载运算符的概念，只会依葫芦画瓢的实现功能，渐渐的觉得这样不太好，虽然细节是魔鬼，但有些东西还是搞明白一点比较好。部分内容转载自[Ohazyi Zone's blog](https://www.ohazyi.com/c_cmp/)\n<!-- more -->\n## sort\n### 自定义比较函数\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool cmp(const node& a, const node& b){\n    return a.x > b.x //对x降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n, cmp);\n    return 0;\n}\n```\n注：自定义比较函数的形式同样也适用于pair类型数据排序。\n### 重载运算符<\n```C++\n//示例\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x; //重载为降序排列\n}\n\nnode d[maxn];\n\nint main(){\n    sort(d, d + n);\n    return 0;\n}\n```\n注：由于sort默认less(升序),所以重载'<'运算符。重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n\n## priority_queue\n### 重载运算符< (运算符重载函数放到结构体外)\n```C++\nstruct node{\n    int x, y;\n};\n\nbool operator <(const node& a, const node& b){\n    return a.x > b.x //less默认大顶堆，改为小顶堆\n}\n\n//bool operator >(const node& a, const node& b){\n//    return a.x < b.x //greater默认小顶堆，改为大顶堆\n//}\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同样重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。\n### 重载运算符< (运算符重载函数放到结构体内)\n```C++\nstruct node{\n    int x, y;\n    bool operator <(node a) const { //必须加const\n        return x > a.x;\n    }\n    //bool operator >(node a) const { //必须加const\n    //    return x < a.x;\n    //}\n};\n\nint main(){\n    priority_queue<node, vector<node>, less<node> > que;\n    //priority_queue<node, vector<node>, greater<node> > que;\n    return 0;\n}\n```\n注：同上。\n### 自定义比较函数\n```C++\nstruct node{\n    int x, y;\n};\n\nstruct cmp1{\n    bool operator()(node a, node b){\n        return a.x > b.x; //小顶堆\n    }\n}\n\nstruct cmp2{\n    bool operator()(node a, node b){\n        return a.x < b.x; //大顶堆\n    }\n}\n\nint main(){\n    priority_queue<node, vector<node>, cmp1> que1; //小顶堆\n    priority_queue<node, vector<node>, cmp2> que2; //大顶堆\n    return 0;\n}\n```\n注：同样适用于pair类型数据排序。\n## 其它\n```C++\nset<int, greater<int> > st; //按照从大到小，默认是less<int>\ntypedef pair <int,int> P;\nset<P> st; //按照pair的第一个元素来排，第一个相等的话按第二个来排\nset<P, greater<P> > st;//按照从大到小的greater来排\n```\n注：set、map的自定义比较函数和重载运算符与优先队列priority_queue类似。","slug":"STL-cmp","published":1,"updated":"2018-11-13T12:02:41.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrmt001db8ouxs536i3u","content":"<p>之前一直搞不太懂自定义比较函数和重载运算符的概念，只会依葫芦画瓢的实现功能，渐渐的觉得这样不太好，虽然细节是魔鬼，但有些东西还是搞明白一点比较好。部分内容转载自<a href=\"https://www.ohazyi.com/c_cmp/\" target=\"_blank\" rel=\"noopener\">Ohazyi Zone’s blog</a><br><a id=\"more\"></a></p>\n<h2 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h2><h3 id=\"自定义比较函数\"><a href=\"#自定义比较函数\" class=\"headerlink\" title=\"自定义比较函数\"></a>自定义比较函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x <span class=\"comment\">//对x降序排列</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sort(d, d + n, cmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：自定义比较函数的形式同样也适用于pair类型数据排序。</p>\n<h3 id=\"重载运算符-lt\"><a href=\"#重载运算符-lt\" class=\"headerlink\" title=\"重载运算符&lt;\"></a>重载运算符&lt;</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x; <span class=\"comment\">//重载为降序排列</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sort(d, d + n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：由于sort默认less(升序),所以重载’&lt;’运算符。重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。</p>\n<h2 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue\"></a>priority_queue</h2><h3 id=\"重载运算符-lt-运算符重载函数放到结构体外\"><a href=\"#重载运算符-lt-运算符重载函数放到结构体外\" class=\"headerlink\" title=\"重载运算符&lt; (运算符重载函数放到结构体外)\"></a>重载运算符&lt; (运算符重载函数放到结构体外)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x <span class=\"comment\">//less默认大顶堆，改为小顶堆</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//bool operator &gt;(const node&amp; a, const node&amp; b)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    return a.x &lt; b.x //greater默认小顶堆，改为大顶堆</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main()&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, less&lt;node&gt; &gt; que;</span><br><span class=\"line\">    <span class=\"comment\">//priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; que;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同样重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。</p>\n<h3 id=\"重载运算符-lt-运算符重载函数放到结构体内\"><a href=\"#重载运算符-lt-运算符重载函数放到结构体内\" class=\"headerlink\" title=\"重载运算符&lt; (运算符重载函数放到结构体内)\"></a>重载运算符&lt; (运算符重载函数放到结构体内)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(node a) <span class=\"keyword\">const</span> &#123; <span class=\"comment\">//必须加const</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x &gt; a.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//bool operator &gt;(node a) const &#123; //必须加const</span></span><br><span class=\"line\">    <span class=\"comment\">//    return x &lt; a.x;</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, less&lt;node&gt; &gt; que;</span><br><span class=\"line\">    <span class=\"comment\">//priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; que;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同上。</p>\n<h3 id=\"自定义比较函数-1\"><a href=\"#自定义比较函数-1\" class=\"headerlink\" title=\"自定义比较函数\"></a>自定义比较函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp1</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(node a, node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.x &gt; b.x; <span class=\"comment\">//小顶堆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp2</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(node a, node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.x &lt; b.x; <span class=\"comment\">//大顶堆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, cmp1&gt; que1; <span class=\"comment\">//小顶堆</span></span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, cmp2&gt; que2; <span class=\"comment\">//大顶堆</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同样适用于pair类型数据排序。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>, greater&lt;<span class=\"keyword\">int</span>&gt; &gt; st; <span class=\"comment\">//按照从大到小，默认是less&lt;int&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;P&gt; st; <span class=\"comment\">//按照pair的第一个元素来排，第一个相等的话按第二个来排</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;P, greater&lt;P&gt; &gt; st;<span class=\"comment\">//按照从大到小的greater来排</span></span><br></pre></td></tr></table></figure>\n<p>注：set、map的自定义比较函数和重载运算符与优先队列priority_queue类似。</p>\n","site":{"data":{}},"excerpt":"<p>之前一直搞不太懂自定义比较函数和重载运算符的概念，只会依葫芦画瓢的实现功能，渐渐的觉得这样不太好，虽然细节是魔鬼，但有些东西还是搞明白一点比较好。部分内容转载自<a href=\"https://www.ohazyi.com/c_cmp/\" target=\"_blank\" rel=\"noopener\">Ohazyi Zone’s blog</a><br></p>","more":"<p></p>\n<h2 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h2><h3 id=\"自定义比较函数\"><a href=\"#自定义比较函数\" class=\"headerlink\" title=\"自定义比较函数\"></a>自定义比较函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x <span class=\"comment\">//对x降序排列</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sort(d, d + n, cmp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：自定义比较函数的形式同样也适用于pair类型数据排序。</p>\n<h3 id=\"重载运算符-lt\"><a href=\"#重载运算符-lt\" class=\"headerlink\" title=\"重载运算符&lt;\"></a>重载运算符&lt;</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x; <span class=\"comment\">//重载为降序排列</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">node d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sort(d, d + n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：由于sort默认less(升序),所以重载’&lt;’运算符。重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。</p>\n<h2 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue\"></a>priority_queue</h2><h3 id=\"重载运算符-lt-运算符重载函数放到结构体外\"><a href=\"#重载运算符-lt-运算符重载函数放到结构体外\" class=\"headerlink\" title=\"重载运算符&lt; (运算符重载函数放到结构体外)\"></a>重载运算符&lt; (运算符重载函数放到结构体外)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"keyword\">const</span> node&amp; a, <span class=\"keyword\">const</span> node&amp; b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.x &gt; b.x <span class=\"comment\">//less默认大顶堆，改为小顶堆</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//bool operator &gt;(const node&amp; a, const node&amp; b)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    return a.x &lt; b.x //greater默认小顶堆，改为大顶堆</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main()&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, less&lt;node&gt; &gt; que;</span><br><span class=\"line\">    <span class=\"comment\">//priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; que;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同样重载运算符的操作不能用于pair类型数据的排序，只能作用于结构体或类对象。</p>\n<h3 id=\"重载运算符-lt-运算符重载函数放到结构体内\"><a href=\"#重载运算符-lt-运算符重载函数放到结构体内\" class=\"headerlink\" title=\"重载运算符&lt; (运算符重载函数放到结构体内)\"></a>重载运算符&lt; (运算符重载函数放到结构体内)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt;(node a) <span class=\"keyword\">const</span> &#123; <span class=\"comment\">//必须加const</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x &gt; a.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//bool operator &gt;(node a) const &#123; //必须加const</span></span><br><span class=\"line\">    <span class=\"comment\">//    return x &lt; a.x;</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, less&lt;node&gt; &gt; que;</span><br><span class=\"line\">    <span class=\"comment\">//priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; que;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同上。</p>\n<h3 id=\"自定义比较函数-1\"><a href=\"#自定义比较函数-1\" class=\"headerlink\" title=\"自定义比较函数\"></a>自定义比较函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp1</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(node a, node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.x &gt; b.x; <span class=\"comment\">//小顶堆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp2</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(node a, node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.x &lt; b.x; <span class=\"comment\">//大顶堆</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, cmp1&gt; que1; <span class=\"comment\">//小顶堆</span></span><br><span class=\"line\">    priority_queue&lt;node, <span class=\"built_in\">vector</span>&lt;node&gt;, cmp2&gt; que2; <span class=\"comment\">//大顶堆</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：同样适用于pair类型数据排序。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>, greater&lt;<span class=\"keyword\">int</span>&gt; &gt; st; <span class=\"comment\">//按照从大到小，默认是less&lt;int&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;P&gt; st; <span class=\"comment\">//按照pair的第一个元素来排，第一个相等的话按第二个来排</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;P, greater&lt;P&gt; &gt; st;<span class=\"comment\">//按照从大到小的greater来排</span></span><br></pre></td></tr></table></figure>\n<p>注：set、map的自定义比较函数和重载运算符与优先队列priority_queue类似。</p>"},{"title":"开源的NES游戏模拟器","date":"2018-12-02T16:28:38.000Z","_content":"偶然发现一个博主分享的开源NES游戏模拟器，安装后只要再去下载rom游戏就可以重温小时候的小霸王游戏机上的游戏！安装之后迫不及待的下载了超级马里奥，还是当年的感觉！激动(≧▽≦)\n![SuperMario](/SuperMario.png)\n<!--more-->\n## 参考链接\n[WTF Daily Blog](http://blog.topspeedsnail.com/archives/4249)\n感谢博主！下面只列出了开源的NES游戏模拟器，更多类型的模拟器请转到博主博客原文。\n\n[NES游戏下载地址](http://nesyouxi.net/)\n\n## NES模拟器\n\n### FCEUX\n[FCEUX](http://www.fceux.com/web/home.html)是开源的NES模拟器，使用C++编写，大概也是Linux上最好用的NES模拟器。它同样支持Windows、Mac os x。如果你使用的是Ubuntu，执行``sudo apt-get install fceux``安装fceux。如果你使用其他Linux发型版，可以从[这里](http://www.fceux.com/web/download.html)下载源代码编译安装 。\n\nPs.你可能会遇到无法解析安装包的情况，可以``sudo apt-get update``之后重新安装。如果依旧安装失败，可以尝试更新软件源。\n\n### Nestopia\n[Nestopia](http://nestopia.sourceforge.net/)另一个开源的NES模拟器，貌似很久没有更新了，它支持Windows、Linux、Mac os x系统。Nestopia也是使用c++编写，并且使用了大量的模版（难读）。它的执行效率还是挺高的。去年，我（指WTF Daily Blog的博主）把它移植到了andorid上，在低端手机上可以流畅运行。\n\n### My Nes\n[My Nes](https://sourceforge.net/projects/mynes/)是使用C#编写的开源NES模拟器，它只支持Windows系统。My Nes的代码非常易读，也许是因为这个原因，导致执行效率不高。","source":"_posts/Super-Mario.md","raw":"---\ntitle: 开源的NES游戏模拟器\ndate: 2018-12-03 00:28:38\ncategories:\n- Messy article\ntags:\n- Game\n---\n偶然发现一个博主分享的开源NES游戏模拟器，安装后只要再去下载rom游戏就可以重温小时候的小霸王游戏机上的游戏！安装之后迫不及待的下载了超级马里奥，还是当年的感觉！激动(≧▽≦)\n![SuperMario](/SuperMario.png)\n<!--more-->\n## 参考链接\n[WTF Daily Blog](http://blog.topspeedsnail.com/archives/4249)\n感谢博主！下面只列出了开源的NES游戏模拟器，更多类型的模拟器请转到博主博客原文。\n\n[NES游戏下载地址](http://nesyouxi.net/)\n\n## NES模拟器\n\n### FCEUX\n[FCEUX](http://www.fceux.com/web/home.html)是开源的NES模拟器，使用C++编写，大概也是Linux上最好用的NES模拟器。它同样支持Windows、Mac os x。如果你使用的是Ubuntu，执行``sudo apt-get install fceux``安装fceux。如果你使用其他Linux发型版，可以从[这里](http://www.fceux.com/web/download.html)下载源代码编译安装 。\n\nPs.你可能会遇到无法解析安装包的情况，可以``sudo apt-get update``之后重新安装。如果依旧安装失败，可以尝试更新软件源。\n\n### Nestopia\n[Nestopia](http://nestopia.sourceforge.net/)另一个开源的NES模拟器，貌似很久没有更新了，它支持Windows、Linux、Mac os x系统。Nestopia也是使用c++编写，并且使用了大量的模版（难读）。它的执行效率还是挺高的。去年，我（指WTF Daily Blog的博主）把它移植到了andorid上，在低端手机上可以流畅运行。\n\n### My Nes\n[My Nes](https://sourceforge.net/projects/mynes/)是使用C#编写的开源NES模拟器，它只支持Windows系统。My Nes的代码非常易读，也许是因为这个原因，导致执行效率不高。","slug":"Super-Mario","published":1,"updated":"2018-12-02T16:53:35.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrmv001gb8ouvfcr1ia0","content":"<p>偶然发现一个博主分享的开源NES游戏模拟器，安装后只要再去下载rom游戏就可以重温小时候的小霸王游戏机上的游戏！安装之后迫不及待的下载了超级马里奥，还是当年的感觉！激动(≧▽≦)<br><img src=\"/2018/12/03/Super-Mario/SuperMario.png\" alt=\"SuperMario\"><br><a id=\"more\"></a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://blog.topspeedsnail.com/archives/4249\" target=\"_blank\" rel=\"noopener\">WTF Daily Blog</a><br>感谢博主！下面只列出了开源的NES游戏模拟器，更多类型的模拟器请转到博主博客原文。</p>\n<p><a href=\"http://nesyouxi.net/\" target=\"_blank\" rel=\"noopener\">NES游戏下载地址</a></p>\n<h2 id=\"NES模拟器\"><a href=\"#NES模拟器\" class=\"headerlink\" title=\"NES模拟器\"></a>NES模拟器</h2><h3 id=\"FCEUX\"><a href=\"#FCEUX\" class=\"headerlink\" title=\"FCEUX\"></a>FCEUX</h3><p><a href=\"http://www.fceux.com/web/home.html\" target=\"_blank\" rel=\"noopener\">FCEUX</a>是开源的NES模拟器，使用C++编写，大概也是Linux上最好用的NES模拟器。它同样支持Windows、Mac os x。如果你使用的是Ubuntu，执行<code>sudo apt-get install fceux</code>安装fceux。如果你使用其他Linux发型版，可以从<a href=\"http://www.fceux.com/web/download.html\" target=\"_blank\" rel=\"noopener\">这里</a>下载源代码编译安装 。</p>\n<p>Ps.你可能会遇到无法解析安装包的情况，可以<code>sudo apt-get update</code>之后重新安装。如果依旧安装失败，可以尝试更新软件源。</p>\n<h3 id=\"Nestopia\"><a href=\"#Nestopia\" class=\"headerlink\" title=\"Nestopia\"></a>Nestopia</h3><p><a href=\"http://nestopia.sourceforge.net/\" target=\"_blank\" rel=\"noopener\">Nestopia</a>另一个开源的NES模拟器，貌似很久没有更新了，它支持Windows、Linux、Mac os x系统。Nestopia也是使用c++编写，并且使用了大量的模版（难读）。它的执行效率还是挺高的。去年，我（指WTF Daily Blog的博主）把它移植到了andorid上，在低端手机上可以流畅运行。</p>\n<h3 id=\"My-Nes\"><a href=\"#My-Nes\" class=\"headerlink\" title=\"My Nes\"></a>My Nes</h3><p><a href=\"https://sourceforge.net/projects/mynes/\" target=\"_blank\" rel=\"noopener\">My Nes</a>是使用C#编写的开源NES模拟器，它只支持Windows系统。My Nes的代码非常易读，也许是因为这个原因，导致执行效率不高。</p>\n","site":{"data":{}},"excerpt":"<p>偶然发现一个博主分享的开源NES游戏模拟器，安装后只要再去下载rom游戏就可以重温小时候的小霸王游戏机上的游戏！安装之后迫不及待的下载了超级马里奥，还是当年的感觉！激动(≧▽≦)<br><img src=\"/2018/12/03/Super-Mario/SuperMario.png\" alt=\"SuperMario\"><br></p>","more":"<p></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"http://blog.topspeedsnail.com/archives/4249\" target=\"_blank\" rel=\"noopener\">WTF Daily Blog</a><br>感谢博主！下面只列出了开源的NES游戏模拟器，更多类型的模拟器请转到博主博客原文。</p>\n<p><a href=\"http://nesyouxi.net/\" target=\"_blank\" rel=\"noopener\">NES游戏下载地址</a></p>\n<h2 id=\"NES模拟器\"><a href=\"#NES模拟器\" class=\"headerlink\" title=\"NES模拟器\"></a>NES模拟器</h2><h3 id=\"FCEUX\"><a href=\"#FCEUX\" class=\"headerlink\" title=\"FCEUX\"></a>FCEUX</h3><p><a href=\"http://www.fceux.com/web/home.html\" target=\"_blank\" rel=\"noopener\">FCEUX</a>是开源的NES模拟器，使用C++编写，大概也是Linux上最好用的NES模拟器。它同样支持Windows、Mac os x。如果你使用的是Ubuntu，执行<code>sudo apt-get install fceux</code>安装fceux。如果你使用其他Linux发型版，可以从<a href=\"http://www.fceux.com/web/download.html\" target=\"_blank\" rel=\"noopener\">这里</a>下载源代码编译安装 。</p>\n<p>Ps.你可能会遇到无法解析安装包的情况，可以<code>sudo apt-get update</code>之后重新安装。如果依旧安装失败，可以尝试更新软件源。</p>\n<h3 id=\"Nestopia\"><a href=\"#Nestopia\" class=\"headerlink\" title=\"Nestopia\"></a>Nestopia</h3><p><a href=\"http://nestopia.sourceforge.net/\" target=\"_blank\" rel=\"noopener\">Nestopia</a>另一个开源的NES模拟器，貌似很久没有更新了，它支持Windows、Linux、Mac os x系统。Nestopia也是使用c++编写，并且使用了大量的模版（难读）。它的执行效率还是挺高的。去年，我（指WTF Daily Blog的博主）把它移植到了andorid上，在低端手机上可以流畅运行。</p>\n<h3 id=\"My-Nes\"><a href=\"#My-Nes\" class=\"headerlink\" title=\"My Nes\"></a>My Nes</h3><p><a href=\"https://sourceforge.net/projects/mynes/\" target=\"_blank\" rel=\"noopener\">My Nes</a>是使用C#编写的开源NES模拟器，它只支持Windows系统。My Nes的代码非常易读，也许是因为这个原因，导致执行效率不高。</p>"},{"title":"Uva10129-Play on Words-欧拉路","date":"2018-11-11T23:25:48.000Z","_content":"输入n个单词，是否可以把所有这些单词排成一个序列，使得每个单词的第一个字母和上一个单词的最后一个字母相同。\n<!--more-->\n## 链接\n[Uva10129-Play on Words](https://vjudge.net/problem/UVA-10129)\n\n## 题解\n建图。将字母看做结点，单词看做有向边。例如单词acm, mouse建图为a->m->e。如果该图存在一条欧拉路则问题有解。首先判断忽略边方向后的无向图是否连通，有两种方法来判断，一种是DFS，另一种是并查集（此代码采用DFS判断）。然后依据建图时统计的各个结点的出度和入度信息判断是否有欧拉路存在。\n**有一个需要注意的地方是，可能两个结点之间存在多条边，但是判断连通性的时候可以忽略，多边存在时按单边处理，不影响连通性。**\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon  12 Nov 07:00:18 CST 2018\n *`\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Degree{\n\tint in;\n\tint out;\n};\nint G[30][30];\nDegree d[30];\nint T, n;\n\nvoid dfs(int x){\n\tfor(int i = 0; i < 26; i++){\n\t\tif(G[x][i]){\n\t\t\tG[x][i] = G[i][0] = 0;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\nbool JudgeEulr(){\n\tvector<int> vec;\n\tfor(int i = 0; i < 26; i++){\n\t\tif(d[i].in != d[i].out){\n\t\t\tvec.push_back(i);\n\t\t} \n\t}\n\tint len = vec.size();\n\tif(len == 0) \n\t\treturn true;\n\telse if(len == 2){\n\t\tif((d[vec[0]].in - 1 == d[vec[0]].out && d[vec[1]].out - 1 == d[vec[1]].in) || (d[vec[0]].out - 1 == d[vec[0]].in && d[vec[1]].in - 1 == d[vec[1]].out))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse\n\t\treturn false;\n}\n\nint main(){\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout.tie(0);\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t#endif\n\n\tcin >> T;\n\twhile(T--){\n\t\tcin >> n;\n\t\tmemset(G, 0, sizeof(G));\n\t\tmemset(d, 0, sizeof(d));\n\t\tstring s;\n\t\tint a, b;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s;\n\t\t\tint len = s.length();\n\t\t\ta = s[0] - 'a', b = s[len - 1] - 'a';\n\t\t\tG[a][b] = 1, G[b][a] = 1;\n\t\t\td[a].out++, d[b].in++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tdfs(i);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << cnt << endl;\n\t\tif(cnt > 1){\n\t\t\tcout << \"The door cannot be opened.\" << endl;\n\t\t}\n\t\telse{\n\t\t\tif(JudgeEulr())\n\t\t\t\tcout << \"Ordering is possible.\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"The door cannot be opened.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```","source":"_posts/Uva10129-Play-on-Words.md","raw":"---\ntitle: Uva10129-Play on Words-欧拉路\ndate: 2018-11-12 07:25:48\ncategories:\n- ACM\n- 欧拉路\ntags:\n- 欧拉路\n- DFS\n---\n输入n个单词，是否可以把所有这些单词排成一个序列，使得每个单词的第一个字母和上一个单词的最后一个字母相同。\n<!--more-->\n## 链接\n[Uva10129-Play on Words](https://vjudge.net/problem/UVA-10129)\n\n## 题解\n建图。将字母看做结点，单词看做有向边。例如单词acm, mouse建图为a->m->e。如果该图存在一条欧拉路则问题有解。首先判断忽略边方向后的无向图是否连通，有两种方法来判断，一种是DFS，另一种是并查集（此代码采用DFS判断）。然后依据建图时统计的各个结点的出度和入度信息判断是否有欧拉路存在。\n**有一个需要注意的地方是，可能两个结点之间存在多条边，但是判断连通性的时候可以忽略，多边存在时按单边处理，不影响连通性。**\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon  12 Nov 07:00:18 CST 2018\n *`\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Degree{\n\tint in;\n\tint out;\n};\nint G[30][30];\nDegree d[30];\nint T, n;\n\nvoid dfs(int x){\n\tfor(int i = 0; i < 26; i++){\n\t\tif(G[x][i]){\n\t\t\tG[x][i] = G[i][0] = 0;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\nbool JudgeEulr(){\n\tvector<int> vec;\n\tfor(int i = 0; i < 26; i++){\n\t\tif(d[i].in != d[i].out){\n\t\t\tvec.push_back(i);\n\t\t} \n\t}\n\tint len = vec.size();\n\tif(len == 0) \n\t\treturn true;\n\telse if(len == 2){\n\t\tif((d[vec[0]].in - 1 == d[vec[0]].out && d[vec[1]].out - 1 == d[vec[1]].in) || (d[vec[0]].out - 1 == d[vec[0]].in && d[vec[1]].in - 1 == d[vec[1]].out))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse\n\t\treturn false;\n}\n\nint main(){\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout.tie(0);\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t#endif\n\n\tcin >> T;\n\twhile(T--){\n\t\tcin >> n;\n\t\tmemset(G, 0, sizeof(G));\n\t\tmemset(d, 0, sizeof(d));\n\t\tstring s;\n\t\tint a, b;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s;\n\t\t\tint len = s.length();\n\t\t\ta = s[0] - 'a', b = s[len - 1] - 'a';\n\t\t\tG[a][b] = 1, G[b][a] = 1;\n\t\t\td[a].out++, d[b].in++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tif(G[i][j]){\n\t\t\t\t\tdfs(i);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << cnt << endl;\n\t\tif(cnt > 1){\n\t\t\tcout << \"The door cannot be opened.\" << endl;\n\t\t}\n\t\telse{\n\t\t\tif(JudgeEulr())\n\t\t\t\tcout << \"Ordering is possible.\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"The door cannot be opened.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```","slug":"Uva10129-Play-on-Words","published":1,"updated":"2018-12-14T13:03:02.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrmx001jb8ouduano1jm","content":"<p>输入n个单词，是否可以把所有这些单词排成一个序列，使得每个单词的第一个字母和上一个单词的最后一个字母相同。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-10129\" target=\"_blank\" rel=\"noopener\">Uva10129-Play on Words</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>建图。将字母看做结点，单词看做有向边。例如单词acm, mouse建图为a-&gt;m-&gt;e。如果该图存在一条欧拉路则问题有解。首先判断忽略边方向后的无向图是否连通，有两种方法来判断，一种是DFS，另一种是并查集（此代码采用DFS判断）。然后依据建图时统计的各个结点的出度和入度信息判断是否有欧拉路存在。<br><strong>有一个需要注意的地方是，可能两个结点之间存在多条边，但是判断连通性的时候可以忽略，多边存在时按单边处理，不影响连通性。</strong></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon  12 Nov 07:00:18 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *`</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Degree</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> in;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> out;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> G[<span class=\"number\">30</span>][<span class=\"number\">30</span>];</span><br><span class=\"line\">Degree d[<span class=\"number\">30</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> T, n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(G[x][i])&#123;</span><br><span class=\"line\">\t\t\tG[x][i] = G[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tdfs(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">JudgeEulr</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(d[i].in != d[i].out)&#123;</span><br><span class=\"line\">\t\t\tvec.push_back(i);</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = vec.size();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>) </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(len == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((d[vec[<span class=\"number\">0</span>]].in - <span class=\"number\">1</span> == d[vec[<span class=\"number\">0</span>]].out &amp;&amp; d[vec[<span class=\"number\">1</span>]].out - <span class=\"number\">1</span> == d[vec[<span class=\"number\">1</span>]].in) || (d[vec[<span class=\"number\">0</span>]].out - <span class=\"number\">1</span> == d[vec[<span class=\"number\">0</span>]].in &amp;&amp; d[vec[<span class=\"number\">1</span>]].in - <span class=\"number\">1</span> == d[vec[<span class=\"number\">1</span>]].out))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">\t<span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">\t<span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\tfreopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; T;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(T--)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(G, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(G));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">\t\t<span class=\"built_in\">string</span> s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">\t\t\ta = s[<span class=\"number\">0</span>] - <span class=\"string\">'a'</span>, b = s[len - <span class=\"number\">1</span>] - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">\t\t\tG[a][b] = <span class=\"number\">1</span>, G[b][a] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\td[a].out++, d[b].in++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">26</span>; j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(G[i][j])&#123;</span><br><span class=\"line\">\t\t\t\t\tdfs(i);</span><br><span class=\"line\">\t\t\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The door cannot be opened.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(JudgeEulr())</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Ordering is possible.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The door cannot be opened.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>输入n个单词，是否可以把所有这些单词排成一个序列，使得每个单词的第一个字母和上一个单词的最后一个字母相同。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-10129\" target=\"_blank\" rel=\"noopener\">Uva10129-Play on Words</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>建图。将字母看做结点，单词看做有向边。例如单词acm, mouse建图为a-&gt;m-&gt;e。如果该图存在一条欧拉路则问题有解。首先判断忽略边方向后的无向图是否连通，有两种方法来判断，一种是DFS，另一种是并查集（此代码采用DFS判断）。然后依据建图时统计的各个结点的出度和入度信息判断是否有欧拉路存在。<br><strong>有一个需要注意的地方是，可能两个结点之间存在多条边，但是判断连通性的时候可以忽略，多边存在时按单边处理，不影响连通性。</strong></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon  12 Nov 07:00:18 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *`</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Degree</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> in;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> out;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> G[<span class=\"number\">30</span>][<span class=\"number\">30</span>];</span><br><span class=\"line\">Degree d[<span class=\"number\">30</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> T, n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(G[x][i])&#123;</span><br><span class=\"line\">\t\t\tG[x][i] = G[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tdfs(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">JudgeEulr</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(d[i].in != d[i].out)&#123;</span><br><span class=\"line\">\t\t\tvec.push_back(i);</span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = vec.size();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>) </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(len == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((d[vec[<span class=\"number\">0</span>]].in - <span class=\"number\">1</span> == d[vec[<span class=\"number\">0</span>]].out &amp;&amp; d[vec[<span class=\"number\">1</span>]].out - <span class=\"number\">1</span> == d[vec[<span class=\"number\">1</span>]].in) || (d[vec[<span class=\"number\">0</span>]].out - <span class=\"number\">1</span> == d[vec[<span class=\"number\">0</span>]].in &amp;&amp; d[vec[<span class=\"number\">1</span>]].in - <span class=\"number\">1</span> == d[vec[<span class=\"number\">1</span>]].out))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">\t<span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">\t<span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\tfreopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; T;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(T--)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(G, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(G));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">\t\t<span class=\"built_in\">string</span> s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\">\t\t\ta = s[<span class=\"number\">0</span>] - <span class=\"string\">'a'</span>, b = s[len - <span class=\"number\">1</span>] - <span class=\"string\">'a'</span>;</span><br><span class=\"line\">\t\t\tG[a][b] = <span class=\"number\">1</span>, G[b][a] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\td[a].out++, d[b].in++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">26</span>; j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(G[i][j])&#123;</span><br><span class=\"line\">\t\t\t\t\tdfs(i);</span><br><span class=\"line\">\t\t\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The door cannot be opened.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(JudgeEulr())</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Ordering is possible.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"The door cannot be opened.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva10305-Ordering Tasks-拓扑排序","date":"2018-11-04T11:47:51.000Z","_content":"有n个变量，m个二元组(u, v), 分别表示u小于v。要求给出一种所有变量从小到大排列的可能。\n<!--more-->\n## 链接\n[Uva10305-Ordering Tasks](https://vjudge.net/problem/UVA-10305)\n## 题解\n建图，以变量为顶点，“小于”关系为有向边。问题变为求这个图的拓扑排序。借助DFS来完成排序。\n```\n在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：\n1. 每个顶点出现且只出现一次；\n2. 若A在序列中排在B的前面，则在图中不存在从B到A的路径。\n```\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun  4 Nov 18:47:13 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint n, m;\nint c[maxn];\nint res[maxn];\nint G[maxn][maxn];\nint t;\n\nbool dfs(int u){\n    c[u] = -1;\n    for(int i = 1; i <= n; i++){\n        if(G[u][i]){\n            if(c[i] == -1) return false;\n            else if(c[i] == 0 && !dfs(i)) return false;\n        }\n        //c[u] = 1, res[--t] = u;\n    }\n    c[u] = 1, res[--t] = u;\n    return true;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        t = n;\n        memset(c, 0, sizeof(c));\n        memset(res, 0, sizeof(res));\n        memset(G, 0, sizeof(G));\n        int x, y;\n        for(int i = 0; i < m; i++){\n            cin >> x >> y;\n            G[x][y] = 1;\n        }\n        for(int i = 1; i <= n; i++){\n            if(!c[i]){\n                //cout << \"i: \" << i << endl;\n                dfs(i);\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(!i) cout << res[i];\n            else cout << \" \" << res[i];\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n## 拓展\n拓扑等价：\n有多个解释，其中一个几何上的解释是，一个曲面经过扭转、弯曲、拉长或收缩得到另一个曲面，期间没有出现任何点的重叠与断开，那么可以说这两个曲面是拓扑等价的。\n```\n//知乎上看到的一个笑话\n“美女和丑女在数学上是不是拓扑等价的？”\n“这要看她有没有打耳洞”\n（逃\n```","source":"_posts/Uva10305-Ordering-Tasks.md","raw":"---\ntitle: Uva10305-Ordering Tasks-拓扑排序\ndate: 2018-11-04 19:47:51\ncategories:\n- ACM\n- 拓扑排序\ntags:\n- DFS\n- 拓扑排序\n---\n有n个变量，m个二元组(u, v), 分别表示u小于v。要求给出一种所有变量从小到大排列的可能。\n<!--more-->\n## 链接\n[Uva10305-Ordering Tasks](https://vjudge.net/problem/UVA-10305)\n## 题解\n建图，以变量为顶点，“小于”关系为有向边。问题变为求这个图的拓扑排序。借助DFS来完成排序。\n```\n在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：\n1. 每个顶点出现且只出现一次；\n2. 若A在序列中排在B的前面，则在图中不存在从B到A的路径。\n```\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun  4 Nov 18:47:13 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint n, m;\nint c[maxn];\nint res[maxn];\nint G[maxn][maxn];\nint t;\n\nbool dfs(int u){\n    c[u] = -1;\n    for(int i = 1; i <= n; i++){\n        if(G[u][i]){\n            if(c[i] == -1) return false;\n            else if(c[i] == 0 && !dfs(i)) return false;\n        }\n        //c[u] = 1, res[--t] = u;\n    }\n    c[u] = 1, res[--t] = u;\n    return true;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        t = n;\n        memset(c, 0, sizeof(c));\n        memset(res, 0, sizeof(res));\n        memset(G, 0, sizeof(G));\n        int x, y;\n        for(int i = 0; i < m; i++){\n            cin >> x >> y;\n            G[x][y] = 1;\n        }\n        for(int i = 1; i <= n; i++){\n            if(!c[i]){\n                //cout << \"i: \" << i << endl;\n                dfs(i);\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(!i) cout << res[i];\n            else cout << \" \" << res[i];\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n```\n## 拓展\n拓扑等价：\n有多个解释，其中一个几何上的解释是，一个曲面经过扭转、弯曲、拉长或收缩得到另一个曲面，期间没有出现任何点的重叠与断开，那么可以说这两个曲面是拓扑等价的。\n```\n//知乎上看到的一个笑话\n“美女和丑女在数学上是不是拓扑等价的？”\n“这要看她有没有打耳洞”\n（逃\n```","slug":"Uva10305-Ordering-Tasks","published":1,"updated":"2018-12-14T13:03:31.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrmy001mb8oumtzy81lm","content":"<p>有n个变量，m个二元组(u, v), 分别表示u小于v。要求给出一种所有变量从小到大排列的可能。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-10305\" target=\"_blank\" rel=\"noopener\">Uva10305-Ordering Tasks</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>建图，以变量为顶点，“小于”关系为有向边。问题变为求这个图的拓扑排序。借助DFS来完成排序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</span><br><span class=\"line\">1. 每个顶点出现且只出现一次；</span><br><span class=\"line\">2. 若A在序列中排在B的前面，则在图中不存在从B到A的路径。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun  4 Nov 18:47:13 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">107</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> res[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> G[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    c[u] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G[u][i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[i] == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[i] == <span class=\"number\">0</span> &amp;&amp; !dfs(i)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//c[u] = 1, res[--t] = u;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    c[u] = <span class=\"number\">1</span>, res[--t] = u;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span> &amp;&amp; m == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        t = n;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(c, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(c));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(res, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(res));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(G, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(G));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class=\"line\">            G[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!c[i])&#123;</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; \"i: \" &lt;&lt; i &lt;&lt; endl;</span></span><br><span class=\"line\">                dfs(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!i) <span class=\"built_in\">cout</span> &lt;&lt; res[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; res[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>拓扑等价：<br>有多个解释，其中一个几何上的解释是，一个曲面经过扭转、弯曲、拉长或收缩得到另一个曲面，期间没有出现任何点的重叠与断开，那么可以说这两个曲面是拓扑等价的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//知乎上看到的一个笑话</span><br><span class=\"line\">“美女和丑女在数学上是不是拓扑等价的？”</span><br><span class=\"line\">“这要看她有没有打耳洞”</span><br><span class=\"line\">（逃</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>有n个变量，m个二元组(u, v), 分别表示u小于v。要求给出一种所有变量从小到大排列的可能。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-10305\" target=\"_blank\" rel=\"noopener\">Uva10305-Ordering Tasks</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>建图，以变量为顶点，“小于”关系为有向边。问题变为求这个图的拓扑排序。借助DFS来完成排序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</span><br><span class=\"line\">1. 每个顶点出现且只出现一次；</span><br><span class=\"line\">2. 若A在序列中排在B的前面，则在图中不存在从B到A的路径。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun  4 Nov 18:47:13 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">107</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> res[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> G[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    c[u] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G[u][i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[i] == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[i] == <span class=\"number\">0</span> &amp;&amp; !dfs(i)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//c[u] = 1, res[--t] = u;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    c[u] = <span class=\"number\">1</span>, res[--t] = u;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span> &amp;&amp; m == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        t = n;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(c, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(c));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(res, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(res));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(G, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(G));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class=\"line\">            G[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!c[i])&#123;</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; \"i: \" &lt;&lt; i &lt;&lt; endl;</span></span><br><span class=\"line\">                dfs(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!i) <span class=\"built_in\">cout</span> &lt;&lt; res[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; res[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>拓扑等价：<br>有多个解释，其中一个几何上的解释是，一个曲面经过扭转、弯曲、拉长或收缩得到另一个曲面，期间没有出现任何点的重叠与断开，那么可以说这两个曲面是拓扑等价的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//知乎上看到的一个笑话</span><br><span class=\"line\">“美女和丑女在数学上是不是拓扑等价的？”</span><br><span class=\"line\">“这要看她有没有打耳洞”</span><br><span class=\"line\">（逃</span><br></pre></td></tr></table></figure></p>"},{"title":"My little angel","date":"2018-06-10T01:57:06.000Z","_content":"## 重庆之旅\n　　和邱小笨蛋在一起四个多月了，但是快一年没见了，她在重庆，我在北京，她读高中，我读大学。感觉有些不可思议，能够遇到，能够在一起。感谢女票的勇敢，我是非常怂的，，，。\n在重庆度过了非常非常开心的几天，刚到的那天晚上给女票发消息说到了之后激动的睡不着，第二天早上终于见到了穿着裙裙来找我的女票票～(｡･ω･｡)ﾉ♡\n![邱小雁](/qxy1.jpg)\n<!-- more -->\n　　女票比印象中要瘦了，可能是高中太累了吧，有些心疼，让她多长些肉肉她还不愿意Ծ‸ Ծ 。之后两人一起牵爪爪去逛商场玩了和女票期待已久的密室逃脱，可惜太菜了，小哥哥可能是可怜我们哈哈让我们看了最后的一关。\n　　一直想去女票学校看看的心愿也达成了，想感受一下女票平时给我发的照片里的地方、花花到底是什么样子的。去了女票平时自习的自习室，稍微有点冷，女票下次去的时候多穿一点啊。竟然还遇到了抓早恋的老师＝＝（害怕.jpg），女票好机智，话说我都大三了为什么还怕这种老师。。\n　　第三天早上和女票在一起吃的早餐，还是要说一下女票吃的太少了，多长肉肉啊亲爱的，不用担心，男票抱得动的(•̀⌄•́)。吃了早餐一起去女票住的小区里打了篮球，之前说要教女票投篮可是自己投了十几个才中了一个，，呜呜呜T^T树立了一个篮球小菜鸡的形象，不过一起吃了可爱多很开心(๑❛ᴗ❛๑)。中午去吃了自助，女票怕我吃不了太辣点了清汤的小火锅，委屈重庆小妹纸了。下午一起做了情侣必做的事情，看电影！而且是小哆啦哈哈，抱着女票看电影的感觉好幸福。\n　　女票怕妈妈担心本来是要在家吃晚饭的，我晚上不知道吃什么和女票说想点外卖，女票就从家跑出来陪我了，感动::>_<::（虽然最后在一起抱了好久连外卖也没吃成哈哈哈），感谢我女票票。晚上送女票回家一起在长江边散步也超级开心，女票还热情的给我介绍了重庆的“移动公厕”哈哈。\n<figure class=\"half\">\n    ![邱小雁](/moon1.jpg)　![邱小雁](/together1.jpg)\n</figure>\n\n　　周五要回学校了，女票早上发消息说她准备来找我了，昨晚梦到我突然就不见了，我骗女票说我是9:45的飞机，我已经走了（其实是11:45的飞机，那时候大概7:40左右我刚醒），本来我以为傻女票不会相信，没想到她直接哭着给我打电话问我“你干嘛啊”，天啊，心都要化了。可能是之前和她说机场有点远不想让她送我，所以她才相信我真的走了吧♡。见到女票后果然被打了，，但是那句“你是猪吗”我却听的如痴如醉，怎么会有这么可爱的女孩子啊。\n　　我爱你，傻女票。","source":"_posts/My-little-angel.md","raw":"---\ntitle: My little angel\ndate: 2018-06-10 09:57:06\ncategories:\n- Diary\ntags:\n- Lover\n---\n## 重庆之旅\n　　和邱小笨蛋在一起四个多月了，但是快一年没见了，她在重庆，我在北京，她读高中，我读大学。感觉有些不可思议，能够遇到，能够在一起。感谢女票的勇敢，我是非常怂的，，，。\n在重庆度过了非常非常开心的几天，刚到的那天晚上给女票发消息说到了之后激动的睡不着，第二天早上终于见到了穿着裙裙来找我的女票票～(｡･ω･｡)ﾉ♡\n![邱小雁](/qxy1.jpg)\n<!-- more -->\n　　女票比印象中要瘦了，可能是高中太累了吧，有些心疼，让她多长些肉肉她还不愿意Ծ‸ Ծ 。之后两人一起牵爪爪去逛商场玩了和女票期待已久的密室逃脱，可惜太菜了，小哥哥可能是可怜我们哈哈让我们看了最后的一关。\n　　一直想去女票学校看看的心愿也达成了，想感受一下女票平时给我发的照片里的地方、花花到底是什么样子的。去了女票平时自习的自习室，稍微有点冷，女票下次去的时候多穿一点啊。竟然还遇到了抓早恋的老师＝＝（害怕.jpg），女票好机智，话说我都大三了为什么还怕这种老师。。\n　　第三天早上和女票在一起吃的早餐，还是要说一下女票吃的太少了，多长肉肉啊亲爱的，不用担心，男票抱得动的(•̀⌄•́)。吃了早餐一起去女票住的小区里打了篮球，之前说要教女票投篮可是自己投了十几个才中了一个，，呜呜呜T^T树立了一个篮球小菜鸡的形象，不过一起吃了可爱多很开心(๑❛ᴗ❛๑)。中午去吃了自助，女票怕我吃不了太辣点了清汤的小火锅，委屈重庆小妹纸了。下午一起做了情侣必做的事情，看电影！而且是小哆啦哈哈，抱着女票看电影的感觉好幸福。\n　　女票怕妈妈担心本来是要在家吃晚饭的，我晚上不知道吃什么和女票说想点外卖，女票就从家跑出来陪我了，感动::>_<::（虽然最后在一起抱了好久连外卖也没吃成哈哈哈），感谢我女票票。晚上送女票回家一起在长江边散步也超级开心，女票还热情的给我介绍了重庆的“移动公厕”哈哈。\n<figure class=\"half\">\n    ![邱小雁](/moon1.jpg)　![邱小雁](/together1.jpg)\n</figure>\n\n　　周五要回学校了，女票早上发消息说她准备来找我了，昨晚梦到我突然就不见了，我骗女票说我是9:45的飞机，我已经走了（其实是11:45的飞机，那时候大概7:40左右我刚醒），本来我以为傻女票不会相信，没想到她直接哭着给我打电话问我“你干嘛啊”，天啊，心都要化了。可能是之前和她说机场有点远不想让她送我，所以她才相信我真的走了吧♡。见到女票后果然被打了，，但是那句“你是猪吗”我却听的如痴如醉，怎么会有这么可爱的女孩子啊。\n　　我爱你，傻女票。","slug":"My-little-angel","published":1,"updated":"2018-10-16T04:34:47.071Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrmz001qb8ou607a3db0","content":"<h2 id=\"重庆之旅\"><a href=\"#重庆之旅\" class=\"headerlink\" title=\"重庆之旅\"></a>重庆之旅</h2><p>　　和邱小笨蛋在一起四个多月了，但是快一年没见了，她在重庆，我在北京，她读高中，我读大学。感觉有些不可思议，能够遇到，能够在一起。感谢女票的勇敢，我是非常怂的，，，。<br>在重庆度过了非常非常开心的几天，刚到的那天晚上给女票发消息说到了之后激动的睡不着，第二天早上终于见到了穿着裙裙来找我的女票票～(｡･ω･｡)ﾉ♡<br><img src=\"/2018/06/10/My-little-angel/qxy1.jpg\" alt=\"邱小雁\"><br><a id=\"more\"></a><br>　　女票比印象中要瘦了，可能是高中太累了吧，有些心疼，让她多长些肉肉她还不愿意Ծ‸ Ծ 。之后两人一起牵爪爪去逛商场玩了和女票期待已久的密室逃脱，可惜太菜了，小哥哥可能是可怜我们哈哈让我们看了最后的一关。<br>　　一直想去女票学校看看的心愿也达成了，想感受一下女票平时给我发的照片里的地方、花花到底是什么样子的。去了女票平时自习的自习室，稍微有点冷，女票下次去的时候多穿一点啊。竟然还遇到了抓早恋的老师＝＝（害怕.jpg），女票好机智，话说我都大三了为什么还怕这种老师。。<br>　　第三天早上和女票在一起吃的早餐，还是要说一下女票吃的太少了，多长肉肉啊亲爱的，不用担心，男票抱得动的(•̀⌄•́)。吃了早餐一起去女票住的小区里打了篮球，之前说要教女票投篮可是自己投了十几个才中了一个，，呜呜呜T^T树立了一个篮球小菜鸡的形象，不过一起吃了可爱多很开心(๑❛ᴗ❛๑)。中午去吃了自助，女票怕我吃不了太辣点了清汤的小火锅，委屈重庆小妹纸了。下午一起做了情侣必做的事情，看电影！而且是小哆啦哈哈，抱着女票看电影的感觉好幸福。<br>　　女票怕妈妈担心本来是要在家吃晚饭的，我晚上不知道吃什么和女票说想点外卖，女票就从家跑出来陪我了，感动::&gt;_&lt;::（虽然最后在一起抱了好久连外卖也没吃成哈哈哈），感谢我女票票。晚上送女票回家一起在长江边散步也超级开心，女票还热情的给我介绍了重庆的“移动公厕”哈哈。</p>\n<figure class=\"half\"><br>    <img src=\"/2018/06/10/My-little-angel/moon1.jpg\" alt=\"邱小雁\">　<img src=\"/2018/06/10/My-little-angel/together1.jpg\" alt=\"邱小雁\"><br></figure>\n\n<p>　　周五要回学校了，女票早上发消息说她准备来找我了，昨晚梦到我突然就不见了，我骗女票说我是9:45的飞机，我已经走了（其实是11:45的飞机，那时候大概7:40左右我刚醒），本来我以为傻女票不会相信，没想到她直接哭着给我打电话问我“你干嘛啊”，天啊，心都要化了。可能是之前和她说机场有点远不想让她送我，所以她才相信我真的走了吧♡。见到女票后果然被打了，，但是那句“你是猪吗”我却听的如痴如醉，怎么会有这么可爱的女孩子啊。<br>　　我爱你，傻女票。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"重庆之旅\"><a href=\"#重庆之旅\" class=\"headerlink\" title=\"重庆之旅\"></a>重庆之旅</h2><p>　　和邱小笨蛋在一起四个多月了，但是快一年没见了，她在重庆，我在北京，她读高中，我读大学。感觉有些不可思议，能够遇到，能够在一起。感谢女票的勇敢，我是非常怂的，，，。<br>在重庆度过了非常非常开心的几天，刚到的那天晚上给女票发消息说到了之后激动的睡不着，第二天早上终于见到了穿着裙裙来找我的女票票～(｡･ω･｡)ﾉ♡<br><img src=\"/2018/06/10/My-little-angel/qxy1.jpg\" alt=\"邱小雁\"><br></p>","more":"<br>　　女票比印象中要瘦了，可能是高中太累了吧，有些心疼，让她多长些肉肉她还不愿意Ծ‸ Ծ 。之后两人一起牵爪爪去逛商场玩了和女票期待已久的密室逃脱，可惜太菜了，小哥哥可能是可怜我们哈哈让我们看了最后的一关。<br>　　一直想去女票学校看看的心愿也达成了，想感受一下女票平时给我发的照片里的地方、花花到底是什么样子的。去了女票平时自习的自习室，稍微有点冷，女票下次去的时候多穿一点啊。竟然还遇到了抓早恋的老师＝＝（害怕.jpg），女票好机智，话说我都大三了为什么还怕这种老师。。<br>　　第三天早上和女票在一起吃的早餐，还是要说一下女票吃的太少了，多长肉肉啊亲爱的，不用担心，男票抱得动的(•̀⌄•́)。吃了早餐一起去女票住的小区里打了篮球，之前说要教女票投篮可是自己投了十几个才中了一个，，呜呜呜T^T树立了一个篮球小菜鸡的形象，不过一起吃了可爱多很开心(๑❛ᴗ❛๑)。中午去吃了自助，女票怕我吃不了太辣点了清汤的小火锅，委屈重庆小妹纸了。下午一起做了情侣必做的事情，看电影！而且是小哆啦哈哈，抱着女票看电影的感觉好幸福。<br>　　女票怕妈妈担心本来是要在家吃晚饭的，我晚上不知道吃什么和女票说想点外卖，女票就从家跑出来陪我了，感动::&gt;_&lt;::（虽然最后在一起抱了好久连外卖也没吃成哈哈哈），感谢我女票票。晚上送女票回家一起在长江边散步也超级开心，女票还热情的给我介绍了重庆的“移动公厕”哈哈。<p></p>\n<figure class=\"half\"><br>    <img src=\"/2018/06/10/My-little-angel/moon1.jpg\" alt=\"邱小雁\">　<img src=\"/2018/06/10/My-little-angel/together1.jpg\" alt=\"邱小雁\"><br></figure>\n\n<p>　　周五要回学校了，女票早上发消息说她准备来找我了，昨晚梦到我突然就不见了，我骗女票说我是9:45的飞机，我已经走了（其实是11:45的飞机，那时候大概7:40左右我刚醒），本来我以为傻女票不会相信，没想到她直接哭着给我打电话问我“你干嘛啊”，天啊，心都要化了。可能是之前和她说机场有点远不想让她送我，所以她才相信我真的走了吧♡。见到女票后果然被打了，，但是那句“你是猪吗”我却听的如痴如醉，怎么会有这么可爱的女孩子啊。<br>　　我爱你，傻女票。</p>"},{"title":"Uva1103-Ancient Messages-DFS","date":"2018-10-28T13:41:19.000Z","_content":"一道让人惊呼“DFS还能这么玩”的题目。给定一个由象形文字组成的图像，要求按字典序输出图中所有象形文字（输出时每个象形文字由一个给定的英文表示）。关键是通过什么方法区分这些象形文字。\n![hier](/hier.png)\n<!--more-->\n## 链接\n[Uva1103-Ancient Messages](https://vjudge.net/problem/UVA-1103)\n## 题目描述\n图像的像素由 $0$ 和 $1$ 组成，其中 $0$ 代表白色像素点，$1$ 代表黑色像素点。整个图像以十六进制形式给出。图像包含六种象形符号中的至少一个，不同的符号不会相互接触。符号的形状和上图给出的拓扑等价（可以随意拉伸但不能拉断）。\n<div style=\"width: 300px; margin: auto\">\n    ![1.png](/1.png)\n    ![2.png](/2.png)\n</div>\n## 题解\n需要找出能够区别出这些不同象形符号的特征量。可以发现每个符号都包含一些白色的色块区域，6个符号从左到右分别包含 $1$，$3$，$5$，$4$，$0$，$2$ 个白色区域，各不相同。所以可以根据这一特征量区分不同的象形符号。\n具体做法为用dfs方法对每一块黑色或白色区域染色，这样可以把图像分为几个不同的颜色区域，再从每个黑色像素区域出发去统计在它内部的白色像素区域的个数。\n\n*需要注意的是初始时要在图像四周多添加一圈白色像素，以保证color 1 每次都表示的是背景白色像素区域*（因为这个地方$WA$了好多次，$QAQ$）\n\n另外这题没有测试数据也很坑2333，最后友情赠送几组测试数据。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 28 Oct 22:24:10 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxh = 207;\nconst int maxw = 50 * 4 + 7;\nint h, w;\nchar pix[maxh][maxw];\nint dig[maxh][maxw];\nint color[maxh][maxw];\nint dcode[256];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nvector<int> rec;\nset<int> st[maxw];\nconst string s = \"WAKJSD\";\n\nvoid decode(char c, int h, int pos){\n    int x = dcode[(int)c];\n    for(int i = 0; i < 4; i++){\n        if(x & (1 << (3 - i))) dig[h][pos + i] = 1;\n        else dig[h][pos + i] = 0;\n    }\n}\n\nvoid dye(int x, int y, int c){\n    color[x][y] = c;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx >= 0 && nx < h && ny >= 0 && ny < w && color[nx][ny] == 0 && dig[nx][ny] == dig[x][y]){\n            dye(nx, ny, c);\n        }\n    }\n}\n\nvoid cal(int x, int y, int c){\n    //cout << x << \" \" << y << endl;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx >= 0 && nx < h && ny >= 0 && ny < w && color[nx][ny] != 1 && dig[nx][ny] == 0){\n            //cout << \"color:\" << color[nx][ny] << endl;\n            st[c].insert(color[nx][ny]);\n        }\n    }\n}\n\nvoid print(){\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cout << dig[i][j] << \" \";\n        }\n    }\n    cout << endl;\n}\n\nvoid printcolor(){\n    cout << endl;\n    for(int j = 0; j < h; j++){\n        for(int i = 0; i < w; i++){\n            cout << color[j][i] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid init(){\n    dcode['0'] = 0x00;\n    dcode['1'] = 0x01;\n    dcode['2'] = 0x02;\n    dcode['3'] = 0x03;\n    dcode['4'] = 0x04;\n    dcode['5'] = 0x05;\n    dcode['6'] = 0x06;\n    dcode['7'] = 0x07;\n    dcode['8'] = 0x08;\n    dcode['9'] = 0x09;\n    dcode['a'] = 0x0a;\n    dcode['b'] = 0x0b;\n    dcode['c'] = 0x0c;\n    dcode['d'] = 0x0d;\n    dcode['e'] = 0x0e;\n    dcode['f'] = 0x0f;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    init();\n    int cs = 0;\n    while(cin >> h >> w){\n        //cout << h << \" \" << w << endl;\n        if(h == 0 && w == 0) break;\n        cout << \"Case \" << (++cs) << \": \";\n        memset(color, 0, sizeof(color));\n        memset(dig, 0, sizeof(dig));\n        for(int i = 0; i < maxw; i++){\n            st[i].clear();\n        }\n        rec.clear();\n        for(int i = 0; i < h; i++){\n            cin >> pix[i];\n            //cout << pix[i] << endl;\n            for(int j = 0; j < w; j++){\n                decode(pix[i][j], i + 1, j * 4 + 1);\n            }\n        }\n        //给图像四周添加一圈白色像素\n        h += 2;\n        w = w * 4 + 2;\n        \n        //print();\n        \n        int cnt = 0;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(color[i][j] == 0){\n                    dye(i, j, ++cnt);\n                    if(dig[i][j] == 1)\n                        rec.push_back(cnt);\n                }\n            }\n        }\n        //printcolor();\n        for(auto x : rec){\n            //cout << x << endl;\n            for(int i = 0; i < h; i++){\n                for(int j = 0; j < w; j++){\n                    if(color[i][j] == x){\n                        cal(i, j, x);\n                    }\n                }\n            }\n        }\n        vector<int> ans;\n        for(auto x : rec){\n            ans.push_back(st[x].size());\n        }\n        char res[10000];\n        int ct = 0;\n        for(size_t i = 0; i < ans.size(); i++){\n            res[ct++] = s[ans[i]];\n        }\n        sort(res, res + ct);\n        for(int i = 0; i < ct; i++){\n            cout << res[i];\n        }\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n## 测试数据及答案\n```\n//数据\n4 4\n0f00\n330e\n1e06\n0c02\n10 5\n00f00\n0198c\n00f0e\n01f8e\n00604\n001e0\n00330\n003f0\n00210\n003f0\n5 5\n0e00e\n1b3ea\n0e32e\n043e4\n000c0\n5 3\nfff\nf0f\nfff\nf0f\nfff\n5 3\nfff\n70e\n7fe\n70e\n7fe\n0 0\n\n//答案\nCase 1: AW\nCase 2: AKW\nCase 3: AAA\nCase 4: K\nCase 5: K\n```","source":"_posts/Uva1103-Ancient-Messages.md","raw":"---\ntitle: Uva1103-Ancient Messages-DFS\ndate: 2018-10-28 21:41:19\ncategories:\n- ACM\n- DFS\ntags:\n- DFS\n- 全局思维\n---\n一道让人惊呼“DFS还能这么玩”的题目。给定一个由象形文字组成的图像，要求按字典序输出图中所有象形文字（输出时每个象形文字由一个给定的英文表示）。关键是通过什么方法区分这些象形文字。\n![hier](/hier.png)\n<!--more-->\n## 链接\n[Uva1103-Ancient Messages](https://vjudge.net/problem/UVA-1103)\n## 题目描述\n图像的像素由 $0$ 和 $1$ 组成，其中 $0$ 代表白色像素点，$1$ 代表黑色像素点。整个图像以十六进制形式给出。图像包含六种象形符号中的至少一个，不同的符号不会相互接触。符号的形状和上图给出的拓扑等价（可以随意拉伸但不能拉断）。\n<div style=\"width: 300px; margin: auto\">\n    ![1.png](/1.png)\n    ![2.png](/2.png)\n</div>\n## 题解\n需要找出能够区别出这些不同象形符号的特征量。可以发现每个符号都包含一些白色的色块区域，6个符号从左到右分别包含 $1$，$3$，$5$，$4$，$0$，$2$ 个白色区域，各不相同。所以可以根据这一特征量区分不同的象形符号。\n具体做法为用dfs方法对每一块黑色或白色区域染色，这样可以把图像分为几个不同的颜色区域，再从每个黑色像素区域出发去统计在它内部的白色像素区域的个数。\n\n*需要注意的是初始时要在图像四周多添加一圈白色像素，以保证color 1 每次都表示的是背景白色像素区域*（因为这个地方$WA$了好多次，$QAQ$）\n\n另外这题没有测试数据也很坑2333，最后友情赠送几组测试数据。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 28 Oct 22:24:10 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxh = 207;\nconst int maxw = 50 * 4 + 7;\nint h, w;\nchar pix[maxh][maxw];\nint dig[maxh][maxw];\nint color[maxh][maxw];\nint dcode[256];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nvector<int> rec;\nset<int> st[maxw];\nconst string s = \"WAKJSD\";\n\nvoid decode(char c, int h, int pos){\n    int x = dcode[(int)c];\n    for(int i = 0; i < 4; i++){\n        if(x & (1 << (3 - i))) dig[h][pos + i] = 1;\n        else dig[h][pos + i] = 0;\n    }\n}\n\nvoid dye(int x, int y, int c){\n    color[x][y] = c;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx >= 0 && nx < h && ny >= 0 && ny < w && color[nx][ny] == 0 && dig[nx][ny] == dig[x][y]){\n            dye(nx, ny, c);\n        }\n    }\n}\n\nvoid cal(int x, int y, int c){\n    //cout << x << \" \" << y << endl;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(nx >= 0 && nx < h && ny >= 0 && ny < w && color[nx][ny] != 1 && dig[nx][ny] == 0){\n            //cout << \"color:\" << color[nx][ny] << endl;\n            st[c].insert(color[nx][ny]);\n        }\n    }\n}\n\nvoid print(){\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cout << dig[i][j] << \" \";\n        }\n    }\n    cout << endl;\n}\n\nvoid printcolor(){\n    cout << endl;\n    for(int j = 0; j < h; j++){\n        for(int i = 0; i < w; i++){\n            cout << color[j][i] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid init(){\n    dcode['0'] = 0x00;\n    dcode['1'] = 0x01;\n    dcode['2'] = 0x02;\n    dcode['3'] = 0x03;\n    dcode['4'] = 0x04;\n    dcode['5'] = 0x05;\n    dcode['6'] = 0x06;\n    dcode['7'] = 0x07;\n    dcode['8'] = 0x08;\n    dcode['9'] = 0x09;\n    dcode['a'] = 0x0a;\n    dcode['b'] = 0x0b;\n    dcode['c'] = 0x0c;\n    dcode['d'] = 0x0d;\n    dcode['e'] = 0x0e;\n    dcode['f'] = 0x0f;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    init();\n    int cs = 0;\n    while(cin >> h >> w){\n        //cout << h << \" \" << w << endl;\n        if(h == 0 && w == 0) break;\n        cout << \"Case \" << (++cs) << \": \";\n        memset(color, 0, sizeof(color));\n        memset(dig, 0, sizeof(dig));\n        for(int i = 0; i < maxw; i++){\n            st[i].clear();\n        }\n        rec.clear();\n        for(int i = 0; i < h; i++){\n            cin >> pix[i];\n            //cout << pix[i] << endl;\n            for(int j = 0; j < w; j++){\n                decode(pix[i][j], i + 1, j * 4 + 1);\n            }\n        }\n        //给图像四周添加一圈白色像素\n        h += 2;\n        w = w * 4 + 2;\n        \n        //print();\n        \n        int cnt = 0;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(color[i][j] == 0){\n                    dye(i, j, ++cnt);\n                    if(dig[i][j] == 1)\n                        rec.push_back(cnt);\n                }\n            }\n        }\n        //printcolor();\n        for(auto x : rec){\n            //cout << x << endl;\n            for(int i = 0; i < h; i++){\n                for(int j = 0; j < w; j++){\n                    if(color[i][j] == x){\n                        cal(i, j, x);\n                    }\n                }\n            }\n        }\n        vector<int> ans;\n        for(auto x : rec){\n            ans.push_back(st[x].size());\n        }\n        char res[10000];\n        int ct = 0;\n        for(size_t i = 0; i < ans.size(); i++){\n            res[ct++] = s[ans[i]];\n        }\n        sort(res, res + ct);\n        for(int i = 0; i < ct; i++){\n            cout << res[i];\n        }\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n## 测试数据及答案\n```\n//数据\n4 4\n0f00\n330e\n1e06\n0c02\n10 5\n00f00\n0198c\n00f0e\n01f8e\n00604\n001e0\n00330\n003f0\n00210\n003f0\n5 5\n0e00e\n1b3ea\n0e32e\n043e4\n000c0\n5 3\nfff\nf0f\nfff\nf0f\nfff\n5 3\nfff\n70e\n7fe\n70e\n7fe\n0 0\n\n//答案\nCase 1: AW\nCase 2: AKW\nCase 3: AAA\nCase 4: K\nCase 5: K\n```","slug":"Uva1103-Ancient-Messages","published":1,"updated":"2018-12-14T13:04:20.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrn1001tb8oubx1hnn3i","content":"<p>一道让人惊呼“DFS还能这么玩”的题目。给定一个由象形文字组成的图像，要求按字典序输出图中所有象形文字（输出时每个象形文字由一个给定的英文表示）。关键是通过什么方法区分这些象形文字。<br><img src=\"/2018/10/28/Uva1103-Ancient-Messages/hier.png\" alt=\"hier\"><br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-1103\" target=\"_blank\" rel=\"noopener\">Uva1103-Ancient Messages</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>图像的像素由 $0$ 和 $1$ 组成，其中 $0$ 代表白色像素点，$1$ 代表黑色像素点。整个图像以十六进制形式给出。图像包含六种象形符号中的至少一个，不同的符号不会相互接触。符号的形状和上图给出的拓扑等价（可以随意拉伸但不能拉断）。</p>\n<p><div style=\"width: 300px; margin: auto\"><br>    <img src=\"/2018/10/28/Uva1103-Ancient-Messages/1.png\" alt=\"1.png\"><br>    <img src=\"/2018/10/28/Uva1103-Ancient-Messages/2.png\" alt=\"2.png\"><br></div></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>需要找出能够区别出这些不同象形符号的特征量。可以发现每个符号都包含一些白色的色块区域，6个符号从左到右分别包含 $1$，$3$，$5$，$4$，$0$，$2$ 个白色区域，各不相同。所以可以根据这一特征量区分不同的象形符号。<br>具体做法为用dfs方法对每一块黑色或白色区域染色，这样可以把图像分为几个不同的颜色区域，再从每个黑色像素区域出发去统计在它内部的白色像素区域的个数。</p>\n<p><em>需要注意的是初始时要在图像四周多添加一圈白色像素，以保证color 1 每次都表示的是背景白色像素区域</em>（因为这个地方$WA$了好多次，$QAQ$）</p>\n<p>另外这题没有测试数据也很坑2333，最后友情赠送几组测试数据。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun 28 Oct 22:24:10 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxh = <span class=\"number\">207</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxw = <span class=\"number\">50</span> * <span class=\"number\">4</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> h, w;</span><br><span class=\"line\"><span class=\"keyword\">char</span> pix[maxh][maxw];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dig[maxh][maxw];</span><br><span class=\"line\"><span class=\"keyword\">int</span> color[maxh][maxw];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dcode[<span class=\"number\">256</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rec;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st[maxw];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> s = <span class=\"string\">\"WAKJSD\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(<span class=\"keyword\">char</span> c, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = dcode[(<span class=\"keyword\">int</span>)c];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &amp; (<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">3</span> - i))) dig[h][pos + i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> dig[h][pos + i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dye</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    color[x][y] = c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; h &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; w &amp;&amp; color[nx][ny] == <span class=\"number\">0</span> &amp;&amp; dig[nx][ny] == dig[x][y])&#123;</span><br><span class=\"line\">            dye(nx, ny, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cal</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; h &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; w &amp;&amp; color[nx][ny] != <span class=\"number\">1</span> &amp;&amp; dig[nx][ny] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; \"color:\" &lt;&lt; color[nx][ny] &lt;&lt; endl;</span></span><br><span class=\"line\">            st[c].insert(color[nx][ny]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; dig[i][j] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printcolor</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; h; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; w; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; color[j][i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    dcode[<span class=\"string\">'0'</span>] = <span class=\"number\">0x00</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'1'</span>] = <span class=\"number\">0x01</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'2'</span>] = <span class=\"number\">0x02</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'3'</span>] = <span class=\"number\">0x03</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'4'</span>] = <span class=\"number\">0x04</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'5'</span>] = <span class=\"number\">0x05</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'6'</span>] = <span class=\"number\">0x06</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'7'</span>] = <span class=\"number\">0x07</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'8'</span>] = <span class=\"number\">0x08</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'9'</span>] = <span class=\"number\">0x09</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'a'</span>] = <span class=\"number\">0x0a</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'b'</span>] = <span class=\"number\">0x0b</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'c'</span>] = <span class=\"number\">0x0c</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'d'</span>] = <span class=\"number\">0x0d</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'e'</span>] = <span class=\"number\">0x0e</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'f'</span>] = <span class=\"number\">0x0f</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cs = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; h &gt;&gt; w)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; h &lt;&lt; \" \" &lt;&lt; w &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(h == <span class=\"number\">0</span> &amp;&amp; w == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case \"</span> &lt;&lt; (++cs) &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(color, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(color));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dig, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dig));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxw; i++)&#123;</span><br><span class=\"line\">            st[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rec.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; pix[i];</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; pix[i] &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)&#123;</span><br><span class=\"line\">                decode(pix[i][j], i + <span class=\"number\">1</span>, j * <span class=\"number\">4</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//给图像四周添加一圈白色像素</span></span><br><span class=\"line\">        h += <span class=\"number\">2</span>;</span><br><span class=\"line\">        w = w * <span class=\"number\">4</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//print();</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(color[i][j] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    dye(i, j, ++cnt);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(dig[i][j] == <span class=\"number\">1</span>)</span><br><span class=\"line\">                        rec.push_back(cnt);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//printcolor();</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : rec)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(color[i][j] == x)&#123;</span><br><span class=\"line\">                        cal(i, j, x);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : rec)&#123;</span><br><span class=\"line\">            ans.push_back(st[x].size());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> res[<span class=\"number\">10000</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ct = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; ans.size(); i++)&#123;</span><br><span class=\"line\">            res[ct++] = s[ans[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(res, res + ct);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ct; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; res[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试数据及答案\"><a href=\"#测试数据及答案\" class=\"headerlink\" title=\"测试数据及答案\"></a>测试数据及答案</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数据</span><br><span class=\"line\">4 4</span><br><span class=\"line\">0f00</span><br><span class=\"line\">330e</span><br><span class=\"line\">1e06</span><br><span class=\"line\">0c02</span><br><span class=\"line\">10 5</span><br><span class=\"line\">00f00</span><br><span class=\"line\">0198c</span><br><span class=\"line\">00f0e</span><br><span class=\"line\">01f8e</span><br><span class=\"line\">00604</span><br><span class=\"line\">001e0</span><br><span class=\"line\">00330</span><br><span class=\"line\">003f0</span><br><span class=\"line\">00210</span><br><span class=\"line\">003f0</span><br><span class=\"line\">5 5</span><br><span class=\"line\">0e00e</span><br><span class=\"line\">1b3ea</span><br><span class=\"line\">0e32e</span><br><span class=\"line\">043e4</span><br><span class=\"line\">000c0</span><br><span class=\"line\">5 3</span><br><span class=\"line\">fff</span><br><span class=\"line\">f0f</span><br><span class=\"line\">fff</span><br><span class=\"line\">f0f</span><br><span class=\"line\">fff</span><br><span class=\"line\">5 3</span><br><span class=\"line\">fff</span><br><span class=\"line\">70e</span><br><span class=\"line\">7fe</span><br><span class=\"line\">70e</span><br><span class=\"line\">7fe</span><br><span class=\"line\">0 0</span><br><span class=\"line\"></span><br><span class=\"line\">//答案</span><br><span class=\"line\">Case 1: AW</span><br><span class=\"line\">Case 2: AKW</span><br><span class=\"line\">Case 3: AAA</span><br><span class=\"line\">Case 4: K</span><br><span class=\"line\">Case 5: K</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>一道让人惊呼“DFS还能这么玩”的题目。给定一个由象形文字组成的图像，要求按字典序输出图中所有象形文字（输出时每个象形文字由一个给定的英文表示）。关键是通过什么方法区分这些象形文字。<br><img src=\"/2018/10/28/Uva1103-Ancient-Messages/hier.png\" alt=\"hier\"><br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-1103\" target=\"_blank\" rel=\"noopener\">Uva1103-Ancient Messages</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>图像的像素由 $0$ 和 $1$ 组成，其中 $0$ 代表白色像素点，$1$ 代表黑色像素点。整个图像以十六进制形式给出。图像包含六种象形符号中的至少一个，不同的符号不会相互接触。符号的形状和上图给出的拓扑等价（可以随意拉伸但不能拉断）。</p>\n<p><div style=\"width: 300px; margin: auto\"><br>    <img src=\"/2018/10/28/Uva1103-Ancient-Messages/1.png\" alt=\"1.png\"><br>    <img src=\"/2018/10/28/Uva1103-Ancient-Messages/2.png\" alt=\"2.png\"><br></div></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>需要找出能够区别出这些不同象形符号的特征量。可以发现每个符号都包含一些白色的色块区域，6个符号从左到右分别包含 $1$，$3$，$5$，$4$，$0$，$2$ 个白色区域，各不相同。所以可以根据这一特征量区分不同的象形符号。<br>具体做法为用dfs方法对每一块黑色或白色区域染色，这样可以把图像分为几个不同的颜色区域，再从每个黑色像素区域出发去统计在它内部的白色像素区域的个数。</p>\n<p><em>需要注意的是初始时要在图像四周多添加一圈白色像素，以保证color 1 每次都表示的是背景白色像素区域</em>（因为这个地方$WA$了好多次，$QAQ$）</p>\n<p>另外这题没有测试数据也很坑2333，最后友情赠送几组测试数据。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun 28 Oct 22:24:10 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxh = <span class=\"number\">207</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxw = <span class=\"number\">50</span> * <span class=\"number\">4</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> h, w;</span><br><span class=\"line\"><span class=\"keyword\">char</span> pix[maxh][maxw];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dig[maxh][maxw];</span><br><span class=\"line\"><span class=\"keyword\">int</span> color[maxh][maxw];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dcode[<span class=\"number\">256</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; rec;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st[maxw];</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> s = <span class=\"string\">\"WAKJSD\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(<span class=\"keyword\">char</span> c, <span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = dcode[(<span class=\"keyword\">int</span>)c];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &amp; (<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">3</span> - i))) dig[h][pos + i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> dig[h][pos + i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dye</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    color[x][y] = c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; h &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; w &amp;&amp; color[nx][ny] == <span class=\"number\">0</span> &amp;&amp; dig[nx][ny] == dig[x][y])&#123;</span><br><span class=\"line\">            dye(nx, ny, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cal</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; h &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; w &amp;&amp; color[nx][ny] != <span class=\"number\">1</span> &amp;&amp; dig[nx][ny] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; \"color:\" &lt;&lt; color[nx][ny] &lt;&lt; endl;</span></span><br><span class=\"line\">            st[c].insert(color[nx][ny]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; dig[i][j] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printcolor</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; h; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; w; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; color[j][i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    dcode[<span class=\"string\">'0'</span>] = <span class=\"number\">0x00</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'1'</span>] = <span class=\"number\">0x01</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'2'</span>] = <span class=\"number\">0x02</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'3'</span>] = <span class=\"number\">0x03</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'4'</span>] = <span class=\"number\">0x04</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'5'</span>] = <span class=\"number\">0x05</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'6'</span>] = <span class=\"number\">0x06</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'7'</span>] = <span class=\"number\">0x07</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'8'</span>] = <span class=\"number\">0x08</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'9'</span>] = <span class=\"number\">0x09</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'a'</span>] = <span class=\"number\">0x0a</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'b'</span>] = <span class=\"number\">0x0b</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'c'</span>] = <span class=\"number\">0x0c</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'d'</span>] = <span class=\"number\">0x0d</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'e'</span>] = <span class=\"number\">0x0e</span>;</span><br><span class=\"line\">    dcode[<span class=\"string\">'f'</span>] = <span class=\"number\">0x0f</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cs = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; h &gt;&gt; w)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; h &lt;&lt; \" \" &lt;&lt; w &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(h == <span class=\"number\">0</span> &amp;&amp; w == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case \"</span> &lt;&lt; (++cs) &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(color, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(color));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dig, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(dig));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxw; i++)&#123;</span><br><span class=\"line\">            st[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rec.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; pix[i];</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; pix[i] &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)&#123;</span><br><span class=\"line\">                decode(pix[i][j], i + <span class=\"number\">1</span>, j * <span class=\"number\">4</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//给图像四周添加一圈白色像素</span></span><br><span class=\"line\">        h += <span class=\"number\">2</span>;</span><br><span class=\"line\">        w = w * <span class=\"number\">4</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//print();</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(color[i][j] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    dye(i, j, ++cnt);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(dig[i][j] == <span class=\"number\">1</span>)</span><br><span class=\"line\">                        rec.push_back(cnt);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//printcolor();</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : rec)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; h; i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; w; j++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(color[i][j] == x)&#123;</span><br><span class=\"line\">                        cal(i, j, x);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : rec)&#123;</span><br><span class=\"line\">            ans.push_back(st[x].size());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> res[<span class=\"number\">10000</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ct = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; ans.size(); i++)&#123;</span><br><span class=\"line\">            res[ct++] = s[ans[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(res, res + ct);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ct; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; res[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试数据及答案\"><a href=\"#测试数据及答案\" class=\"headerlink\" title=\"测试数据及答案\"></a>测试数据及答案</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数据</span><br><span class=\"line\">4 4</span><br><span class=\"line\">0f00</span><br><span class=\"line\">330e</span><br><span class=\"line\">1e06</span><br><span class=\"line\">0c02</span><br><span class=\"line\">10 5</span><br><span class=\"line\">00f00</span><br><span class=\"line\">0198c</span><br><span class=\"line\">00f0e</span><br><span class=\"line\">01f8e</span><br><span class=\"line\">00604</span><br><span class=\"line\">001e0</span><br><span class=\"line\">00330</span><br><span class=\"line\">003f0</span><br><span class=\"line\">00210</span><br><span class=\"line\">003f0</span><br><span class=\"line\">5 5</span><br><span class=\"line\">0e00e</span><br><span class=\"line\">1b3ea</span><br><span class=\"line\">0e32e</span><br><span class=\"line\">043e4</span><br><span class=\"line\">000c0</span><br><span class=\"line\">5 3</span><br><span class=\"line\">fff</span><br><span class=\"line\">f0f</span><br><span class=\"line\">fff</span><br><span class=\"line\">f0f</span><br><span class=\"line\">fff</span><br><span class=\"line\">5 3</span><br><span class=\"line\">fff</span><br><span class=\"line\">70e</span><br><span class=\"line\">7fe</span><br><span class=\"line\">70e</span><br><span class=\"line\">7fe</span><br><span class=\"line\">0 0</span><br><span class=\"line\"></span><br><span class=\"line\">//答案</span><br><span class=\"line\">Case 1: AW</span><br><span class=\"line\">Case 2: AKW</span><br><span class=\"line\">Case 3: AAA</span><br><span class=\"line\">Case 4: K</span><br><span class=\"line\">Case 5: K</span><br></pre></td></tr></table></figure>"},{"title":"Uva11059-Maximum Product-暴力枚举","date":"2018-12-17T12:07:59.000Z","_content":"输入$n$个元素组成的序列$S$，找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，输出0。$1 <=n <= 18，-10 <= S_i <= 10$。\n<!--more-->\n## 链接\n[Uva11059-Maximum Product](https://vjudge.net/problem/UVA-11059)\n\n## 题解\n**连续子序列有两个要素：起点和终点**。因此枚举起点和终点即可。\n\n*注意用long long存储。*\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 16 Dec 23:18:45 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 20;\nint n;\nint d[maxn];\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int cnt = 0;\n    while(cin >> n){\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        \n        long long res = 0, p = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                p = 1;\n                for(int k = i; k <= j; k++){\n                    p *= d[k];\n                }\n                res = max(res, p);\n            }\n        }        \n\n        cout << \"Case #\" << ++cnt << \": The maximum product is \" << res << \".\" << endl << endl;\n    }\n    return 0;\n}\n```\n循环枚举部分还可以写成这种稍难理解但简单的形式：\n```C++\nfor(int i = 0; i < n; i++){\n    p = 1;\n    for(int j = i; j < n; j++){\n        p *= d[j];\n        res = max(res, p);\n    }\n}\n```","source":"_posts/Uva11059-Maximum-Product.md","raw":"---\ntitle: Uva11059-Maximum Product-暴力枚举\ndate: 2018-12-17 20:07:59\ncategories:\n- ACM\n- 暴力枚举\ntags:\n- 暴力枚举\n---\n输入$n$个元素组成的序列$S$，找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，输出0。$1 <=n <= 18，-10 <= S_i <= 10$。\n<!--more-->\n## 链接\n[Uva11059-Maximum Product](https://vjudge.net/problem/UVA-11059)\n\n## 题解\n**连续子序列有两个要素：起点和终点**。因此枚举起点和终点即可。\n\n*注意用long long存储。*\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 16 Dec 23:18:45 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 20;\nint n;\nint d[maxn];\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int cnt = 0;\n    while(cin >> n){\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        \n        long long res = 0, p = 1;\n        for(int i = 0; i < n; i++){\n            for(int j = i; j < n; j++){\n                p = 1;\n                for(int k = i; k <= j; k++){\n                    p *= d[k];\n                }\n                res = max(res, p);\n            }\n        }        \n\n        cout << \"Case #\" << ++cnt << \": The maximum product is \" << res << \".\" << endl << endl;\n    }\n    return 0;\n}\n```\n循环枚举部分还可以写成这种稍难理解但简单的形式：\n```C++\nfor(int i = 0; i < n; i++){\n    p = 1;\n    for(int j = i; j < n; j++){\n        p *= d[j];\n        res = max(res, p);\n    }\n}\n```","slug":"Uva11059-Maximum-Product","published":1,"updated":"2018-12-20T15:19:29.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrn2001yb8ouq4mwde44","content":"<p>输入$n$个元素组成的序列$S$，找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，输出0。$1 &lt;=n &lt;= 18，-10 &lt;= S_i &lt;= 10$。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-11059\" target=\"_blank\" rel=\"noopener\">Uva11059-Maximum Product</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p><strong>连续子序列有两个要素：起点和终点</strong>。因此枚举起点和终点即可。</p>\n<p><em>注意用long long存储。</em></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun 16 Dec 23:18:45 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; d[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = <span class=\"number\">0</span>, p = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class=\"line\">                p = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = i; k &lt;= j; k++)&#123;</span><br><span class=\"line\">                    p *= d[k];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                res = max(res, p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; ++cnt &lt;&lt; <span class=\"string\">\": The maximum product is \"</span> &lt;&lt; res &lt;&lt; <span class=\"string\">\".\"</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>循环枚举部分还可以写成这种稍难理解但简单的形式：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    p = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class=\"line\">        p *= d[j];</span><br><span class=\"line\">        res = max(res, p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>输入$n$个元素组成的序列$S$，找出一个乘积最大的连续子序列。如果这个最大的乘积不是正数，输出0。$1 &lt;=n &lt;= 18，-10 &lt;= S_i &lt;= 10$。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-11059\" target=\"_blank\" rel=\"noopener\">Uva11059-Maximum Product</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p><strong>连续子序列有两个要素：起点和终点</strong>。因此枚举起点和终点即可。</p>\n<p><em>注意用long long存储。</em></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun 16 Dec 23:18:45 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; d[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res = <span class=\"number\">0</span>, p = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class=\"line\">                p = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = i; k &lt;= j; k++)&#123;</span><br><span class=\"line\">                    p *= d[k];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                res = max(res, p);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; ++cnt &lt;&lt; <span class=\"string\">\": The maximum product is \"</span> &lt;&lt; res &lt;&lt; <span class=\"string\">\".\"</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>循环枚举部分还可以写成这种稍难理解但简单的形式：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    p = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class=\"line\">        p *= d[j];</span><br><span class=\"line\">        res = max(res, p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"Uva11853-Painball-全局+DFS","date":"2018-11-20T02:53:30.000Z","_content":"好题哇。有一个 $1000 \\times 1000$ 的方形场地，有n个敌人分别在 $(x_i，y_i)$ 处，且每个人有一个攻击范围 $r_i$ ,求解是否可以在不受攻击的情况下从场地的最西侧走到场地的最东侧，若可以，输出起始和终点坐标。如果有多个位置满足条件，输出最靠北的位置。\n<!--more-->\n## 链接\n[Uva-Painball](https://vjudge.net/problem/UVA-11853)\n\n## 题解\n一开始的思路是建一个 $1000 \\times 1000$ 的图，将每一个敌人攻击范围内的所有点做标记，做为图中的障碍物，然后从上边界开始跑一遍DFS/BFS，看是否可以到达下边界。如果可以的话说明图被分成了左右两部分，东西两侧不可达。参考了刘汝佳老师的代码后发现完全没有这个必要 = =。\n不以坐标为基本单位，而直接以各个圆为基本单位，从一个与上边界有交的圆出发，不断递归寻找和它自身相交的圆，判断是否可以到达一个与下边界相交的圆。同时沿途检查这一系列中和左右边界有交的圆，这些圆和左边界的所有交点中最南边的点就是最北起始点，和右边界的所有交点中最南边的点就是最北终止点。膜Orz。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 20 Nov 09:54:58 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1000 + 7;\nconst double brd = 1000.0;\nint n;\ndouble x[maxn], y[maxn], r[maxn];\nbool vis[maxn];\nbool ok;\ndouble lb, rb;\n\nbool intersect(int u, int v){\n    return (x[u] - x[v]) * (x[u] - x[v]) + (y[u] - y[v]) * (y[u] - y[v]) <= (r[u] + r[v]) * (r[u] + r[v]);\n}\n\nvoid checkcircle(int c){\n    if(x[c] - r[c] <= 0){\n        lb = min(lb, y[c] - sqrt(r[c] * r[c] - x[c] * x[c]));\n    }\n    if(x[c] + r[c] >= brd){\n        rb = min(rb, y[c] - sqrt(r[c] * r[c] - (brd - x[c]) * (brd - x[c])));\n    }\n}\n\nvoid dfs(int c){\n    if(y[c] - r[c] <= 0){\n        ok = false;\n        return;\n    }\n    for(int i = 0; i < n; i++){\n        if(!vis[i] && intersect(c, i)){\n            vis[i] = 1;\n            dfs(i);\n        }\n    }\n    checkcircle(c);\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        ok = true;\n        lb = rb = brd;\n        memset(vis, 0, sizeof(vis));\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i] >> r[i];\n        }\n        for(int i = 0; i < n; i++){\n            if(y[i] + r[i] >= brd){\n                vis[i] = 1;\n                dfs(i);\n                if(!ok) break;\n            }\n        }\n        if(!ok) cout << \"IMPOSSIBLE\" << endl;\n        else printf(\"0.00 %.2f 1000.00 %.2f\\n\", lb, rb);\n    }\n    return 0;\n}\n```","source":"_posts/Uva11853-Painball.md","raw":"---\ntitle: Uva11853-Painball-全局+DFS\ndate: 2018-11-20 10:53:30\ncategories:\n- ACM\n- DFS\ntags:\n- DFS\n- 全局思想\n---\n好题哇。有一个 $1000 \\times 1000$ 的方形场地，有n个敌人分别在 $(x_i，y_i)$ 处，且每个人有一个攻击范围 $r_i$ ,求解是否可以在不受攻击的情况下从场地的最西侧走到场地的最东侧，若可以，输出起始和终点坐标。如果有多个位置满足条件，输出最靠北的位置。\n<!--more-->\n## 链接\n[Uva-Painball](https://vjudge.net/problem/UVA-11853)\n\n## 题解\n一开始的思路是建一个 $1000 \\times 1000$ 的图，将每一个敌人攻击范围内的所有点做标记，做为图中的障碍物，然后从上边界开始跑一遍DFS/BFS，看是否可以到达下边界。如果可以的话说明图被分成了左右两部分，东西两侧不可达。参考了刘汝佳老师的代码后发现完全没有这个必要 = =。\n不以坐标为基本单位，而直接以各个圆为基本单位，从一个与上边界有交的圆出发，不断递归寻找和它自身相交的圆，判断是否可以到达一个与下边界相交的圆。同时沿途检查这一系列中和左右边界有交的圆，这些圆和左边界的所有交点中最南边的点就是最北起始点，和右边界的所有交点中最南边的点就是最北终止点。膜Orz。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 20 Nov 09:54:58 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1000 + 7;\nconst double brd = 1000.0;\nint n;\ndouble x[maxn], y[maxn], r[maxn];\nbool vis[maxn];\nbool ok;\ndouble lb, rb;\n\nbool intersect(int u, int v){\n    return (x[u] - x[v]) * (x[u] - x[v]) + (y[u] - y[v]) * (y[u] - y[v]) <= (r[u] + r[v]) * (r[u] + r[v]);\n}\n\nvoid checkcircle(int c){\n    if(x[c] - r[c] <= 0){\n        lb = min(lb, y[c] - sqrt(r[c] * r[c] - x[c] * x[c]));\n    }\n    if(x[c] + r[c] >= brd){\n        rb = min(rb, y[c] - sqrt(r[c] * r[c] - (brd - x[c]) * (brd - x[c])));\n    }\n}\n\nvoid dfs(int c){\n    if(y[c] - r[c] <= 0){\n        ok = false;\n        return;\n    }\n    for(int i = 0; i < n; i++){\n        if(!vis[i] && intersect(c, i)){\n            vis[i] = 1;\n            dfs(i);\n        }\n    }\n    checkcircle(c);\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        ok = true;\n        lb = rb = brd;\n        memset(vis, 0, sizeof(vis));\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i] >> r[i];\n        }\n        for(int i = 0; i < n; i++){\n            if(y[i] + r[i] >= brd){\n                vis[i] = 1;\n                dfs(i);\n                if(!ok) break;\n            }\n        }\n        if(!ok) cout << \"IMPOSSIBLE\" << endl;\n        else printf(\"0.00 %.2f 1000.00 %.2f\\n\", lb, rb);\n    }\n    return 0;\n}\n```","slug":"Uva11853-Painball","published":1,"updated":"2018-12-14T13:01:27.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrn30020b8ouvhcggz34","content":"<p>好题哇。有一个 $1000 \\times 1000$ 的方形场地，有n个敌人分别在 $(x_i，y_i)$ 处，且每个人有一个攻击范围 $r_i$ ,求解是否可以在不受攻击的情况下从场地的最西侧走到场地的最东侧，若可以，输出起始和终点坐标。如果有多个位置满足条件，输出最靠北的位置。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-11853\" target=\"_blank\" rel=\"noopener\">Uva-Painball</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一开始的思路是建一个 $1000 \\times 1000$ 的图，将每一个敌人攻击范围内的所有点做标记，做为图中的障碍物，然后从上边界开始跑一遍DFS/BFS，看是否可以到达下边界。如果可以的话说明图被分成了左右两部分，东西两侧不可达。参考了刘汝佳老师的代码后发现完全没有这个必要 = =。<br>不以坐标为基本单位，而直接以各个圆为基本单位，从一个与上边界有交的圆出发，不断递归寻找和它自身相交的圆，判断是否可以到达一个与下边界相交的圆。同时沿途检查这一系列中和左右边界有交的圆，这些圆和左边界的所有交点中最南边的点就是最北起始点，和右边界的所有交点中最南边的点就是最北终止点。膜Orz。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 20 Nov 09:54:58 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1000</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> brd = <span class=\"number\">1000.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">double</span> x[maxn], y[maxn], r[maxn];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[maxn];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> ok;</span><br><span class=\"line\"><span class=\"keyword\">double</span> lb, rb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">intersect</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x[u] - x[v]) * (x[u] - x[v]) + (y[u] - y[v]) * (y[u] - y[v]) &lt;= (r[u] + r[v]) * (r[u] + r[v]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkcircle</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x[c] - r[c] &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        lb = min(lb, y[c] - <span class=\"built_in\">sqrt</span>(r[c] * r[c] - x[c] * x[c]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x[c] + r[c] &gt;= brd)&#123;</span><br><span class=\"line\">        rb = min(rb, y[c] - <span class=\"built_in\">sqrt</span>(r[c] * r[c] - (brd - x[c]) * (brd - x[c])));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(y[c] - r[c] &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        ok = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i] &amp;&amp; intersect(c, i))&#123;</span><br><span class=\"line\">            vis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    checkcircle(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        ok = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        lb = rb = brd;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; r[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(y[i] + r[i] &gt;= brd)&#123;</span><br><span class=\"line\">                vis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                dfs(i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!ok) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!ok) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"IMPOSSIBLE\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"0.00 %.2f 1000.00 %.2f\\n\"</span>, lb, rb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>好题哇。有一个 $1000 \\times 1000$ 的方形场地，有n个敌人分别在 $(x_i，y_i)$ 处，且每个人有一个攻击范围 $r_i$ ,求解是否可以在不受攻击的情况下从场地的最西侧走到场地的最东侧，若可以，输出起始和终点坐标。如果有多个位置满足条件，输出最靠北的位置。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-11853\" target=\"_blank\" rel=\"noopener\">Uva-Painball</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一开始的思路是建一个 $1000 \\times 1000$ 的图，将每一个敌人攻击范围内的所有点做标记，做为图中的障碍物，然后从上边界开始跑一遍DFS/BFS，看是否可以到达下边界。如果可以的话说明图被分成了左右两部分，东西两侧不可达。参考了刘汝佳老师的代码后发现完全没有这个必要 = =。<br>不以坐标为基本单位，而直接以各个圆为基本单位，从一个与上边界有交的圆出发，不断递归寻找和它自身相交的圆，判断是否可以到达一个与下边界相交的圆。同时沿途检查这一系列中和左右边界有交的圆，这些圆和左边界的所有交点中最南边的点就是最北起始点，和右边界的所有交点中最南边的点就是最北终止点。膜Orz。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 20 Nov 09:54:58 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1000</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> brd = <span class=\"number\">1000.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">double</span> x[maxn], y[maxn], r[maxn];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[maxn];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> ok;</span><br><span class=\"line\"><span class=\"keyword\">double</span> lb, rb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">intersect</span><span class=\"params\">(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (x[u] - x[v]) * (x[u] - x[v]) + (y[u] - y[v]) * (y[u] - y[v]) &lt;= (r[u] + r[v]) * (r[u] + r[v]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkcircle</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x[c] - r[c] &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        lb = min(lb, y[c] - <span class=\"built_in\">sqrt</span>(r[c] * r[c] - x[c] * x[c]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x[c] + r[c] &gt;= brd)&#123;</span><br><span class=\"line\">        rb = min(rb, y[c] - <span class=\"built_in\">sqrt</span>(r[c] * r[c] - (brd - x[c]) * (brd - x[c])));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(y[c] - r[c] &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        ok = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i] &amp;&amp; intersect(c, i))&#123;</span><br><span class=\"line\">            vis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    checkcircle(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        ok = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        lb = rb = brd;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; r[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(y[i] + r[i] &gt;= brd)&#123;</span><br><span class=\"line\">                vis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                dfs(i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!ok) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!ok) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"IMPOSSIBLE\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"0.00 %.2f 1000.00 %.2f\\n\"</span>, lb, rb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva12096-The SetStack Computer-STL","date":"2018-08-09T14:44:02.000Z","_content":"最近在看刘汝佳老师的《算法竞赛入门经典（第2版）》，收获很大，很多知识都在上面查漏补缺，书上有一道STL的例题，用到了stack、vector、map、set，而且“化集合为ID”的思路很好，记录一下。\n<!-- more -->\n## 链接\n[Uva12096-The SetStack Computer](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3248)\n## 题目描述\n有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且支持一下操作。\n- PUSH:空集“{}”入栈。\n- DUP:把当前栈顶元素复制一份后再入栈。\n- UNION:出栈两个集合，然后把二者的并集入栈。\n- INTERSECT:出栈两个集合，然后把出栈的集合加入到后出栈的集合中，把结果入栈。\n\n每次操作后，输出栈顶集合的大小（即元素个数）。\n\n## 题解\n本题的集合并不是简单的整数集合或者字符串集合，而是集合的集合。为了方便为每个不同的集合分配一个唯一的ID，则每个集合都可以表示成所包含元素的ID的集合，这样就可以用STL的set<int> 来表示了，而整个栈则是一个stack<int>。map用来把集合映射成ID，vector则根据ID取集合。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu  9 Aug 16:19:36 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nint n;\ntypedef set<int> Set;\nmap<Set, int> mp;\nvector<Set> vec;\n\nint ID(Set st){\n    if(mp.count(st)) return mp[st];\n    vec.push_back(st);\n    return mp[st] = vec.size() - 1;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        cin >> n;\n        stack<int> stc;\n        string s;\n        vec.clear();\n        mp.clear();\n        for(int i = 0; i < n; i++){\n            cin >> s;\n            if(s[0] == 'P') stc.push(ID(Set ()));\n            else if(s[0] == 'D') stc.push(stc.top());\n            else{\n                Set st1 = vec[stc.top()]; stc.pop();\n                Set st2 = vec[stc.top()]; stc.pop();\n                Set st;\n                if(s[0] == 'U') set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'I') set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'A') {st = st2; st.insert(ID(st1));}\n                stc.push(ID(st));\n            }\n            cout << vec[stc.top()].size() << endl;\n        }\n        cout << \"***\" << endl;\n    }\n    \n    return 0;\n}\n```\n## 补充\n### 并集\n对两个集合取交集可以使用std::set_union，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n### 交集\n对两个集合取交集可以使用std::set_intersection，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n类似的还有：\n- set_difference:差集，从第一个区间去除第二个区间的元素。\n- set_merge:合并，与set_union不同，set_merge不会去除重复的元素（不能用于set，可用于vector）。\n\n注意：set_union和set_intersection等也可用于vector，但必须是排好序的vector。\n","source":"_posts/Uva12096-The-SetStack-Computer-STL.md","raw":"---\ntitle: Uva12096-The SetStack Computer-STL\ndate: 2018-08-09 22:44:02\ncategories:\n- ACM\n- map\ntags:\n- stack\n- STL\n---\n最近在看刘汝佳老师的《算法竞赛入门经典（第2版）》，收获很大，很多知识都在上面查漏补缺，书上有一道STL的例题，用到了stack、vector、map、set，而且“化集合为ID”的思路很好，记录一下。\n<!-- more -->\n## 链接\n[Uva12096-The SetStack Computer](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3248)\n## 题目描述\n有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且支持一下操作。\n- PUSH:空集“{}”入栈。\n- DUP:把当前栈顶元素复制一份后再入栈。\n- UNION:出栈两个集合，然后把二者的并集入栈。\n- INTERSECT:出栈两个集合，然后把出栈的集合加入到后出栈的集合中，把结果入栈。\n\n每次操作后，输出栈顶集合的大小（即元素个数）。\n\n## 题解\n本题的集合并不是简单的整数集合或者字符串集合，而是集合的集合。为了方便为每个不同的集合分配一个唯一的ID，则每个集合都可以表示成所包含元素的ID的集合，这样就可以用STL的set<int> 来表示了，而整个栈则是一个stack<int>。map用来把集合映射成ID，vector则根据ID取集合。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu  9 Aug 16:19:36 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nint n;\ntypedef set<int> Set;\nmap<Set, int> mp;\nvector<Set> vec;\n\nint ID(Set st){\n    if(mp.count(st)) return mp[st];\n    vec.push_back(st);\n    return mp[st] = vec.size() - 1;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        cin >> n;\n        stack<int> stc;\n        string s;\n        vec.clear();\n        mp.clear();\n        for(int i = 0; i < n; i++){\n            cin >> s;\n            if(s[0] == 'P') stc.push(ID(Set ()));\n            else if(s[0] == 'D') stc.push(stc.top());\n            else{\n                Set st1 = vec[stc.top()]; stc.pop();\n                Set st2 = vec[stc.top()]; stc.pop();\n                Set st;\n                if(s[0] == 'U') set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'I') set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n                if(s[0] == 'A') {st = st2; st.insert(ID(st1));}\n                stc.push(ID(st));\n            }\n            cout << vec[stc.top()].size() << endl;\n        }\n        cout << \"***\" << endl;\n    }\n    \n    return 0;\n}\n```\n## 补充\n### 并集\n对两个集合取交集可以使用std::set_union，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n### 交集\n对两个集合取交集可以使用std::set_intersection，该函数需要两对迭代器，以及一个输出迭代器。\n```C++\nset<int> st1;\nset<int> st2;\nset<int> st;\nset_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));\n```\n类似的还有：\n- set_difference:差集，从第一个区间去除第二个区间的元素。\n- set_merge:合并，与set_union不同，set_merge不会去除重复的元素（不能用于set，可用于vector）。\n\n注意：set_union和set_intersection等也可用于vector，但必须是排好序的vector。\n","slug":"Uva12096-The-SetStack-Computer-STL","published":1,"updated":"2018-12-14T13:10:07.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrn50024b8oue8lm16mn","content":"<p>最近在看刘汝佳老师的《算法竞赛入门经典（第2版）》，收获很大，很多知识都在上面查漏补缺，书上有一道STL的例题，用到了stack、vector、map、set，而且“化集合为ID”的思路很好，记录一下。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3248\" target=\"_blank\" rel=\"noopener\">Uva12096-The SetStack Computer</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且支持一下操作。</p>\n<ul>\n<li>PUSH:空集“{}”入栈。</li>\n<li>DUP:把当前栈顶元素复制一份后再入栈。</li>\n<li>UNION:出栈两个集合，然后把二者的并集入栈。</li>\n<li>INTERSECT:出栈两个集合，然后把出栈的集合加入到后出栈的集合中，把结果入栈。</li>\n</ul>\n<p>每次操作后，输出栈顶集合的大小（即元素个数）。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>本题的集合并不是简单的整数集合或者字符串集合，而是集合的集合。为了方便为每个不同的集合分配一个唯一的ID，则每个集合都可以表示成所包含元素的ID的集合，这样就可以用STL的set<int> 来表示了，而整个栈则是一个stack<int>。map用来把集合映射成ID，vector则根据ID取集合。</int></int></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Thu  9 Aug 16:19:36 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; Set;</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;Set, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Set&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ID</span><span class=\"params\">(Set st)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mp.count(st)) <span class=\"keyword\">return</span> mp[st];</span><br><span class=\"line\">    vec.push_back(st);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mp[st] = vec.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stc;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        mp.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'P'</span>) stc.push(ID(Set ()));</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'D'</span>) stc.push(stc.top());</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                Set st1 = vec[stc.top()]; stc.pop();</span><br><span class=\"line\">                Set st2 = vec[stc.top()]; stc.pop();</span><br><span class=\"line\">                Set st;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'U'</span>) set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'I'</span>) set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'A'</span>) &#123;st = st2; st.insert(ID(st1));&#125;</span><br><span class=\"line\">                stc.push(ID(st));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; vec[stc.top()].size() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"***\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"并集\"><a href=\"#并集\" class=\"headerlink\" title=\"并集\"></a>并集</h3><p>对两个集合取交集可以使用std::set_union，该函数需要两对迭代器，以及一个输出迭代器。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st1;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st2;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"交集\"><a href=\"#交集\" class=\"headerlink\" title=\"交集\"></a>交集</h3><p>对两个集合取交集可以使用std::set_intersection，该函数需要两对迭代器，以及一个输出迭代器。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st1;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st2;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br></pre></td></tr></table></figure></p>\n<p>类似的还有：</p>\n<ul>\n<li>set_difference:差集，从第一个区间去除第二个区间的元素。</li>\n<li>set_merge:合并，与set_union不同，set_merge不会去除重复的元素（不能用于set，可用于vector）。</li>\n</ul>\n<p>注意：set_union和set_intersection等也可用于vector，但必须是排好序的vector。</p>\n","site":{"data":{}},"excerpt":"<p>最近在看刘汝佳老师的《算法竞赛入门经典（第2版）》，收获很大，很多知识都在上面查漏补缺，书上有一道STL的例题，用到了stack、vector、map、set，而且“化集合为ID”的思路很好，记录一下。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3248\" target=\"_blank\" rel=\"noopener\">Uva12096-The SetStack Computer</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈，并且支持一下操作。</p>\n<ul>\n<li>PUSH:空集“{}”入栈。</li>\n<li>DUP:把当前栈顶元素复制一份后再入栈。</li>\n<li>UNION:出栈两个集合，然后把二者的并集入栈。</li>\n<li>INTERSECT:出栈两个集合，然后把出栈的集合加入到后出栈的集合中，把结果入栈。</li>\n</ul>\n<p>每次操作后，输出栈顶集合的大小（即元素个数）。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>本题的集合并不是简单的整数集合或者字符串集合，而是集合的集合。为了方便为每个不同的集合分配一个唯一的ID，则每个集合都可以表示成所包含元素的ID的集合，这样就可以用STL的set<int> 来表示了，而整个栈则是一个stack<int>。map用来把集合映射成ID，vector则根据ID取集合。</int></int></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Thu  9 Aug 16:19:36 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; Set;</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;Set, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Set&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ID</span><span class=\"params\">(Set st)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mp.count(st)) <span class=\"keyword\">return</span> mp[st];</span><br><span class=\"line\">    vec.push_back(st);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mp[st] = vec.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; stc;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        mp.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'P'</span>) stc.push(ID(Set ()));</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'D'</span>) stc.push(stc.top());</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                Set st1 = vec[stc.top()]; stc.pop();</span><br><span class=\"line\">                Set st2 = vec[stc.top()]; stc.pop();</span><br><span class=\"line\">                Set st;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'U'</span>) set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'I'</span>) set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'A'</span>) &#123;st = st2; st.insert(ID(st1));&#125;</span><br><span class=\"line\">                stc.push(ID(st));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; vec[stc.top()].size() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"***\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"并集\"><a href=\"#并集\" class=\"headerlink\" title=\"并集\"></a>并集</h3><p>对两个集合取交集可以使用std::set_union，该函数需要两对迭代器，以及一个输出迭代器。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st1;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st2;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">set_union(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"交集\"><a href=\"#交集\" class=\"headerlink\" title=\"交集\"></a>交集</h3><p>对两个集合取交集可以使用std::set_intersection，该函数需要两对迭代器，以及一个输出迭代器。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st1;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st2;</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; st;</span><br><span class=\"line\">set_intersection(st1.begin(), st1.end(), st2.begin(), st2.end(), inserter(st, st.begin()));</span><br></pre></td></tr></table></figure></p>\n<p>类似的还有：</p>\n<ul>\n<li>set_difference:差集，从第一个区间去除第二个区间的元素。</li>\n<li>set_merge:合并，与set_union不同，set_merge不会去除重复的元素（不能用于set，可用于vector）。</li>\n</ul>\n<p>注意：set_union和set_intersection等也可用于vector，但必须是排好序的vector。</p>"},{"title":"Uva12166-Equilibrium Mobile-思维+二叉树","date":"2018-12-04T02:40:03.000Z","_content":"吹爆思维好题！给定一个深度不超过16的二叉树，代表一个天平，天平两端可能是递归的子天平也可能是砝码。每个砝码的质量已知，求至少修改多少个砝码的质量才能让天平平衡。\n![balance](/balance.png)\n如图，把7改成3天平平衡。\n<!--more-->\n## 链接\n题目链接[Uva12166-Equilibrium Mobile](https://vjudge.net/problem/UVA-12166)\n\n参考链接[crazysillynerd's csdn blog](https://blog.csdn.net/crazysillynerd/article/details/43876123)\n\n## 题解\n想要修改砝码使天平平衡，需要找其中一个砝码作为基准，用它来调整整个天平。假设基准砝码的质量为w，它在二叉树中的深度为d，则用它调整后的整个天平的重量为$w * pow(2，d)$。\n可能存在一些砝码，当以他们为基准时，调整后天平的总重量相同。那么这些砝码的数量就代表了保持不变的砝码数量，总砝码数量减去保持不变的砝码数量就是需要修改的砝码数量。\n用DFS构建二叉树，对每一个叶节点计算调整后的天平总重量；用STL中的map来维护不同总重量所代表的砝码个数。\n\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue  4 Dec 10:02:37 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nint sum;\nmap<long long, int> mp;\nstring s;\n\nvoid dfs(int st, int ed, int depth){\n    //cout << st << \" \" << ed << \" \" << depth << endl;\n    if(s[st] == '['){\n        int p = 0;\n        for(int i = st + 1; i <= ed; i++){\n            if(s[i] == '[') p++;\n            if(s[i] == ']') p--;\n            if(s[i] == ',' && p == 0){\n                //cout << st + 1 << \" \" << i - 1 << \" \" << depth + 1 << endl;\n                dfs(st + 1, i - 1, depth + 1);\n                //cout << i + 1 << \" \" << ed - 1 << \" \" << depth + 1 << endl;\n                dfs(i + 1, ed - 1, depth + 1);\n            }\n        }\n    }\n    else{\n        long long w = 0;\n        for(int i = st; i <= ed; i++){\n            w *= 10;\n            w += s[i] - '0';\n        }\n        //cout << w << endl;\n        sum++;\n        mp[w << depth]++;\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> t;\n    while(t--){\n        mp.clear();\n        sum = 0;\n\n        cin >> s;\n        dfs(0, s.length() - 1, 0);\n\n        int ans = 0;\n        for(auto x : mp){\n            ans = max(ans, x.second);\n        }\n        cout << sum - ans << endl;\n    }\n    return 0;\n}\n```\n","source":"_posts/Uva12166-Equilibrium-Mobile.md","raw":"---\ntitle: Uva12166-Equilibrium Mobile-思维+二叉树\ndate: 2018-12-04 10:40:03\ncategories:\n- ACM\n- 树\ntags:\n- 思维\n- 二叉树\n---\n吹爆思维好题！给定一个深度不超过16的二叉树，代表一个天平，天平两端可能是递归的子天平也可能是砝码。每个砝码的质量已知，求至少修改多少个砝码的质量才能让天平平衡。\n![balance](/balance.png)\n如图，把7改成3天平平衡。\n<!--more-->\n## 链接\n题目链接[Uva12166-Equilibrium Mobile](https://vjudge.net/problem/UVA-12166)\n\n参考链接[crazysillynerd's csdn blog](https://blog.csdn.net/crazysillynerd/article/details/43876123)\n\n## 题解\n想要修改砝码使天平平衡，需要找其中一个砝码作为基准，用它来调整整个天平。假设基准砝码的质量为w，它在二叉树中的深度为d，则用它调整后的整个天平的重量为$w * pow(2，d)$。\n可能存在一些砝码，当以他们为基准时，调整后天平的总重量相同。那么这些砝码的数量就代表了保持不变的砝码数量，总砝码数量减去保持不变的砝码数量就是需要修改的砝码数量。\n用DFS构建二叉树，对每一个叶节点计算调整后的天平总重量；用STL中的map来维护不同总重量所代表的砝码个数。\n\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue  4 Dec 10:02:37 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nint sum;\nmap<long long, int> mp;\nstring s;\n\nvoid dfs(int st, int ed, int depth){\n    //cout << st << \" \" << ed << \" \" << depth << endl;\n    if(s[st] == '['){\n        int p = 0;\n        for(int i = st + 1; i <= ed; i++){\n            if(s[i] == '[') p++;\n            if(s[i] == ']') p--;\n            if(s[i] == ',' && p == 0){\n                //cout << st + 1 << \" \" << i - 1 << \" \" << depth + 1 << endl;\n                dfs(st + 1, i - 1, depth + 1);\n                //cout << i + 1 << \" \" << ed - 1 << \" \" << depth + 1 << endl;\n                dfs(i + 1, ed - 1, depth + 1);\n            }\n        }\n    }\n    else{\n        long long w = 0;\n        for(int i = st; i <= ed; i++){\n            w *= 10;\n            w += s[i] - '0';\n        }\n        //cout << w << endl;\n        sum++;\n        mp[w << depth]++;\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> t;\n    while(t--){\n        mp.clear();\n        sum = 0;\n\n        cin >> s;\n        dfs(0, s.length() - 1, 0);\n\n        int ans = 0;\n        for(auto x : mp){\n            ans = max(ans, x.second);\n        }\n        cout << sum - ans << endl;\n    }\n    return 0;\n}\n```\n","slug":"Uva12166-Equilibrium-Mobile","published":1,"updated":"2018-12-14T12:59:11.578Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrn70027b8ou0jlzv8n0","content":"<p>吹爆思维好题！给定一个深度不超过16的二叉树，代表一个天平，天平两端可能是递归的子天平也可能是砝码。每个砝码的质量已知，求至少修改多少个砝码的质量才能让天平平衡。<br><img src=\"/2018/12/04/Uva12166-Equilibrium-Mobile/balance.png\" alt=\"balance\"><br>如图，把7改成3天平平衡。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>题目链接<a href=\"https://vjudge.net/problem/UVA-12166\" target=\"_blank\" rel=\"noopener\">Uva12166-Equilibrium Mobile</a></p>\n<p>参考链接<a href=\"https://blog.csdn.net/crazysillynerd/article/details/43876123\" target=\"_blank\" rel=\"noopener\">crazysillynerd’s csdn blog</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>想要修改砝码使天平平衡，需要找其中一个砝码作为基准，用它来调整整个天平。假设基准砝码的质量为w，它在二叉树中的深度为d，则用它调整后的整个天平的重量为$w * pow(2，d)$。<br>可能存在一些砝码，当以他们为基准时，调整后天平的总重量相同。那么这些砝码的数量就代表了保持不变的砝码数量，总砝码数量减去保持不变的砝码数量就是需要修改的砝码数量。<br>用DFS构建二叉树，对每一个叶节点计算调整后的天平总重量；用STL中的map来维护不同总重量所代表的砝码个数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue  4 Dec 10:02:37 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum;</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> st, <span class=\"keyword\">int</span> ed, <span class=\"keyword\">int</span> depth)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; st &lt;&lt; \" \" &lt;&lt; ed &lt;&lt; \" \" &lt;&lt; depth &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s[st] == <span class=\"string\">'['</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = st + <span class=\"number\">1</span>; i &lt;= ed; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'['</span>) p++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">']'</span>) p--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">','</span> &amp;&amp; p == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; st + 1 &lt;&lt; \" \" &lt;&lt; i - 1 &lt;&lt; \" \" &lt;&lt; depth + 1 &lt;&lt; endl;</span></span><br><span class=\"line\">                dfs(st + <span class=\"number\">1</span>, i - <span class=\"number\">1</span>, depth + <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; i + 1 &lt;&lt; \" \" &lt;&lt; ed - 1 &lt;&lt; \" \" &lt;&lt; depth + 1 &lt;&lt; endl;</span></span><br><span class=\"line\">                dfs(i + <span class=\"number\">1</span>, ed - <span class=\"number\">1</span>, depth + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = st; i &lt;= ed; i++)&#123;</span><br><span class=\"line\">            w *= <span class=\"number\">10</span>;</span><br><span class=\"line\">            w += s[i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; w &lt;&lt; endl;</span></span><br><span class=\"line\">        sum++;</span><br><span class=\"line\">        mp[w &lt;&lt; depth]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        mp.clear();</span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">        dfs(<span class=\"number\">0</span>, s.length() - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : mp)&#123;</span><br><span class=\"line\">            ans = max(ans, x.second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; sum - ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>吹爆思维好题！给定一个深度不超过16的二叉树，代表一个天平，天平两端可能是递归的子天平也可能是砝码。每个砝码的质量已知，求至少修改多少个砝码的质量才能让天平平衡。<br><img src=\"/2018/12/04/Uva12166-Equilibrium-Mobile/balance.png\" alt=\"balance\"><br>如图，把7改成3天平平衡。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>题目链接<a href=\"https://vjudge.net/problem/UVA-12166\" target=\"_blank\" rel=\"noopener\">Uva12166-Equilibrium Mobile</a></p>\n<p>参考链接<a href=\"https://blog.csdn.net/crazysillynerd/article/details/43876123\" target=\"_blank\" rel=\"noopener\">crazysillynerd’s csdn blog</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>想要修改砝码使天平平衡，需要找其中一个砝码作为基准，用它来调整整个天平。假设基准砝码的质量为w，它在二叉树中的深度为d，则用它调整后的整个天平的重量为$w * pow(2，d)$。<br>可能存在一些砝码，当以他们为基准时，调整后天平的总重量相同。那么这些砝码的数量就代表了保持不变的砝码数量，总砝码数量减去保持不变的砝码数量就是需要修改的砝码数量。<br>用DFS构建二叉树，对每一个叶节点计算调整后的天平总重量；用STL中的map来维护不同总重量所代表的砝码个数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue  4 Dec 10:02:37 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum;</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> st, <span class=\"keyword\">int</span> ed, <span class=\"keyword\">int</span> depth)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; st &lt;&lt; \" \" &lt;&lt; ed &lt;&lt; \" \" &lt;&lt; depth &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s[st] == <span class=\"string\">'['</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = st + <span class=\"number\">1</span>; i &lt;= ed; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'['</span>) p++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">']'</span>) p--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">','</span> &amp;&amp; p == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; st + 1 &lt;&lt; \" \" &lt;&lt; i - 1 &lt;&lt; \" \" &lt;&lt; depth + 1 &lt;&lt; endl;</span></span><br><span class=\"line\">                dfs(st + <span class=\"number\">1</span>, i - <span class=\"number\">1</span>, depth + <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; i + 1 &lt;&lt; \" \" &lt;&lt; ed - 1 &lt;&lt; \" \" &lt;&lt; depth + 1 &lt;&lt; endl;</span></span><br><span class=\"line\">                dfs(i + <span class=\"number\">1</span>, ed - <span class=\"number\">1</span>, depth + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> w = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = st; i &lt;= ed; i++)&#123;</span><br><span class=\"line\">            w *= <span class=\"number\">10</span>;</span><br><span class=\"line\">            w += s[i] - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; w &lt;&lt; endl;</span></span><br><span class=\"line\">        sum++;</span><br><span class=\"line\">        mp[w &lt;&lt; depth]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        mp.clear();</span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">        dfs(<span class=\"number\">0</span>, s.length() - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : mp)&#123;</span><br><span class=\"line\">            ans = max(ans, x.second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; sum - ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva12118-Inspetor's Dilemma-DFS求连通+欧拉路","date":"2018-12-17T10:36:53.000Z","_content":"V个城市之间两两相连，给定E条需要走的边，走过一条边需要时间T。求走完所有的E条边需要的最少时间。E条边不一定在一个连通图中。\n竟然卡在``ifndef ONLINE_JUDGE``上好久，单词``ONLINE``手滑打成了``ONLIEN``，= =。吐血。\n\n*紫书第六章结束*\n<!--more-->\n## 链接\n题目链接[Uva12118-Inspetor's Dilemma](https://vjudge.net/problem/UVA-12118)\n参考[SingleK's Blog](https://blog.csdn.net/xiao_k666/article/details/79209697)精简了自己的代码。\n\n## 题解\n因为E条边不一定在一个连通图中，所以首先DFS遍历连通块，统计每一个连通块中度数为奇数的结点个数。若能满足构成欧拉路的条件，则一次“一笔画”就可以走完当前连通块中的边。若不能构成欧拉路（奇度数结点个数大于2），则通过加边的方式，使其可以构成欧拉路。n个连通块之间还需要n - 1条边连接。\n所以最后的所需要走过的边是E，加上添加边的个数，再加上连通块个数减1。\n\n*最后不要忘记乘以T得到总耗时 = =，以及当给定E为0时，结果会出现负数，要特判。*\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 15 Dec 17:21:07 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e3 + 7;\nint V, E, T;\nbool vis[maxn];\nvector<int> d[maxn];\nint ans;\nint odd;\n\nvoid dfs(int u){\n    vis[u] = 1;\n    if(d[u].size() % 2) odd++;\n    for(size_t i = 0; i < d[u].size(); i++){\n        int v = d[u][i];\n        if(!vis[v]){\n            dfs(v);\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int kase = 0;\n    while(cin >> V >> E >> T){\n        if(V == 0 && E == 0 && T == 0) break;\n        kase++;\n        memset(vis, 0, sizeof(vis));\n        for(int i = 1; i <= V; i++){\n            d[i].clear();\n        }\n        ans = 0;\n\n        int u, v;\n        for(int i = 0; i < E; i++){\n            cin >> u >> v;\n            d[u].push_back(v);\n            d[v].push_back(u);\n        }\n\n        int cnt = 0;\n        for(int i = 1; i <= V; i++){\n            odd = 0;\n            if(!d[i].empty() && !vis[i]){\n                dfs(i);\n                cnt++;\n                if(odd > 2) ans += (odd - 2) / 2;\n            }\n        }\n        ans += E;\n        ans += cnt - 1;\n        ans *= T;\n        if(ans < 0) cout << \"Case \" << kase << \": \" << 0 << endl;\n        else cout << \"Case \" << kase << \": \" << ans << endl;\n    }\n    return 0;\n}\n```","source":"_posts/Uva12118-Inspetor-s-Dilemma.md","raw":"---\ntitle: Uva12118-Inspetor's Dilemma-DFS求连通+欧拉路\ndate: 2018-12-17 18:36:53\ncategories:\n- ACM\n- 欧拉路\ntags:\n- 欧拉路\n---\nV个城市之间两两相连，给定E条需要走的边，走过一条边需要时间T。求走完所有的E条边需要的最少时间。E条边不一定在一个连通图中。\n竟然卡在``ifndef ONLINE_JUDGE``上好久，单词``ONLINE``手滑打成了``ONLIEN``，= =。吐血。\n\n*紫书第六章结束*\n<!--more-->\n## 链接\n题目链接[Uva12118-Inspetor's Dilemma](https://vjudge.net/problem/UVA-12118)\n参考[SingleK's Blog](https://blog.csdn.net/xiao_k666/article/details/79209697)精简了自己的代码。\n\n## 题解\n因为E条边不一定在一个连通图中，所以首先DFS遍历连通块，统计每一个连通块中度数为奇数的结点个数。若能满足构成欧拉路的条件，则一次“一笔画”就可以走完当前连通块中的边。若不能构成欧拉路（奇度数结点个数大于2），则通过加边的方式，使其可以构成欧拉路。n个连通块之间还需要n - 1条边连接。\n所以最后的所需要走过的边是E，加上添加边的个数，再加上连通块个数减1。\n\n*最后不要忘记乘以T得到总耗时 = =，以及当给定E为0时，结果会出现负数，要特判。*\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 15 Dec 17:21:07 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e3 + 7;\nint V, E, T;\nbool vis[maxn];\nvector<int> d[maxn];\nint ans;\nint odd;\n\nvoid dfs(int u){\n    vis[u] = 1;\n    if(d[u].size() % 2) odd++;\n    for(size_t i = 0; i < d[u].size(); i++){\n        int v = d[u][i];\n        if(!vis[v]){\n            dfs(v);\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    int kase = 0;\n    while(cin >> V >> E >> T){\n        if(V == 0 && E == 0 && T == 0) break;\n        kase++;\n        memset(vis, 0, sizeof(vis));\n        for(int i = 1; i <= V; i++){\n            d[i].clear();\n        }\n        ans = 0;\n\n        int u, v;\n        for(int i = 0; i < E; i++){\n            cin >> u >> v;\n            d[u].push_back(v);\n            d[v].push_back(u);\n        }\n\n        int cnt = 0;\n        for(int i = 1; i <= V; i++){\n            odd = 0;\n            if(!d[i].empty() && !vis[i]){\n                dfs(i);\n                cnt++;\n                if(odd > 2) ans += (odd - 2) / 2;\n            }\n        }\n        ans += E;\n        ans += cnt - 1;\n        ans *= T;\n        if(ans < 0) cout << \"Case \" << kase << \": \" << 0 << endl;\n        else cout << \"Case \" << kase << \": \" << ans << endl;\n    }\n    return 0;\n}\n```","slug":"Uva12118-Inspetor-s-Dilemma","published":1,"updated":"2018-12-17T11:33:26.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrn8002bb8ouzdglhurf","content":"<p>V个城市之间两两相连，给定E条需要走的边，走过一条边需要时间T。求走完所有的E条边需要的最少时间。E条边不一定在一个连通图中。<br>竟然卡在<code>ifndef ONLINE_JUDGE</code>上好久，单词<code>ONLINE</code>手滑打成了<code>ONLIEN</code>，= =。吐血。</p>\n<p><em>紫书第六章结束</em><br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>题目链接<a href=\"https://vjudge.net/problem/UVA-12118\" target=\"_blank\" rel=\"noopener\">Uva12118-Inspetor’s Dilemma</a><br>参考<a href=\"https://blog.csdn.net/xiao_k666/article/details/79209697\" target=\"_blank\" rel=\"noopener\">SingleK’s Blog</a>精简了自己的代码。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为E条边不一定在一个连通图中，所以首先DFS遍历连通块，统计每一个连通块中度数为奇数的结点个数。若能满足构成欧拉路的条件，则一次“一笔画”就可以走完当前连通块中的边。若不能构成欧拉路（奇度数结点个数大于2），则通过加边的方式，使其可以构成欧拉路。n个连通块之间还需要n - 1条边连接。<br>所以最后的所需要走过的边是E，加上添加边的个数，再加上连通块个数减1。</p>\n<p><em>最后不要忘记乘以T得到总耗时 = =，以及当给定E为0时，结果会出现负数，要特判。</em></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 15 Dec 17:21:07 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e3</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> V, E, T;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[maxn];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans;</span><br><span class=\"line\"><span class=\"keyword\">int</span> odd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    vis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[u].size() % <span class=\"number\">2</span>) odd++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; d[u].size(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = d[u][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[v])&#123;</span><br><span class=\"line\">            dfs(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> kase = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; V &gt;&gt; E &gt;&gt; T)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(V == <span class=\"number\">0</span> &amp;&amp; E == <span class=\"number\">0</span> &amp;&amp; T == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        kase++;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= V; i++)&#123;</span><br><span class=\"line\">            d[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> u, v;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; E; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">            d[u].push_back(v);</span><br><span class=\"line\">            d[v].push_back(u);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= V; i++)&#123;</span><br><span class=\"line\">            odd = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!d[i].empty() &amp;&amp; !vis[i])&#123;</span><br><span class=\"line\">                dfs(i);</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(odd &gt; <span class=\"number\">2</span>) ans += (odd - <span class=\"number\">2</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans += E;</span><br><span class=\"line\">        ans += cnt - <span class=\"number\">1</span>;</span><br><span class=\"line\">        ans *= T;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans &lt; <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case \"</span> &lt;&lt; kase &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; <span class=\"number\">0</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case \"</span> &lt;&lt; kase &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>V个城市之间两两相连，给定E条需要走的边，走过一条边需要时间T。求走完所有的E条边需要的最少时间。E条边不一定在一个连通图中。<br>竟然卡在<code>ifndef ONLINE_JUDGE</code>上好久，单词<code>ONLINE</code>手滑打成了<code>ONLIEN</code>，= =。吐血。</p>\n<p><em>紫书第六章结束</em><br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>题目链接<a href=\"https://vjudge.net/problem/UVA-12118\" target=\"_blank\" rel=\"noopener\">Uva12118-Inspetor’s Dilemma</a><br>参考<a href=\"https://blog.csdn.net/xiao_k666/article/details/79209697\" target=\"_blank\" rel=\"noopener\">SingleK’s Blog</a>精简了自己的代码。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为E条边不一定在一个连通图中，所以首先DFS遍历连通块，统计每一个连通块中度数为奇数的结点个数。若能满足构成欧拉路的条件，则一次“一笔画”就可以走完当前连通块中的边。若不能构成欧拉路（奇度数结点个数大于2），则通过加边的方式，使其可以构成欧拉路。n个连通块之间还需要n - 1条边连接。<br>所以最后的所需要走过的边是E，加上添加边的个数，再加上连通块个数减1。</p>\n<p><em>最后不要忘记乘以T得到总耗时 = =，以及当给定E为0时，结果会出现负数，要特判。</em></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 15 Dec 17:21:07 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e3</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> V, E, T;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[maxn];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans;</span><br><span class=\"line\"><span class=\"keyword\">int</span> odd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    vis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[u].size() % <span class=\"number\">2</span>) odd++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; d[u].size(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = d[u][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[v])&#123;</span><br><span class=\"line\">            dfs(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> kase = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; V &gt;&gt; E &gt;&gt; T)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(V == <span class=\"number\">0</span> &amp;&amp; E == <span class=\"number\">0</span> &amp;&amp; T == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        kase++;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= V; i++)&#123;</span><br><span class=\"line\">            d[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> u, v;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; E; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">            d[u].push_back(v);</span><br><span class=\"line\">            d[v].push_back(u);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= V; i++)&#123;</span><br><span class=\"line\">            odd = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!d[i].empty() &amp;&amp; !vis[i])&#123;</span><br><span class=\"line\">                dfs(i);</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(odd &gt; <span class=\"number\">2</span>) ans += (odd - <span class=\"number\">2</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans += E;</span><br><span class=\"line\">        ans += cnt - <span class=\"number\">1</span>;</span><br><span class=\"line\">        ans *= T;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans &lt; <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case \"</span> &lt;&lt; kase &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; <span class=\"number\">0</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case \"</span> &lt;&lt; kase &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"牛客暑期ACM多校训练营(第四场)G题-Maxinum Mode-思维+map","date":"2018-07-29T12:06:46.000Z","_content":"一道逆向思维的好题,比赛的时候没有做出来,赛后补题的时候按原来的思路写出来了,然而代码超时了= =,阅读了别人的代码后发现自己想复杂了,从逆向来考虑感觉非常巧妙,思路也很顺畅.从正向考虑反而要顾及很多情况,可能就是因为考虑的太多代码冗余就TLE了.\n<!-- more -->\n## 链接\n[Nowcoder-Fourth-G](https://www.nowcoder.com/acm/contest/142/G)\n## 题目描述\nThe mode of an integer sequence is the value that appears most often. Chiaki has n integers a1,a2,...,an. She woud like to delete exactly m of them such that: the rest integers have only one mode and the mode is maximum.\n输入描述:\nThere are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:\nThe first line contains two integers n and m (1 ≤ n ≤ 105, 0 ≤ m < n) -- the length of the sequence and the number of integers to delete.\nThe second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) denoting the sequence.\nIt is guaranteed that the sum of all n does not exceed 106.\n输出描述:\nFor each test case, output an integer denoting the only maximum mode, or -1 if Chiaki cannot achieve it.\n输入:\n5\n5 0\n2 2 3 3 4\n5 1\n2 2 3 3 4\n5 2\n2 2 3 3 4\n5 3\n2 2 3 3 4\n5 4\n2 2 3 3 4\n输出:\n-1\n3\n3\n3\n4\n## 题解\n题目大意是给定n个数,从这n个数中删掉m个数,使得出现次数最多的数只有一个且要求尽量大.求解这个出现次数最多的数.\n思路:\nmap存数据及数据个数, 按键值从大到小排(实际上map会按键值从小到大自动排列,那么就从后往前判断就好了).然后不考虑删除数的情况而是考虑剩余数(逆向思维)的情况,首先判断剩余数的个数是否小于等于最大值的个数,若满足则最终的结果就是最大值;若不满足则把剩余的数进行分配,看是否可以在满足min(d[max] - 1,d[i])的分配条件下将剩余的数分配完(其中d[i]表示第i个数的个数,用d[max]表示了最大的数的个数),如果可以分配完则最终结果就是最大值.若最大值不能满足上述情况则考虑次大值,以此类推,若全都不满足则无解,输出-1.\n\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\ntypedef pair<int, int> P;\nP d[maxn];\nint t;\nint n, m;\nmap<int, int> mp;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &t);\n    while(t--){\n        mp.clear();\n        scanf(\"%d%d\", &n, &m);\n        int tmp;\n        for(int i = 0; i < n; i++){\n            scanf(\"%d\", &tmp);\n            mp[tmp]++;\n        }\n        \n        int cnt = 0;\n        for(auto x : mp){\n            d[cnt].first = x.first;\n            d[cnt].second = x.second;\n            cnt++;\n        }\n        \n        int flag = 0;\n        int rem = n - m;//剩余数的个数\n        int i;\n        for(i = cnt - 1; i >= 0; i--){\n            int res = rem - d[i].second;\n            if(res <= 0){\n                flag = 1;\n                break;\n            }\n            for(int j = 0; j < cnt; j++){\n                if(j == i) continue;\n                res -= min(d[i].second - 1, d[j].second);\n                if(res <= 0){\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag) break;\n        }\n        \n        if(flag) printf(\"%d\\n\", d[i].first);\n        else printf(\"-1\\n\");\n    }\n    \n    return 0;\n}\n```","source":"_posts/Nowcoder-Fourth-G.md","raw":"---\ntitle: 牛客暑期ACM多校训练营(第四场)G题-Maxinum Mode-思维+map\ndate: 2018-07-29 20:06:46\ncategories:\n- ACM\n- 思维\ntags:\n- 逆向思维\n---\n一道逆向思维的好题,比赛的时候没有做出来,赛后补题的时候按原来的思路写出来了,然而代码超时了= =,阅读了别人的代码后发现自己想复杂了,从逆向来考虑感觉非常巧妙,思路也很顺畅.从正向考虑反而要顾及很多情况,可能就是因为考虑的太多代码冗余就TLE了.\n<!-- more -->\n## 链接\n[Nowcoder-Fourth-G](https://www.nowcoder.com/acm/contest/142/G)\n## 题目描述\nThe mode of an integer sequence is the value that appears most often. Chiaki has n integers a1,a2,...,an. She woud like to delete exactly m of them such that: the rest integers have only one mode and the mode is maximum.\n输入描述:\nThere are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:\nThe first line contains two integers n and m (1 ≤ n ≤ 105, 0 ≤ m < n) -- the length of the sequence and the number of integers to delete.\nThe second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) denoting the sequence.\nIt is guaranteed that the sum of all n does not exceed 106.\n输出描述:\nFor each test case, output an integer denoting the only maximum mode, or -1 if Chiaki cannot achieve it.\n输入:\n5\n5 0\n2 2 3 3 4\n5 1\n2 2 3 3 4\n5 2\n2 2 3 3 4\n5 3\n2 2 3 3 4\n5 4\n2 2 3 3 4\n输出:\n-1\n3\n3\n3\n4\n## 题解\n题目大意是给定n个数,从这n个数中删掉m个数,使得出现次数最多的数只有一个且要求尽量大.求解这个出现次数最多的数.\n思路:\nmap存数据及数据个数, 按键值从大到小排(实际上map会按键值从小到大自动排列,那么就从后往前判断就好了).然后不考虑删除数的情况而是考虑剩余数(逆向思维)的情况,首先判断剩余数的个数是否小于等于最大值的个数,若满足则最终的结果就是最大值;若不满足则把剩余的数进行分配,看是否可以在满足min(d[max] - 1,d[i])的分配条件下将剩余的数分配完(其中d[i]表示第i个数的个数,用d[max]表示了最大的数的个数),如果可以分配完则最终结果就是最大值.若最大值不能满足上述情况则考虑次大值,以此类推,若全都不满足则无解,输出-1.\n\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\ntypedef pair<int, int> P;\nP d[maxn];\nint t;\nint n, m;\nmap<int, int> mp;\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    scanf(\"%d\", &t);\n    while(t--){\n        mp.clear();\n        scanf(\"%d%d\", &n, &m);\n        int tmp;\n        for(int i = 0; i < n; i++){\n            scanf(\"%d\", &tmp);\n            mp[tmp]++;\n        }\n        \n        int cnt = 0;\n        for(auto x : mp){\n            d[cnt].first = x.first;\n            d[cnt].second = x.second;\n            cnt++;\n        }\n        \n        int flag = 0;\n        int rem = n - m;//剩余数的个数\n        int i;\n        for(i = cnt - 1; i >= 0; i--){\n            int res = rem - d[i].second;\n            if(res <= 0){\n                flag = 1;\n                break;\n            }\n            for(int j = 0; j < cnt; j++){\n                if(j == i) continue;\n                res -= min(d[i].second - 1, d[j].second);\n                if(res <= 0){\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag) break;\n        }\n        \n        if(flag) printf(\"%d\\n\", d[i].first);\n        else printf(\"-1\\n\");\n    }\n    \n    return 0;\n}\n```","slug":"Nowcoder-Fourth-G","published":1,"updated":"2018-12-14T13:21:47.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrna002fb8ou7b3dkvo2","content":"<p>一道逆向思维的好题,比赛的时候没有做出来,赛后补题的时候按原来的思路写出来了,然而代码超时了= =,阅读了别人的代码后发现自己想复杂了,从逆向来考虑感觉非常巧妙,思路也很顺畅.从正向考虑反而要顾及很多情况,可能就是因为考虑的太多代码冗余就TLE了.<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.nowcoder.com/acm/contest/142/G\" target=\"_blank\" rel=\"noopener\">Nowcoder-Fourth-G</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>The mode of an integer sequence is the value that appears most often. Chiaki has n integers a1,a2,…,an. She woud like to delete exactly m of them such that: the rest integers have only one mode and the mode is maximum.<br>输入描述:<br>There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:<br>The first line contains two integers n and m (1 ≤ n ≤ 105, 0 ≤ m &lt; n) – the length of the sequence and the number of integers to delete.<br>The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 109) denoting the sequence.<br>It is guaranteed that the sum of all n does not exceed 106.<br>输出描述:<br>For each test case, output an integer denoting the only maximum mode, or -1 if Chiaki cannot achieve it.<br>输入:<br>5<br>5 0<br>2 2 3 3 4<br>5 1<br>2 2 3 3 4<br>5 2<br>2 2 3 3 4<br>5 3<br>2 2 3 3 4<br>5 4<br>2 2 3 3 4<br>输出:<br>-1<br>3<br>3<br>3<br>4</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意是给定n个数,从这n个数中删掉m个数,使得出现次数最多的数只有一个且要求尽量大.求解这个出现次数最多的数.<br>思路:<br>map存数据及数据个数, 按键值从大到小排(实际上map会按键值从小到大自动排列,那么就从后往前判断就好了).然后不考虑删除数的情况而是考虑剩余数(逆向思维)的情况,首先判断剩余数的个数是否小于等于最大值的个数,若满足则最终的结果就是最大值;若不满足则把剩余的数进行分配,看是否可以在满足min(d[max] - 1,d[i])的分配条件下将剩余的数分配完(其中d[i]表示第i个数的个数,用d[max]表示了最大的数的个数),如果可以分配完则最终结果就是最大值.若最大值不能满足上述情况则考虑次大值,以此类推,若全都不满足则无解,输出-1.</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\">P d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        mp.clear();</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;tmp);</span><br><span class=\"line\">            mp[tmp]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : mp)&#123;</span><br><span class=\"line\">            d[cnt].first = x.first;</span><br><span class=\"line\">            d[cnt].second = x.second;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rem = n - m;<span class=\"comment\">//剩余数的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = cnt - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> res = rem - d[i].second;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(res &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cnt; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j == i) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                res -= min(d[i].second - <span class=\"number\">1</span>, d[j].second);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(res &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, d[i].first);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>一道逆向思维的好题,比赛的时候没有做出来,赛后补题的时候按原来的思路写出来了,然而代码超时了= =,阅读了别人的代码后发现自己想复杂了,从逆向来考虑感觉非常巧妙,思路也很顺畅.从正向考虑反而要顾及很多情况,可能就是因为考虑的太多代码冗余就TLE了.<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.nowcoder.com/acm/contest/142/G\" target=\"_blank\" rel=\"noopener\">Nowcoder-Fourth-G</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>The mode of an integer sequence is the value that appears most often. Chiaki has n integers a1,a2,…,an. She woud like to delete exactly m of them such that: the rest integers have only one mode and the mode is maximum.<br>输入描述:<br>There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:<br>The first line contains two integers n and m (1 ≤ n ≤ 105, 0 ≤ m &lt; n) – the length of the sequence and the number of integers to delete.<br>The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 109) denoting the sequence.<br>It is guaranteed that the sum of all n does not exceed 106.<br>输出描述:<br>For each test case, output an integer denoting the only maximum mode, or -1 if Chiaki cannot achieve it.<br>输入:<br>5<br>5 0<br>2 2 3 3 4<br>5 1<br>2 2 3 3 4<br>5 2<br>2 2 3 3 4<br>5 3<br>2 2 3 3 4<br>5 4<br>2 2 3 3 4<br>输出:<br>-1<br>3<br>3<br>3<br>4</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目大意是给定n个数,从这n个数中删掉m个数,使得出现次数最多的数只有一个且要求尽量大.求解这个出现次数最多的数.<br>思路:<br>map存数据及数据个数, 按键值从大到小排(实际上map会按键值从小到大自动排列,那么就从后往前判断就好了).然后不考虑删除数的情况而是考虑剩余数(逆向思维)的情况,首先判断剩余数的个数是否小于等于最大值的个数,若满足则最终的结果就是最大值;若不满足则把剩余的数进行分配,看是否可以在满足min(d[max] - 1,d[i])的分配条件下将剩余的数分配完(其中d[i]表示第i个数的个数,用d[max]表示了最大的数的个数),如果可以分配完则最终结果就是最大值.若最大值不能满足上述情况则考虑次大值,以此类推,若全都不满足则无解,输出-1.</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; P;</span><br><span class=\"line\">P d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; mp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        mp.clear();</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;tmp);</span><br><span class=\"line\">            mp[tmp]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : mp)&#123;</span><br><span class=\"line\">            d[cnt].first = x.first;</span><br><span class=\"line\">            d[cnt].second = x.second;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rem = n - m;<span class=\"comment\">//剩余数的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = cnt - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> res = rem - d[i].second;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(res &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cnt; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j == i) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                res -= min(d[i].second - <span class=\"number\">1</span>, d[j].second);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(res &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, d[i].first);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva127-Accordian Patience-链表","date":"2018-12-12T02:25:11.000Z","_content":"一副扑克牌（52张），按照从左往右的顺序，若当前扑克牌和它的左一或左三扑克牌的数字或花色相同，就把它移动到那张牌的上方，移动后如果继续满足条件则继续移动。左一和左三同时满足时，左三优先。当有某个位置的牌为空时，要及时把这个位置消除。\n实战了一把数组模拟链表，还发现了一个大佬的博客，嚯嚯。收获了感动，坚定了继续坚持下去的信念。\n<!--more-->\n## 链接\n题目链接[Uva127-\"Accordian Patience\"](https://vjudge.net/problem/UVA-127)\n参考链接[shuangde800的博客](https://blog.csdn.net/shuangde800/article/details/7703781#commentBox)\n\n## 题解\n52个位置的牌堆分别用一个栈来维护。因为有消除牌堆的过程，所以会有频繁的移动，用链表来维护牌堆之间的关系效率比较高。代码里用两个数组next_idx和front_idx模拟了双向链表。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 11 Dec 20:19:53 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstack<string> d[60];\nint next_idx[60];\nint front_idx[60];\n\nbool input(){\n    memset(next_idx, -1, sizeof(next_idx));\n    memset(front_idx, -1, sizeof(front_idx));\n    string s;\n    stack<string> stk;\n    for(int i = 0; i < 52; i++){\n        cin >> s;\n        if(s == \"#\") return false;\n        stk.push(s);\n        d[i] = stk;\n        stk.pop();\n    }\n    return true;\n}\n\n//judge if we can move 3 steps\nbool ok_3(int i){\n    int last3;\n    last3 = front_idx[front_idx[front_idx[i]]];\n    //if(last3 < 0) return false;\n    if(d[last3].top()[0] == d[i].top()[0] || d[last3].top()[1] == d[i].top()[1]){\n        d[last3].push(d[i].top());\n        d[i].pop();\n        return true;\n    }\n    else return false;\n}\n\n//judge if we can move 1 step\nbool ok_1(int i){\n    int last1;\n    last1 = front_idx[i];\n    //if(last1 < 0) return false;\n    if(d[last1].top()[0] == d[i].top()[0] || d[last1].top()[1] == d[i].top()[1]){\n        d[last1].push(d[i].top());\n        d[i].pop();\n        return true;\n    }\n    else return false;\n}\n\nbool move(){\n    int cnt = 0;\n    for(int i = 0; i != -1; i = next_idx[i], cnt++){\n        if(cnt > 2)\n            if(ok_3(i)) return true;\n        if(cnt > 0)\n            if(ok_1(i)) return true;\n    }\n    return false;\n}\n\n//erase empty position\nvoid erase(){\n    for(int i = 0; i != -1; i = next_idx[i]){\n        if(d[i].empty()){\n            int l = front_idx[i];\n            int r = next_idx[i];\n            next_idx[l] = r;\n            front_idx[r] = l;\n            next_idx[i] = front_idx[i] = -1;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE    \n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(input()){\n        for(int i = 0; i < 51; i++){\n            next_idx[i] = i + 1;\n        }\n        for(int i = 1; i < 53; i++){\n            front_idx[i] = i - 1;\n        }\n\n        while(move()){\n            erase();\n        }\n\n        vector<int> ans;\n        for(int i = 0; i != -1; i = next_idx[i]){\n            ans.push_back(d[i].size());\n        }\n        int len = ans.size();\n        if(len == 1){\n            cout << \"1 pile remaining: \" << ans[0] << endl;\n        }\n        else{\n            cout << len << \" piles remaining:\";\n            for(int x : ans){\n                cout << \" \" << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n```","source":"_posts/Uva127-Accordian-Patience.md","raw":"---\ntitle: Uva127-Accordian Patience-链表\ndate: 2018-12-12 10:25:11\ncategories:\n- ACM\n- 链表\ntags:\n- 链表\n- 栈\n---\n一副扑克牌（52张），按照从左往右的顺序，若当前扑克牌和它的左一或左三扑克牌的数字或花色相同，就把它移动到那张牌的上方，移动后如果继续满足条件则继续移动。左一和左三同时满足时，左三优先。当有某个位置的牌为空时，要及时把这个位置消除。\n实战了一把数组模拟链表，还发现了一个大佬的博客，嚯嚯。收获了感动，坚定了继续坚持下去的信念。\n<!--more-->\n## 链接\n题目链接[Uva127-\"Accordian Patience\"](https://vjudge.net/problem/UVA-127)\n参考链接[shuangde800的博客](https://blog.csdn.net/shuangde800/article/details/7703781#commentBox)\n\n## 题解\n52个位置的牌堆分别用一个栈来维护。因为有消除牌堆的过程，所以会有频繁的移动，用链表来维护牌堆之间的关系效率比较高。代码里用两个数组next_idx和front_idx模拟了双向链表。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 11 Dec 20:19:53 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstack<string> d[60];\nint next_idx[60];\nint front_idx[60];\n\nbool input(){\n    memset(next_idx, -1, sizeof(next_idx));\n    memset(front_idx, -1, sizeof(front_idx));\n    string s;\n    stack<string> stk;\n    for(int i = 0; i < 52; i++){\n        cin >> s;\n        if(s == \"#\") return false;\n        stk.push(s);\n        d[i] = stk;\n        stk.pop();\n    }\n    return true;\n}\n\n//judge if we can move 3 steps\nbool ok_3(int i){\n    int last3;\n    last3 = front_idx[front_idx[front_idx[i]]];\n    //if(last3 < 0) return false;\n    if(d[last3].top()[0] == d[i].top()[0] || d[last3].top()[1] == d[i].top()[1]){\n        d[last3].push(d[i].top());\n        d[i].pop();\n        return true;\n    }\n    else return false;\n}\n\n//judge if we can move 1 step\nbool ok_1(int i){\n    int last1;\n    last1 = front_idx[i];\n    //if(last1 < 0) return false;\n    if(d[last1].top()[0] == d[i].top()[0] || d[last1].top()[1] == d[i].top()[1]){\n        d[last1].push(d[i].top());\n        d[i].pop();\n        return true;\n    }\n    else return false;\n}\n\nbool move(){\n    int cnt = 0;\n    for(int i = 0; i != -1; i = next_idx[i], cnt++){\n        if(cnt > 2)\n            if(ok_3(i)) return true;\n        if(cnt > 0)\n            if(ok_1(i)) return true;\n    }\n    return false;\n}\n\n//erase empty position\nvoid erase(){\n    for(int i = 0; i != -1; i = next_idx[i]){\n        if(d[i].empty()){\n            int l = front_idx[i];\n            int r = next_idx[i];\n            next_idx[l] = r;\n            front_idx[r] = l;\n            next_idx[i] = front_idx[i] = -1;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE    \n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(input()){\n        for(int i = 0; i < 51; i++){\n            next_idx[i] = i + 1;\n        }\n        for(int i = 1; i < 53; i++){\n            front_idx[i] = i - 1;\n        }\n\n        while(move()){\n            erase();\n        }\n\n        vector<int> ans;\n        for(int i = 0; i != -1; i = next_idx[i]){\n            ans.push_back(d[i].size());\n        }\n        int len = ans.size();\n        if(len == 1){\n            cout << \"1 pile remaining: \" << ans[0] << endl;\n        }\n        else{\n            cout << len << \" piles remaining:\";\n            for(int x : ans){\n                cout << \" \" << x;\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n```","slug":"Uva127-Accordian-Patience","published":1,"updated":"2018-12-14T12:59:00.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrnb002ib8ouq11cy7ct","content":"<p>一副扑克牌（52张），按照从左往右的顺序，若当前扑克牌和它的左一或左三扑克牌的数字或花色相同，就把它移动到那张牌的上方，移动后如果继续满足条件则继续移动。左一和左三同时满足时，左三优先。当有某个位置的牌为空时，要及时把这个位置消除。<br>实战了一把数组模拟链表，还发现了一个大佬的博客，嚯嚯。收获了感动，坚定了继续坚持下去的信念。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>题目链接<a href=\"https://vjudge.net/problem/UVA-127\" target=\"_blank\" rel=\"noopener\">Uva127-“Accordian Patience”</a><br>参考链接<a href=\"https://blog.csdn.net/shuangde800/article/details/7703781#commentBox\" target=\"_blank\" rel=\"noopener\">shuangde800的博客</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>52个位置的牌堆分别用一个栈来维护。因为有消除牌堆的过程，所以会有频繁的移动，用链表来维护牌堆之间的关系效率比较高。代码里用两个数组next_idx和front_idx模拟了双向链表。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 11 Dec 20:19:53 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">string</span>&gt; d[<span class=\"number\">60</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> next_idx[<span class=\"number\">60</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> front_idx[<span class=\"number\">60</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">input</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(next_idx, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(next_idx));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(front_idx, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(front_idx));</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">string</span>&gt; stk;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">52</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s == <span class=\"string\">\"#\"</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        stk.push(s);</span><br><span class=\"line\">        d[i] = stk;</span><br><span class=\"line\">        stk.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//judge if we can move 3 steps</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok_3</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last3;</span><br><span class=\"line\">    last3 = front_idx[front_idx[front_idx[i]]];</span><br><span class=\"line\">    <span class=\"comment\">//if(last3 &lt; 0) return false;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[last3].top()[<span class=\"number\">0</span>] == d[i].top()[<span class=\"number\">0</span>] || d[last3].top()[<span class=\"number\">1</span>] == d[i].top()[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">        d[last3].push(d[i].top());</span><br><span class=\"line\">        d[i].pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//judge if we can move 1 step</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok_1</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last1;</span><br><span class=\"line\">    last1 = front_idx[i];</span><br><span class=\"line\">    <span class=\"comment\">//if(last1 &lt; 0) return false;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[last1].top()[<span class=\"number\">0</span>] == d[i].top()[<span class=\"number\">0</span>] || d[last1].top()[<span class=\"number\">1</span>] == d[i].top()[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">        d[last1].push(d[i].top());</span><br><span class=\"line\">        d[i].pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">move</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != <span class=\"number\">-1</span>; i = next_idx[i], cnt++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ok_3(i)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ok_1(i)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//erase empty position</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">erase</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != <span class=\"number\">-1</span>; i = next_idx[i])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[i].empty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l = front_idx[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> r = next_idx[i];</span><br><span class=\"line\">            next_idx[l] = r;</span><br><span class=\"line\">            front_idx[r] = l;</span><br><span class=\"line\">            next_idx[i] = front_idx[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE    </span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(input())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">51</span>; i++)&#123;</span><br><span class=\"line\">            next_idx[i] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">53</span>; i++)&#123;</span><br><span class=\"line\">            front_idx[i] = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(move())&#123;</span><br><span class=\"line\">            erase();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != <span class=\"number\">-1</span>; i = next_idx[i])&#123;</span><br><span class=\"line\">            ans.push_back(d[i].size());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = ans.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"1 pile remaining: \"</span> &lt;&lt; ans[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; len &lt;&lt; <span class=\"string\">\" piles remaining:\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x : ans)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; x;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>一副扑克牌（52张），按照从左往右的顺序，若当前扑克牌和它的左一或左三扑克牌的数字或花色相同，就把它移动到那张牌的上方，移动后如果继续满足条件则继续移动。左一和左三同时满足时，左三优先。当有某个位置的牌为空时，要及时把这个位置消除。<br>实战了一把数组模拟链表，还发现了一个大佬的博客，嚯嚯。收获了感动，坚定了继续坚持下去的信念。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>题目链接<a href=\"https://vjudge.net/problem/UVA-127\" target=\"_blank\" rel=\"noopener\">Uva127-“Accordian Patience”</a><br>参考链接<a href=\"https://blog.csdn.net/shuangde800/article/details/7703781#commentBox\" target=\"_blank\" rel=\"noopener\">shuangde800的博客</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>52个位置的牌堆分别用一个栈来维护。因为有消除牌堆的过程，所以会有频繁的移动，用链表来维护牌堆之间的关系效率比较高。代码里用两个数组next_idx和front_idx模拟了双向链表。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 11 Dec 20:19:53 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">string</span>&gt; d[<span class=\"number\">60</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> next_idx[<span class=\"number\">60</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> front_idx[<span class=\"number\">60</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">input</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(next_idx, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(next_idx));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(front_idx, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(front_idx));</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"built_in\">string</span>&gt; stk;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">52</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s == <span class=\"string\">\"#\"</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        stk.push(s);</span><br><span class=\"line\">        d[i] = stk;</span><br><span class=\"line\">        stk.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//judge if we can move 3 steps</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok_3</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last3;</span><br><span class=\"line\">    last3 = front_idx[front_idx[front_idx[i]]];</span><br><span class=\"line\">    <span class=\"comment\">//if(last3 &lt; 0) return false;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[last3].top()[<span class=\"number\">0</span>] == d[i].top()[<span class=\"number\">0</span>] || d[last3].top()[<span class=\"number\">1</span>] == d[i].top()[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">        d[last3].push(d[i].top());</span><br><span class=\"line\">        d[i].pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//judge if we can move 1 step</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok_1</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last1;</span><br><span class=\"line\">    last1 = front_idx[i];</span><br><span class=\"line\">    <span class=\"comment\">//if(last1 &lt; 0) return false;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[last1].top()[<span class=\"number\">0</span>] == d[i].top()[<span class=\"number\">0</span>] || d[last1].top()[<span class=\"number\">1</span>] == d[i].top()[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">        d[last1].push(d[i].top());</span><br><span class=\"line\">        d[i].pop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">move</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != <span class=\"number\">-1</span>; i = next_idx[i], cnt++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ok_3(i)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ok_1(i)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//erase empty position</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">erase</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != <span class=\"number\">-1</span>; i = next_idx[i])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[i].empty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l = front_idx[i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> r = next_idx[i];</span><br><span class=\"line\">            next_idx[l] = r;</span><br><span class=\"line\">            front_idx[r] = l;</span><br><span class=\"line\">            next_idx[i] = front_idx[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE    </span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(input())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">51</span>; i++)&#123;</span><br><span class=\"line\">            next_idx[i] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">53</span>; i++)&#123;</span><br><span class=\"line\">            front_idx[i] = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(move())&#123;</span><br><span class=\"line\">            erase();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != <span class=\"number\">-1</span>; i = next_idx[i])&#123;</span><br><span class=\"line\">            ans.push_back(d[i].size());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = ans.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"1 pile remaining: \"</span> &lt;&lt; ans[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; len &lt;&lt; <span class=\"string\">\" piles remaining:\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x : ans)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; x;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva1599-Ideal Path-双向BFS","date":"2018-11-18T02:49:44.000Z","_content":"给定一个n个顶点和m条边的无向图，每条边都有颜色，求从结点1到结点n的一条最短路，若有多条则取路径颜色序列字典序最小的那条。可能会有重边和自环。\n<!--more-->\n## 链接\n[Uva1599-Ideal Path](https://vjudge.net/problem/UVA-1599)\n\n## 题解\n这里每条边的权值都是一样的，可以求最短路的方式有 $BFS$，$SPFA$，$Dijkstra$ 等。但是这些方法都不能保证求得的最短路的字典序最小。可以先从节点n出发跑一次 $BFS$。这样再从节点1出发时可以按照各个结点已经标记好的距离，每次到达一个新结点时保证d值恰好减1,直到到达终点。\n按照上述规则从起点出发，优先选择颜色字典序最小的走，若多条边的颜色字典序都最小则记录所有这些边的终点，下一步时考虑从所有这些点出发的边。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 17 Nov 23:09:12 CST 2018\n *\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nconst int inf = 1e9 + 7;\nstruct Edge{\n    int to;\n    int color;\n};\nvector<Edge> G[maxn];\nint n, m;\nint d[maxn];\nbool vis[maxn];\n\nvoid back_bfs(){\n    d[n - 1] = 0;\n    vis[n - 1] = true;\n    queue<int> que;\n    que.push(n - 1);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        for(size_t i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            int u = e.to;\n            if(!vis[u]){\n                d[u] = d[v] + 1;\n                que.push(u);\n                vis[u] = true;\n            }\n        }\n\n    }\n}\n\nvector<int> ans;\n\nvoid bfs(){\n    memset(vis, 0, sizeof(vis));\n    vis[0] = true;\n\n    vector<int> next;\n    next.push_back(0);\n    for(int i = 0; i < d[0]; i++){\n        int minColor = inf;\n        for(size_t j = 0; j < next.size(); j++){\n            int v = next[j];\n            for(size_t k = 0; k < G[v].size(); k++){\n                Edge e = G[v][k];\n                int u = e.to;\n                if(d[u] == d[v] - 1){\n                    minColor = min(minColor, e.color);\n                }\n            }\n        }\n        ans.push_back(minColor);\n\n        vector<int> next2;\n        for(size_t j = 0; j < next.size(); j++){\n            int v = next[j];\n            for(size_t k = 0; k < G[v].size(); k++){\n                Edge e = G[v][k];\n                if(e.color == minColor && !vis[e.to] && d[e.to] == d[v] - 1){\n                    next2.push_back(e.to);\n                    vis[e.to] = true;\n                }\n            }\n        }\n        next = next2;\n    }\n\n    int res = ans.size();\n    cout << res << endl;\n    for(int i = 0; i < res; i++){\n        if(i == 0) cout << ans[i];\n        else cout << \" \" << ans[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n >> m){\n        memset(d, 0, sizeof(d));\n        memset(vis, 0, sizeof(vis));\n        ans.clear();\n        for(int i = 0; i < n; i++){\n            G[i].clear();\n        }\n\n        int a, b, c;\n        Edge e;\n        for(int i = 0; i < m; i++){\n            cin >> a >> b >> c;\n            e.to = b - 1;\n            e.color = c;\n            G[a - 1].push_back(e);\n            e.to = a - 1;\n            G[b - 1].push_back(e);\n        }\n\n        back_bfs();\n        bfs();\n    }\n    return 0;\n}\n```\n","source":"_posts/Uva1599-Ideal-Path.md","raw":"---\ntitle: Uva1599-Ideal Path-双向BFS\ndate: 2018-11-18 10:49:44\ncategories:\n- ACM\n- BFS\ntags:\n- BFS\n---\n给定一个n个顶点和m条边的无向图，每条边都有颜色，求从结点1到结点n的一条最短路，若有多条则取路径颜色序列字典序最小的那条。可能会有重边和自环。\n<!--more-->\n## 链接\n[Uva1599-Ideal Path](https://vjudge.net/problem/UVA-1599)\n\n## 题解\n这里每条边的权值都是一样的，可以求最短路的方式有 $BFS$，$SPFA$，$Dijkstra$ 等。但是这些方法都不能保证求得的最短路的字典序最小。可以先从节点n出发跑一次 $BFS$。这样再从节点1出发时可以按照各个结点已经标记好的距离，每次到达一个新结点时保证d值恰好减1,直到到达终点。\n按照上述规则从起点出发，优先选择颜色字典序最小的走，若多条边的颜色字典序都最小则记录所有这些边的终点，下一步时考虑从所有这些点出发的边。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 17 Nov 23:09:12 CST 2018\n *\n */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nconst int inf = 1e9 + 7;\nstruct Edge{\n    int to;\n    int color;\n};\nvector<Edge> G[maxn];\nint n, m;\nint d[maxn];\nbool vis[maxn];\n\nvoid back_bfs(){\n    d[n - 1] = 0;\n    vis[n - 1] = true;\n    queue<int> que;\n    que.push(n - 1);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        for(size_t i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            int u = e.to;\n            if(!vis[u]){\n                d[u] = d[v] + 1;\n                que.push(u);\n                vis[u] = true;\n            }\n        }\n\n    }\n}\n\nvector<int> ans;\n\nvoid bfs(){\n    memset(vis, 0, sizeof(vis));\n    vis[0] = true;\n\n    vector<int> next;\n    next.push_back(0);\n    for(int i = 0; i < d[0]; i++){\n        int minColor = inf;\n        for(size_t j = 0; j < next.size(); j++){\n            int v = next[j];\n            for(size_t k = 0; k < G[v].size(); k++){\n                Edge e = G[v][k];\n                int u = e.to;\n                if(d[u] == d[v] - 1){\n                    minColor = min(minColor, e.color);\n                }\n            }\n        }\n        ans.push_back(minColor);\n\n        vector<int> next2;\n        for(size_t j = 0; j < next.size(); j++){\n            int v = next[j];\n            for(size_t k = 0; k < G[v].size(); k++){\n                Edge e = G[v][k];\n                if(e.color == minColor && !vis[e.to] && d[e.to] == d[v] - 1){\n                    next2.push_back(e.to);\n                    vis[e.to] = true;\n                }\n            }\n        }\n        next = next2;\n    }\n\n    int res = ans.size();\n    cout << res << endl;\n    for(int i = 0; i < res; i++){\n        if(i == 0) cout << ans[i];\n        else cout << \" \" << ans[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n >> m){\n        memset(d, 0, sizeof(d));\n        memset(vis, 0, sizeof(vis));\n        ans.clear();\n        for(int i = 0; i < n; i++){\n            G[i].clear();\n        }\n\n        int a, b, c;\n        Edge e;\n        for(int i = 0; i < m; i++){\n            cin >> a >> b >> c;\n            e.to = b - 1;\n            e.color = c;\n            G[a - 1].push_back(e);\n            e.to = a - 1;\n            G[b - 1].push_back(e);\n        }\n\n        back_bfs();\n        bfs();\n    }\n    return 0;\n}\n```\n","slug":"Uva1599-Ideal-Path","published":1,"updated":"2018-12-14T13:01:44.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrnc002lb8ouvzdzhnec","content":"<p>给定一个n个顶点和m条边的无向图，每条边都有颜色，求从结点1到结点n的一条最短路，若有多条则取路径颜色序列字典序最小的那条。可能会有重边和自环。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-1599\" target=\"_blank\" rel=\"noopener\">Uva1599-Ideal Path</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这里每条边的权值都是一样的，可以求最短路的方式有 $BFS$，$SPFA$，$Dijkstra$ 等。但是这些方法都不能保证求得的最短路的字典序最小。可以先从节点n出发跑一次 $BFS$。这样再从节点1出发时可以按照各个结点已经标记好的距离，每次到达一个新结点时保证d值恰好减1,直到到达终点。<br>按照上述规则从起点出发，优先选择颜色字典序最小的走，若多条边的颜色字典序都最小则记录所有这些边的终点，下一步时考虑从所有这些点出发的边。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 17 Nov 23:09:12 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> inf = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> color;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Edge&gt; G[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">back_bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    d[n - <span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vis[n - <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; que;</span><br><span class=\"line\">    que.push(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class=\"line\">            Edge e = G[v][i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> u = e.to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[u])&#123;</span><br><span class=\"line\">                d[u] = d[v] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                que.push(u);</span><br><span class=\"line\">                vis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">    vis[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; next;</span><br><span class=\"line\">    next.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; d[<span class=\"number\">0</span>]; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minColor = inf;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; next.size(); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v = next[j];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> k = <span class=\"number\">0</span>; k &lt; G[v].size(); k++)&#123;</span><br><span class=\"line\">                Edge e = G[v][k];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> u = e.to;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(d[u] == d[v] - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    minColor = min(minColor, e.color);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.push_back(minColor);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; next2;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; next.size(); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v = next[j];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> k = <span class=\"number\">0</span>; k &lt; G[v].size(); k++)&#123;</span><br><span class=\"line\">                Edge e = G[v][k];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(e.color == minColor &amp;&amp; !vis[e.to] &amp;&amp; d[e.to] == d[v] - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    next2.push_back(e.to);</span><br><span class=\"line\">                    vis[e.to] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next = next2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = ans.size();</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; res &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; res; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; ans[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; ans[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        ans.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            G[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">        Edge e;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\">            e.to = b - <span class=\"number\">1</span>;</span><br><span class=\"line\">            e.color = c;</span><br><span class=\"line\">            G[a - <span class=\"number\">1</span>].push_back(e);</span><br><span class=\"line\">            e.to = a - <span class=\"number\">1</span>;</span><br><span class=\"line\">            G[b - <span class=\"number\">1</span>].push_back(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        back_bfs();</span><br><span class=\"line\">        bfs();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>给定一个n个顶点和m条边的无向图，每条边都有颜色，求从结点1到结点n的一条最短路，若有多条则取路径颜色序列字典序最小的那条。可能会有重边和自环。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-1599\" target=\"_blank\" rel=\"noopener\">Uva1599-Ideal Path</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这里每条边的权值都是一样的，可以求最短路的方式有 $BFS$，$SPFA$，$Dijkstra$ 等。但是这些方法都不能保证求得的最短路的字典序最小。可以先从节点n出发跑一次 $BFS$。这样再从节点1出发时可以按照各个结点已经标记好的距离，每次到达一个新结点时保证d值恰好减1,直到到达终点。<br>按照上述规则从起点出发，优先选择颜色字典序最小的走，若多条边的颜色字典序都最小则记录所有这些边的终点，下一步时考虑从所有这些点出发的边。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 17 Nov 23:09:12 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> inf = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> color;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Edge&gt; G[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">back_bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    d[n - <span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vis[n - <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; que;</span><br><span class=\"line\">    que.push(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class=\"line\">            Edge e = G[v][i];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> u = e.to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[u])&#123;</span><br><span class=\"line\">                d[u] = d[v] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                que.push(u);</span><br><span class=\"line\">                vis[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">    vis[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; next;</span><br><span class=\"line\">    next.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; d[<span class=\"number\">0</span>]; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minColor = inf;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; next.size(); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v = next[j];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> k = <span class=\"number\">0</span>; k &lt; G[v].size(); k++)&#123;</span><br><span class=\"line\">                Edge e = G[v][k];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> u = e.to;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(d[u] == d[v] - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    minColor = min(minColor, e.color);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.push_back(minColor);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; next2;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; next.size(); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v = next[j];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> k = <span class=\"number\">0</span>; k &lt; G[v].size(); k++)&#123;</span><br><span class=\"line\">                Edge e = G[v][k];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(e.color == minColor &amp;&amp; !vis[e.to] &amp;&amp; d[e.to] == d[v] - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    next2.push_back(e.to);</span><br><span class=\"line\">                    vis[e.to] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next = next2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = ans.size();</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; res &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; res; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; ans[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; ans[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        ans.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            G[i].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">        Edge e;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class=\"line\">            e.to = b - <span class=\"number\">1</span>;</span><br><span class=\"line\">            e.color = c;</span><br><span class=\"line\">            G[a - <span class=\"number\">1</span>].push_back(e);</span><br><span class=\"line\">            e.to = a - <span class=\"number\">1</span>;</span><br><span class=\"line\">            G[b - <span class=\"number\">1</span>].push_back(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        back_bfs();</span><br><span class=\"line\">        bfs();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva1600-Patrol Robot-BFS","date":"2018-12-03T01:20:27.000Z","_content":"一个$ m \\times n $的长方形场地，0表示可走格子，1表示障碍物。求从 $(1，1)$ 到 $(m，n)$的最短路径。其中可以走存在障碍物的格子，但不能在障碍物上连续走k步。\n<!--more-->\n## 链接\n[Uva1600-Patrol Robot](https://vjudge.net/problem/UVA-1600)\n\n## 题解\n用BFS和DFS搜索路径都可以，但如果不剪枝的用DFS会TL。用BFS搜索，为队列中的每一项，除了x，y坐标属性之外，再加上当前的k值属性。同时还有需要注意的一点是，**这个问题里同一格子可以被多次放入队列，只要它的k值属性或距离d值相比之前有提升**。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 30 Nov 19:05:23 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 27;\nint mp[maxn][maxn];\nint d[maxn][maxn];\nint record_k[maxn][maxn];\nint t, m, n, k;\nstruct Node{\n    Node(int x = 0, int y = 0, int k = 0):x(x), y(y), k(k){}\n    int x, y;\n    int k;\n};\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint bfs(){\n    d[0][0] = 0;\n    record_k[0][0] = k;\n    queue<Node> que;\n    que.push(Node(0, 0, k));\n\n    while(!que.empty()){\n        Node nd = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = nd.x + dx[i], ny = nd.y + dy[i];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                if(mp[nx][ny] == 0){\n                    if(d[nx][ny] == -1 || (d[nx][ny] > d[nd.x][nd.y] && record_k[nx][ny] < k)){\n                        d[nx][ny] = d[nd.x][nd.y] + 1;\n                        record_k[nx][ny] = k;\n                        que.push(Node(nx, ny, k));\n                    }\n                }\n                else if(mp[nx][ny] == 1 && nd.k > 0){\n                    if(d[nx][ny] == -1 || (d[nx][ny] > d[nd.x][nd.y] && record_k[nx][ny] < nd.k - 1)){\n                        d[nx][ny] = d[nd.x][nd.y] + 1;\n                        record_k[nx][ny] = nd.k - 1;\n                        que.push(Node(nx, ny, nd.k - 1));\n                    }\n                }\n            }\n        }\n    }\n\n    return d[m - 1][n - 1];\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> t;\n    while(t--){\n        memset(d, -1, sizeof(d));\n        memset(record_k, 0, sizeof(record_k));\n        cin >> m >> n >> k;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                cin >> mp[i][j];\n            }\n        }\n        int ans = bfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n```","source":"_posts/Uva1600-Patrol-Robot.md","raw":"---\ntitle: Uva1600-Patrol Robot-BFS\ndate: 2018-12-03 09:20:27\ncategories:\n- ACM\n- BFS\ntags:\n- BFS\n---\n一个$ m \\times n $的长方形场地，0表示可走格子，1表示障碍物。求从 $(1，1)$ 到 $(m，n)$的最短路径。其中可以走存在障碍物的格子，但不能在障碍物上连续走k步。\n<!--more-->\n## 链接\n[Uva1600-Patrol Robot](https://vjudge.net/problem/UVA-1600)\n\n## 题解\n用BFS和DFS搜索路径都可以，但如果不剪枝的用DFS会TL。用BFS搜索，为队列中的每一项，除了x，y坐标属性之外，再加上当前的k值属性。同时还有需要注意的一点是，**这个问题里同一格子可以被多次放入队列，只要它的k值属性或距离d值相比之前有提升**。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 30 Nov 19:05:23 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 27;\nint mp[maxn][maxn];\nint d[maxn][maxn];\nint record_k[maxn][maxn];\nint t, m, n, k;\nstruct Node{\n    Node(int x = 0, int y = 0, int k = 0):x(x), y(y), k(k){}\n    int x, y;\n    int k;\n};\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint bfs(){\n    d[0][0] = 0;\n    record_k[0][0] = k;\n    queue<Node> que;\n    que.push(Node(0, 0, k));\n\n    while(!que.empty()){\n        Node nd = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int nx = nd.x + dx[i], ny = nd.y + dy[i];\n            if(nx >= 0 && nx < m && ny >= 0 && ny < n){\n                if(mp[nx][ny] == 0){\n                    if(d[nx][ny] == -1 || (d[nx][ny] > d[nd.x][nd.y] && record_k[nx][ny] < k)){\n                        d[nx][ny] = d[nd.x][nd.y] + 1;\n                        record_k[nx][ny] = k;\n                        que.push(Node(nx, ny, k));\n                    }\n                }\n                else if(mp[nx][ny] == 1 && nd.k > 0){\n                    if(d[nx][ny] == -1 || (d[nx][ny] > d[nd.x][nd.y] && record_k[nx][ny] < nd.k - 1)){\n                        d[nx][ny] = d[nd.x][nd.y] + 1;\n                        record_k[nx][ny] = nd.k - 1;\n                        que.push(Node(nx, ny, nd.k - 1));\n                    }\n                }\n            }\n        }\n    }\n\n    return d[m - 1][n - 1];\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> t;\n    while(t--){\n        memset(d, -1, sizeof(d));\n        memset(record_k, 0, sizeof(record_k));\n        cin >> m >> n >> k;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                cin >> mp[i][j];\n            }\n        }\n        int ans = bfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n```","slug":"Uva1600-Patrol-Robot","published":1,"updated":"2018-12-14T12:59:18.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrnf002nb8ouyujz548h","content":"<p>一个$ m \\times n $的长方形场地，0表示可走格子，1表示障碍物。求从 $(1，1)$ 到 $(m，n)$的最短路径。其中可以走存在障碍物的格子，但不能在障碍物上连续走k步。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-1600\" target=\"_blank\" rel=\"noopener\">Uva1600-Patrol Robot</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>用BFS和DFS搜索路径都可以，但如果不剪枝的用DFS会TL。用BFS搜索，为队列中的每一项，除了x，y坐标属性之外，再加上当前的k值属性。同时还有需要注意的一点是，<strong>这个问题里同一格子可以被多次放入队列，只要它的k值属性或距离d值相比之前有提升</strong>。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Fri 30 Nov 19:05:23 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">27</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> mp[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> record_k[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t, m, n, k;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> y = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>):x(x), y(y), k(k)&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    d[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    record_k[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = k;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;Node&gt; que;</span><br><span class=\"line\">    que.push(Node(<span class=\"number\">0</span>, <span class=\"number\">0</span>, k));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        Node nd = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nx = nd.x + dx[i], ny = nd.y + dy[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; n)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mp[nx][ny] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(d[nx][ny] == <span class=\"number\">-1</span> || (d[nx][ny] &gt; d[nd.x][nd.y] &amp;&amp; record_k[nx][ny] &lt; k))&#123;</span><br><span class=\"line\">                        d[nx][ny] = d[nd.x][nd.y] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                        record_k[nx][ny] = k;</span><br><span class=\"line\">                        que.push(Node(nx, ny, k));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mp[nx][ny] == <span class=\"number\">1</span> &amp;&amp; nd.k &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(d[nx][ny] == <span class=\"number\">-1</span> || (d[nx][ny] &gt; d[nd.x][nd.y] &amp;&amp; record_k[nx][ny] &lt; nd.k - <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                        d[nx][ny] = d[nd.x][nd.y] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                        record_k[nx][ny] = nd.k - <span class=\"number\">1</span>;</span><br><span class=\"line\">                        que.push(Node(nx, ny, nd.k - <span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> d[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(record_k, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(record_k));</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cin</span> &gt;&gt; mp[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = bfs();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>一个$ m \\times n $的长方形场地，0表示可走格子，1表示障碍物。求从 $(1，1)$ 到 $(m，n)$的最短路径。其中可以走存在障碍物的格子，但不能在障碍物上连续走k步。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-1600\" target=\"_blank\" rel=\"noopener\">Uva1600-Patrol Robot</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>用BFS和DFS搜索路径都可以，但如果不剪枝的用DFS会TL。用BFS搜索，为队列中的每一项，除了x，y坐标属性之外，再加上当前的k值属性。同时还有需要注意的一点是，<strong>这个问题里同一格子可以被多次放入队列，只要它的k值属性或距离d值相比之前有提升</strong>。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Fri 30 Nov 19:05:23 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">27</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> mp[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> record_k[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t, m, n, k;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> y = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>):x(x), y(y), k(k)&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    d[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    record_k[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = k;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;Node&gt; que;</span><br><span class=\"line\">    que.push(Node(<span class=\"number\">0</span>, <span class=\"number\">0</span>, k));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        Node nd = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nx = nd.x + dx[i], ny = nd.y + dy[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; n)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mp[nx][ny] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(d[nx][ny] == <span class=\"number\">-1</span> || (d[nx][ny] &gt; d[nd.x][nd.y] &amp;&amp; record_k[nx][ny] &lt; k))&#123;</span><br><span class=\"line\">                        d[nx][ny] = d[nd.x][nd.y] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                        record_k[nx][ny] = k;</span><br><span class=\"line\">                        que.push(Node(nx, ny, k));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mp[nx][ny] == <span class=\"number\">1</span> &amp;&amp; nd.k &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(d[nx][ny] == <span class=\"number\">-1</span> || (d[nx][ny] &gt; d[nd.x][nd.y] &amp;&amp; record_k[nx][ny] &lt; nd.k - <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                        d[nx][ny] = d[nd.x][nd.y] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                        record_k[nx][ny] = nd.k - <span class=\"number\">1</span>;</span><br><span class=\"line\">                        que.push(Node(nx, ny, nd.k - <span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> d[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(record_k, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(record_k));</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cin</span> &gt;&gt; mp[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = bfs();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva548-二叉树构建&&DFS","date":"2018-09-22T03:30:57.000Z","_content":"首先根据二叉树的中序和后序遍历构建二叉树，然后找一个叶子节点使得它到根的路径上的权和最小。\n<!--more-->\n## 链接\n[Uva548-Tree](https://vjudge.net/problem/UVA-548)\n## 题目描述\n给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍历，找一个叶子节点使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。\n## 题解\n根据中序和后序遍历可以构建出这棵二叉，然后用DFS搜索找到结果。\n## 代码\n**通过设置best_sum和best找到最优解的方法值得学习啊。**\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 22 Sep 11:20:12 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e4 + 7;\nint in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];\nstring line;\nint n;\nint best, best_sum;\n\nbool read(int* s){\n    if(!getline(cin, line)) return false;\n    stringstream ss(line);\n    n = 0;\n    int x;\n    while(ss >> x){\n        s[n++] = x;\n    }\n    return true;\n}\n\nint build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return 0;\n    int v = post_order[r2];\n    int pos = 0;\n    while(in_order[pos] != v) pos++;\n    int len = pos - l1;\n    lch[v] = build(l1, l1 + len - 1, l2, l2 + len - 1);\n    rch[v] = build(l1 + len + 1, r1, l2 + len, r2 - 1);\n    return v;\n}\n\nvoid dfs(int v, int sum){\n    sum += v;\n    if(!lch[v] && !rch[v]){\n        if(sum < best_sum || (sum == best_sum && v < best)){\n            best_sum = sum;\n            best = v;\n        }\n        return;\n    }\n    if(lch[v]) dfs(lch[v], sum);\n    if(rch[v]) dfs(rch[v], sum);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(read(in_order)){\n        read(post_order);\n        int root = build(0, n - 1, 0, n - 1);\n        best_sum = 1e9;\n        dfs(root, 0);\n        cout << best << endl;\n    }\n    \n    return 0;\n}\n```","source":"_posts/Uva548-二叉树构建-DFS.md","raw":"---\ntitle: Uva548-二叉树构建&&DFS\ndate: 2018-09-22 11:30:57\ncategories:\n- ACM\n- 树\ntags:\n- 二叉树\n- DFS\n---\n首先根据二叉树的中序和后序遍历构建二叉树，然后找一个叶子节点使得它到根的路径上的权和最小。\n<!--more-->\n## 链接\n[Uva548-Tree](https://vjudge.net/problem/UVA-548)\n## 题目描述\n给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍历，找一个叶子节点使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。\n## 题解\n根据中序和后序遍历可以构建出这棵二叉，然后用DFS搜索找到结果。\n## 代码\n**通过设置best_sum和best找到最优解的方法值得学习啊。**\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 22 Sep 11:20:12 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e4 + 7;\nint in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];\nstring line;\nint n;\nint best, best_sum;\n\nbool read(int* s){\n    if(!getline(cin, line)) return false;\n    stringstream ss(line);\n    n = 0;\n    int x;\n    while(ss >> x){\n        s[n++] = x;\n    }\n    return true;\n}\n\nint build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return 0;\n    int v = post_order[r2];\n    int pos = 0;\n    while(in_order[pos] != v) pos++;\n    int len = pos - l1;\n    lch[v] = build(l1, l1 + len - 1, l2, l2 + len - 1);\n    rch[v] = build(l1 + len + 1, r1, l2 + len, r2 - 1);\n    return v;\n}\n\nvoid dfs(int v, int sum){\n    sum += v;\n    if(!lch[v] && !rch[v]){\n        if(sum < best_sum || (sum == best_sum && v < best)){\n            best_sum = sum;\n            best = v;\n        }\n        return;\n    }\n    if(lch[v]) dfs(lch[v], sum);\n    if(rch[v]) dfs(rch[v], sum);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(read(in_order)){\n        read(post_order);\n        int root = build(0, n - 1, 0, n - 1);\n        best_sum = 1e9;\n        dfs(root, 0);\n        cout << best << endl;\n    }\n    \n    return 0;\n}\n```","slug":"Uva548-二叉树构建-DFS","published":1,"updated":"2018-12-14T13:05:45.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrnh002sb8oum4jltxq5","content":"<p>首先根据二叉树的中序和后序遍历构建二叉树，然后找一个叶子节点使得它到根的路径上的权和最小。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-548\" target=\"_blank\" rel=\"noopener\">Uva548-Tree</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍历，找一个叶子节点使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>根据中序和后序遍历可以构建出这棵二叉，然后用DFS搜索找到结果。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p><strong>通过设置best_sum和best找到最优解的方法值得学习啊。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 22 Sep 11:20:12 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e4</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];</span><br><span class=\"line\"><span class=\"built_in\">string</span> line;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> best, best_sum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span>* s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!getline(<span class=\"built_in\">cin</span>, line)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(line)</span></span>;</span><br><span class=\"line\">    n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss &gt;&gt; x)&#123;</span><br><span class=\"line\">        s[n++] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l1, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> l2, <span class=\"keyword\">int</span> r2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1 &gt; r1) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = post_order[r2];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(in_order[pos] != v) pos++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = pos - l1;</span><br><span class=\"line\">    lch[v] = build(l1, l1 + len - <span class=\"number\">1</span>, l2, l2 + len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    rch[v] = build(l1 + len + <span class=\"number\">1</span>, r1, l2 + len, r2 - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> sum)</span></span>&#123;</span><br><span class=\"line\">    sum += v;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!lch[v] &amp;&amp; !rch[v])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum &lt; best_sum || (sum == best_sum &amp;&amp; v &lt; best))&#123;</span><br><span class=\"line\">            best_sum = sum;</span><br><span class=\"line\">            best = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(lch[v]) dfs(lch[v], sum);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(rch[v]) dfs(rch[v], sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(read(in_order))&#123;</span><br><span class=\"line\">        read(post_order);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> root = build(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        best_sum = <span class=\"number\">1e9</span>;</span><br><span class=\"line\">        dfs(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; best &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>首先根据二叉树的中序和后序遍历构建二叉树，然后找一个叶子节点使得它到根的路径上的权和最小。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-548\" target=\"_blank\" rel=\"noopener\">Uva548-Tree</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍历，找一个叶子节点使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>根据中序和后序遍历可以构建出这棵二叉，然后用DFS搜索找到结果。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p><strong>通过设置best_sum和best找到最优解的方法值得学习啊。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 22 Sep 11:20:12 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e4</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];</span><br><span class=\"line\"><span class=\"built_in\">string</span> line;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> best, best_sum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span>* s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!getline(<span class=\"built_in\">cin</span>, line)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(line)</span></span>;</span><br><span class=\"line\">    n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss &gt;&gt; x)&#123;</span><br><span class=\"line\">        s[n++] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l1, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> l2, <span class=\"keyword\">int</span> r2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1 &gt; r1) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = post_order[r2];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(in_order[pos] != v) pos++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = pos - l1;</span><br><span class=\"line\">    lch[v] = build(l1, l1 + len - <span class=\"number\">1</span>, l2, l2 + len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    rch[v] = build(l1 + len + <span class=\"number\">1</span>, r1, l2 + len, r2 - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> sum)</span></span>&#123;</span><br><span class=\"line\">    sum += v;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!lch[v] &amp;&amp; !rch[v])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum &lt; best_sum || (sum == best_sum &amp;&amp; v &lt; best))&#123;</span><br><span class=\"line\">            best_sum = sum;</span><br><span class=\"line\">            best = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(lch[v]) dfs(lch[v], sum);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(rch[v]) dfs(rch[v], sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(read(in_order))&#123;</span><br><span class=\"line\">        read(post_order);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> root = build(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        best_sum = <span class=\"number\">1e9</span>;</span><br><span class=\"line\">        dfs(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; best &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"Uva673-Parentheses Balance-栈","date":"2018-11-26T23:08:53.000Z","_content":"输入一个包含 $“()”$ 和 $“[]”$ 的括号序列，判断是否合法。具体规则：\n- 空串合法\n- 如果A和B都合法，则AB合法\n- 如果A合法则(A)和[A]都合法\n\n可能最近DFS，BFS做多了，总想往搜索上套...不过最后能想到栈还是很鸡冻＼（≧▽≦）／\n<!--more-->\n## 链接\n[Uva673-Parentheses Balance](https://vjudge.net/problem/UVA-673)\n\n## 题解\n能想到用栈之后这道题基本就可解了，将字符序列依次放入栈中遇到可以匹配的括号对　$“()”$ 或 $“[]”$　就出栈。如果最后栈中还有未匹配的括号，则不合法；否则若栈空，则合法。\n*可能含有空串所以读入的时候用getline(cin, s)读入，因为cin会自动忽略'\\n'，即忽略空串。*\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 26 Nov 23:30:58 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 130;\nstring s;\nint n;\nstack<char> stk;\nbool p;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> n;\n    getchar();\n    while(n--){\n        while(!stk.empty()){\n            stk.pop();\n        }\n\n        getline(cin , s);\n        if(s.length() % 2){\n            cout << \"No\" << endl;\n            continue;\n        }\n        for(size_t i = 0; i < s.length(); i++){\n            p = false;\n            if(!stk.empty()){\n                if((stk.top() == '(' && s[i] == ')') || (stk.top() == '[' && s[i] == ']')){\n                    stk.pop();\n                    p = true;\n                }\n            }\n            if(!p) stk.push(s[i]);\n        }\n\n        if(!stk.empty()) cout << \"No\" << endl;\n        else cout << \"Yes\" << endl;\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Uva673-Parentheses-Balance.md","raw":"---\ntitle: Uva673-Parentheses Balance-栈\ndate: 2018-11-27 07:08:53\ncategories:\n- ACM\n- 栈\ntags:\n- Stack\n---\n输入一个包含 $“()”$ 和 $“[]”$ 的括号序列，判断是否合法。具体规则：\n- 空串合法\n- 如果A和B都合法，则AB合法\n- 如果A合法则(A)和[A]都合法\n\n可能最近DFS，BFS做多了，总想往搜索上套...不过最后能想到栈还是很鸡冻＼（≧▽≦）／\n<!--more-->\n## 链接\n[Uva673-Parentheses Balance](https://vjudge.net/problem/UVA-673)\n\n## 题解\n能想到用栈之后这道题基本就可解了，将字符序列依次放入栈中遇到可以匹配的括号对　$“()”$ 或 $“[]”$　就出栈。如果最后栈中还有未匹配的括号，则不合法；否则若栈空，则合法。\n*可能含有空串所以读入的时候用getline(cin, s)读入，因为cin会自动忽略'\\n'，即忽略空串。*\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 26 Nov 23:30:58 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 130;\nstring s;\nint n;\nstack<char> stk;\nbool p;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    cin >> n;\n    getchar();\n    while(n--){\n        while(!stk.empty()){\n            stk.pop();\n        }\n\n        getline(cin , s);\n        if(s.length() % 2){\n            cout << \"No\" << endl;\n            continue;\n        }\n        for(size_t i = 0; i < s.length(); i++){\n            p = false;\n            if(!stk.empty()){\n                if((stk.top() == '(' && s[i] == ')') || (stk.top() == '[' && s[i] == ']')){\n                    stk.pop();\n                    p = true;\n                }\n            }\n            if(!p) stk.push(s[i]);\n        }\n\n        if(!stk.empty()) cout << \"No\" << endl;\n        else cout << \"Yes\" << endl;\n    }\n    return 0;\n}\n```\n\n","slug":"Uva673-Parentheses-Balance","published":1,"updated":"2018-12-14T12:58:35.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrnl002vb8ou229sk2he","content":"<p>输入一个包含 $“()”$ 和 $“[]”$ 的括号序列，判断是否合法。具体规则：</p>\n<ul>\n<li>空串合法</li>\n<li>如果A和B都合法，则AB合法</li>\n<li>如果A合法则(A)和[A]都合法</li>\n</ul>\n<p>可能最近DFS，BFS做多了，总想往搜索上套…不过最后能想到栈还是很鸡冻＼（≧▽≦）／<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-673\" target=\"_blank\" rel=\"noopener\">Uva673-Parentheses Balance</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>能想到用栈之后这道题基本就可解了，将字符序列依次放入栈中遇到可以匹配的括号对　$“()”$ 或 $“[]”$　就出栈。如果最后栈中还有未匹配的括号，则不合法；否则若栈空，则合法。<br><em>可能含有空串所以读入的时候用getline(cin, s)读入，因为cin会自动忽略’\\n’，即忽略空串。</em></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon 26 Nov 23:30:58 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">130</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; stk;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> p;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    getchar();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stk.empty())&#123;</span><br><span class=\"line\">            stk.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        getline(<span class=\"built_in\">cin</span> , s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length() % <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"No\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class=\"line\">            p = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!stk.empty())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((stk.top() == <span class=\"string\">'('</span> &amp;&amp; s[i] == <span class=\"string\">')'</span>) || (stk.top() == <span class=\"string\">'['</span> &amp;&amp; s[i] == <span class=\"string\">']'</span>))&#123;</span><br><span class=\"line\">                    stk.pop();</span><br><span class=\"line\">                    p = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!p) stk.push(s[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!stk.empty()) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"No\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Yes\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>输入一个包含 $“()”$ 和 $“[]”$ 的括号序列，判断是否合法。具体规则：</p>\n<ul>\n<li>空串合法</li>\n<li>如果A和B都合法，则AB合法</li>\n<li>如果A合法则(A)和[A]都合法</li>\n</ul>\n<p>可能最近DFS，BFS做多了，总想往搜索上套…不过最后能想到栈还是很鸡冻＼（≧▽≦）／<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-673\" target=\"_blank\" rel=\"noopener\">Uva673-Parentheses Balance</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>能想到用栈之后这道题基本就可解了，将字符序列依次放入栈中遇到可以匹配的括号对　$“()”$ 或 $“[]”$　就出栈。如果最后栈中还有未匹配的括号，则不合法；否则若栈空，则合法。<br><em>可能含有空串所以读入的时候用getline(cin, s)读入，因为cin会自动忽略’\\n’，即忽略空串。</em></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon 26 Nov 23:30:58 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">130</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">char</span>&gt; stk;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> p;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    getchar();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stk.empty())&#123;</span><br><span class=\"line\">            stk.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        getline(<span class=\"built_in\">cin</span> , s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.length() % <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"No\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class=\"line\">            p = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!stk.empty())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((stk.top() == <span class=\"string\">'('</span> &amp;&amp; s[i] == <span class=\"string\">')'</span>) || (stk.top() == <span class=\"string\">'['</span> &amp;&amp; s[i] == <span class=\"string\">']'</span>))&#123;</span><br><span class=\"line\">                    stk.pop();</span><br><span class=\"line\">                    p = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!p) stk.push(s[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!stk.empty()) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"No\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Yes\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva221-Urban Elevations-离散化","date":"2018-11-14T02:00:10.000Z","_content":"输入每个建筑物左下角坐标、宽度、深度和高度，输出正视图中能看到的所有建筑物，按照左下角x坐标从小到大进行排序。坐下角x坐标相同时，按y坐标从小到大排序。\n![building](/building.png)\n*第一眼看上去很像当时面试北航计算机时候的机试题，后来做着做着发现不对劲= =。结尾放一个彩蛋，把印象中的机试题和解题思路说一下。*\n<!--more-->\n## 链接\n[Uva221-Urban Elevation](https://vjudge.net/problem/UVA-221)\n\n## 题解\n因为是正视图，所以判断可见性的时候忽略深度参数，只把它当做判断前后层次的一个信息。判断一个建筑物是否可见，只要满足建筑物在x方向上有一些点（大于一个）可见，那么建筑物可见。因为x值连续有无穷个，所以无法枚举x。需要进行离散化，把无穷变为有限。\n把所有x坐标排序去重，则任意两个相邻x坐标形成的区间要么完全可见，要么完全不可见。等效于按照所有建筑物的垂直轮廓线进行区间划分，然后只要对这几个区间进行判断，任取区间一点，若这点对建筑物可见，则这段区间对建筑物可见，则可以说这个建筑物可见。判断一个建筑物是否在某个坐标点可见的条件是：建筑物坐标中必须包含这个坐标；建筑物前方不能有包含这个坐标且高于它的其它建筑物。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed 14 Nov 07:22:41 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nstruct Building{\n    int id;\n    double x, y, w, d, h;\n};\nBuilding bld[maxn];\nint xp[maxn * 2];\nint n;\n\nbool cmp(const Building& a, const Building& b){\n    if(a.x == b.x){\n        return a.y < b.y;\n    }\n    else{\n        return a.x < b.x;\n    }\n}\n\nbool visible(int ct, int x){\n    ///cout << \"target: \" << bld[ct].id << endl;\n    for(int i = 0; i < n; i++){\n        if(i == ct) continue;\n        if(bld[i].y <= bld[ct].y && bld[i].x <= x && bld[i].x + bld[i].w >= x){\n            //cout << bld[i].id << endl;\n            if(bld[i].h >= bld[ct].h) return false;\n        }\n    }\n    //cout << \"******\" << endl;\n    return true;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    while(cin >> n){\n        if(n == 0) break;\n        memset(bld, 0, sizeof(bld));\n        double x, y, w, d, h;\n        for(int i = 0; i < n; i++){\n            bld[i].id = i + 1;\n            cin >> x >> y >> w >> d >> h;\n            bld[i].x = x, bld[i].y = y, bld[i].w = w, bld[i].d = d, bld[i].h = h;\n            xp[2 * i] = x, xp[2 * i + 1] = x + w;\n        }\n        sort(bld, bld + n, cmp);\n        sort(xp, xp + 2 * n);\n        int m = unique(xp, xp + 2 * n) - xp;\n        vector<int> vec;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m - 1; j++){\n                if(bld[i].x >= xp[j + 1] || bld[i].x + bld[i].w <= xp[j]) continue;\n                if(visible(i, (xp[j] + xp[j + 1]) / 2)){\n                    vec.push_back(bld[i].id);\n                    break;\n                }\n            }\n        }\n\n        if(cnt > 1) cout << endl;\n        printf(\"For map #%d, the visible buildings are numbered as follows:\\n\", cnt++);\n        int len = vec.size();\n        for(int i = 0; i < len; i++){\n            if(!i) cout << vec[i];\n            else cout << \" \" << vec[i];\n        }\n        cout << endl;\n\n    }\n    return 0;    \n}\n```\n\n## 彩蛋\n北航那道机试题的题意大致是模拟点击window窗口的操作。平面上有几个窗口，以左下角坐标、长度和宽度的形式给出，同时以字符串形式给出每个窗口中的内容。接着给定n组坐标，表示鼠标点击的位置，（鼠标点击到某个窗口的有效位置，即未被遮挡的位置时，该窗口上升到第一层），要求输出这n次点击之后，其中一个指定窗口的可见内容部分。例如，一个窗口中的内容为```I am the content in this window```，经过n次点击之后，它在第三层，在它之上有两个窗口且对它的内容有部分遮挡，假设它的可见部分为```I```，```the```，```in```，```win```，那么应输出```I****the*********in******win***```，其中```*```表示不可见。\n思路就是进行模拟。定义一个结构体保存窗口编号、坐标、长度、宽度、内容以及它当前所在层。接下来模拟点击，鼠标每点击一次，根据点击区域调整各个窗口所在层并重新按层次进行排序。模拟完点击之后，对要输出内容的窗口中的每一个字符首先求出它的坐标，接着判断这个坐标是否包含在它之上窗口的区域内，若包含则输出```*```，若不包含则输出原字符。\n之所以说后面发现和上面那道题不一致，是因为北航这道题其实本来就是离散的，一个字符相当于一个坐标点，不存在小数坐标点的情况。\n\n*北航计算机的机试基本不涉及算法，比较考验基本功。考场提供的IDE有codeblocks、DEV和VC++6.0，语言要求C/C++，不限制STL的使用，时间是2个小时，题目数量2~3道，我那年是两道，第一道是简单的排序题，用sort函数加上自定义比较函数就能解决*","source":"_posts/Uva221-Urban-Elevations.md","raw":"---\ntitle: Uva221-Urban Elevations-离散化\ndate: 2018-11-14 10:00:10\ncategories:\n- ACM\n- 离散化\ntags:\n- 离散化\n---\n输入每个建筑物左下角坐标、宽度、深度和高度，输出正视图中能看到的所有建筑物，按照左下角x坐标从小到大进行排序。坐下角x坐标相同时，按y坐标从小到大排序。\n![building](/building.png)\n*第一眼看上去很像当时面试北航计算机时候的机试题，后来做着做着发现不对劲= =。结尾放一个彩蛋，把印象中的机试题和解题思路说一下。*\n<!--more-->\n## 链接\n[Uva221-Urban Elevation](https://vjudge.net/problem/UVA-221)\n\n## 题解\n因为是正视图，所以判断可见性的时候忽略深度参数，只把它当做判断前后层次的一个信息。判断一个建筑物是否可见，只要满足建筑物在x方向上有一些点（大于一个）可见，那么建筑物可见。因为x值连续有无穷个，所以无法枚举x。需要进行离散化，把无穷变为有限。\n把所有x坐标排序去重，则任意两个相邻x坐标形成的区间要么完全可见，要么完全不可见。等效于按照所有建筑物的垂直轮廓线进行区间划分，然后只要对这几个区间进行判断，任取区间一点，若这点对建筑物可见，则这段区间对建筑物可见，则可以说这个建筑物可见。判断一个建筑物是否在某个坐标点可见的条件是：建筑物坐标中必须包含这个坐标；建筑物前方不能有包含这个坐标且高于它的其它建筑物。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed 14 Nov 07:22:41 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nstruct Building{\n    int id;\n    double x, y, w, d, h;\n};\nBuilding bld[maxn];\nint xp[maxn * 2];\nint n;\n\nbool cmp(const Building& a, const Building& b){\n    if(a.x == b.x){\n        return a.y < b.y;\n    }\n    else{\n        return a.x < b.x;\n    }\n}\n\nbool visible(int ct, int x){\n    ///cout << \"target: \" << bld[ct].id << endl;\n    for(int i = 0; i < n; i++){\n        if(i == ct) continue;\n        if(bld[i].y <= bld[ct].y && bld[i].x <= x && bld[i].x + bld[i].w >= x){\n            //cout << bld[i].id << endl;\n            if(bld[i].h >= bld[ct].h) return false;\n        }\n    }\n    //cout << \"******\" << endl;\n    return true;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 1;\n    while(cin >> n){\n        if(n == 0) break;\n        memset(bld, 0, sizeof(bld));\n        double x, y, w, d, h;\n        for(int i = 0; i < n; i++){\n            bld[i].id = i + 1;\n            cin >> x >> y >> w >> d >> h;\n            bld[i].x = x, bld[i].y = y, bld[i].w = w, bld[i].d = d, bld[i].h = h;\n            xp[2 * i] = x, xp[2 * i + 1] = x + w;\n        }\n        sort(bld, bld + n, cmp);\n        sort(xp, xp + 2 * n);\n        int m = unique(xp, xp + 2 * n) - xp;\n        vector<int> vec;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m - 1; j++){\n                if(bld[i].x >= xp[j + 1] || bld[i].x + bld[i].w <= xp[j]) continue;\n                if(visible(i, (xp[j] + xp[j + 1]) / 2)){\n                    vec.push_back(bld[i].id);\n                    break;\n                }\n            }\n        }\n\n        if(cnt > 1) cout << endl;\n        printf(\"For map #%d, the visible buildings are numbered as follows:\\n\", cnt++);\n        int len = vec.size();\n        for(int i = 0; i < len; i++){\n            if(!i) cout << vec[i];\n            else cout << \" \" << vec[i];\n        }\n        cout << endl;\n\n    }\n    return 0;    \n}\n```\n\n## 彩蛋\n北航那道机试题的题意大致是模拟点击window窗口的操作。平面上有几个窗口，以左下角坐标、长度和宽度的形式给出，同时以字符串形式给出每个窗口中的内容。接着给定n组坐标，表示鼠标点击的位置，（鼠标点击到某个窗口的有效位置，即未被遮挡的位置时，该窗口上升到第一层），要求输出这n次点击之后，其中一个指定窗口的可见内容部分。例如，一个窗口中的内容为```I am the content in this window```，经过n次点击之后，它在第三层，在它之上有两个窗口且对它的内容有部分遮挡，假设它的可见部分为```I```，```the```，```in```，```win```，那么应输出```I****the*********in******win***```，其中```*```表示不可见。\n思路就是进行模拟。定义一个结构体保存窗口编号、坐标、长度、宽度、内容以及它当前所在层。接下来模拟点击，鼠标每点击一次，根据点击区域调整各个窗口所在层并重新按层次进行排序。模拟完点击之后，对要输出内容的窗口中的每一个字符首先求出它的坐标，接着判断这个坐标是否包含在它之上窗口的区域内，若包含则输出```*```，若不包含则输出原字符。\n之所以说后面发现和上面那道题不一致，是因为北航这道题其实本来就是离散的，一个字符相当于一个坐标点，不存在小数坐标点的情况。\n\n*北航计算机的机试基本不涉及算法，比较考验基本功。考场提供的IDE有codeblocks、DEV和VC++6.0，语言要求C/C++，不限制STL的使用，时间是2个小时，题目数量2~3道，我那年是两道，第一道是简单的排序题，用sort函数加上自定义比较函数就能解决*","slug":"Uva221-Urban-Elevations","published":1,"updated":"2018-12-14T13:02:15.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrnn0030b8ougajoimbs","content":"<p>输入每个建筑物左下角坐标、宽度、深度和高度，输出正视图中能看到的所有建筑物，按照左下角x坐标从小到大进行排序。坐下角x坐标相同时，按y坐标从小到大排序。<br><img src=\"/2018/11/14/Uva221-Urban-Elevations/building.png\" alt=\"building\"><br><em>第一眼看上去很像当时面试北航计算机时候的机试题，后来做着做着发现不对劲= =。结尾放一个彩蛋，把印象中的机试题和解题思路说一下。</em><br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-221\" target=\"_blank\" rel=\"noopener\">Uva221-Urban Elevation</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为是正视图，所以判断可见性的时候忽略深度参数，只把它当做判断前后层次的一个信息。判断一个建筑物是否可见，只要满足建筑物在x方向上有一些点（大于一个）可见，那么建筑物可见。因为x值连续有无穷个，所以无法枚举x。需要进行离散化，把无穷变为有限。<br>把所有x坐标排序去重，则任意两个相邻x坐标形成的区间要么完全可见，要么完全不可见。等效于按照所有建筑物的垂直轮廓线进行区间划分，然后只要对这几个区间进行判断，任取区间一点，若这点对建筑物可见，则这段区间对建筑物可见，则可以说这个建筑物可见。判断一个建筑物是否在某个坐标点可见的条件是：建筑物坐标中必须包含这个坐标；建筑物前方不能有包含这个坐标且高于它的其它建筑物。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Wed 14 Nov 07:22:41 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">107</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Building</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x, y, w, d, h;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Building bld[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> xp[maxn * <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> Building&amp; a, <span class=\"keyword\">const</span> Building&amp; b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.x == b.x)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.y &lt; b.y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.x &lt; b.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">visible</span><span class=\"params\">(<span class=\"keyword\">int</span> ct, <span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">///cout &lt;&lt; \"target: \" &lt;&lt; bld[ct].id &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == ct) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(bld[i].y &lt;= bld[ct].y &amp;&amp; bld[i].x &lt;= x &amp;&amp; bld[i].x + bld[i].w &gt;= x)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; bld[i].id &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(bld[i].h &gt;= bld[ct].h) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; \"******\" &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(bld, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(bld));</span><br><span class=\"line\">        <span class=\"keyword\">double</span> x, y, w, d, h;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            bld[i].id = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w &gt;&gt; d &gt;&gt; h;</span><br><span class=\"line\">            bld[i].x = x, bld[i].y = y, bld[i].w = w, bld[i].d = d, bld[i].h = h;</span><br><span class=\"line\">            xp[<span class=\"number\">2</span> * i] = x, xp[<span class=\"number\">2</span> * i + <span class=\"number\">1</span>] = x + w;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(bld, bld + n, cmp);</span><br><span class=\"line\">        sort(xp, xp + <span class=\"number\">2</span> * n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = unique(xp, xp + <span class=\"number\">2</span> * n) - xp;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m - <span class=\"number\">1</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(bld[i].x &gt;= xp[j + <span class=\"number\">1</span>] || bld[i].x + bld[i].w &lt;= xp[j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(visible(i, (xp[j] + xp[j + <span class=\"number\">1</span>]) / <span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">                    vec.push_back(bld[i].id);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">1</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"For map #%d, the visible buildings are numbered as follows:\\n\"</span>, cnt++);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = vec.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!i) <span class=\"built_in\">cout</span> &lt;&lt; vec[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; vec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>北航那道机试题的题意大致是模拟点击window窗口的操作。平面上有几个窗口，以左下角坐标、长度和宽度的形式给出，同时以字符串形式给出每个窗口中的内容。接着给定n组坐标，表示鼠标点击的位置，（鼠标点击到某个窗口的有效位置，即未被遮挡的位置时，该窗口上升到第一层），要求输出这n次点击之后，其中一个指定窗口的可见内容部分。例如，一个窗口中的内容为<code>I am the content in this window</code>，经过n次点击之后，它在第三层，在它之上有两个窗口且对它的内容有部分遮挡，假设它的可见部分为<code>I</code>，<code>the</code>，<code>in</code>，<code>win</code>，那么应输出<code>I****the*********in******win***</code>，其中<code>*</code>表示不可见。<br>思路就是进行模拟。定义一个结构体保存窗口编号、坐标、长度、宽度、内容以及它当前所在层。接下来模拟点击，鼠标每点击一次，根据点击区域调整各个窗口所在层并重新按层次进行排序。模拟完点击之后，对要输出内容的窗口中的每一个字符首先求出它的坐标，接着判断这个坐标是否包含在它之上窗口的区域内，若包含则输出<code>*</code>，若不包含则输出原字符。<br>之所以说后面发现和上面那道题不一致，是因为北航这道题其实本来就是离散的，一个字符相当于一个坐标点，不存在小数坐标点的情况。</p>\n<p><em>北航计算机的机试基本不涉及算法，比较考验基本功。考场提供的IDE有codeblocks、DEV和VC++6.0，语言要求C/C++，不限制STL的使用，时间是2个小时，题目数量2~3道，我那年是两道，第一道是简单的排序题，用sort函数加上自定义比较函数就能解决</em></p>\n","site":{"data":{}},"excerpt":"<p>输入每个建筑物左下角坐标、宽度、深度和高度，输出正视图中能看到的所有建筑物，按照左下角x坐标从小到大进行排序。坐下角x坐标相同时，按y坐标从小到大排序。<br><img src=\"/2018/11/14/Uva221-Urban-Elevations/building.png\" alt=\"building\"><br><em>第一眼看上去很像当时面试北航计算机时候的机试题，后来做着做着发现不对劲= =。结尾放一个彩蛋，把印象中的机试题和解题思路说一下。</em><br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-221\" target=\"_blank\" rel=\"noopener\">Uva221-Urban Elevation</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为是正视图，所以判断可见性的时候忽略深度参数，只把它当做判断前后层次的一个信息。判断一个建筑物是否可见，只要满足建筑物在x方向上有一些点（大于一个）可见，那么建筑物可见。因为x值连续有无穷个，所以无法枚举x。需要进行离散化，把无穷变为有限。<br>把所有x坐标排序去重，则任意两个相邻x坐标形成的区间要么完全可见，要么完全不可见。等效于按照所有建筑物的垂直轮廓线进行区间划分，然后只要对这几个区间进行判断，任取区间一点，若这点对建筑物可见，则这段区间对建筑物可见，则可以说这个建筑物可见。判断一个建筑物是否在某个坐标点可见的条件是：建筑物坐标中必须包含这个坐标；建筑物前方不能有包含这个坐标且高于它的其它建筑物。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Wed 14 Nov 07:22:41 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">107</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Building</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x, y, w, d, h;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Building bld[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> xp[maxn * <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> Building&amp; a, <span class=\"keyword\">const</span> Building&amp; b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.x == b.x)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.y &lt; b.y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.x &lt; b.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">visible</span><span class=\"params\">(<span class=\"keyword\">int</span> ct, <span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">///cout &lt;&lt; \"target: \" &lt;&lt; bld[ct].id &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == ct) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(bld[i].y &lt;= bld[ct].y &amp;&amp; bld[i].x &lt;= x &amp;&amp; bld[i].x + bld[i].w &gt;= x)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; bld[i].id &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(bld[i].h &gt;= bld[ct].h) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; \"******\" &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(bld, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(bld));</span><br><span class=\"line\">        <span class=\"keyword\">double</span> x, y, w, d, h;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            bld[i].id = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w &gt;&gt; d &gt;&gt; h;</span><br><span class=\"line\">            bld[i].x = x, bld[i].y = y, bld[i].w = w, bld[i].d = d, bld[i].h = h;</span><br><span class=\"line\">            xp[<span class=\"number\">2</span> * i] = x, xp[<span class=\"number\">2</span> * i + <span class=\"number\">1</span>] = x + w;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(bld, bld + n, cmp);</span><br><span class=\"line\">        sort(xp, xp + <span class=\"number\">2</span> * n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = unique(xp, xp + <span class=\"number\">2</span> * n) - xp;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; m - <span class=\"number\">1</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(bld[i].x &gt;= xp[j + <span class=\"number\">1</span>] || bld[i].x + bld[i].w &lt;= xp[j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(visible(i, (xp[j] + xp[j + <span class=\"number\">1</span>]) / <span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">                    vec.push_back(bld[i].id);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">1</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"For map #%d, the visible buildings are numbered as follows:\\n\"</span>, cnt++);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = vec.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!i) <span class=\"built_in\">cout</span> &lt;&lt; vec[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; vec[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>北航那道机试题的题意大致是模拟点击window窗口的操作。平面上有几个窗口，以左下角坐标、长度和宽度的形式给出，同时以字符串形式给出每个窗口中的内容。接着给定n组坐标，表示鼠标点击的位置，（鼠标点击到某个窗口的有效位置，即未被遮挡的位置时，该窗口上升到第一层），要求输出这n次点击之后，其中一个指定窗口的可见内容部分。例如，一个窗口中的内容为<code>I am the content in this window</code>，经过n次点击之后，它在第三层，在它之上有两个窗口且对它的内容有部分遮挡，假设它的可见部分为<code>I</code>，<code>the</code>，<code>in</code>，<code>win</code>，那么应输出<code>I****the*********in******win***</code>，其中<code>*</code>表示不可见。<br>思路就是进行模拟。定义一个结构体保存窗口编号、坐标、长度、宽度、内容以及它当前所在层。接下来模拟点击，鼠标每点击一次，根据点击区域调整各个窗口所在层并重新按层次进行排序。模拟完点击之后，对要输出内容的窗口中的每一个字符首先求出它的坐标，接着判断这个坐标是否包含在它之上窗口的区域内，若包含则输出<code>*</code>，若不包含则输出原字符。<br>之所以说后面发现和上面那道题不一致，是因为北航这道题其实本来就是离散的，一个字符相当于一个坐标点，不存在小数坐标点的情况。</p>\n<p><em>北航计算机的机试基本不涉及算法，比较考验基本功。考场提供的IDE有codeblocks、DEV和VC++6.0，语言要求C/C++，不限制STL的使用，时间是2个小时，题目数量2~3道，我那年是两道，第一道是简单的排序题，用sort函数加上自定义比较函数就能解决</em></p>"},{"title":"牛客暑期ACM多校训练营(第三场)A题-PACM Team-多维01背包+记录路径","date":"2018-07-26T15:16:37.000Z","_content":"DP果然是最弱的，记录路径更是十分懵，在多校训练营里被虐的抬不起头，，，算了，只要不死，就会更强(赛亚人的特性其实也就是人的特性)\n<!-- more -->\n## 题目描述\nEddy was a contestant participating in ACM ICPC contests. ACM is short for Algorithm, Coding, Math. Since in the ACM contest, the most important knowledge is about algorithm, followed by coding(implementation ability), then math. However, in the ACM ICPC World Finals 2018, Eddy failed to solve a physics equation, which pushed him away from a potential medal.\n\nSince then on, Eddy found that physics is actually the most important thing in the contest. Thus, he wants to form a team to guide the following contestants to conquer the PACM contests(PACM is short for Physics, Algorithm, Coding, Math). \n\nThere are N candidate groups each composed of pi physics experts, ai algorithm experts, ci coding experts, mi math experts. For each group, Eddy can either invite all of them or none of them. If i-th team is invited, they will bring gi knowledge points which is calculated by Eddy's magic formula. Eddy believes that the higher the total knowledge points is, the better a team could place in a contest. But, Eddy doesn't want too many experts in the same area in the invited groups. Thus, the number of invited physics experts should not exceed P, and A for algorithm experts, C for coding experts, M for math experts.\n\nEddy is still busy in studying Physics. You come to help him to figure out which groups should be invited such that they doesn't exceed the constraint and will bring the most knowledge points in total.\n\n输入描述:\nThe first line contains a positive integer N indicating the number of candidate groups.\nEach of following N lines contains five space-separated integer pi, ai, ci, mi, gi indicating that i-th team consists of pi physics experts, ai algorithm experts, ci coding experts, mi math experts, and will bring gi knowledge points.\nThe last line contains four space-separated integer P, A, C, M indicating the maximum possible number of physics experts, algorithm experts, coding experts, and math experts, respectively.\n\n 1 ≤ N ≤ 36\n 0 ≤ pi,ai,ci,mi,gi ≤ 36\n 0 ≤ P, A, C, M ≤ 36\n输出描述:\n\nThe first line should contain a non-negative integer K indicating the number of invited groups.\nThe second line should contain K space-separated integer indicating the index of invited groups(groups are indexed from 0).\n\nYou can output index in any order as long as each index appears at most once. If there are multiple way to reach the most total knowledge points, you can output any one of them. If none of the groups will be invited, you could either output one line or output a blank line in the second line.\n示例1:\n\n输入:\n2\n1 0 2 1 10\n1 0 2 1 21\n1 0 2 1\n输出:\n1\n1\n\n示例2:\n\n输入:\n1\n2 1 1 0 31\n1 0 2 1\n输出：\n0\n\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 40;\nint p[maxn], a[maxn], c[maxn], m[maxn];\nint v[maxn];\nshort d[maxn][maxn][maxn][maxn][maxn];\nint n;\nint Pm, Am, Cm, Mm;\nint used[maxn];//记录路径\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    memset(used, 0, sizeof(used));\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d%d%d%d%d\", p + i, a + i, c + i, m + i, v + i);\n    }\n\n    scanf(\"%d%d%d%d\", &Pm, &Am, &Cm, &Mm);\n    for(int i = 0; i <= Pm; i++){\n        for(int j = 0; j <= Am; j++){\n            for(int k = 0; k <= Cm; k++){\n                for(int l = 0; l <= Mm; l++){\n                    d[0][i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= Pm; j++){\n            for(int k = 0; k <= Am; k++){\n                for(int l = 0; l <= Cm; l++){\n                    for(int q = 0; q <= Mm; q++){\n                        d[i + 1][j][k][l][q] = d[i][j][k][l][q];\n                        if(j >= p[i] && k >= a[i] && l >= c[i] && q >= m[i]){\n                            int tmp = v[i] + d[i][j - p[i]][k - a[i]][l - c[i]][q - m[i]];\n                            if(tmp > d[i + 1][j][k][l][q]) {\n                                d[i + 1][j][k][l][q] = tmp;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //记录路径部分\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][Pm][Am][Cm][Mm] != d[i][Pm][Am][Cm][Mm]){\n            used[i] = 1;\n            Pm -= p[i];\n            Am -= a[i];\n            Cm -= c[i];\n            Mm -= m[i];\n        }\n    }\n    int cnt = 0;\n    for(int i = 0; i < n; i++){\n        if(used[i] == 1){\n            cnt++;\n        }\n    }\n    printf(\"%d\\n\", cnt);\n    if(cnt){\n        for(int i = 0; i < n; i++){\n            if(used[i]) printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n## 坑点\n数据d的类型要是short类型，int类型会爆内存，char类型会数据溢出．\n\n## 背包记录路径问题总结\n### 方法一核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            if(j < w[i]){\n                d[i + 1][j] = d[i][j];\n            }\n            else{\n                d[i + 1][j] = max(d[i][j], d[i][j - w[i]] + v[i]);\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][W] != d[i][W]){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n### 方法二核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            d[i + 1][j] = d[i][j];\n            if(j >= w[i]){\n                int tmp = d[i][j - w[i]] + v[i];\n                if(tmp > d[i + 1][j]){\n                    d[i + 1][j] = tmp;\n                    path[i][j] = 1;\n                }\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(path[i][W] == 1){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n","source":"_posts/Nowcoder-Third-A.md","raw":"---\ntitle: 牛客暑期ACM多校训练营(第三场)A题-PACM Team-多维01背包+记录路径\ndate: 2018-07-26 23:16:37\ncategories:\n- ACM\n- 背包\ntags:\n- DP\n- 01背包\n---\nDP果然是最弱的，记录路径更是十分懵，在多校训练营里被虐的抬不起头，，，算了，只要不死，就会更强(赛亚人的特性其实也就是人的特性)\n<!-- more -->\n## 题目描述\nEddy was a contestant participating in ACM ICPC contests. ACM is short for Algorithm, Coding, Math. Since in the ACM contest, the most important knowledge is about algorithm, followed by coding(implementation ability), then math. However, in the ACM ICPC World Finals 2018, Eddy failed to solve a physics equation, which pushed him away from a potential medal.\n\nSince then on, Eddy found that physics is actually the most important thing in the contest. Thus, he wants to form a team to guide the following contestants to conquer the PACM contests(PACM is short for Physics, Algorithm, Coding, Math). \n\nThere are N candidate groups each composed of pi physics experts, ai algorithm experts, ci coding experts, mi math experts. For each group, Eddy can either invite all of them or none of them. If i-th team is invited, they will bring gi knowledge points which is calculated by Eddy's magic formula. Eddy believes that the higher the total knowledge points is, the better a team could place in a contest. But, Eddy doesn't want too many experts in the same area in the invited groups. Thus, the number of invited physics experts should not exceed P, and A for algorithm experts, C for coding experts, M for math experts.\n\nEddy is still busy in studying Physics. You come to help him to figure out which groups should be invited such that they doesn't exceed the constraint and will bring the most knowledge points in total.\n\n输入描述:\nThe first line contains a positive integer N indicating the number of candidate groups.\nEach of following N lines contains five space-separated integer pi, ai, ci, mi, gi indicating that i-th team consists of pi physics experts, ai algorithm experts, ci coding experts, mi math experts, and will bring gi knowledge points.\nThe last line contains four space-separated integer P, A, C, M indicating the maximum possible number of physics experts, algorithm experts, coding experts, and math experts, respectively.\n\n 1 ≤ N ≤ 36\n 0 ≤ pi,ai,ci,mi,gi ≤ 36\n 0 ≤ P, A, C, M ≤ 36\n输出描述:\n\nThe first line should contain a non-negative integer K indicating the number of invited groups.\nThe second line should contain K space-separated integer indicating the index of invited groups(groups are indexed from 0).\n\nYou can output index in any order as long as each index appears at most once. If there are multiple way to reach the most total knowledge points, you can output any one of them. If none of the groups will be invited, you could either output one line or output a blank line in the second line.\n示例1:\n\n输入:\n2\n1 0 2 1 10\n1 0 2 1 21\n1 0 2 1\n输出:\n1\n1\n\n示例2:\n\n输入:\n1\n2 1 1 0 31\n1 0 2 1\n输出：\n0\n\n## 代码\n``` C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 40;\nint p[maxn], a[maxn], c[maxn], m[maxn];\nint v[maxn];\nshort d[maxn][maxn][maxn][maxn][maxn];\nint n;\nint Pm, Am, Cm, Mm;\nint used[maxn];//记录路径\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    memset(used, 0, sizeof(used));\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d%d%d%d%d\", p + i, a + i, c + i, m + i, v + i);\n    }\n\n    scanf(\"%d%d%d%d\", &Pm, &Am, &Cm, &Mm);\n    for(int i = 0; i <= Pm; i++){\n        for(int j = 0; j <= Am; j++){\n            for(int k = 0; k <= Cm; k++){\n                for(int l = 0; l <= Mm; l++){\n                    d[0][i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= Pm; j++){\n            for(int k = 0; k <= Am; k++){\n                for(int l = 0; l <= Cm; l++){\n                    for(int q = 0; q <= Mm; q++){\n                        d[i + 1][j][k][l][q] = d[i][j][k][l][q];\n                        if(j >= p[i] && k >= a[i] && l >= c[i] && q >= m[i]){\n                            int tmp = v[i] + d[i][j - p[i]][k - a[i]][l - c[i]][q - m[i]];\n                            if(tmp > d[i + 1][j][k][l][q]) {\n                                d[i + 1][j][k][l][q] = tmp;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //记录路径部分\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][Pm][Am][Cm][Mm] != d[i][Pm][Am][Cm][Mm]){\n            used[i] = 1;\n            Pm -= p[i];\n            Am -= a[i];\n            Cm -= c[i];\n            Mm -= m[i];\n        }\n    }\n    int cnt = 0;\n    for(int i = 0; i < n; i++){\n        if(used[i] == 1){\n            cnt++;\n        }\n    }\n    printf(\"%d\\n\", cnt);\n    if(cnt){\n        for(int i = 0; i < n; i++){\n            if(used[i]) printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n```\n## 坑点\n数据d的类型要是short类型，int类型会爆内存，char类型会数据溢出．\n\n## 背包记录路径问题总结\n### 方法一核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            if(j < w[i]){\n                d[i + 1][j] = d[i][j];\n            }\n            else{\n                d[i + 1][j] = max(d[i][j], d[i][j - w[i]] + v[i]);\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(d[i + 1][W] != d[i][W]){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n### 方法二核心代码\n``` C++\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j <= W; j++){\n            d[i + 1][j] = d[i][j];\n            if(j >= w[i]){\n                int tmp = d[i][j - w[i]] + v[i];\n                if(tmp > d[i + 1][j]){\n                    d[i + 1][j] = tmp;\n                    path[i][j] = 1;\n                }\n            }\n        }\n    }\n\n    for(int i = n - 1; i >= 0; i--){\n        if(path[i][W] == 1){\n            used[i] = 1;\n            W -= w[i];\n        }\n    }\n```\n","slug":"Nowcoder-Third-A","published":1,"updated":"2018-12-14T13:11:34.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrno0033b8ou86ak73ir","content":"<p>DP果然是最弱的，记录路径更是十分懵，在多校训练营里被虐的抬不起头，，，算了，只要不死，就会更强(赛亚人的特性其实也就是人的特性)<br><a id=\"more\"></a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Eddy was a contestant participating in ACM ICPC contests. ACM is short for Algorithm, Coding, Math. Since in the ACM contest, the most important knowledge is about algorithm, followed by coding(implementation ability), then math. However, in the ACM ICPC World Finals 2018, Eddy failed to solve a physics equation, which pushed him away from a potential medal.</p>\n<p>Since then on, Eddy found that physics is actually the most important thing in the contest. Thus, he wants to form a team to guide the following contestants to conquer the PACM contests(PACM is short for Physics, Algorithm, Coding, Math). </p>\n<p>There are N candidate groups each composed of pi physics experts, ai algorithm experts, ci coding experts, mi math experts. For each group, Eddy can either invite all of them or none of them. If i-th team is invited, they will bring gi knowledge points which is calculated by Eddy’s magic formula. Eddy believes that the higher the total knowledge points is, the better a team could place in a contest. But, Eddy doesn’t want too many experts in the same area in the invited groups. Thus, the number of invited physics experts should not exceed P, and A for algorithm experts, C for coding experts, M for math experts.</p>\n<p>Eddy is still busy in studying Physics. You come to help him to figure out which groups should be invited such that they doesn’t exceed the constraint and will bring the most knowledge points in total.</p>\n<p>输入描述:<br>The first line contains a positive integer N indicating the number of candidate groups.<br>Each of following N lines contains five space-separated integer pi, ai, ci, mi, gi indicating that i-th team consists of pi physics experts, ai algorithm experts, ci coding experts, mi math experts, and will bring gi knowledge points.<br>The last line contains four space-separated integer P, A, C, M indicating the maximum possible number of physics experts, algorithm experts, coding experts, and math experts, respectively.</p>\n<p> 1 ≤ N ≤ 36<br> 0 ≤ pi,ai,ci,mi,gi ≤ 36<br> 0 ≤ P, A, C, M ≤ 36<br>输出描述:</p>\n<p>The first line should contain a non-negative integer K indicating the number of invited groups.<br>The second line should contain K space-separated integer indicating the index of invited groups(groups are indexed from 0).</p>\n<p>You can output index in any order as long as each index appears at most once. If there are multiple way to reach the most total knowledge points, you can output any one of them. If none of the groups will be invited, you could either output one line or output a blank line in the second line.<br>示例1:</p>\n<p>输入:<br>2<br>1 0 2 1 10<br>1 0 2 1 21<br>1 0 2 1<br>输出:<br>1<br>1</p>\n<p>示例2:</p>\n<p>输入:<br>1<br>2 1 1 0 31<br>1 0 2 1<br>输出：<br>0</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">40</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> p[maxn], a[maxn], c[maxn], m[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> v[maxn];</span><br><span class=\"line\"><span class=\"keyword\">short</span> d[maxn][maxn][maxn][maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Pm, Am, Cm, Mm;</span><br><span class=\"line\"><span class=\"keyword\">int</span> used[maxn];<span class=\"comment\">//记录路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(used, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(used));</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d%d\"</span>, p + i, a + i, c + i, m + i, v + i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>, &amp;Pm, &amp;Am, &amp;Cm, &amp;Mm);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= Pm; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= Am; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= Cm; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt;= Mm; l++)&#123;</span><br><span class=\"line\">                    d[<span class=\"number\">0</span>][i][j][k][l] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= Pm; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= Am; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt;= Cm; l++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> q = <span class=\"number\">0</span>; q &lt;= Mm; q++)&#123;</span><br><span class=\"line\">                        d[i + <span class=\"number\">1</span>][j][k][l][q] = d[i][j][k][l][q];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(j &gt;= p[i] &amp;&amp; k &gt;= a[i] &amp;&amp; l &gt;= c[i] &amp;&amp; q &gt;= m[i])&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> tmp = v[i] + d[i][j - p[i]][k - a[i]][l - c[i]][q - m[i]];</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(tmp &gt; d[i + <span class=\"number\">1</span>][j][k][l][q]) &#123;</span><br><span class=\"line\">                                d[i + <span class=\"number\">1</span>][j][k][l][q] = tmp;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//记录路径部分</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[i + <span class=\"number\">1</span>][Pm][Am][Cm][Mm] != d[i][Pm][Am][Cm][Mm])&#123;</span><br><span class=\"line\">            used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            Pm -= p[i];</span><br><span class=\"line\">            Am -= a[i];</span><br><span class=\"line\">            Cm -= c[i];</span><br><span class=\"line\">            Mm -= m[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(used[i] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i]) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>数据d的类型要是short类型，int类型会爆内存，char类型会数据溢出．</p>\n<h2 id=\"背包记录路径问题总结\"><a href=\"#背包记录路径问题总结\" class=\"headerlink\" title=\"背包记录路径问题总结\"></a>背包记录路径问题总结</h2><h3 id=\"方法一核心代码\"><a href=\"#方法一核心代码\" class=\"headerlink\" title=\"方法一核心代码\"></a>方法一核心代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= W; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j &lt; w[i])&#123;</span><br><span class=\"line\">            d[i + <span class=\"number\">1</span>][j] = d[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            d[i + <span class=\"number\">1</span>][j] = max(d[i][j], d[i][j - w[i]] + v[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[i + <span class=\"number\">1</span>][W] != d[i][W])&#123;</span><br><span class=\"line\">        used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        W -= w[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二核心代码\"><a href=\"#方法二核心代码\" class=\"headerlink\" title=\"方法二核心代码\"></a>方法二核心代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= W; j++)&#123;</span><br><span class=\"line\">        d[i + <span class=\"number\">1</span>][j] = d[i][j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j &gt;= w[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = d[i][j - w[i]] + v[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp &gt; d[i + <span class=\"number\">1</span>][j])&#123;</span><br><span class=\"line\">                d[i + <span class=\"number\">1</span>][j] = tmp;</span><br><span class=\"line\">                path[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(path[i][W] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        W -= w[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>DP果然是最弱的，记录路径更是十分懵，在多校训练营里被虐的抬不起头，，，算了，只要不死，就会更强(赛亚人的特性其实也就是人的特性)<br></p>","more":"<p></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Eddy was a contestant participating in ACM ICPC contests. ACM is short for Algorithm, Coding, Math. Since in the ACM contest, the most important knowledge is about algorithm, followed by coding(implementation ability), then math. However, in the ACM ICPC World Finals 2018, Eddy failed to solve a physics equation, which pushed him away from a potential medal.</p>\n<p>Since then on, Eddy found that physics is actually the most important thing in the contest. Thus, he wants to form a team to guide the following contestants to conquer the PACM contests(PACM is short for Physics, Algorithm, Coding, Math). </p>\n<p>There are N candidate groups each composed of pi physics experts, ai algorithm experts, ci coding experts, mi math experts. For each group, Eddy can either invite all of them or none of them. If i-th team is invited, they will bring gi knowledge points which is calculated by Eddy’s magic formula. Eddy believes that the higher the total knowledge points is, the better a team could place in a contest. But, Eddy doesn’t want too many experts in the same area in the invited groups. Thus, the number of invited physics experts should not exceed P, and A for algorithm experts, C for coding experts, M for math experts.</p>\n<p>Eddy is still busy in studying Physics. You come to help him to figure out which groups should be invited such that they doesn’t exceed the constraint and will bring the most knowledge points in total.</p>\n<p>输入描述:<br>The first line contains a positive integer N indicating the number of candidate groups.<br>Each of following N lines contains five space-separated integer pi, ai, ci, mi, gi indicating that i-th team consists of pi physics experts, ai algorithm experts, ci coding experts, mi math experts, and will bring gi knowledge points.<br>The last line contains four space-separated integer P, A, C, M indicating the maximum possible number of physics experts, algorithm experts, coding experts, and math experts, respectively.</p>\n<p> 1 ≤ N ≤ 36<br> 0 ≤ pi,ai,ci,mi,gi ≤ 36<br> 0 ≤ P, A, C, M ≤ 36<br>输出描述:</p>\n<p>The first line should contain a non-negative integer K indicating the number of invited groups.<br>The second line should contain K space-separated integer indicating the index of invited groups(groups are indexed from 0).</p>\n<p>You can output index in any order as long as each index appears at most once. If there are multiple way to reach the most total knowledge points, you can output any one of them. If none of the groups will be invited, you could either output one line or output a blank line in the second line.<br>示例1:</p>\n<p>输入:<br>2<br>1 0 2 1 10<br>1 0 2 1 21<br>1 0 2 1<br>输出:<br>1<br>1</p>\n<p>示例2:</p>\n<p>输入:<br>1<br>2 1 1 0 31<br>1 0 2 1<br>输出：<br>0</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">40</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> p[maxn], a[maxn], c[maxn], m[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> v[maxn];</span><br><span class=\"line\"><span class=\"keyword\">short</span> d[maxn][maxn][maxn][maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> Pm, Am, Cm, Mm;</span><br><span class=\"line\"><span class=\"keyword\">int</span> used[maxn];<span class=\"comment\">//记录路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(used, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(used));</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d%d\"</span>, p + i, a + i, c + i, m + i, v + i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>, &amp;Pm, &amp;Am, &amp;Cm, &amp;Mm);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= Pm; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= Am; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= Cm; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt;= Mm; l++)&#123;</span><br><span class=\"line\">                    d[<span class=\"number\">0</span>][i][j][k][l] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= Pm; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= Am; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>; l &lt;= Cm; l++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> q = <span class=\"number\">0</span>; q &lt;= Mm; q++)&#123;</span><br><span class=\"line\">                        d[i + <span class=\"number\">1</span>][j][k][l][q] = d[i][j][k][l][q];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(j &gt;= p[i] &amp;&amp; k &gt;= a[i] &amp;&amp; l &gt;= c[i] &amp;&amp; q &gt;= m[i])&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">int</span> tmp = v[i] + d[i][j - p[i]][k - a[i]][l - c[i]][q - m[i]];</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(tmp &gt; d[i + <span class=\"number\">1</span>][j][k][l][q]) &#123;</span><br><span class=\"line\">                                d[i + <span class=\"number\">1</span>][j][k][l][q] = tmp;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//记录路径部分</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[i + <span class=\"number\">1</span>][Pm][Am][Cm][Mm] != d[i][Pm][Am][Cm][Mm])&#123;</span><br><span class=\"line\">            used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            Pm -= p[i];</span><br><span class=\"line\">            Am -= a[i];</span><br><span class=\"line\">            Cm -= c[i];</span><br><span class=\"line\">            Mm -= m[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(used[i] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i]) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>数据d的类型要是short类型，int类型会爆内存，char类型会数据溢出．</p>\n<h2 id=\"背包记录路径问题总结\"><a href=\"#背包记录路径问题总结\" class=\"headerlink\" title=\"背包记录路径问题总结\"></a>背包记录路径问题总结</h2><h3 id=\"方法一核心代码\"><a href=\"#方法一核心代码\" class=\"headerlink\" title=\"方法一核心代码\"></a>方法一核心代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= W; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j &lt; w[i])&#123;</span><br><span class=\"line\">            d[i + <span class=\"number\">1</span>][j] = d[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            d[i + <span class=\"number\">1</span>][j] = max(d[i][j], d[i][j - w[i]] + v[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(d[i + <span class=\"number\">1</span>][W] != d[i][W])&#123;</span><br><span class=\"line\">        used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        W -= w[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二核心代码\"><a href=\"#方法二核心代码\" class=\"headerlink\" title=\"方法二核心代码\"></a>方法二核心代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= W; j++)&#123;</span><br><span class=\"line\">        d[i + <span class=\"number\">1</span>][j] = d[i][j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j &gt;= w[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = d[i][j - w[i]] + v[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp &gt; d[i + <span class=\"number\">1</span>][j])&#123;</span><br><span class=\"line\">                d[i + <span class=\"number\">1</span>][j] = tmp;</span><br><span class=\"line\">                path[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(path[i][W] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        used[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        W -= w[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva806-Spatial Structures-四分树","date":"2018-12-04T12:48:34.000Z","_content":"有幸做World Final的题，，做了一下午= =，刷新我的单题代码长度了，怕了怕了。\n黑白图像有两种表示方法，点阵表示和路径表示。路径表示法首先需要把图像转化为四分树，然后记录所有黑结点到根的路径。\n任务是在这两种表示法之间进行转换。\n<!--more-->\n\n## 链接\n[Uva806-Spatial Structures](https://vjudge.net/problem/UVA-806)\n\n## 题目描述\n中间图为点阵表示：\n![1](/1.png)\n四分树：\n![2](/2.png)\n四分树中NW，NE，SW，SE分别用1、2、3、4表示。其实它们的代表是把图像四分后的左上、右上、左下和右下部分。把得到的路径数字串看成是五进制的，转化为十进制后排序。例如上面的树在转化，排序后的结果是：9 14 17 22 23 44 63 69 88 94 113。\n要求给定一串数字路径还原点阵形式，或给定点阵写出所有黑结点的数字路径并排序输出。\n\n## 题解\n题目本身难度不是很大，只不过有很多细节需要注意。自己就被Presentation Error了好久= =。点阵转路径的时候，递归进行四分，如果子区域全白或全黑，跳出递归，边递归边统计路径，全黑时就把路径转成十进制存起来。路径转点阵的过程类似，可以用队列维护数字串，每取出一个就重新规划区域，直到队列为空，把当前区域全部涂黑。\n*除去输出格式的问题，还有一个需要注意的是，若初始图像全白，则路径用空串来表示，需要特殊处理，同时意味着读入路径数据的时候要用getline。*\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue  4 Dec 14:36:07 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 70;\nint n;\nchar d[maxn][maxn];\nint x, y;\nstack<int> rec;\nvector<int> ans;\nint cnt = 0;\n\nbool All_Black(int r, int c, int w){\n    for(int i = r; i < r + w; i++){\n        for(int j = c; j < c + w; j++){\n            if(d[i][j] == '0') return false;\n        }\n    }\n    return true;\n}\n\nbool All_White(int r, int c, int w){\n    for(int i = r; i < r + w; i++){\n        for(int j = c; j < c + w; j++){\n            if(d[i][j] == '1') return false;\n        }\n    }\n    return true;\n}\n\nvoid cal(){\n    int sum = 0;\n    stack<int> tmp = rec;\n    while(!tmp.empty()){\n        sum *= 5;\n        sum += tmp.top();\n        tmp.pop();\n    }\n    ans.push_back(sum);\n}\n\nvoid dfs(int r, int c, int w, stack<int>& rec){\n    //cout << r << \" \" << c << \" \" << w << endl;\n    if(All_Black(r, c, w)){\n        //cout << \"all black\" << endl;\n        cal();\n        return;\n    }\n    if(All_White(r, c, w)){\n        //cout << \"all white\" << endl;\n        return;\n    }\n    rec.push(1);\n    dfs(r, c, w / 2, rec);\n    rec.pop();\n    rec.push(2);\n    dfs(r, c + w / 2, w / 2, rec);\n    rec.pop();\n    rec.push(3);\n    dfs(r + w / 2, c, w / 2, rec);\n    rec.pop();\n    rec.push(4);\n    dfs(r + w / 2, c + w / 2, w / 2, rec);\n    rec.pop();\n} \n\nvoid solve1(){\n    for(int i = 0; i < n; i++){\n        scanf(\"%s\", d[i]);\n    }\n    while(!rec.empty()) rec.pop();\n    dfs(0, 0, n, rec);\n    sort(ans.begin(), ans.end());\n\n    printf(\"Image %d\\n\", cnt);\n    int len = ans.size();\n    for(int i = 0; i < len; i++){\n        if((i + 1) %12 == 1) printf(\"%d\", ans[i]);\n        else printf(\" %d\", ans[i]);\n\n        if((i + 1) % 12 == 0) printf(\"\\n\");\n    }\n    if((len % 12) != 0) printf(\"\\n\");\n    printf(\"Total number of black nodes = %d\\n\", len);\n}\n\nvoid draw(int r, int c, int w, queue<int>& que){\n    if(que.empty()){\n        for(int i = r; i < r + w; i++){\n            for(int j = c; j < c + w; j++){\n                d[i][j] = '*';\n            }\n        }\n        return;\n    }\n    int tmp = que.front();\n    que.pop();\n    if(tmp == 1) draw(r, c, w / 2, que);\n    if(tmp == 2) draw(r, c + w / 2, w / 2, que);\n    if(tmp == 3) draw(r + w / 2, c, w / 2, que);\n    if(tmp == 4) draw(r + w / 2, c + w / 2, w / 2, que); \n}\n\nvoid Print_White(){\n    printf(\"Image %d\\n\", cnt);\n    for(int i = 0; i < -n; i++){\n        for(int j = 0; j < -n; j++){\n            printf(\".\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid solve2(){\n    getchar();\n    int num;\n    queue<int> que;\n    stringstream ss1, ss2;\n    string s1, s2;\n    //fgets(s, 1000, stdin);\n    getline(cin, s1);\n    if(s1[0] == '\\n') {\n        Print_White();\n        return;\n    }\n\n    ss1.str(s1);\n    while(ss1 >> s2){\n        ss2.str(s2);\n        ss2 >> num;\n        ss2.clear();\n        if(num == -1) break;\n\n        while(!que.empty()) que.pop();\n\n        while(num){\n            que.push(num % 5);\n            num /= 5;\n        }\n        draw(0, 0, -n, que);\n    }\n\n    printf(\"Image %d\\n\", cnt);\n    for(int i = 0; i < -n; i++){\n        for(int j = 0; j < -n; j++){\n            if(d[i][j] != '*'){\n                d[i][j] = '.';\n            }\n            printf(\"%c\", d[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(1){\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n\n        memset(d, 0, sizeof(d));\n        ans.clear();\n\n        if(cnt > 0) printf(\"\\n\");\n        cnt++;\n        if(n > 0){\n            solve1();\n        }\n        if(n < 0){\n            solve2();\n        }\n    }\n    return 0;\n}\n```\n\n","source":"_posts/Uva806-Spatial-Structures.md","raw":"---\ntitle: Uva806-Spatial Structures-四分树\ndate: 2018-12-04 20:48:34\ncategories:\n- ACM\n- 树\ntags:\n- 四分树\n---\n有幸做World Final的题，，做了一下午= =，刷新我的单题代码长度了，怕了怕了。\n黑白图像有两种表示方法，点阵表示和路径表示。路径表示法首先需要把图像转化为四分树，然后记录所有黑结点到根的路径。\n任务是在这两种表示法之间进行转换。\n<!--more-->\n\n## 链接\n[Uva806-Spatial Structures](https://vjudge.net/problem/UVA-806)\n\n## 题目描述\n中间图为点阵表示：\n![1](/1.png)\n四分树：\n![2](/2.png)\n四分树中NW，NE，SW，SE分别用1、2、3、4表示。其实它们的代表是把图像四分后的左上、右上、左下和右下部分。把得到的路径数字串看成是五进制的，转化为十进制后排序。例如上面的树在转化，排序后的结果是：9 14 17 22 23 44 63 69 88 94 113。\n要求给定一串数字路径还原点阵形式，或给定点阵写出所有黑结点的数字路径并排序输出。\n\n## 题解\n题目本身难度不是很大，只不过有很多细节需要注意。自己就被Presentation Error了好久= =。点阵转路径的时候，递归进行四分，如果子区域全白或全黑，跳出递归，边递归边统计路径，全黑时就把路径转成十进制存起来。路径转点阵的过程类似，可以用队列维护数字串，每取出一个就重新规划区域，直到队列为空，把当前区域全部涂黑。\n*除去输出格式的问题，还有一个需要注意的是，若初始图像全白，则路径用空串来表示，需要特殊处理，同时意味着读入路径数据的时候要用getline。*\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue  4 Dec 14:36:07 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 70;\nint n;\nchar d[maxn][maxn];\nint x, y;\nstack<int> rec;\nvector<int> ans;\nint cnt = 0;\n\nbool All_Black(int r, int c, int w){\n    for(int i = r; i < r + w; i++){\n        for(int j = c; j < c + w; j++){\n            if(d[i][j] == '0') return false;\n        }\n    }\n    return true;\n}\n\nbool All_White(int r, int c, int w){\n    for(int i = r; i < r + w; i++){\n        for(int j = c; j < c + w; j++){\n            if(d[i][j] == '1') return false;\n        }\n    }\n    return true;\n}\n\nvoid cal(){\n    int sum = 0;\n    stack<int> tmp = rec;\n    while(!tmp.empty()){\n        sum *= 5;\n        sum += tmp.top();\n        tmp.pop();\n    }\n    ans.push_back(sum);\n}\n\nvoid dfs(int r, int c, int w, stack<int>& rec){\n    //cout << r << \" \" << c << \" \" << w << endl;\n    if(All_Black(r, c, w)){\n        //cout << \"all black\" << endl;\n        cal();\n        return;\n    }\n    if(All_White(r, c, w)){\n        //cout << \"all white\" << endl;\n        return;\n    }\n    rec.push(1);\n    dfs(r, c, w / 2, rec);\n    rec.pop();\n    rec.push(2);\n    dfs(r, c + w / 2, w / 2, rec);\n    rec.pop();\n    rec.push(3);\n    dfs(r + w / 2, c, w / 2, rec);\n    rec.pop();\n    rec.push(4);\n    dfs(r + w / 2, c + w / 2, w / 2, rec);\n    rec.pop();\n} \n\nvoid solve1(){\n    for(int i = 0; i < n; i++){\n        scanf(\"%s\", d[i]);\n    }\n    while(!rec.empty()) rec.pop();\n    dfs(0, 0, n, rec);\n    sort(ans.begin(), ans.end());\n\n    printf(\"Image %d\\n\", cnt);\n    int len = ans.size();\n    for(int i = 0; i < len; i++){\n        if((i + 1) %12 == 1) printf(\"%d\", ans[i]);\n        else printf(\" %d\", ans[i]);\n\n        if((i + 1) % 12 == 0) printf(\"\\n\");\n    }\n    if((len % 12) != 0) printf(\"\\n\");\n    printf(\"Total number of black nodes = %d\\n\", len);\n}\n\nvoid draw(int r, int c, int w, queue<int>& que){\n    if(que.empty()){\n        for(int i = r; i < r + w; i++){\n            for(int j = c; j < c + w; j++){\n                d[i][j] = '*';\n            }\n        }\n        return;\n    }\n    int tmp = que.front();\n    que.pop();\n    if(tmp == 1) draw(r, c, w / 2, que);\n    if(tmp == 2) draw(r, c + w / 2, w / 2, que);\n    if(tmp == 3) draw(r + w / 2, c, w / 2, que);\n    if(tmp == 4) draw(r + w / 2, c + w / 2, w / 2, que); \n}\n\nvoid Print_White(){\n    printf(\"Image %d\\n\", cnt);\n    for(int i = 0; i < -n; i++){\n        for(int j = 0; j < -n; j++){\n            printf(\".\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid solve2(){\n    getchar();\n    int num;\n    queue<int> que;\n    stringstream ss1, ss2;\n    string s1, s2;\n    //fgets(s, 1000, stdin);\n    getline(cin, s1);\n    if(s1[0] == '\\n') {\n        Print_White();\n        return;\n    }\n\n    ss1.str(s1);\n    while(ss1 >> s2){\n        ss2.str(s2);\n        ss2 >> num;\n        ss2.clear();\n        if(num == -1) break;\n\n        while(!que.empty()) que.pop();\n\n        while(num){\n            que.push(num % 5);\n            num /= 5;\n        }\n        draw(0, 0, -n, que);\n    }\n\n    printf(\"Image %d\\n\", cnt);\n    for(int i = 0; i < -n; i++){\n        for(int j = 0; j < -n; j++){\n            if(d[i][j] != '*'){\n                d[i][j] = '.';\n            }\n            printf(\"%c\", d[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(1){\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n\n        memset(d, 0, sizeof(d));\n        ans.clear();\n\n        if(cnt > 0) printf(\"\\n\");\n        cnt++;\n        if(n > 0){\n            solve1();\n        }\n        if(n < 0){\n            solve2();\n        }\n    }\n    return 0;\n}\n```\n\n","slug":"Uva806-Spatial-Structures","published":1,"updated":"2018-12-14T12:59:05.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrnq0037b8ouyjcg0wny","content":"<p>有幸做World Final的题，，做了一下午= =，刷新我的单题代码长度了，怕了怕了。<br>黑白图像有两种表示方法，点阵表示和路径表示。路径表示法首先需要把图像转化为四分树，然后记录所有黑结点到根的路径。<br>任务是在这两种表示法之间进行转换。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-806\" target=\"_blank\" rel=\"noopener\">Uva806-Spatial Structures</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>中间图为点阵表示：<br><img src=\"/2018/12/04/Uva806-Spatial-Structures/1.png\" alt=\"1\"><br>四分树：<br><img src=\"/2018/12/04/Uva806-Spatial-Structures/2.png\" alt=\"2\"><br>四分树中NW，NE，SW，SE分别用1、2、3、4表示。其实它们的代表是把图像四分后的左上、右上、左下和右下部分。把得到的路径数字串看成是五进制的，转化为十进制后排序。例如上面的树在转化，排序后的结果是：9 14 17 22 23 44 63 69 88 94 113。<br>要求给定一串数字路径还原点阵形式，或给定点阵写出所有黑结点的数字路径并排序输出。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目本身难度不是很大，只不过有很多细节需要注意。自己就被Presentation Error了好久= =。点阵转路径的时候，递归进行四分，如果子区域全白或全黑，跳出递归，边递归边统计路径，全黑时就把路径转成十进制存起来。路径转点阵的过程类似，可以用队列维护数字串，每取出一个就重新规划区域，直到队列为空，把当前区域全部涂黑。<br><em>除去输出格式的问题，还有一个需要注意的是，若初始图像全白，则路径用空串来表示，需要特殊处理，同时意味着读入路径数据的时候要用getline。</em></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue  4 Dec 14:36:07 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">70</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">char</span> d[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; rec;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">All_Black</span><span class=\"params\">(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = r; i &lt; r + w; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = c; j &lt; c + w; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[i][j] == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">All_White</span><span class=\"params\">(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = r; i &lt; r + w; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = c; j &lt; c + w; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[i][j] == <span class=\"string\">'1'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cal</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; tmp = rec;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!tmp.empty())&#123;</span><br><span class=\"line\">        sum *= <span class=\"number\">5</span>;</span><br><span class=\"line\">        sum += tmp.top();</span><br><span class=\"line\">        tmp.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans.push_back(sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> w, <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; rec)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; r &lt;&lt; \" \" &lt;&lt; c &lt;&lt; \" \" &lt;&lt; w &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(All_Black(r, c, w))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; \"all black\" &lt;&lt; endl;</span></span><br><span class=\"line\">        cal();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(All_White(r, c, w))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; \"all white\" &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rec.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">    dfs(r, c, w / <span class=\"number\">2</span>, rec);</span><br><span class=\"line\">    rec.pop();</span><br><span class=\"line\">    rec.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">    dfs(r, c + w / <span class=\"number\">2</span>, w / <span class=\"number\">2</span>, rec);</span><br><span class=\"line\">    rec.pop();</span><br><span class=\"line\">    rec.push(<span class=\"number\">3</span>);</span><br><span class=\"line\">    dfs(r + w / <span class=\"number\">2</span>, c, w / <span class=\"number\">2</span>, rec);</span><br><span class=\"line\">    rec.pop();</span><br><span class=\"line\">    rec.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">    dfs(r + w / <span class=\"number\">2</span>, c + w / <span class=\"number\">2</span>, w / <span class=\"number\">2</span>, rec);</span><br><span class=\"line\">    rec.pop();</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, d[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!rec.empty()) rec.pop();</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>, n, rec);</span><br><span class=\"line\">    sort(ans.begin(), ans.end());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Image %d\\n\"</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = ans.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((i + <span class=\"number\">1</span>) %<span class=\"number\">12</span> == <span class=\"number\">1</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, ans[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>, ans[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((i + <span class=\"number\">1</span>) % <span class=\"number\">12</span> == <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((len % <span class=\"number\">12</span>) != <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Total number of black nodes = %d\\n\"</span>, len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> w, <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; que)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(que.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = r; i &lt; r + w; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = c; j &lt; c + w; j++)&#123;</span><br><span class=\"line\">                d[i][j] = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = que.front();</span><br><span class=\"line\">    que.pop();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp == <span class=\"number\">1</span>) draw(r, c, w / <span class=\"number\">2</span>, que);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp == <span class=\"number\">2</span>) draw(r, c + w / <span class=\"number\">2</span>, w / <span class=\"number\">2</span>, que);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp == <span class=\"number\">3</span>) draw(r + w / <span class=\"number\">2</span>, c, w / <span class=\"number\">2</span>, que);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp == <span class=\"number\">4</span>) draw(r + w / <span class=\"number\">2</span>, c + w / <span class=\"number\">2</span>, w / <span class=\"number\">2</span>, que); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print_White</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Image %d\\n\"</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; -n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; -n; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    getchar();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; que;</span><br><span class=\"line\">    <span class=\"built_in\">stringstream</span> ss1, ss2;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s1, s2;</span><br><span class=\"line\">    <span class=\"comment\">//fgets(s, 1000, stdin);</span></span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, s1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s1[<span class=\"number\">0</span>] == <span class=\"string\">'\\n'</span>) &#123;</span><br><span class=\"line\">        Print_White();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ss1.str(s1);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss1 &gt;&gt; s2)&#123;</span><br><span class=\"line\">        ss2.str(s2);</span><br><span class=\"line\">        ss2 &gt;&gt; num;</span><br><span class=\"line\">        ss2.clear();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"number\">-1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que.empty()) que.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num)&#123;</span><br><span class=\"line\">            que.push(num % <span class=\"number\">5</span>);</span><br><span class=\"line\">            num /= <span class=\"number\">5</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        draw(<span class=\"number\">0</span>, <span class=\"number\">0</span>, -n, que);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Image %d\\n\"</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; -n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; -n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[i][j] != <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                d[i][j] = <span class=\"string\">'.'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, d[i][j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">        ans.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            solve1();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            solve2();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>有幸做World Final的题，，做了一下午= =，刷新我的单题代码长度了，怕了怕了。<br>黑白图像有两种表示方法，点阵表示和路径表示。路径表示法首先需要把图像转化为四分树，然后记录所有黑结点到根的路径。<br>任务是在这两种表示法之间进行转换。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-806\" target=\"_blank\" rel=\"noopener\">Uva806-Spatial Structures</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>中间图为点阵表示：<br><img src=\"/2018/12/04/Uva806-Spatial-Structures/1.png\" alt=\"1\"><br>四分树：<br><img src=\"/2018/12/04/Uva806-Spatial-Structures/2.png\" alt=\"2\"><br>四分树中NW，NE，SW，SE分别用1、2、3、4表示。其实它们的代表是把图像四分后的左上、右上、左下和右下部分。把得到的路径数字串看成是五进制的，转化为十进制后排序。例如上面的树在转化，排序后的结果是：9 14 17 22 23 44 63 69 88 94 113。<br>要求给定一串数字路径还原点阵形式，或给定点阵写出所有黑结点的数字路径并排序输出。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目本身难度不是很大，只不过有很多细节需要注意。自己就被Presentation Error了好久= =。点阵转路径的时候，递归进行四分，如果子区域全白或全黑，跳出递归，边递归边统计路径，全黑时就把路径转成十进制存起来。路径转点阵的过程类似，可以用队列维护数字串，每取出一个就重新规划区域，直到队列为空，把当前区域全部涂黑。<br><em>除去输出格式的问题，还有一个需要注意的是，若初始图像全白，则路径用空串来表示，需要特殊处理，同时意味着读入路径数据的时候要用getline。</em></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue  4 Dec 14:36:07 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">70</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">char</span> d[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; rec;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">All_Black</span><span class=\"params\">(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = r; i &lt; r + w; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = c; j &lt; c + w; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[i][j] == <span class=\"string\">'0'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">All_White</span><span class=\"params\">(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = r; i &lt; r + w; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = c; j &lt; c + w; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[i][j] == <span class=\"string\">'1'</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cal</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; tmp = rec;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!tmp.empty())&#123;</span><br><span class=\"line\">        sum *= <span class=\"number\">5</span>;</span><br><span class=\"line\">        sum += tmp.top();</span><br><span class=\"line\">        tmp.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans.push_back(sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> w, <span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; rec)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; r &lt;&lt; \" \" &lt;&lt; c &lt;&lt; \" \" &lt;&lt; w &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(All_Black(r, c, w))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; \"all black\" &lt;&lt; endl;</span></span><br><span class=\"line\">        cal();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(All_White(r, c, w))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; \"all white\" &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rec.push(<span class=\"number\">1</span>);</span><br><span class=\"line\">    dfs(r, c, w / <span class=\"number\">2</span>, rec);</span><br><span class=\"line\">    rec.pop();</span><br><span class=\"line\">    rec.push(<span class=\"number\">2</span>);</span><br><span class=\"line\">    dfs(r, c + w / <span class=\"number\">2</span>, w / <span class=\"number\">2</span>, rec);</span><br><span class=\"line\">    rec.pop();</span><br><span class=\"line\">    rec.push(<span class=\"number\">3</span>);</span><br><span class=\"line\">    dfs(r + w / <span class=\"number\">2</span>, c, w / <span class=\"number\">2</span>, rec);</span><br><span class=\"line\">    rec.pop();</span><br><span class=\"line\">    rec.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">    dfs(r + w / <span class=\"number\">2</span>, c + w / <span class=\"number\">2</span>, w / <span class=\"number\">2</span>, rec);</span><br><span class=\"line\">    rec.pop();</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, d[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!rec.empty()) rec.pop();</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>, n, rec);</span><br><span class=\"line\">    sort(ans.begin(), ans.end());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Image %d\\n\"</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = ans.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((i + <span class=\"number\">1</span>) %<span class=\"number\">12</span> == <span class=\"number\">1</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, ans[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\" %d\"</span>, ans[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((i + <span class=\"number\">1</span>) % <span class=\"number\">12</span> == <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((len % <span class=\"number\">12</span>) != <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Total number of black nodes = %d\\n\"</span>, len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> w, <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; que)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(que.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = r; i &lt; r + w; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = c; j &lt; c + w; j++)&#123;</span><br><span class=\"line\">                d[i][j] = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = que.front();</span><br><span class=\"line\">    que.pop();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp == <span class=\"number\">1</span>) draw(r, c, w / <span class=\"number\">2</span>, que);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp == <span class=\"number\">2</span>) draw(r, c + w / <span class=\"number\">2</span>, w / <span class=\"number\">2</span>, que);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp == <span class=\"number\">3</span>) draw(r + w / <span class=\"number\">2</span>, c, w / <span class=\"number\">2</span>, que);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tmp == <span class=\"number\">4</span>) draw(r + w / <span class=\"number\">2</span>, c + w / <span class=\"number\">2</span>, w / <span class=\"number\">2</span>, que); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print_White</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Image %d\\n\"</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; -n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; -n; j++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    getchar();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; que;</span><br><span class=\"line\">    <span class=\"built_in\">stringstream</span> ss1, ss2;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s1, s2;</span><br><span class=\"line\">    <span class=\"comment\">//fgets(s, 1000, stdin);</span></span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, s1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s1[<span class=\"number\">0</span>] == <span class=\"string\">'\\n'</span>) &#123;</span><br><span class=\"line\">        Print_White();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ss1.str(s1);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss1 &gt;&gt; s2)&#123;</span><br><span class=\"line\">        ss2.str(s2);</span><br><span class=\"line\">        ss2 &gt;&gt; num;</span><br><span class=\"line\">        ss2.clear();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"number\">-1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que.empty()) que.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num)&#123;</span><br><span class=\"line\">            que.push(num % <span class=\"number\">5</span>);</span><br><span class=\"line\">            num /= <span class=\"number\">5</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        draw(<span class=\"number\">0</span>, <span class=\"number\">0</span>, -n, que);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Image %d\\n\"</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; -n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; -n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d[i][j] != <span class=\"string\">'*'</span>)&#123;</span><br><span class=\"line\">                d[i][j] = <span class=\"string\">'.'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%c\"</span>, d[i][j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;n);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(d, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(d));</span><br><span class=\"line\">        ans.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            solve1();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            solve2();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva816-Abbott's Revenge-BFS","date":"2018-11-01T08:18:17.000Z","_content":"一道比较别致的BFS搜索题，题目规定了在迷宫里沿特定方向到达某点后只能再沿特定一个或几个方向继续前进，而不是平常的任意四个方向都可以前进。\n在输出格式上WA了很久，，什么时候我才能“Bug Free”啊，哭QAQ\n<!--more-->\n## 链接\n[Uva816-Abbott's Revenge](https://vjudge.net/problem/UVA-816)\n## 题目描述\n迷宫找最短路径问题，不同于以往的障碍物形式，题目规定沿某一方向进入节点（东，南，西，北）之后只能按照给定的方向离开该节点（前进，左转，右转）。给定起点和终点，要求输出最短路径。\n## 题解\n带方向的BFS，在构建地图的时候添加上方向和转向两个维度。在更新节点距离和记录路径的时候加上方向维度。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed 31 Oct 07:40:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10, dir = 4, turn = 3;\nchar dirs[] = \"NESW\", turns[] = \"FLR\";\nint mp[maxn][maxn][dir][turn];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\nint dis[maxn][maxn][dir];\nstruct Node{\n    int x;\n    int y;\n    int dir;\n    Node(){}\n    Node(int xx, int yy, int ddir): x(xx), y(yy), dir(ddir){}\n};\nNode path[maxn][maxn][dir];\nint stx, sty, edx, edy;\nchar stdir;\n\nint finddir(char c){\n    return strchr(dirs, c) - dirs;\n}\n\nint findturn(char c){\n    return strchr(turns, c) - turns;\n}\n\n\nvoid read(){\n    int x, y, dr, tr;\n    string s;\n    while(1){\n        cin >> x;\n        if(x == 0) break;\n        cin >> y;\n        for(;;){\n            cin >> s;\n            //cout << s << endl;\n            if(s == \"*\") break;\n            dr = finddir(s[0]);\n            //cout << dr << endl;\n            for(size_t i = 1; i < s.length(); i++){\n                tr = findturn(s[i]);\n                //cout << tr << endl;\n                mp[x][y][dr][tr] = 1;\n            }\n        }\n    }\n}\n\nbool inside(int x, int y){\n    if(x >= 1 && x <= 9 && y >= 1 && y <= 9) return true;\n    else return false;\n}\n\nint trans(int turn, int dir){\n    if(turn == 0) return dir;\n    else if(turn == 1) return (dir + 3) % 4;\n    else return (dir + 1) % 4;\n}\n\nvoid print(Node node){\n    //cout << \"GodBlessMe!\" << endl;\n    vector<Node> vec;\n    vec.push_back(node);\n    Node nd;\n    while(1){\n        nd = path[node.x][node.y][node.dir];\n        if(nd.x == -1) break;\n        vec.push_back(nd);\n        node = nd;\n    }\n    vec.push_back(Node(stx, sty, finddir(stdir)));\n    reverse(vec.begin(), vec.end());\n    \n    int cnt = 0;\n    for(auto x : vec){\n        if(cnt % 10 == 0) cout << \" \";\n        cout << \" (\" << x.x << \",\" << x.y << \")\";\n        if(++cnt % 10 == 0) cout << \"\\n\";\n    }\n    if(vec.size() % 10 != 0) cout << endl;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    string s;\n    bool ok;\n    while(cin >> s){\n        if(s == \"END\") break;\n        memset(mp, 0, sizeof(mp));\n        memset(dis, -1, sizeof(dis));\n        memset(path, -1, sizeof(path));\n        ok = false;\n        \n        cin >> stx >> sty >> stdir >> edx >> edy;\n        read();\n        queue<Node> que;\n        Node node;\n        int num = finddir(stdir);\n        node.x = stx + dx[num], node.y = sty + dy[num], node.dir = num;\n        que.push(node);\n        dis[node.x][node.y][node.dir] = 0;\n        while(!que.empty()){\n            Node nd = que.front();\n            if(nd.x == edx && nd.y == edy){\n                ok = true;\n                break;\n            }\n            que.pop();\n            for(int i = 0; i < 3; i++){\n                int k = trans(i, nd.dir);\n                int nx = nd.x + dx[k], ny = nd.y + dy[k];\n                if(mp[nd.x][nd.y][nd.dir][i] && inside(nx, ny) && dis[nx][ny][k] == -1){\n                    dis[nx][ny][k] = dis[nd.x][nd.y][nd.dir] + 1;\n                    que.push(Node(nx, ny, k));\n                    path[nx][ny][k] = nd;\n                }\n            }\n        }\n        cout << s << endl;\n        if(ok) print(que.front());\n        else cout << \"  No Solution Possible\" << endl;\n    }\n    \n    return 0;\n}\n```","source":"_posts/Uva816-Abbott-s-Revenge-BFS.md","raw":"---\ntitle: Uva816-Abbott's Revenge-BFS\ndate: 2018-11-01 16:18:17\ncategories:\n- ACM\n- BFS\ntags:\n- BFS\n---\n一道比较别致的BFS搜索题，题目规定了在迷宫里沿特定方向到达某点后只能再沿特定一个或几个方向继续前进，而不是平常的任意四个方向都可以前进。\n在输出格式上WA了很久，，什么时候我才能“Bug Free”啊，哭QAQ\n<!--more-->\n## 链接\n[Uva816-Abbott's Revenge](https://vjudge.net/problem/UVA-816)\n## 题目描述\n迷宫找最短路径问题，不同于以往的障碍物形式，题目规定沿某一方向进入节点（东，南，西，北）之后只能按照给定的方向离开该节点（前进，左转，右转）。给定起点和终点，要求输出最短路径。\n## 题解\n带方向的BFS，在构建地图的时候添加上方向和转向两个维度。在更新节点距离和记录路径的时候加上方向维度。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Wed 31 Oct 07:40:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 10, dir = 4, turn = 3;\nchar dirs[] = \"NESW\", turns[] = \"FLR\";\nint mp[maxn][maxn][dir][turn];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\nint dis[maxn][maxn][dir];\nstruct Node{\n    int x;\n    int y;\n    int dir;\n    Node(){}\n    Node(int xx, int yy, int ddir): x(xx), y(yy), dir(ddir){}\n};\nNode path[maxn][maxn][dir];\nint stx, sty, edx, edy;\nchar stdir;\n\nint finddir(char c){\n    return strchr(dirs, c) - dirs;\n}\n\nint findturn(char c){\n    return strchr(turns, c) - turns;\n}\n\n\nvoid read(){\n    int x, y, dr, tr;\n    string s;\n    while(1){\n        cin >> x;\n        if(x == 0) break;\n        cin >> y;\n        for(;;){\n            cin >> s;\n            //cout << s << endl;\n            if(s == \"*\") break;\n            dr = finddir(s[0]);\n            //cout << dr << endl;\n            for(size_t i = 1; i < s.length(); i++){\n                tr = findturn(s[i]);\n                //cout << tr << endl;\n                mp[x][y][dr][tr] = 1;\n            }\n        }\n    }\n}\n\nbool inside(int x, int y){\n    if(x >= 1 && x <= 9 && y >= 1 && y <= 9) return true;\n    else return false;\n}\n\nint trans(int turn, int dir){\n    if(turn == 0) return dir;\n    else if(turn == 1) return (dir + 3) % 4;\n    else return (dir + 1) % 4;\n}\n\nvoid print(Node node){\n    //cout << \"GodBlessMe!\" << endl;\n    vector<Node> vec;\n    vec.push_back(node);\n    Node nd;\n    while(1){\n        nd = path[node.x][node.y][node.dir];\n        if(nd.x == -1) break;\n        vec.push_back(nd);\n        node = nd;\n    }\n    vec.push_back(Node(stx, sty, finddir(stdir)));\n    reverse(vec.begin(), vec.end());\n    \n    int cnt = 0;\n    for(auto x : vec){\n        if(cnt % 10 == 0) cout << \" \";\n        cout << \" (\" << x.x << \",\" << x.y << \")\";\n        if(++cnt % 10 == 0) cout << \"\\n\";\n    }\n    if(vec.size() % 10 != 0) cout << endl;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    string s;\n    bool ok;\n    while(cin >> s){\n        if(s == \"END\") break;\n        memset(mp, 0, sizeof(mp));\n        memset(dis, -1, sizeof(dis));\n        memset(path, -1, sizeof(path));\n        ok = false;\n        \n        cin >> stx >> sty >> stdir >> edx >> edy;\n        read();\n        queue<Node> que;\n        Node node;\n        int num = finddir(stdir);\n        node.x = stx + dx[num], node.y = sty + dy[num], node.dir = num;\n        que.push(node);\n        dis[node.x][node.y][node.dir] = 0;\n        while(!que.empty()){\n            Node nd = que.front();\n            if(nd.x == edx && nd.y == edy){\n                ok = true;\n                break;\n            }\n            que.pop();\n            for(int i = 0; i < 3; i++){\n                int k = trans(i, nd.dir);\n                int nx = nd.x + dx[k], ny = nd.y + dy[k];\n                if(mp[nd.x][nd.y][nd.dir][i] && inside(nx, ny) && dis[nx][ny][k] == -1){\n                    dis[nx][ny][k] = dis[nd.x][nd.y][nd.dir] + 1;\n                    que.push(Node(nx, ny, k));\n                    path[nx][ny][k] = nd;\n                }\n            }\n        }\n        cout << s << endl;\n        if(ok) print(que.front());\n        else cout << \"  No Solution Possible\" << endl;\n    }\n    \n    return 0;\n}\n```","slug":"Uva816-Abbott-s-Revenge-BFS","published":1,"updated":"2018-12-14T13:04:02.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrns003bb8ougi22v46a","content":"<p>一道比较别致的BFS搜索题，题目规定了在迷宫里沿特定方向到达某点后只能再沿特定一个或几个方向继续前进，而不是平常的任意四个方向都可以前进。<br>在输出格式上WA了很久，，什么时候我才能“Bug Free”啊，哭QAQ<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-816\" target=\"_blank\" rel=\"noopener\">Uva816-Abbott’s Revenge</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>迷宫找最短路径问题，不同于以往的障碍物形式，题目规定沿某一方向进入节点（东，南，西，北）之后只能按照给定的方向离开该节点（前进，左转，右转）。给定起点和终点，要求输出最短路径。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>带方向的BFS，在构建地图的时候添加上方向和转向两个维度。在更新节点距离和记录路径的时候加上方向维度。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Wed 31 Oct 07:40:43 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">10</span>, dir = <span class=\"number\">4</span>, turn = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> dirs[] = <span class=\"string\">\"NESW\"</span>, turns[] = <span class=\"string\">\"FLR\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> mp[maxn][maxn][dir][turn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxn][maxn][dir];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> dir;</span><br><span class=\"line\">    Node()&#123;&#125;</span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> xx, <span class=\"keyword\">int</span> yy, <span class=\"keyword\">int</span> ddir): x(xx), y(yy), dir(ddir)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Node path[maxn][maxn][dir];</span><br><span class=\"line\"><span class=\"keyword\">int</span> stx, sty, edx, edy;</span><br><span class=\"line\"><span class=\"keyword\">char</span> stdir;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">finddir</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strchr</span>(dirs, c) - dirs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findturn</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strchr</span>(turns, c) - turns;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y, dr, tr;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; y;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s == <span class=\"string\">\"*\"</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            dr = finddir(s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; dr &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class=\"line\">                tr = findturn(s[i]);</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; tr &lt;&lt; endl;</span></span><br><span class=\"line\">                mp[x][y][dr][tr] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">inside</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &gt;= <span class=\"number\">1</span> &amp;&amp; x &lt;= <span class=\"number\">9</span> &amp;&amp; y &gt;= <span class=\"number\">1</span> &amp;&amp; y &lt;= <span class=\"number\">9</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">trans</span><span class=\"params\">(<span class=\"keyword\">int</span> turn, <span class=\"keyword\">int</span> dir)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(turn == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> dir;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(turn == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> (dir + <span class=\"number\">3</span>) % <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> (dir + <span class=\"number\">1</span>) % <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(Node node)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; \"GodBlessMe!\" &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Node&gt; vec;</span><br><span class=\"line\">    vec.push_back(node);</span><br><span class=\"line\">    Node nd;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        nd = path[node.x][node.y][node.dir];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nd.x == <span class=\"number\">-1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        vec.push_back(nd);</span><br><span class=\"line\">        node = nd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vec.push_back(Node(stx, sty, finddir(stdir)));</span><br><span class=\"line\">    reverse(vec.begin(), vec.end());</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : vec)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt % <span class=\"number\">10</span> == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" (\"</span> &lt;&lt; x.x &lt;&lt; <span class=\"string\">\",\"</span> &lt;&lt; x.y &lt;&lt; <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(++cnt % <span class=\"number\">10</span> == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vec.size() % <span class=\"number\">10</span> != <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ok;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; s)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s == <span class=\"string\">\"END\"</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(mp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mp));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dis, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(path, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(path));</span><br><span class=\"line\">        ok = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; stx &gt;&gt; sty &gt;&gt; stdir &gt;&gt; edx &gt;&gt; edy;</span><br><span class=\"line\">        read();</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;Node&gt; que;</span><br><span class=\"line\">        Node node;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = finddir(stdir);</span><br><span class=\"line\">        node.x = stx + dx[num], node.y = sty + dy[num], node.dir = num;</span><br><span class=\"line\">        que.push(node);</span><br><span class=\"line\">        dis[node.x][node.y][node.dir] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">            Node nd = que.front();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nd.x == edx &amp;&amp; nd.y == edy)&#123;</span><br><span class=\"line\">                ok = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            que.pop();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> k = trans(i, nd.dir);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nx = nd.x + dx[k], ny = nd.y + dy[k];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mp[nd.x][nd.y][nd.dir][i] &amp;&amp; inside(nx, ny) &amp;&amp; dis[nx][ny][k] == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                    dis[nx][ny][k] = dis[nd.x][nd.y][nd.dir] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    que.push(Node(nx, ny, k));</span><br><span class=\"line\">                    path[nx][ny][k] = nd;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; s &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ok) print(que.front());</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"  No Solution Possible\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>一道比较别致的BFS搜索题，题目规定了在迷宫里沿特定方向到达某点后只能再沿特定一个或几个方向继续前进，而不是平常的任意四个方向都可以前进。<br>在输出格式上WA了很久，，什么时候我才能“Bug Free”啊，哭QAQ<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-816\" target=\"_blank\" rel=\"noopener\">Uva816-Abbott’s Revenge</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>迷宫找最短路径问题，不同于以往的障碍物形式，题目规定沿某一方向进入节点（东，南，西，北）之后只能按照给定的方向离开该节点（前进，左转，右转）。给定起点和终点，要求输出最短路径。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>带方向的BFS，在构建地图的时候添加上方向和转向两个维度。在更新节点距离和记录路径的时候加上方向维度。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Wed 31 Oct 07:40:43 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">10</span>, dir = <span class=\"number\">4</span>, turn = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> dirs[] = <span class=\"string\">\"NESW\"</span>, turns[] = <span class=\"string\">\"FLR\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> mp[maxn][maxn][dir][turn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dx[] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxn][maxn][dir];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> dir;</span><br><span class=\"line\">    Node()&#123;&#125;</span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> xx, <span class=\"keyword\">int</span> yy, <span class=\"keyword\">int</span> ddir): x(xx), y(yy), dir(ddir)&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Node path[maxn][maxn][dir];</span><br><span class=\"line\"><span class=\"keyword\">int</span> stx, sty, edx, edy;</span><br><span class=\"line\"><span class=\"keyword\">char</span> stdir;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">finddir</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strchr</span>(dirs, c) - dirs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findturn</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">strchr</span>(turns, c) - turns;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y, dr, tr;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; y;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; s;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s == <span class=\"string\">\"*\"</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            dr = finddir(s[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; dr &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class=\"line\">                tr = findturn(s[i]);</span><br><span class=\"line\">                <span class=\"comment\">//cout &lt;&lt; tr &lt;&lt; endl;</span></span><br><span class=\"line\">                mp[x][y][dr][tr] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">inside</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &gt;= <span class=\"number\">1</span> &amp;&amp; x &lt;= <span class=\"number\">9</span> &amp;&amp; y &gt;= <span class=\"number\">1</span> &amp;&amp; y &lt;= <span class=\"number\">9</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">trans</span><span class=\"params\">(<span class=\"keyword\">int</span> turn, <span class=\"keyword\">int</span> dir)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(turn == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> dir;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(turn == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> (dir + <span class=\"number\">3</span>) % <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> (dir + <span class=\"number\">1</span>) % <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(Node node)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//cout &lt;&lt; \"GodBlessMe!\" &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;Node&gt; vec;</span><br><span class=\"line\">    vec.push_back(node);</span><br><span class=\"line\">    Node nd;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        nd = path[node.x][node.y][node.dir];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nd.x == <span class=\"number\">-1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        vec.push_back(nd);</span><br><span class=\"line\">        node = nd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vec.push_back(Node(stx, sty, finddir(stdir)));</span><br><span class=\"line\">    reverse(vec.begin(), vec.end());</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : vec)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt % <span class=\"number\">10</span> == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" (\"</span> &lt;&lt; x.x &lt;&lt; <span class=\"string\">\",\"</span> &lt;&lt; x.y &lt;&lt; <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(++cnt % <span class=\"number\">10</span> == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vec.size() % <span class=\"number\">10</span> != <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ok;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; s)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s == <span class=\"string\">\"END\"</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(mp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mp));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dis, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(path, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(path));</span><br><span class=\"line\">        ok = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; stx &gt;&gt; sty &gt;&gt; stdir &gt;&gt; edx &gt;&gt; edy;</span><br><span class=\"line\">        read();</span><br><span class=\"line\">        <span class=\"built_in\">queue</span>&lt;Node&gt; que;</span><br><span class=\"line\">        Node node;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = finddir(stdir);</span><br><span class=\"line\">        node.x = stx + dx[num], node.y = sty + dy[num], node.dir = num;</span><br><span class=\"line\">        que.push(node);</span><br><span class=\"line\">        dis[node.x][node.y][node.dir] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">            Node nd = que.front();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nd.x == edx &amp;&amp; nd.y == edy)&#123;</span><br><span class=\"line\">                ok = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            que.pop();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> k = trans(i, nd.dir);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nx = nd.x + dx[k], ny = nd.y + dy[k];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mp[nd.x][nd.y][nd.dir][i] &amp;&amp; inside(nx, ny) &amp;&amp; dis[nx][ny][k] == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                    dis[nx][ny][k] = dis[nd.x][nd.y][nd.dir] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    que.push(Node(nx, ny, k));</span><br><span class=\"line\">                    path[nx][ny][k] = nd;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; s &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ok) print(que.front());</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"  No Solution Possible\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva839-二叉树的递归处理","date":"2018-09-22T14:53:32.000Z","_content":"输入一个树状天平，根据力矩相等原则判断是否平衡。即判断是否满足$W_lD_l=W_rD_r$。\n![example](/tree.png)\n<!--more-->\n## 链接\n[Uva839-Not so Mobile](https://vjudge.net/problem/UVA-839)\n## 题目描述\n题目输入采用递归（先序）方式：每个天平的格式为$W_l$，$D_l$，$W_r$，$D_r$，当$W_l$或$W_r$为$0$时，表示该“砝码”实际是一个子天平，接下来会进一步描述这个子天平。当$W_l=W_r=0$时，会先描述左子天平，然后是右子天平。\n## 题解\n因为题目的输入就采取了递归方式定义，所以编写一个递归过程读取输入同时进行处理比较合适。在递归的过程中判断子天平是否满足平衡并自下向上不断的更新$W$为$0$的节点（更新为其左子砝码重量$W_l$和右子砝码重量$W_r$之和）。可以定义一个标志变量来标明整个过程是否一直都满足平衡条件。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 22 Sep 22:02:34 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nbool f;\n\nint solve(){\n    int w1, d1, w2, d2;\n    cin >> w1 >> d1 >> w2 >> d2;\n    if(!w1) w1 = solve();\n    if(!w2) w2 = solve();\n    if(w1 * d1 != w2 * d2) f = false;\n    return w1 + w2;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        f = true;\n        solve();\n        if(f) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        if(t) cout << endl;\n    }\n    \n    return 0;\n}\n```","source":"_posts/Uva839-二叉树的递归处理.md","raw":"---\ntitle: Uva839-二叉树的递归处理\ndate: 2018-09-22 22:53:32\ncategories:\n- ACM\n- 树\ntags:\n- 二叉树\n- DFS\n---\n输入一个树状天平，根据力矩相等原则判断是否平衡。即判断是否满足$W_lD_l=W_rD_r$。\n![example](/tree.png)\n<!--more-->\n## 链接\n[Uva839-Not so Mobile](https://vjudge.net/problem/UVA-839)\n## 题目描述\n题目输入采用递归（先序）方式：每个天平的格式为$W_l$，$D_l$，$W_r$，$D_r$，当$W_l$或$W_r$为$0$时，表示该“砝码”实际是一个子天平，接下来会进一步描述这个子天平。当$W_l=W_r=0$时，会先描述左子天平，然后是右子天平。\n## 题解\n因为题目的输入就采取了递归方式定义，所以编写一个递归过程读取输入同时进行处理比较合适。在递归的过程中判断子天平是否满足平衡并自下向上不断的更新$W$为$0$的节点（更新为其左子砝码重量$W_l$和右子砝码重量$W_r$之和）。可以定义一个标志变量来标明整个过程是否一直都满足平衡条件。\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 22 Sep 22:02:34 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t;\nbool f;\n\nint solve(){\n    int w1, d1, w2, d2;\n    cin >> w1 >> d1 >> w2 >> d2;\n    if(!w1) w1 = solve();\n    if(!w2) w2 = solve();\n    if(w1 * d1 != w2 * d2) f = false;\n    return w1 + w2;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    cin >> t;\n    while(t--){\n        f = true;\n        solve();\n        if(f) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        if(t) cout << endl;\n    }\n    \n    return 0;\n}\n```","slug":"Uva839-二叉树的递归处理","published":1,"updated":"2018-12-14T13:04:59.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrnv003fb8ou7twenwm5","content":"<p>输入一个树状天平，根据力矩相等原则判断是否平衡。即判断是否满足$W_lD_l=W_rD_r$。<br><img src=\"/2018/09/22/Uva839-二叉树的递归处理/tree.png\" alt=\"example\"><br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-839\" target=\"_blank\" rel=\"noopener\">Uva839-Not so Mobile</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>题目输入采用递归（先序）方式：每个天平的格式为$W_l$，$D_l$，$W_r$，$D_r$，当$W_l$或$W_r$为$0$时，表示该“砝码”实际是一个子天平，接下来会进一步描述这个子天平。当$W_l=W_r=0$时，会先描述左子天平，然后是右子天平。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为题目的输入就采取了递归方式定义，所以编写一个递归过程读取输入同时进行处理比较合适。在递归的过程中判断子天平是否满足平衡并自下向上不断的更新$W$为$0$的节点（更新为其左子砝码重量$W_l$和右子砝码重量$W_r$之和）。可以定义一个标志变量来标明整个过程是否一直都满足平衡条件。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 22 Sep 22:02:34 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> f;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> w1, d1, w2, d2;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; w1 &gt;&gt; d1 &gt;&gt; w2 &gt;&gt; d2;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!w1) w1 = solve();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!w2) w2 = solve();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(w1 * d1 != w2 * d2) f = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> w1 + w2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        f = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"YES\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"NO\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>输入一个树状天平，根据力矩相等原则判断是否平衡。即判断是否满足$W_lD_l=W_rD_r$。<br><img src=\"/2018/09/22/Uva839-二叉树的递归处理/tree.png\" alt=\"example\"><br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-839\" target=\"_blank\" rel=\"noopener\">Uva839-Not so Mobile</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>题目输入采用递归（先序）方式：每个天平的格式为$W_l$，$D_l$，$W_r$，$D_r$，当$W_l$或$W_r$为$0$时，表示该“砝码”实际是一个子天平，接下来会进一步描述这个子天平。当$W_l=W_r=0$时，会先描述左子天平，然后是右子天平。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为题目的输入就采取了递归方式定义，所以编写一个递归过程读取输入同时进行处理比较合适。在递归的过程中判断子天平是否满足平衡并自下向上不断的更新$W$为$0$的节点（更新为其左子砝码重量$W_l$和右子砝码重量$W_r$之和）。可以定义一个标志变量来标明整个过程是否一直都满足平衡条件。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 22 Sep 22:02:34 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> f;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> w1, d1, w2, d2;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; w1 &gt;&gt; d1 &gt;&gt; w2 &gt;&gt; d2;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!w1) w1 = solve();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!w2) w2 = solve();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(w1 * d1 != w2 * d2) f = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> w1 + w2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        f = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        solve();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"YES\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"NO\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"extern-外部变量","date":"2018-12-02T22:56:26.000Z","_content":"前两天被同学问起extern的用法，才发现自己对extern的用法也不清晰，囧，整理一下。\n<!--more-->\n## 参考链接\n[when to use extern in C++](https://stackoverflow.com/questions/10422034/when-to-use-extern-in-c)\n\n## extern\nextern用于多文件编程时，不同源文件之间共享变量。我们在头文件中声明外部变量，这样所有包含该头文件的的源文件就都有了这个外部变量的**声明**，而我们只需要在**其中一个**源文件中**定义**一次。\n\n``extern int x``告诉编译器有一个叫``x``的``int``型变量在某个地方，正如之前[C语言编译连接过程](https://ain-crad.github.io/2018/12/02/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A-h%E5%92%8C-c%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/)里说的那样，此时编译器并不关心``x``的具体实现，即不关心``x``定义在哪个源文件中。编译器只需要知道这个变量的类型和名字，就知道了该如何使用它。编译完成生成之后，链接器会将所有**引用**``x``的地方定向到**定义**它的某一个源文件中。\n为了使上述过程顺利进行，``x``必须要在某个源文件中被定义为**全局变量**，并且不能包含``static``关键字。\n\n## 例子\nprint.h\n```C\n#ifndef _PRINT_H\n#define _PRINT_H\n\nextern int global_x;    //任何包含这个头文件的源文件都将可以使用global_x变量\nvoid print_global_x();\n\n#endif\n\n```\n\nprint.c\n```C\n#include <stdio.h>\n#include \"print.h\"\n\nint global_x;   //global_x的具体定义的位置\nprintf(\"%d\\n\", global_x);\n```\n\nmain.c\n```C\n#include \"print.h\"  //头文件中包含global_x的声明\n\nint main(){\n    global_x = 5;\n    print_global_x();\n\n    return 0;\n}\n```","source":"_posts/extern-外部变量.md","raw":"---\ntitle: extern-外部变量\ndate: 2018-12-03 06:56:26\ncategories:\n- Summary\ntags:\n- C语言\n---\n前两天被同学问起extern的用法，才发现自己对extern的用法也不清晰，囧，整理一下。\n<!--more-->\n## 参考链接\n[when to use extern in C++](https://stackoverflow.com/questions/10422034/when-to-use-extern-in-c)\n\n## extern\nextern用于多文件编程时，不同源文件之间共享变量。我们在头文件中声明外部变量，这样所有包含该头文件的的源文件就都有了这个外部变量的**声明**，而我们只需要在**其中一个**源文件中**定义**一次。\n\n``extern int x``告诉编译器有一个叫``x``的``int``型变量在某个地方，正如之前[C语言编译连接过程](https://ain-crad.github.io/2018/12/02/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A-h%E5%92%8C-c%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/)里说的那样，此时编译器并不关心``x``的具体实现，即不关心``x``定义在哪个源文件中。编译器只需要知道这个变量的类型和名字，就知道了该如何使用它。编译完成生成之后，链接器会将所有**引用**``x``的地方定向到**定义**它的某一个源文件中。\n为了使上述过程顺利进行，``x``必须要在某个源文件中被定义为**全局变量**，并且不能包含``static``关键字。\n\n## 例子\nprint.h\n```C\n#ifndef _PRINT_H\n#define _PRINT_H\n\nextern int global_x;    //任何包含这个头文件的源文件都将可以使用global_x变量\nvoid print_global_x();\n\n#endif\n\n```\n\nprint.c\n```C\n#include <stdio.h>\n#include \"print.h\"\n\nint global_x;   //global_x的具体定义的位置\nprintf(\"%d\\n\", global_x);\n```\n\nmain.c\n```C\n#include \"print.h\"  //头文件中包含global_x的声明\n\nint main(){\n    global_x = 5;\n    print_global_x();\n\n    return 0;\n}\n```","slug":"extern-外部变量","published":1,"updated":"2018-12-02T23:59:32.435Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrnx003jb8oudtro2355","content":"<p>前两天被同学问起extern的用法，才发现自己对extern的用法也不清晰，囧，整理一下。<br><a id=\"more\"></a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://stackoverflow.com/questions/10422034/when-to-use-extern-in-c\" target=\"_blank\" rel=\"noopener\">when to use extern in C++</a></p>\n<h2 id=\"extern\"><a href=\"#extern\" class=\"headerlink\" title=\"extern\"></a>extern</h2><p>extern用于多文件编程时，不同源文件之间共享变量。我们在头文件中声明外部变量，这样所有包含该头文件的的源文件就都有了这个外部变量的<strong>声明</strong>，而我们只需要在<strong>其中一个</strong>源文件中<strong>定义</strong>一次。</p>\n<p><code>extern int x</code>告诉编译器有一个叫<code>x</code>的<code>int</code>型变量在某个地方，正如之前<a href=\"https://ain-crad.github.io/2018/12/02/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A-h%E5%92%8C-c%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">C语言编译连接过程</a>里说的那样，此时编译器并不关心<code>x</code>的具体实现，即不关心<code>x</code>定义在哪个源文件中。编译器只需要知道这个变量的类型和名字，就知道了该如何使用它。编译完成生成之后，链接器会将所有<strong>引用</strong><code>x</code>的地方定向到<strong>定义</strong>它的某一个源文件中。<br>为了使上述过程顺利进行，<code>x</code>必须要在某个源文件中被定义为<strong>全局变量</strong>，并且不能包含<code>static</code>关键字。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>print.h<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _PRINT_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _PRINT_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> global_x;    <span class=\"comment\">//任何包含这个头文件的源文件都将可以使用global_x变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_global_x</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>print.c<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"print.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> global_x;   <span class=\"comment\">//global_x的具体定义的位置</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, global_x);</span><br></pre></td></tr></table></figure></p>\n<p>main.c<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"print.h\"</span>  <span class=\"comment\">//头文件中包含global_x的声明</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    global_x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    print_global_x();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>前两天被同学问起extern的用法，才发现自己对extern的用法也不清晰，囧，整理一下。<br></p>","more":"<p></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://stackoverflow.com/questions/10422034/when-to-use-extern-in-c\" target=\"_blank\" rel=\"noopener\">when to use extern in C++</a></p>\n<h2 id=\"extern\"><a href=\"#extern\" class=\"headerlink\" title=\"extern\"></a>extern</h2><p>extern用于多文件编程时，不同源文件之间共享变量。我们在头文件中声明外部变量，这样所有包含该头文件的的源文件就都有了这个外部变量的<strong>声明</strong>，而我们只需要在<strong>其中一个</strong>源文件中<strong>定义</strong>一次。</p>\n<p><code>extern int x</code>告诉编译器有一个叫<code>x</code>的<code>int</code>型变量在某个地方，正如之前<a href=\"https://ain-crad.github.io/2018/12/02/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A-h%E5%92%8C-c%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">C语言编译连接过程</a>里说的那样，此时编译器并不关心<code>x</code>的具体实现，即不关心<code>x</code>定义在哪个源文件中。编译器只需要知道这个变量的类型和名字，就知道了该如何使用它。编译完成生成之后，链接器会将所有<strong>引用</strong><code>x</code>的地方定向到<strong>定义</strong>它的某一个源文件中。<br>为了使上述过程顺利进行，<code>x</code>必须要在某个源文件中被定义为<strong>全局变量</strong>，并且不能包含<code>static</code>关键字。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>print.h<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _PRINT_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _PRINT_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> global_x;    <span class=\"comment\">//任何包含这个头文件的源文件都将可以使用global_x变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_global_x</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>print.c<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"print.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> global_x;   <span class=\"comment\">//global_x的具体定义的位置</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, global_x);</span><br></pre></td></tr></table></figure></p>\n<p>main.c<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"print.h\"</span>  <span class=\"comment\">//头文件中包含global_x的声明</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    global_x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    print_global_x();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"hexo中mathjax使用坑点","date":"2018-04-09T07:29:50.000Z","_content":"刚刚开始自己的博客之旅，开始真是无比艰难啊，各种被坑。过程中博客需要插入数学公式，下载了mathjax插件(安装之后就可以使用Latex定义的宏写数学公式了)，结果被坑惨(也不算是mathjax的锅，markdown自己也要背)，卡了2个小时，气愤(╯‵□′)╯︵┻━┻\n这里记录一下在mathjax里踩到的坑。\nmathjax的安装配置和使用大家可以参照[Steven's space的博文](http://stevenshi.me/2017/06/26/hexo-insert-formula/)，不再赘述了。\n<!-- more -->\n## 坑点\nmarkdown本身的特殊符号和Latex中的符号会出现冲突。\n- 下划线\\_在markdown中是斜体，但是Latex中下划线是下标的意思，所以这里会冲突。\n- 双斜线\\\\\\\\在markdown中会被转义为\\，所以Latex的\\\\\\\\换行功能也会不正常。\n- 乘法符号\\*在markdown中是粗体＝＝(就是在这被卡了)，所以Latex在写两个数相乘时不能直接写\n```\n$a*b$\n```\n以上情况都会导致无法在mathjax中渲染出来。\n\n## 解决方法\n手动转义：\n比如需要在公式中写乘法*可以写成\n```\n$a\\*b$\n```\n下标写成\n```\n$a\\_1$\n```\n换行写成\n```\n$\\\\\\\\$\n```\n解决，散花。\n\n更多解决方法可以参考[hexo下mathjax的转义问题](http://shomy.top/2016/10/22/hexo-markdown-mathjax/)\n","source":"_posts/hexo-mathjax.md","raw":"---\ntitle: hexo中mathjax使用坑点\ndate: 2018-04-09 15:29:50\ncategories:\n- Messy article\ntags:\n- mathjax\n- hexo插入数学公式\n- 总结\n---\n刚刚开始自己的博客之旅，开始真是无比艰难啊，各种被坑。过程中博客需要插入数学公式，下载了mathjax插件(安装之后就可以使用Latex定义的宏写数学公式了)，结果被坑惨(也不算是mathjax的锅，markdown自己也要背)，卡了2个小时，气愤(╯‵□′)╯︵┻━┻\n这里记录一下在mathjax里踩到的坑。\nmathjax的安装配置和使用大家可以参照[Steven's space的博文](http://stevenshi.me/2017/06/26/hexo-insert-formula/)，不再赘述了。\n<!-- more -->\n## 坑点\nmarkdown本身的特殊符号和Latex中的符号会出现冲突。\n- 下划线\\_在markdown中是斜体，但是Latex中下划线是下标的意思，所以这里会冲突。\n- 双斜线\\\\\\\\在markdown中会被转义为\\，所以Latex的\\\\\\\\换行功能也会不正常。\n- 乘法符号\\*在markdown中是粗体＝＝(就是在这被卡了)，所以Latex在写两个数相乘时不能直接写\n```\n$a*b$\n```\n以上情况都会导致无法在mathjax中渲染出来。\n\n## 解决方法\n手动转义：\n比如需要在公式中写乘法*可以写成\n```\n$a\\*b$\n```\n下标写成\n```\n$a\\_1$\n```\n换行写成\n```\n$\\\\\\\\$\n```\n解决，散花。\n\n更多解决方法可以参考[hexo下mathjax的转义问题](http://shomy.top/2016/10/22/hexo-markdown-mathjax/)\n","slug":"hexo-mathjax","published":1,"updated":"2018-08-09T15:47:10.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrny003nb8ouddclayfs","content":"<p>刚刚开始自己的博客之旅，开始真是无比艰难啊，各种被坑。过程中博客需要插入数学公式，下载了mathjax插件(安装之后就可以使用Latex定义的宏写数学公式了)，结果被坑惨(也不算是mathjax的锅，markdown自己也要背)，卡了2个小时，气愤(╯‵□′)╯︵┻━┻<br>这里记录一下在mathjax里踩到的坑。<br>mathjax的安装配置和使用大家可以参照<a href=\"http://stevenshi.me/2017/06/26/hexo-insert-formula/\" target=\"_blank\" rel=\"noopener\">Steven’s space的博文</a>，不再赘述了。<br><a id=\"more\"></a></p>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>markdown本身的特殊符号和Latex中的符号会出现冲突。</p>\n<ul>\n<li>下划线_在markdown中是斜体，但是Latex中下划线是下标的意思，所以这里会冲突。</li>\n<li>双斜线\\\\在markdown中会被转义为\\，所以Latex的\\\\换行功能也会不正常。</li>\n<li>乘法符号*在markdown中是粗体＝＝(就是在这被卡了)，所以Latex在写两个数相乘时不能直接写<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a*b$</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上情况都会导致无法在mathjax中渲染出来。</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>手动转义：<br>比如需要在公式中写乘法*可以写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a\\*b$</span><br></pre></td></tr></table></figure></p>\n<p>下标写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a\\_1$</span><br></pre></td></tr></table></figure></p>\n<p>换行写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$\\\\\\\\$</span><br></pre></td></tr></table></figure></p>\n<p>解决，散花。</p>\n<p>更多解决方法可以参考<a href=\"http://shomy.top/2016/10/22/hexo-markdown-mathjax/\" target=\"_blank\" rel=\"noopener\">hexo下mathjax的转义问题</a></p>\n","site":{"data":{}},"excerpt":"<p>刚刚开始自己的博客之旅，开始真是无比艰难啊，各种被坑。过程中博客需要插入数学公式，下载了mathjax插件(安装之后就可以使用Latex定义的宏写数学公式了)，结果被坑惨(也不算是mathjax的锅，markdown自己也要背)，卡了2个小时，气愤(╯‵□′)╯︵┻━┻<br>这里记录一下在mathjax里踩到的坑。<br>mathjax的安装配置和使用大家可以参照<a href=\"http://stevenshi.me/2017/06/26/hexo-insert-formula/\" target=\"_blank\" rel=\"noopener\">Steven’s space的博文</a>，不再赘述了。<br></p>","more":"<p></p>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>markdown本身的特殊符号和Latex中的符号会出现冲突。</p>\n<ul>\n<li>下划线_在markdown中是斜体，但是Latex中下划线是下标的意思，所以这里会冲突。</li>\n<li>双斜线\\\\在markdown中会被转义为\\，所以Latex的\\\\换行功能也会不正常。</li>\n<li>乘法符号*在markdown中是粗体＝＝(就是在这被卡了)，所以Latex在写两个数相乘时不能直接写<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a*b$</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上情况都会导致无法在mathjax中渲染出来。</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>手动转义：<br>比如需要在公式中写乘法*可以写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a\\*b$</span><br></pre></td></tr></table></figure></p>\n<p>下标写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a\\_1$</span><br></pre></td></tr></table></figure></p>\n<p>换行写成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$\\\\\\\\$</span><br></pre></td></tr></table></figure></p>\n<p>解决，散花。</p>\n<p>更多解决方法可以参考<a href=\"http://shomy.top/2016/10/22/hexo-markdown-mathjax/\" target=\"_blank\" rel=\"noopener\">hexo下mathjax的转义问题</a></p>"},{"title":"Uva10410-Tree Reconstruction-树还原","date":"2018-12-14T12:02:42.000Z","_content":"根据一棵树的BFS和DFS序列还原这颗树的结构。关于树的一种新的类型的题，mark。\n<!--more-->\n## 链接\n题目链接[Uva10410-Tree Reconstruction](https://vjudge.net/problem/UVA-10410)\n参考链接[20143605--pcx's Blog](https://www.cnblogs.com/20143605--pcx/p/4859424.html)和[Chengrui's Blog](https://wcr1996.com/2015/02/24/uva-10410-tree-reconstruction/)\n\n## 题解\n用BFS序列去分离DFS，首先根据BFS序列顺序记录每个节点的位置。子结点的下标一定比父结点的下标至少大于1，（根节点除外，根结点和第一个子结点的下标距离等于1）。\n用栈维护DFS序列，根据条件不断判断栈中的top结点和新读入结点之间的位置关系，``若top结点下标 + 1 < 新结点下标，或者top结点是根节点``，则表示新结点是top的结点的一个子结点；``若top结点下标 + 1 = 新结点下标``，表示新结点和top结点之间是兄弟结点，同时表示当前top结点往下的分支已扫描完毕，pop出top结点；``若top结点下标 + 1 > 新结点下标``，表示新结点已不在top结点所在子树，同样pop出top结点。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 14 Dec 19:36:24 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e3 + 7;\nint n;\nint pos[maxn];\nstack<int> dfs;\nvector<int> tree[maxn];\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        while(!dfs.empty()) dfs.pop();\n        \n        int x;\n        for(int i = 0; i < n; i++){\n            cin >> x;\n            pos[x] = i;\n            tree[i + 1].clear();\n        }\n\n        int root;\n        cin >> root;\n        dfs.push(root);\n        for(int i = 1; i < n; i++){\n            cin >> x;\n            while(1){\n                int u = dfs.top();\n                if(u == root || pos[u] + 1 < pos[x]){\n                    tree[u].push_back(x);\n                    dfs.push(x);\n                    break;\n                }\n                dfs.pop();\n            }\n        }\n\n        for(int i = 1; i <= n; i++){\n            cout << i << \":\";\n            int len = tree[i].size();\n            for(int j = 0; j < len; j++){\n                cout << \" \" << tree[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n```","source":"_posts/Uva10410-Tree-Reconstruction.md","raw":"---\ntitle: Uva10410-Tree Reconstruction-树还原\ndate: 2018-12-14 20:02:42\ncategories:\n- ACM\n- 树\ntags:\n- 树\n---\n根据一棵树的BFS和DFS序列还原这颗树的结构。关于树的一种新的类型的题，mark。\n<!--more-->\n## 链接\n题目链接[Uva10410-Tree Reconstruction](https://vjudge.net/problem/UVA-10410)\n参考链接[20143605--pcx's Blog](https://www.cnblogs.com/20143605--pcx/p/4859424.html)和[Chengrui's Blog](https://wcr1996.com/2015/02/24/uva-10410-tree-reconstruction/)\n\n## 题解\n用BFS序列去分离DFS，首先根据BFS序列顺序记录每个节点的位置。子结点的下标一定比父结点的下标至少大于1，（根节点除外，根结点和第一个子结点的下标距离等于1）。\n用栈维护DFS序列，根据条件不断判断栈中的top结点和新读入结点之间的位置关系，``若top结点下标 + 1 < 新结点下标，或者top结点是根节点``，则表示新结点是top的结点的一个子结点；``若top结点下标 + 1 = 新结点下标``，表示新结点和top结点之间是兄弟结点，同时表示当前top结点往下的分支已扫描完毕，pop出top结点；``若top结点下标 + 1 > 新结点下标``，表示新结点已不在top结点所在子树，同样pop出top结点。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 14 Dec 19:36:24 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e3 + 7;\nint n;\nint pos[maxn];\nstack<int> dfs;\nvector<int> tree[maxn];\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        while(!dfs.empty()) dfs.pop();\n        \n        int x;\n        for(int i = 0; i < n; i++){\n            cin >> x;\n            pos[x] = i;\n            tree[i + 1].clear();\n        }\n\n        int root;\n        cin >> root;\n        dfs.push(root);\n        for(int i = 1; i < n; i++){\n            cin >> x;\n            while(1){\n                int u = dfs.top();\n                if(u == root || pos[u] + 1 < pos[x]){\n                    tree[u].push_back(x);\n                    dfs.push(x);\n                    break;\n                }\n                dfs.pop();\n            }\n        }\n\n        for(int i = 1; i <= n; i++){\n            cout << i << \":\";\n            int len = tree[i].size();\n            for(int j = 0; j < len; j++){\n                cout << \" \" << tree[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n```","slug":"Uva10410-Tree-Reconstruction","published":1,"updated":"2018-12-14T13:00:51.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslro0003rb8oueivv5tcr","content":"<p>根据一棵树的BFS和DFS序列还原这颗树的结构。关于树的一种新的类型的题，mark。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>题目链接<a href=\"https://vjudge.net/problem/UVA-10410\" target=\"_blank\" rel=\"noopener\">Uva10410-Tree Reconstruction</a><br>参考链接<a href=\"https://www.cnblogs.com/20143605--pcx/p/4859424.html\" target=\"_blank\" rel=\"noopener\">20143605–pcx’s Blog</a>和<a href=\"https://wcr1996.com/2015/02/24/uva-10410-tree-reconstruction/\" target=\"_blank\" rel=\"noopener\">Chengrui’s Blog</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>用BFS序列去分离DFS，首先根据BFS序列顺序记录每个节点的位置。子结点的下标一定比父结点的下标至少大于1，（根节点除外，根结点和第一个子结点的下标距离等于1）。<br>用栈维护DFS序列，根据条件不断判断栈中的top结点和新读入结点之间的位置关系，<code>若top结点下标 + 1 &lt; 新结点下标，或者top结点是根节点</code>，则表示新结点是top的结点的一个子结点；<code>若top结点下标 + 1 = 新结点下标</code>，表示新结点和top结点之间是兄弟结点，同时表示当前top结点往下的分支已扫描完毕，pop出top结点；<code>若top结点下标 + 1 &gt; 新结点下标</code>，表示新结点已不在top结点所在子树，同样pop出top结点。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Fri 14 Dec 19:36:24 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e3</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> pos[maxn];</span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; dfs;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tree[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!dfs.empty()) dfs.pop();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">            pos[x] = i;</span><br><span class=\"line\">            tree[i + <span class=\"number\">1</span>].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> root;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; root;</span><br><span class=\"line\">        dfs.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> u = dfs.top();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(u == root || pos[u] + <span class=\"number\">1</span> &lt; pos[x])&#123;</span><br><span class=\"line\">                    tree[u].push_back(x);</span><br><span class=\"line\">                    dfs.push(x);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dfs.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\":\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = tree[i].size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; len; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; tree[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>根据一棵树的BFS和DFS序列还原这颗树的结构。关于树的一种新的类型的题，mark。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>题目链接<a href=\"https://vjudge.net/problem/UVA-10410\" target=\"_blank\" rel=\"noopener\">Uva10410-Tree Reconstruction</a><br>参考链接<a href=\"https://www.cnblogs.com/20143605--pcx/p/4859424.html\" target=\"_blank\" rel=\"noopener\">20143605–pcx’s Blog</a>和<a href=\"https://wcr1996.com/2015/02/24/uva-10410-tree-reconstruction/\" target=\"_blank\" rel=\"noopener\">Chengrui’s Blog</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>用BFS序列去分离DFS，首先根据BFS序列顺序记录每个节点的位置。子结点的下标一定比父结点的下标至少大于1，（根节点除外，根结点和第一个子结点的下标距离等于1）。<br>用栈维护DFS序列，根据条件不断判断栈中的top结点和新读入结点之间的位置关系，<code>若top结点下标 + 1 &lt; 新结点下标，或者top结点是根节点</code>，则表示新结点是top的结点的一个子结点；<code>若top结点下标 + 1 = 新结点下标</code>，表示新结点和top结点之间是兄弟结点，同时表示当前top结点往下的分支已扫描完毕，pop出top结点；<code>若top结点下标 + 1 &gt; 新结点下标</code>，表示新结点已不在top结点所在子树，同样pop出top结点。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Fri 14 Dec 19:36:24 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e3</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> pos[maxn];</span><br><span class=\"line\"><span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; dfs;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tree[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!dfs.empty()) dfs.pop();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">            pos[x] = i;</span><br><span class=\"line\">            tree[i + <span class=\"number\">1</span>].clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> root;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; root;</span><br><span class=\"line\">        dfs.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> u = dfs.top();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(u == root || pos[u] + <span class=\"number\">1</span> &lt; pos[x])&#123;</span><br><span class=\"line\">                    tree[u].push_back(x);</span><br><span class=\"line\">                    dfs.push(x);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dfs.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\":\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = tree[i].size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; len; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; tree[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"new keyword","date":"2018-09-20T05:21:31.000Z","_content":"使用$new$关键字和不使用$new$关键字创建对象的异同及优劣对比。\n<!--more-->\n## 参考链接\n[When should I use the new keyword in C++](https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c)\n顺便安利一波[Stack Overflow](https://stackoverflow.com/) |･ω･｀)\n## 使用new关键字\n```C++\nMyClass* myClass = new Myclass();\nmyClass->MyField = \"Hello World!\";\n```\n特点：\n1. 为创建的对象在自由存储区分配内存。\n2. 之后需要使用$delete$手动释放分配的内存（否则会造成内存泄露）。\n3. 在使用$delete$之前被分配的内存空间持续存在（意味着用$new$关键字创建的对象可以作为指针被函数返回）。\n\n## 不使用new关键字\n```C++\nMyClass myClass;\nmyClass.MyField = \"Hello World!\";\n```\n特点：\n1. 为创建的对象在堆栈段分配内存。\n2. 不需要使用$delete$来手动释放。\n3. 调用结束时内存空间被清除（意味着用这种方式创建的对象不能作为指针来被函数返回）。\n\n## 拓展\n可执行文件由正文段、数据段、和$BSS$段组成。\n- 正文段（$Text Segment$）:用于储存指令。\n- 数据段（$Data Segment$）:用于储存已初始化的全局变量。\n- $BSS$段（$BSS Segment$）:用于储存未赋值的全局变量所需的空间。\n\n调用栈不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为**堆栈段**（$Stack Segment$）。\n调用栈：调用栈描述的是函数之间的调用关系。它由多个栈帧（$Stack Frame$）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的**返回地址**和**局部变量**，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证不同函数间的局部变量互不相干－－因为不同函数对应着不同的栈帧。\n堆栈段的空间相对于自由空间十分有限（具体大小和操作系统相关，大概几十$M$）。所以建议把较大的数组放在$main$函数外，因为局部变量也是放在堆栈段的。栈溢出（$Segmentation fault$）不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。\n## 总结\n如果不想时刻担心要调用$delete$释放内存，那么就不要使用$new$关键字。\n如果需要在一个函数中返回对象的指针，那么就一定要使用$new$关键字（局部变量的方式会在函数调用结束时清除分配的空间）。","source":"_posts/new-keyword.md","raw":"---\ntitle: new keyword\ndate: 2018-09-20 13:21:31\ncategories:\n- C++\ntags:\n- C++\n---\n使用$new$关键字和不使用$new$关键字创建对象的异同及优劣对比。\n<!--more-->\n## 参考链接\n[When should I use the new keyword in C++](https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c)\n顺便安利一波[Stack Overflow](https://stackoverflow.com/) |･ω･｀)\n## 使用new关键字\n```C++\nMyClass* myClass = new Myclass();\nmyClass->MyField = \"Hello World!\";\n```\n特点：\n1. 为创建的对象在自由存储区分配内存。\n2. 之后需要使用$delete$手动释放分配的内存（否则会造成内存泄露）。\n3. 在使用$delete$之前被分配的内存空间持续存在（意味着用$new$关键字创建的对象可以作为指针被函数返回）。\n\n## 不使用new关键字\n```C++\nMyClass myClass;\nmyClass.MyField = \"Hello World!\";\n```\n特点：\n1. 为创建的对象在堆栈段分配内存。\n2. 不需要使用$delete$来手动释放。\n3. 调用结束时内存空间被清除（意味着用这种方式创建的对象不能作为指针来被函数返回）。\n\n## 拓展\n可执行文件由正文段、数据段、和$BSS$段组成。\n- 正文段（$Text Segment$）:用于储存指令。\n- 数据段（$Data Segment$）:用于储存已初始化的全局变量。\n- $BSS$段（$BSS Segment$）:用于储存未赋值的全局变量所需的空间。\n\n调用栈不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为**堆栈段**（$Stack Segment$）。\n调用栈：调用栈描述的是函数之间的调用关系。它由多个栈帧（$Stack Frame$）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的**返回地址**和**局部变量**，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证不同函数间的局部变量互不相干－－因为不同函数对应着不同的栈帧。\n堆栈段的空间相对于自由空间十分有限（具体大小和操作系统相关，大概几十$M$）。所以建议把较大的数组放在$main$函数外，因为局部变量也是放在堆栈段的。栈溢出（$Segmentation fault$）不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。\n## 总结\n如果不想时刻担心要调用$delete$释放内存，那么就不要使用$new$关键字。\n如果需要在一个函数中返回对象的指针，那么就一定要使用$new$关键字（局部变量的方式会在函数调用结束时清除分配的空间）。","slug":"new-keyword","published":1,"updated":"2018-12-04T03:16:54.415Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslro1003ub8oua1uv9n0x","content":"<p>使用$new$关键字和不使用$new$关键字创建对象的异同及优劣对比。<br><a id=\"more\"></a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c\" target=\"_blank\" rel=\"noopener\">When should I use the new keyword in C++</a><br>顺便安利一波<a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">Stack Overflow</a> |･ω･｀)</p>\n<h2 id=\"使用new关键字\"><a href=\"#使用new关键字\" class=\"headerlink\" title=\"使用new关键字\"></a>使用new关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass* myClass = <span class=\"keyword\">new</span> Myclass();</span><br><span class=\"line\">myClass-&gt;MyField = <span class=\"string\">\"Hello World!\"</span>;</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>为创建的对象在自由存储区分配内存。</li>\n<li>之后需要使用$delete$手动释放分配的内存（否则会造成内存泄露）。</li>\n<li>在使用$delete$之前被分配的内存空间持续存在（意味着用$new$关键字创建的对象可以作为指针被函数返回）。</li>\n</ol>\n<h2 id=\"不使用new关键字\"><a href=\"#不使用new关键字\" class=\"headerlink\" title=\"不使用new关键字\"></a>不使用new关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass myClass;</span><br><span class=\"line\">myClass.MyField = <span class=\"string\">\"Hello World!\"</span>;</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>为创建的对象在堆栈段分配内存。</li>\n<li>不需要使用$delete$来手动释放。</li>\n<li>调用结束时内存空间被清除（意味着用这种方式创建的对象不能作为指针来被函数返回）。</li>\n</ol>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>可执行文件由正文段、数据段、和$BSS$段组成。</p>\n<ul>\n<li>正文段（$Text Segment$）:用于储存指令。</li>\n<li>数据段（$Data Segment$）:用于储存已初始化的全局变量。</li>\n<li>$BSS$段（$BSS Segment$）:用于储存未赋值的全局变量所需的空间。</li>\n</ul>\n<p>调用栈不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为<strong>堆栈段</strong>（$Stack Segment$）。<br>调用栈：调用栈描述的是函数之间的调用关系。它由多个栈帧（$Stack Frame$）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的<strong>返回地址</strong>和<strong>局部变量</strong>，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证不同函数间的局部变量互不相干－－因为不同函数对应着不同的栈帧。<br>堆栈段的空间相对于自由空间十分有限（具体大小和操作系统相关，大概几十$M$）。所以建议把较大的数组放在$main$函数外，因为局部变量也是放在堆栈段的。栈溢出（$Segmentation fault$）不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果不想时刻担心要调用$delete$释放内存，那么就不要使用$new$关键字。<br>如果需要在一个函数中返回对象的指针，那么就一定要使用$new$关键字（局部变量的方式会在函数调用结束时清除分配的空间）。</p>\n","site":{"data":{}},"excerpt":"<p>使用$new$关键字和不使用$new$关键字创建对象的异同及优劣对比。<br></p>","more":"<p></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://stackoverflow.com/questions/655065/when-should-i-use-the-new-keyword-in-c\" target=\"_blank\" rel=\"noopener\">When should I use the new keyword in C++</a><br>顺便安利一波<a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">Stack Overflow</a> |･ω･｀)</p>\n<h2 id=\"使用new关键字\"><a href=\"#使用new关键字\" class=\"headerlink\" title=\"使用new关键字\"></a>使用new关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass* myClass = <span class=\"keyword\">new</span> Myclass();</span><br><span class=\"line\">myClass-&gt;MyField = <span class=\"string\">\"Hello World!\"</span>;</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>为创建的对象在自由存储区分配内存。</li>\n<li>之后需要使用$delete$手动释放分配的内存（否则会造成内存泄露）。</li>\n<li>在使用$delete$之前被分配的内存空间持续存在（意味着用$new$关键字创建的对象可以作为指针被函数返回）。</li>\n</ol>\n<h2 id=\"不使用new关键字\"><a href=\"#不使用new关键字\" class=\"headerlink\" title=\"不使用new关键字\"></a>不使用new关键字</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass myClass;</span><br><span class=\"line\">myClass.MyField = <span class=\"string\">\"Hello World!\"</span>;</span><br></pre></td></tr></table></figure>\n<p>特点：</p>\n<ol>\n<li>为创建的对象在堆栈段分配内存。</li>\n<li>不需要使用$delete$来手动释放。</li>\n<li>调用结束时内存空间被清除（意味着用这种方式创建的对象不能作为指针来被函数返回）。</li>\n</ol>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>可执行文件由正文段、数据段、和$BSS$段组成。</p>\n<ul>\n<li>正文段（$Text Segment$）:用于储存指令。</li>\n<li>数据段（$Data Segment$）:用于储存已初始化的全局变量。</li>\n<li>$BSS$段（$BSS Segment$）:用于储存未赋值的全局变量所需的空间。</li>\n</ul>\n<p>调用栈不储存在可执行文件中，而是在运行时创建。调用栈所在的段称为<strong>堆栈段</strong>（$Stack Segment$）。<br>调用栈：调用栈描述的是函数之间的调用关系。它由多个栈帧（$Stack Frame$）组成，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的<strong>返回地址</strong>和<strong>局部变量</strong>，因而不仅能在执行完毕后找到正确的返回地址，还很自然地保证不同函数间的局部变量互不相干－－因为不同函数对应着不同的栈帧。<br>堆栈段的空间相对于自由空间十分有限（具体大小和操作系统相关，大概几十$M$）。所以建议把较大的数组放在$main$函数外，因为局部变量也是放在堆栈段的。栈溢出（$Segmentation fault$）不一定是递归调用太多，也可能是局部变量太大。只要总大小超过了允许的范围，就会产生栈溢出。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果不想时刻担心要调用$delete$释放内存，那么就不要使用$new$关键字。<br>如果需要在一个函数中返回对象的指针，那么就一定要使用$new$关键字（局部变量的方式会在函数调用结束时清除分配的空间）。</p>"},{"title":"next_permutation解析","date":"2018-12-18T02:34:22.000Z","_content":"next_permutation是C++的STL中提供的一个库函数，声明在algorithm头文件中，用来求下一个排列。好奇内部是怎么实现的，在Stack Overflow上看到了精彩的回答。\n<!--more-->\n## 链接\n参考链接[std::next_permutation Implementation Explanation](https://stackoverflow.com/questions/11483060/stdnext-permutation-implementation-explanation)\n\n## 内部实现\n```C++\n\ntemplate<typename It>\nbool next_permutation(It begin, It end)\n{\n    if (begin == end)\n        return false;\n\n    It i = begin;\n    ++i;\n    if (i == end)\n        return false;\n\n    i = end;\n    --i;\n\n    while (true)\n    {\n        It j = i;\n        --i;\n\n        if (*i < *j)\n        {\n            It k = end;\n\n             while (!(*i < *--k))\n                /* pass */;\n\n            iter_swap(i, k);\n            reverse(j, end);\n            return true;\n        }\n\n        if (i == begin)\n        {\n            reverse(begin, end);\n            return false;\n        }\n    }\n}\n\n```\n\n## 解析\n```\n1 2 3 4\n1 2 4 3\n1 3 2 4\n1 3 4 2\n1 4 3 2 \n2 1 3 4\n...\n```\n要得到一个排列的下一个排列，**我们可以把排列中的每一个元素看做数字中的某一位，整个排列看做一个具体的数**。这样求下一个排列的问题就变成了求比当前数字的大的那些数字中最小的那个数（即上确界）。例如排列组成的所有可能的数中，比1234大的数中最小的那个就是1243。\n在上面的例子里我们看到前几个排列都是1作为排列的首部，当1作为首部的情况被改变的时候是1后面的三个数字降序排列的时候。\n所以算法设计的关键是**从后向前找到第一个打破降序的数字，将它和它右边降序排列中它的上确界调换位置，之后再将原本的降序序列部分反转**。之所以反转是因为调换位置后已经是一个新的排列，而反转后的升序序列是原本降序序列的最小状态。\n\n核心代码：\n```\nwhile (true)\n    {\n        It j = i;\n        --i;\n\n        //找到最先打破降序的元素\n        if (*i < *j)\n        {\n            It k = end;\n\n            //找到这个元素在它右边降序序列的上确界\n             while (!(*i < *--k))\n                /* pass */;\n\n            iter_swap(i, k);//交换元素\n            reverse(j, end);//降序序列部分反转\n            return true;\n        }\n\n        //表示整个序列已经是降序序列\n        if (i == begin)\n        {\n            reverse(begin, end);\n            return false;\n        }\n    }\n```\n\n","source":"_posts/next-permutation解析.md","raw":"---\ntitle: next_permutation解析\ndate: 2018-12-18 10:34:22\ncategories:\n- C++\ntags:\n- 排列\n---\nnext_permutation是C++的STL中提供的一个库函数，声明在algorithm头文件中，用来求下一个排列。好奇内部是怎么实现的，在Stack Overflow上看到了精彩的回答。\n<!--more-->\n## 链接\n参考链接[std::next_permutation Implementation Explanation](https://stackoverflow.com/questions/11483060/stdnext-permutation-implementation-explanation)\n\n## 内部实现\n```C++\n\ntemplate<typename It>\nbool next_permutation(It begin, It end)\n{\n    if (begin == end)\n        return false;\n\n    It i = begin;\n    ++i;\n    if (i == end)\n        return false;\n\n    i = end;\n    --i;\n\n    while (true)\n    {\n        It j = i;\n        --i;\n\n        if (*i < *j)\n        {\n            It k = end;\n\n             while (!(*i < *--k))\n                /* pass */;\n\n            iter_swap(i, k);\n            reverse(j, end);\n            return true;\n        }\n\n        if (i == begin)\n        {\n            reverse(begin, end);\n            return false;\n        }\n    }\n}\n\n```\n\n## 解析\n```\n1 2 3 4\n1 2 4 3\n1 3 2 4\n1 3 4 2\n1 4 3 2 \n2 1 3 4\n...\n```\n要得到一个排列的下一个排列，**我们可以把排列中的每一个元素看做数字中的某一位，整个排列看做一个具体的数**。这样求下一个排列的问题就变成了求比当前数字的大的那些数字中最小的那个数（即上确界）。例如排列组成的所有可能的数中，比1234大的数中最小的那个就是1243。\n在上面的例子里我们看到前几个排列都是1作为排列的首部，当1作为首部的情况被改变的时候是1后面的三个数字降序排列的时候。\n所以算法设计的关键是**从后向前找到第一个打破降序的数字，将它和它右边降序排列中它的上确界调换位置，之后再将原本的降序序列部分反转**。之所以反转是因为调换位置后已经是一个新的排列，而反转后的升序序列是原本降序序列的最小状态。\n\n核心代码：\n```\nwhile (true)\n    {\n        It j = i;\n        --i;\n\n        //找到最先打破降序的元素\n        if (*i < *j)\n        {\n            It k = end;\n\n            //找到这个元素在它右边降序序列的上确界\n             while (!(*i < *--k))\n                /* pass */;\n\n            iter_swap(i, k);//交换元素\n            reverse(j, end);//降序序列部分反转\n            return true;\n        }\n\n        //表示整个序列已经是降序序列\n        if (i == begin)\n        {\n            reverse(begin, end);\n            return false;\n        }\n    }\n```\n\n","slug":"next-permutation解析","published":1,"updated":"2018-12-18T03:22:06.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslro5003zb8oujvevwxe8","content":"<p>next_permutation是C++的STL中提供的一个库函数，声明在algorithm头文件中，用来求下一个排列。好奇内部是怎么实现的，在Stack Overflow上看到了精彩的回答。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>参考链接<a href=\"https://stackoverflow.com/questions/11483060/stdnext-permutation-implementation-explanation\" target=\"_blank\" rel=\"noopener\">std::next_permutation Implementation Explanation</a></p>\n<h2 id=\"内部实现\"><a href=\"#内部实现\" class=\"headerlink\" title=\"内部实现\"></a>内部实现</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> It&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">next_permutation</span><span class=\"params\">(It begin, It end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (begin == end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    It i = begin;</span><br><span class=\"line\">    ++i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    i = end;</span><br><span class=\"line\">    --i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        It j = i;</span><br><span class=\"line\">        --i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*i &lt; *j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            It k = end;</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"keyword\">while</span> (!(*i &lt; *--k))</span><br><span class=\"line\">                <span class=\"comment\">/* pass */</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            iter_swap(i, k);</span><br><span class=\"line\">            reverse(j, end);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == begin)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            reverse(begin, end);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4</span><br><span class=\"line\">1 2 4 3</span><br><span class=\"line\">1 3 2 4</span><br><span class=\"line\">1 3 4 2</span><br><span class=\"line\">1 4 3 2 </span><br><span class=\"line\">2 1 3 4</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>要得到一个排列的下一个排列，<strong>我们可以把排列中的每一个元素看做数字中的某一位，整个排列看做一个具体的数</strong>。这样求下一个排列的问题就变成了求比当前数字的大的那些数字中最小的那个数（即上确界）。例如排列组成的所有可能的数中，比1234大的数中最小的那个就是1243。<br>在上面的例子里我们看到前几个排列都是1作为排列的首部，当1作为首部的情况被改变的时候是1后面的三个数字降序排列的时候。<br>所以算法设计的关键是<strong>从后向前找到第一个打破降序的数字，将它和它右边降序排列中它的上确界调换位置，之后再将原本的降序序列部分反转</strong>。之所以反转是因为调换位置后已经是一个新的排列，而反转后的升序序列是原本降序序列的最小状态。</p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        It j = i;</span><br><span class=\"line\">        --i;</span><br><span class=\"line\"></span><br><span class=\"line\">        //找到最先打破降序的元素</span><br><span class=\"line\">        if (*i &lt; *j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            It k = end;</span><br><span class=\"line\"></span><br><span class=\"line\">            //找到这个元素在它右边降序序列的上确界</span><br><span class=\"line\">             while (!(*i &lt; *--k))</span><br><span class=\"line\">                /* pass */;</span><br><span class=\"line\"></span><br><span class=\"line\">            iter_swap(i, k);//交换元素</span><br><span class=\"line\">            reverse(j, end);//降序序列部分反转</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //表示整个序列已经是降序序列</span><br><span class=\"line\">        if (i == begin)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            reverse(begin, end);</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>next_permutation是C++的STL中提供的一个库函数，声明在algorithm头文件中，用来求下一个排列。好奇内部是怎么实现的，在Stack Overflow上看到了精彩的回答。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>参考链接<a href=\"https://stackoverflow.com/questions/11483060/stdnext-permutation-implementation-explanation\" target=\"_blank\" rel=\"noopener\">std::next_permutation Implementation Explanation</a></p>\n<h2 id=\"内部实现\"><a href=\"#内部实现\" class=\"headerlink\" title=\"内部实现\"></a>内部实现</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> It&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">next_permutation</span><span class=\"params\">(It begin, It end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (begin == end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    It i = begin;</span><br><span class=\"line\">    ++i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    i = end;</span><br><span class=\"line\">    --i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        It j = i;</span><br><span class=\"line\">        --i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*i &lt; *j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            It k = end;</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"keyword\">while</span> (!(*i &lt; *--k))</span><br><span class=\"line\">                <span class=\"comment\">/* pass */</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            iter_swap(i, k);</span><br><span class=\"line\">            reverse(j, end);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == begin)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            reverse(begin, end);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 3 4</span><br><span class=\"line\">1 2 4 3</span><br><span class=\"line\">1 3 2 4</span><br><span class=\"line\">1 3 4 2</span><br><span class=\"line\">1 4 3 2 </span><br><span class=\"line\">2 1 3 4</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>要得到一个排列的下一个排列，<strong>我们可以把排列中的每一个元素看做数字中的某一位，整个排列看做一个具体的数</strong>。这样求下一个排列的问题就变成了求比当前数字的大的那些数字中最小的那个数（即上确界）。例如排列组成的所有可能的数中，比1234大的数中最小的那个就是1243。<br>在上面的例子里我们看到前几个排列都是1作为排列的首部，当1作为首部的情况被改变的时候是1后面的三个数字降序排列的时候。<br>所以算法设计的关键是<strong>从后向前找到第一个打破降序的数字，将它和它右边降序排列中它的上确界调换位置，之后再将原本的降序序列部分反转</strong>。之所以反转是因为调换位置后已经是一个新的排列，而反转后的升序序列是原本降序序列的最小状态。</p>\n<p>核心代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        It j = i;</span><br><span class=\"line\">        --i;</span><br><span class=\"line\"></span><br><span class=\"line\">        //找到最先打破降序的元素</span><br><span class=\"line\">        if (*i &lt; *j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            It k = end;</span><br><span class=\"line\"></span><br><span class=\"line\">            //找到这个元素在它右边降序序列的上确界</span><br><span class=\"line\">             while (!(*i &lt; *--k))</span><br><span class=\"line\">                /* pass */;</span><br><span class=\"line\"></span><br><span class=\"line\">            iter_swap(i, k);//交换元素</span><br><span class=\"line\">            reverse(j, end);//降序序列部分反转</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //表示整个序列已经是降序序列</span><br><span class=\"line\">        if (i == begin)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            reverse(begin, end);</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"新起点","date":"2018-04-08T15:12:00.000Z","_content":"搭一个自己的独立博客的想法记得从去年暑假就有了，可是当时还是小菜鸡蛋，什么都不懂＝＝，现在孵成了小菜鸡，才终于磨磨蹭蹭的搭了起来，内心还是十分激动的(〃∇〃)，其间走了很多弯路，陷进了很多坑，感谢[CrazyMilk的这篇博文](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)以及[陶司机](http://logqtainia.github.io/)的指导，感谢女票的支持，也感谢自己没有就此放弃ヽ(•̀ω•́ )ゝ。\n<!-- more -->\n### 为什么要搭建独立博客\n最近３个月左右，一直在跟着校内的ACM队进行训练，最初是想提高自己的编程能力，后来发现自己无论对这个团队还是对这项竞赛都有一种由衷的向往，虽然最后因为个人能力以及年级太高(大三下)等方面因素没能成为正式队员，但还是想至少沿这个方向走下去。从接触ACM开始后就发现，优秀的人实在太多太多，自己会的实在太少太少，都不敢以菜鸡自称，简直是菜鸡蛋2333\n所以想在这里记录自己的成长，努力成为一个优秀的人。我也十分赞同CrazyMilk博主提到的Litten（Yilia主题的制作者）说的那句话：有了一个独立博客，就有了属于自己的一片田，开始默默耕作。\n等到自己不再是小菜鸡的那一天再回头来看那个曾经的小菜鸡的成长历程，应该会别有一番滋味吧，哈哈，期待。\n\nHello, Aincrad.\n\n要去耕作了(ง •̀_•́)ง，告辞。\n\nPs:博客框架采用hexo,及其经典的next主题。\n","source":"_posts/new start point.md","raw":"---\ntitle: 新起点\ndate : 2018-04-08 23:12:00\ncategories:\n- Diary\ntags:\n- 生活\n- 总结\n---\n搭一个自己的独立博客的想法记得从去年暑假就有了，可是当时还是小菜鸡蛋，什么都不懂＝＝，现在孵成了小菜鸡，才终于磨磨蹭蹭的搭了起来，内心还是十分激动的(〃∇〃)，其间走了很多弯路，陷进了很多坑，感谢[CrazyMilk的这篇博文](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)以及[陶司机](http://logqtainia.github.io/)的指导，感谢女票的支持，也感谢自己没有就此放弃ヽ(•̀ω•́ )ゝ。\n<!-- more -->\n### 为什么要搭建独立博客\n最近３个月左右，一直在跟着校内的ACM队进行训练，最初是想提高自己的编程能力，后来发现自己无论对这个团队还是对这项竞赛都有一种由衷的向往，虽然最后因为个人能力以及年级太高(大三下)等方面因素没能成为正式队员，但还是想至少沿这个方向走下去。从接触ACM开始后就发现，优秀的人实在太多太多，自己会的实在太少太少，都不敢以菜鸡自称，简直是菜鸡蛋2333\n所以想在这里记录自己的成长，努力成为一个优秀的人。我也十分赞同CrazyMilk博主提到的Litten（Yilia主题的制作者）说的那句话：有了一个独立博客，就有了属于自己的一片田，开始默默耕作。\n等到自己不再是小菜鸡的那一天再回头来看那个曾经的小菜鸡的成长历程，应该会别有一番滋味吧，哈哈，期待。\n\nHello, Aincrad.\n\n要去耕作了(ง •̀_•́)ง，告辞。\n\nPs:博客框架采用hexo,及其经典的next主题。\n","slug":"new start point","published":1,"updated":"2018-08-09T16:01:33.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslro70042b8ouw02cau2m","content":"<p>搭一个自己的独立博客的想法记得从去年暑假就有了，可是当时还是小菜鸡蛋，什么都不懂＝＝，现在孵成了小菜鸡，才终于磨磨蹭蹭的搭了起来，内心还是十分激动的(〃∇〃)，其间走了很多弯路，陷进了很多坑，感谢<a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"noopener\">CrazyMilk的这篇博文</a>以及<a href=\"http://logqtainia.github.io/\" target=\"_blank\" rel=\"noopener\">陶司机</a>的指导，感谢女票的支持，也感谢自己没有就此放弃ヽ(•̀ω•́ )ゝ。<br><a id=\"more\"></a></p>\n<h3 id=\"为什么要搭建独立博客\"><a href=\"#为什么要搭建独立博客\" class=\"headerlink\" title=\"为什么要搭建独立博客\"></a>为什么要搭建独立博客</h3><p>最近３个月左右，一直在跟着校内的ACM队进行训练，最初是想提高自己的编程能力，后来发现自己无论对这个团队还是对这项竞赛都有一种由衷的向往，虽然最后因为个人能力以及年级太高(大三下)等方面因素没能成为正式队员，但还是想至少沿这个方向走下去。从接触ACM开始后就发现，优秀的人实在太多太多，自己会的实在太少太少，都不敢以菜鸡自称，简直是菜鸡蛋2333<br>所以想在这里记录自己的成长，努力成为一个优秀的人。我也十分赞同CrazyMilk博主提到的Litten（Yilia主题的制作者）说的那句话：有了一个独立博客，就有了属于自己的一片田，开始默默耕作。<br>等到自己不再是小菜鸡的那一天再回头来看那个曾经的小菜鸡的成长历程，应该会别有一番滋味吧，哈哈，期待。</p>\n<p>Hello, Aincrad.</p>\n<p>要去耕作了(ง •̀_•́)ง，告辞。</p>\n<p>Ps:博客框架采用hexo,及其经典的next主题。</p>\n","site":{"data":{}},"excerpt":"<p>搭一个自己的独立博客的想法记得从去年暑假就有了，可是当时还是小菜鸡蛋，什么都不懂＝＝，现在孵成了小菜鸡，才终于磨磨蹭蹭的搭了起来，内心还是十分激动的(〃∇〃)，其间走了很多弯路，陷进了很多坑，感谢<a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\" target=\"_blank\" rel=\"noopener\">CrazyMilk的这篇博文</a>以及<a href=\"http://logqtainia.github.io/\" target=\"_blank\" rel=\"noopener\">陶司机</a>的指导，感谢女票的支持，也感谢自己没有就此放弃ヽ(•̀ω•́ )ゝ。<br></p>","more":"<p></p>\n<h3 id=\"为什么要搭建独立博客\"><a href=\"#为什么要搭建独立博客\" class=\"headerlink\" title=\"为什么要搭建独立博客\"></a>为什么要搭建独立博客</h3><p>最近３个月左右，一直在跟着校内的ACM队进行训练，最初是想提高自己的编程能力，后来发现自己无论对这个团队还是对这项竞赛都有一种由衷的向往，虽然最后因为个人能力以及年级太高(大三下)等方面因素没能成为正式队员，但还是想至少沿这个方向走下去。从接触ACM开始后就发现，优秀的人实在太多太多，自己会的实在太少太少，都不敢以菜鸡自称，简直是菜鸡蛋2333<br>所以想在这里记录自己的成长，努力成为一个优秀的人。我也十分赞同CrazyMilk博主提到的Litten（Yilia主题的制作者）说的那句话：有了一个独立博客，就有了属于自己的一片田，开始默默耕作。<br>等到自己不再是小菜鸡的那一天再回头来看那个曾经的小菜鸡的成长历程，应该会别有一番滋味吧，哈哈，期待。</p>\n<p>Hello, Aincrad.</p>\n<p>要去耕作了(ง •̀_•́)ง，告辞。</p>\n<p>Ps:博客框架采用hexo,及其经典的next主题。</p>"},{"title":"pick numbers-DFS","date":"2018-08-11T09:23:02.000Z","_content":"从$n$个整数中任选$k$个整数相加，求得到的一系列和中为素数的共有多少种．\n<!-- more -->\n## 链接\n[NOIP2002](http://acmoj.shu.edu.cn/problem/264/)\n## 题目\n已知$n$个整数$x1, x2,...,xn$，以及一个整数$k$．从$n$个整数中任选$k$个整数相加，可分别得到一系列的和．例如当$n = 4, k = 3$, $4$个整数分别为$3, 7, 12, 19$时，可得到全部的组合与它们的和为：\n$3 + 7 + 12 = 22$\n$3 + 7 + 19 = 29$\n$7 + 12 + 19 = 38$\n$3 + 12 + 19 = 34$\n现在，要求你计算和为素数共有多少种．\n## 思路\nDFS对每一种情况遍历．\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 11 Aug 16:32:41 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n, k;\nint d[maxn];\nint ans = 0;\nint sum = 0;\n\nbool is_prime(){\n    if(sum < 2)\n        return false;\n    int tmp = sqrt(sum);\n    for(int i = 2; i <= tmp; i++){\n        if(!(sum % i)) \n            return false;\n    }\n    return true;\n}\n\nvoid dfs(int now, int dep){\n    if(dep == k){\n        if(is_prime())\n            ans++;\n        return;\n    }\n    if(now == n){\n        return;\n    }\n    for(int i = now; i < n; i++){\n        sum += d[i];\n        dfs(i + 1, dep + 1);\n        sum -= d[i];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(cin >> n >> k){\n        ans = 0;\n        sum = 0;\n        //cout << n << \" \" << k << endl;\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/pick-numbers.md","raw":"---\ntitle: pick numbers-DFS\ndate: 2018-08-11 17:23:02\ncategories:\n- ACM\n- DFS\ntags:\n- DFS\n---\n从$n$个整数中任选$k$个整数相加，求得到的一系列和中为素数的共有多少种．\n<!-- more -->\n## 链接\n[NOIP2002](http://acmoj.shu.edu.cn/problem/264/)\n## 题目\n已知$n$个整数$x1, x2,...,xn$，以及一个整数$k$．从$n$个整数中任选$k$个整数相加，可分别得到一系列的和．例如当$n = 4, k = 3$, $4$个整数分别为$3, 7, 12, 19$时，可得到全部的组合与它们的和为：\n$3 + 7 + 12 = 22$\n$3 + 7 + 19 = 29$\n$7 + 12 + 19 = 38$\n$3 + 12 + 19 = 34$\n现在，要求你计算和为素数共有多少种．\n## 思路\nDFS对每一种情况遍历．\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sat 11 Aug 16:32:41 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30;\nint n, k;\nint d[maxn];\nint ans = 0;\nint sum = 0;\n\nbool is_prime(){\n    if(sum < 2)\n        return false;\n    int tmp = sqrt(sum);\n    for(int i = 2; i <= tmp; i++){\n        if(!(sum % i)) \n            return false;\n    }\n    return true;\n}\n\nvoid dfs(int now, int dep){\n    if(dep == k){\n        if(is_prime())\n            ans++;\n        return;\n    }\n    if(now == n){\n        return;\n    }\n    for(int i = now; i < n; i++){\n        sum += d[i];\n        dfs(i + 1, dep + 1);\n        sum -= d[i];\n    }\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        //freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(cin >> n >> k){\n        ans = 0;\n        sum = 0;\n        //cout << n << \" \" << k << endl;\n        for(int i = 0; i < n; i++){\n            cin >> d[i];\n        }\n        dfs(0, 0);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n```\n","slug":"pick-numbers","published":1,"updated":"2018-12-14T13:09:10.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslroa0047b8ouxvmn12d7","content":"<p>从$n$个整数中任选$k$个整数相加，求得到的一系列和中为素数的共有多少种．<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acmoj.shu.edu.cn/problem/264/\" target=\"_blank\" rel=\"noopener\">NOIP2002</a></p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>已知$n$个整数$x1, x2,…,xn$，以及一个整数$k$．从$n$个整数中任选$k$个整数相加，可分别得到一系列的和．例如当$n = 4, k = 3$, $4$个整数分别为$3, 7, 12, 19$时，可得到全部的组合与它们的和为：<br>$3 + 7 + 12 = 22$<br>$3 + 7 + 19 = 29$<br>$7 + 12 + 19 = 38$<br>$3 + 12 + 19 = 34$<br>现在，要求你计算和为素数共有多少种．</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>DFS对每一种情况遍历．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 11 Aug 16:32:41 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, k;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_prime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sum &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"built_in\">sqrt</span>(sum);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= tmp; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(sum % i)) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> now, <span class=\"keyword\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep == k)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is_prime())</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(now == n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = now; i &lt; n; i++)&#123;</span><br><span class=\"line\">        sum += d[i];</span><br><span class=\"line\">        dfs(i + <span class=\"number\">1</span>, dep + <span class=\"number\">1</span>);</span><br><span class=\"line\">        sum -= d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k)&#123;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; k &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; d[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>从$n$个整数中任选$k$个整数相加，求得到的一系列和中为素数的共有多少种．<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://acmoj.shu.edu.cn/problem/264/\" target=\"_blank\" rel=\"noopener\">NOIP2002</a></p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>已知$n$个整数$x1, x2,…,xn$，以及一个整数$k$．从$n$个整数中任选$k$个整数相加，可分别得到一系列的和．例如当$n = 4, k = 3$, $4$个整数分别为$3, 7, 12, 19$时，可得到全部的组合与它们的和为：<br>$3 + 7 + 12 = 22$<br>$3 + 7 + 19 = 29$<br>$7 + 12 + 19 = 38$<br>$3 + 12 + 19 = 34$<br>现在，要求你计算和为素数共有多少种．</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>DFS对每一种情况遍历．</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sat 11 Aug 16:32:41 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, k;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">is_prime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sum &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"built_in\">sqrt</span>(sum);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= tmp; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!(sum % i)) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> now, <span class=\"keyword\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep == k)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is_prime())</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(now == n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = now; i &lt; n; i++)&#123;</span><br><span class=\"line\">        sum += d[i];</span><br><span class=\"line\">        dfs(i + <span class=\"number\">1</span>, dep + <span class=\"number\">1</span>);</span><br><span class=\"line\">        sum -= d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"comment\">//freopen(\"in.txt\", \"r\", stdin);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k)&#123;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; k &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; d[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"矩阵快速幂","date":"2018-05-14T01:41:44.000Z","_content":"最近在做一道DP的题时发现数据范围竟然是1e18，这样的话只能用log(n)复杂度的算法来实现了，于是从队长那里了解到了矩阵快速幂。在这里记录一下快速幂以及其它矩阵处理的模板。\n矩阵快速幂模板参考自[eecrazy](https://github.com/eecrazy/ACM/blob/master/%E6%95%B0%E8%AE%BA/poj3233%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.cpp)\n<!-- more -->\n## 常数快速幂\n```C++\ntypedef long long ll;\nll mod_pow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res *= x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n```\n## 矩阵快速幂\n``` C++\nstruct Ma\n{\n    int m[maxn][maxn];\n};\n\nMa a,per;\nint n, mod;\n\nvoid init()//矩阵初始化\n{\n    int i,j;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n        {\n            scanf(\"%d\", &a.m[i][j]);\n            a.m[i][j] %= mod;\n            per.m[i][j] = (i == j);\n        }\n}\n\nMa add(Ma a,Ma b)//矩阵加法\n{\n    Ma c;\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n        {\n            c.m[i][j] = (a.m[i][j] + b.m[i][j]) % mod;\n        }\n    }\n    return c;\n}\n\n\nMa multi(Ma a,Ma b)//矩阵乘法\n{\n    Ma c;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n        {\n            c.m[i][j] = 0;\n            for(int k = 0; k < n; k++)\n            {\n                c.m[i][j] += a.m[i][k] * b.m[k][j];\n            }\n            c.m[i][j] %= mod;\n        }\n    return c;\n}\n\nMa quick_pow(long long x)//矩阵快速幂\n{\n    Ma res = per;\n    Ma p = a;\n    while(x)\n    {\n        if(x&1) res = multi(res,p);\n        p = multi(p,p);\n        x >>= 1;\n    }\n    return res;\n}\n```","source":"_posts/quick-matrix.md","raw":"---\ntitle: 矩阵快速幂\ndate: 2018-05-14 09:41:44\ncategories:\n- ACM\ntags:\n- math\n---\n最近在做一道DP的题时发现数据范围竟然是1e18，这样的话只能用log(n)复杂度的算法来实现了，于是从队长那里了解到了矩阵快速幂。在这里记录一下快速幂以及其它矩阵处理的模板。\n矩阵快速幂模板参考自[eecrazy](https://github.com/eecrazy/ACM/blob/master/%E6%95%B0%E8%AE%BA/poj3233%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.cpp)\n<!-- more -->\n## 常数快速幂\n```C++\ntypedef long long ll;\nll mod_pow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res *= x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n```\n## 矩阵快速幂\n``` C++\nstruct Ma\n{\n    int m[maxn][maxn];\n};\n\nMa a,per;\nint n, mod;\n\nvoid init()//矩阵初始化\n{\n    int i,j;\n    for(i = 0; i < n; i++)\n        for(j = 0; j < n; j++)\n        {\n            scanf(\"%d\", &a.m[i][j]);\n            a.m[i][j] %= mod;\n            per.m[i][j] = (i == j);\n        }\n}\n\nMa add(Ma a,Ma b)//矩阵加法\n{\n    Ma c;\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n        {\n            c.m[i][j] = (a.m[i][j] + b.m[i][j]) % mod;\n        }\n    }\n    return c;\n}\n\n\nMa multi(Ma a,Ma b)//矩阵乘法\n{\n    Ma c;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n        {\n            c.m[i][j] = 0;\n            for(int k = 0; k < n; k++)\n            {\n                c.m[i][j] += a.m[i][k] * b.m[k][j];\n            }\n            c.m[i][j] %= mod;\n        }\n    return c;\n}\n\nMa quick_pow(long long x)//矩阵快速幂\n{\n    Ma res = per;\n    Ma p = a;\n    while(x)\n    {\n        if(x&1) res = multi(res,p);\n        p = multi(p,p);\n        x >>= 1;\n    }\n    return res;\n}\n```","slug":"quick-matrix","published":1,"updated":"2018-08-09T15:50:59.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrod004ab8ouwj8qmwdg","content":"<p>最近在做一道DP的题时发现数据范围竟然是1e18，这样的话只能用log(n)复杂度的算法来实现了，于是从队长那里了解到了矩阵快速幂。在这里记录一下快速幂以及其它矩阵处理的模板。<br>矩阵快速幂模板参考自<a href=\"https://github.com/eecrazy/ACM/blob/master/%E6%95%B0%E8%AE%BA/poj3233%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.cpp\" target=\"_blank\" rel=\"noopener\">eecrazy</a><br><a id=\"more\"></a></p>\n<h2 id=\"常数快速幂\"><a href=\"#常数快速幂\" class=\"headerlink\" title=\"常数快速幂\"></a>常数快速幂</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mod_pow</span><span class=\"params\">(ll x, ll n, ll mod)</span></span>&#123;</span><br><span class=\"line\">    ll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &amp; <span class=\"number\">1</span>) res *= x % mod;</span><br><span class=\"line\">        x = x * x % mod;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"矩阵快速幂\"><a href=\"#矩阵快速幂\" class=\"headerlink\" title=\"矩阵快速幂\"></a>矩阵快速幂</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Ma</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m[maxn][maxn];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Ma a,per;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, mod;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span><span class=\"comment\">//矩阵初始化</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a.m[i][j]);</span><br><span class=\"line\">            a.m[i][j] %= mod;</span><br><span class=\"line\">            per.m[i][j] = (i == j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">add</span><span class=\"params\">(Ma a,Ma b)</span><span class=\"comment\">//矩阵加法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            c.m[i][j] = (a.m[i][j] + b.m[i][j]) % mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">multi</span><span class=\"params\">(Ma a,Ma b)</span><span class=\"comment\">//矩阵乘法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            c.m[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                c.m[i][j] += a.m[i][k] * b.m[k][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            c.m[i][j] %= mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">quick_pow</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x)</span><span class=\"comment\">//矩阵快速幂</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma res = per;</span><br><span class=\"line\">    Ma p = a;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&amp;<span class=\"number\">1</span>) res = multi(res,p);</span><br><span class=\"line\">        p = multi(p,p);</span><br><span class=\"line\">        x &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>最近在做一道DP的题时发现数据范围竟然是1e18，这样的话只能用log(n)复杂度的算法来实现了，于是从队长那里了解到了矩阵快速幂。在这里记录一下快速幂以及其它矩阵处理的模板。<br>矩阵快速幂模板参考自<a href=\"https://github.com/eecrazy/ACM/blob/master/%E6%95%B0%E8%AE%BA/poj3233%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82.cpp\" target=\"_blank\" rel=\"noopener\">eecrazy</a><br></p>","more":"<p></p>\n<h2 id=\"常数快速幂\"><a href=\"#常数快速幂\" class=\"headerlink\" title=\"常数快速幂\"></a>常数快速幂</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ll;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">mod_pow</span><span class=\"params\">(ll x, ll n, ll mod)</span></span>&#123;</span><br><span class=\"line\">    ll res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &amp; <span class=\"number\">1</span>) res *= x % mod;</span><br><span class=\"line\">        x = x * x % mod;</span><br><span class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"矩阵快速幂\"><a href=\"#矩阵快速幂\" class=\"headerlink\" title=\"矩阵快速幂\"></a>矩阵快速幂</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Ma</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m[maxn][maxn];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Ma a,per;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, mod;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span><span class=\"comment\">//矩阵初始化</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a.m[i][j]);</span><br><span class=\"line\">            a.m[i][j] %= mod;</span><br><span class=\"line\">            per.m[i][j] = (i == j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">add</span><span class=\"params\">(Ma a,Ma b)</span><span class=\"comment\">//矩阵加法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            c.m[i][j] = (a.m[i][j] + b.m[i][j]) % mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">multi</span><span class=\"params\">(Ma a,Ma b)</span><span class=\"comment\">//矩阵乘法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            c.m[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; k++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                c.m[i][j] += a.m[i][k] * b.m[k][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            c.m[i][j] %= mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Ma <span class=\"title\">quick_pow</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x)</span><span class=\"comment\">//矩阵快速幂</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Ma res = per;</span><br><span class=\"line\">    Ma p = a;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&amp;<span class=\"number\">1</span>) res = multi(res,p);</span><br><span class=\"line\">        p = multi(p,p);</span><br><span class=\"line\">        x &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva122-二叉树构建与层次遍历","date":"2018-09-21T10:36:04.000Z","_content":"根据输入构建一颗二叉树并输出层次遍历的结果，二叉树的构建有结构体和数组两种形式。\n<!--more-->\n## 链接\n[Uva122-Trees on the level](https://vjudge.net/problem/UVA-122)\n## 题目描述\n以一组$(n, s)$的形式给定一棵二叉树，其中$n$是从根节点出发以$s$为路径到达的节点的权值。要求输出这棵二叉树的层次遍历结果。\n## 题解\n层次遍历直接用$BFS$就可以得到。关键是构建出二叉树，构建二叉树的方式有两种：一种是采用动态结构，即以结构体来表示一个节点，储存这个节点的权值、左右子树的信息；另一种是采用静态结构，即用数组来储存节点信息，例如$val[maxn]$，$left[maxn]$，$right[maxn]$分别存储节点的权值和左右子树信息。\n## 代码\n#### 动态结构\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu 20 Sep 22:23:49 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 307;\nchar s[maxn];\nbool failed;\n\nstruct Node{\n    int v;\n    Node *left, *right;\n    bool h_val;\n    Node():left(NULL), right(NULL), h_val(false){}; \n};\n\nNode* root;\n\nvoid addnode(char* s, int v){\n    int n = strlen(s);\n    Node* u = root;\n    for(int i = 0; i < n - 1; i++){\n        if(s[i] == 'L'){\n            if(u->left == NULL) u->left = new Node();\n            u = u->left;\n        }\n        else if(s[i] == 'R'){\n            if(u->right == NULL) u->right = new Node();\n            u = u->right;\n        }\n    }\n    if(u->h_val) failed = true;\n    u->v = v;\n    u->h_val = true;\n}\n\nbool read_input(){\n    int v;\n    failed = false;\n    root = new Node();\n    while(1){\n        if(scanf(\"%s\", s) == EOF) return false;\n        if(strcmp(s, \"()\") == 0) break;\n        sscanf(s + 1, \"%d\", &v);\n        addnode(strchr(s, ',') + 1, v);\n    }\n    return true;\n}\n\nvoid bfs(){\n    vector<int> vec;\n    queue<Node*> que;\n    que.push(root);\n    while(!que.empty()){\n        Node* u = que.front();\n        que.pop();\n        if(!u->h_val){\n            cout << \"not complete\" << endl;\n            return;\n        }\n        vec.push_back(u->v);\n        if(u->left != NULL) que.push(u->left);\n        if(u->right != NULL) que.push(u->right);\n    }\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(1){\n        if(read_input()){\n            if(failed) cout << \"not complete\" << endl;\n            else bfs();\n        }\n        else{\n            break;\n        }\n    }\n    return 0;\n}\n```\n#### 静态结构\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 14:10:14 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 307;\nint leftt[maxn], rightt[maxn], val[maxn];\nbool h_val[maxn], failed;\nchar s[maxn];\nint root, cnt;\n\nvoid bfs(){\n    vector<int> vec;\n    queue<int> que;\n    que.push(root);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        if(!h_val[v]){\n            cout << \"not complete\" << endl;\n            return;\n        }\n        vec.push_back(val[v]);\n        if(leftt[v]) que.push(leftt[v]);\n        if(rightt[v]) que.push(rightt[v]);\n    }\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n}\n\nvoid addnode(char* s, int v){\n    int n = strlen(s);\n    int u = root;\n    for(int i = 0; i < n - 1; i++){\n        if(s[i] == 'L'){\n            if(leftt[u] == 0){\n                cnt++;\n                leftt[u] = cnt;\n            }\n            u = leftt[u];\n        }\n        else if(s[i] == 'R'){\n            if(rightt[u] == 0){\n                cnt++;\n                rightt[u] = cnt;\n            }\n            u = rightt[u];\n        }\n    }\n    if(h_val[u]) failed = true;\n    val[u] = v;\n    h_val[u] = true;\n}\n\nbool read_input(){\n    memset(h_val, false, sizeof(h_val));\n    memset(leftt, 0, sizeof(leftt));\n    memset(rightt, 0, sizeof(rightt));\n    int v;\n    root = 1;\n    cnt = 1;\n    failed = false;\n    leftt[root] = 0, rightt[root] = 0; \n    while(1){\n        if(scanf(\"%s\", s) == EOF) return false;\n        if(strcmp(s, \"()\") == 0) break;\n        sscanf(s + 1, \"%d\", &v);\n        addnode(strchr(s, ',') + 1, v);\n    }\n    return true;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(1){\n        if(read_input()){\n            if(failed) cout << \"not complete\" << endl;\n            else bfs();\n        }\n        else\n            break;\n    }\n    \n    return 0;\n}\n```","source":"_posts/Uva122-二叉树构建与层次遍历.md","raw":"---\ntitle: Uva122-二叉树构建与层次遍历\ndate: 2018-09-21 18:36:04\ncategories:\n- ACM\n- 树\ntags:\n- 二叉树\n- BFS\n---\n根据输入构建一颗二叉树并输出层次遍历的结果，二叉树的构建有结构体和数组两种形式。\n<!--more-->\n## 链接\n[Uva122-Trees on the level](https://vjudge.net/problem/UVA-122)\n## 题目描述\n以一组$(n, s)$的形式给定一棵二叉树，其中$n$是从根节点出发以$s$为路径到达的节点的权值。要求输出这棵二叉树的层次遍历结果。\n## 题解\n层次遍历直接用$BFS$就可以得到。关键是构建出二叉树，构建二叉树的方式有两种：一种是采用动态结构，即以结构体来表示一个节点，储存这个节点的权值、左右子树的信息；另一种是采用静态结构，即用数组来储存节点信息，例如$val[maxn]$，$left[maxn]$，$right[maxn]$分别存储节点的权值和左右子树信息。\n## 代码\n#### 动态结构\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Thu 20 Sep 22:23:49 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 307;\nchar s[maxn];\nbool failed;\n\nstruct Node{\n    int v;\n    Node *left, *right;\n    bool h_val;\n    Node():left(NULL), right(NULL), h_val(false){}; \n};\n\nNode* root;\n\nvoid addnode(char* s, int v){\n    int n = strlen(s);\n    Node* u = root;\n    for(int i = 0; i < n - 1; i++){\n        if(s[i] == 'L'){\n            if(u->left == NULL) u->left = new Node();\n            u = u->left;\n        }\n        else if(s[i] == 'R'){\n            if(u->right == NULL) u->right = new Node();\n            u = u->right;\n        }\n    }\n    if(u->h_val) failed = true;\n    u->v = v;\n    u->h_val = true;\n}\n\nbool read_input(){\n    int v;\n    failed = false;\n    root = new Node();\n    while(1){\n        if(scanf(\"%s\", s) == EOF) return false;\n        if(strcmp(s, \"()\") == 0) break;\n        sscanf(s + 1, \"%d\", &v);\n        addnode(strchr(s, ',') + 1, v);\n    }\n    return true;\n}\n\nvoid bfs(){\n    vector<int> vec;\n    queue<Node*> que;\n    que.push(root);\n    while(!que.empty()){\n        Node* u = que.front();\n        que.pop();\n        if(!u->h_val){\n            cout << \"not complete\" << endl;\n            return;\n        }\n        vec.push_back(u->v);\n        if(u->left != NULL) que.push(u->left);\n        if(u->right != NULL) que.push(u->right);\n    }\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(1){\n        if(read_input()){\n            if(failed) cout << \"not complete\" << endl;\n            else bfs();\n        }\n        else{\n            break;\n        }\n    }\n    return 0;\n}\n```\n#### 静态结构\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 14:10:14 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 307;\nint leftt[maxn], rightt[maxn], val[maxn];\nbool h_val[maxn], failed;\nchar s[maxn];\nint root, cnt;\n\nvoid bfs(){\n    vector<int> vec;\n    queue<int> que;\n    que.push(root);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        if(!h_val[v]){\n            cout << \"not complete\" << endl;\n            return;\n        }\n        vec.push_back(val[v]);\n        if(leftt[v]) que.push(leftt[v]);\n        if(rightt[v]) que.push(rightt[v]);\n    }\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n}\n\nvoid addnode(char* s, int v){\n    int n = strlen(s);\n    int u = root;\n    for(int i = 0; i < n - 1; i++){\n        if(s[i] == 'L'){\n            if(leftt[u] == 0){\n                cnt++;\n                leftt[u] = cnt;\n            }\n            u = leftt[u];\n        }\n        else if(s[i] == 'R'){\n            if(rightt[u] == 0){\n                cnt++;\n                rightt[u] = cnt;\n            }\n            u = rightt[u];\n        }\n    }\n    if(h_val[u]) failed = true;\n    val[u] = v;\n    h_val[u] = true;\n}\n\nbool read_input(){\n    memset(h_val, false, sizeof(h_val));\n    memset(leftt, 0, sizeof(leftt));\n    memset(rightt, 0, sizeof(rightt));\n    int v;\n    root = 1;\n    cnt = 1;\n    failed = false;\n    leftt[root] = 0, rightt[root] = 0; \n    while(1){\n        if(scanf(\"%s\", s) == EOF) return false;\n        if(strcmp(s, \"()\") == 0) break;\n        sscanf(s + 1, \"%d\", &v);\n        addnode(strchr(s, ',') + 1, v);\n    }\n    return true;\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    while(1){\n        if(read_input()){\n            if(failed) cout << \"not complete\" << endl;\n            else bfs();\n        }\n        else\n            break;\n    }\n    \n    return 0;\n}\n```","slug":"Uva122-二叉树构建与层次遍历","published":1,"updated":"2018-12-14T13:06:28.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrof004fb8ouu54k4qgn","content":"<p>根据输入构建一颗二叉树并输出层次遍历的结果，二叉树的构建有结构体和数组两种形式。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-122\" target=\"_blank\" rel=\"noopener\">Uva122-Trees on the level</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>以一组$(n, s)$的形式给定一棵二叉树，其中$n$是从根节点出发以$s$为路径到达的节点的权值。要求输出这棵二叉树的层次遍历结果。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>层次遍历直接用$BFS$就可以得到。关键是构建出二叉树，构建二叉树的方式有两种：一种是采用动态结构，即以结构体来表示一个节点，储存这个节点的权值、左右子树的信息；另一种是采用静态结构，即用数组来储存节点信息，例如$val[maxn]$，$left[maxn]$，$right[maxn]$分别存储节点的权值和左右子树信息。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h4 id=\"动态结构\"><a href=\"#动态结构\" class=\"headerlink\" title=\"动态结构\"></a>动态结构</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Thu 20 Sep 22:23:49 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">307</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> s[maxn];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> failed;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    Node *left, *right;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> h_val;</span><br><span class=\"line\">    Node():left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>), h_val(<span class=\"literal\">false</span>)&#123;&#125;; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Node* root;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addnode</span><span class=\"params\">(<span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    Node* u = root;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'L'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(u-&gt;left == <span class=\"literal\">NULL</span>) u-&gt;left = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">            u = u-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'R'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(u-&gt;right == <span class=\"literal\">NULL</span>) u-&gt;right = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">            u = u-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(u-&gt;h_val) failed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    u-&gt;v = v;</span><br><span class=\"line\">    u-&gt;h_val = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">read_input</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    failed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    root = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, s) == EOF) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(s, <span class=\"string\">\"()\"</span>) == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">sscanf</span>(s + <span class=\"number\">1</span>, <span class=\"string\">\"%d\"</span>, &amp;v);</span><br><span class=\"line\">        addnode(<span class=\"built_in\">strchr</span>(s, <span class=\"string\">','</span>) + <span class=\"number\">1</span>, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;Node*&gt; que;</span><br><span class=\"line\">    que.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        Node* u = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!u-&gt;h_val)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not complete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vec.push_back(u-&gt;v);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(u-&gt;left != <span class=\"literal\">NULL</span>) que.push(u-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(u-&gt;right != <span class=\"literal\">NULL</span>) que.push(u-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; vec.size(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; vec[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; vec[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(read_input())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(failed) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not complete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> bfs();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"静态结构\"><a href=\"#静态结构\" class=\"headerlink\" title=\"静态结构\"></a>静态结构</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Fri 21 Sep 14:10:14 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">307</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> leftt[maxn], rightt[maxn], val[maxn];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> h_val[maxn], failed;</span><br><span class=\"line\"><span class=\"keyword\">char</span> s[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> root, cnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; que;</span><br><span class=\"line\">    que.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!h_val[v])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not complete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vec.push_back(val[v]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(leftt[v]) que.push(leftt[v]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rightt[v]) que.push(rightt[v]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; vec.size(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; vec[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; vec[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addnode</span><span class=\"params\">(<span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> u = root;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'L'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(leftt[u] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                leftt[u] = cnt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            u = leftt[u];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'R'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(rightt[u] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                rightt[u] = cnt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            u = rightt[u];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(h_val[u]) failed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    val[u] = v;</span><br><span class=\"line\">    h_val[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">read_input</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h_val, <span class=\"literal\">false</span>, <span class=\"keyword\">sizeof</span>(h_val));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(leftt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(leftt));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(rightt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(rightt));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    root = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    failed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    leftt[root] = <span class=\"number\">0</span>, rightt[root] = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, s) == EOF) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(s, <span class=\"string\">\"()\"</span>) == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">sscanf</span>(s + <span class=\"number\">1</span>, <span class=\"string\">\"%d\"</span>, &amp;v);</span><br><span class=\"line\">        addnode(<span class=\"built_in\">strchr</span>(s, <span class=\"string\">','</span>) + <span class=\"number\">1</span>, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(read_input())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(failed) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not complete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> bfs();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>根据输入构建一颗二叉树并输出层次遍历的结果，二叉树的构建有结构体和数组两种形式。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-122\" target=\"_blank\" rel=\"noopener\">Uva122-Trees on the level</a></p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>以一组$(n, s)$的形式给定一棵二叉树，其中$n$是从根节点出发以$s$为路径到达的节点的权值。要求输出这棵二叉树的层次遍历结果。</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>层次遍历直接用$BFS$就可以得到。关键是构建出二叉树，构建二叉树的方式有两种：一种是采用动态结构，即以结构体来表示一个节点，储存这个节点的权值、左右子树的信息；另一种是采用静态结构，即用数组来储存节点信息，例如$val[maxn]$，$left[maxn]$，$right[maxn]$分别存储节点的权值和左右子树信息。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h4 id=\"动态结构\"><a href=\"#动态结构\" class=\"headerlink\" title=\"动态结构\"></a>动态结构</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Thu 20 Sep 22:23:49 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">307</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> s[maxn];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> failed;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    Node *left, *right;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> h_val;</span><br><span class=\"line\">    Node():left(<span class=\"literal\">NULL</span>), right(<span class=\"literal\">NULL</span>), h_val(<span class=\"literal\">false</span>)&#123;&#125;; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Node* root;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addnode</span><span class=\"params\">(<span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    Node* u = root;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'L'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(u-&gt;left == <span class=\"literal\">NULL</span>) u-&gt;left = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">            u = u-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'R'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(u-&gt;right == <span class=\"literal\">NULL</span>) u-&gt;right = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">            u = u-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(u-&gt;h_val) failed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    u-&gt;v = v;</span><br><span class=\"line\">    u-&gt;h_val = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">read_input</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    failed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    root = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, s) == EOF) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(s, <span class=\"string\">\"()\"</span>) == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">sscanf</span>(s + <span class=\"number\">1</span>, <span class=\"string\">\"%d\"</span>, &amp;v);</span><br><span class=\"line\">        addnode(<span class=\"built_in\">strchr</span>(s, <span class=\"string\">','</span>) + <span class=\"number\">1</span>, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;Node*&gt; que;</span><br><span class=\"line\">    que.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        Node* u = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!u-&gt;h_val)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not complete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vec.push_back(u-&gt;v);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(u-&gt;left != <span class=\"literal\">NULL</span>) que.push(u-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(u-&gt;right != <span class=\"literal\">NULL</span>) que.push(u-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; vec.size(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; vec[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; vec[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(read_input())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(failed) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not complete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> bfs();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"静态结构\"><a href=\"#静态结构\" class=\"headerlink\" title=\"静态结构\"></a>静态结构</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Fri 21 Sep 14:10:14 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">307</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> leftt[maxn], rightt[maxn], val[maxn];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> h_val[maxn], failed;</span><br><span class=\"line\"><span class=\"keyword\">char</span> s[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> root, cnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; que;</span><br><span class=\"line\">    que.push(root);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!que.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = que.front();</span><br><span class=\"line\">        que.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!h_val[v])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not complete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vec.push_back(val[v]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(leftt[v]) que.push(leftt[v]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rightt[v]) que.push(rightt[v]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; vec.size(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; vec[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; vec[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addnode</span><span class=\"params\">(<span class=\"keyword\">char</span>* s, <span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> u = root;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'L'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(leftt[u] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                leftt[u] = cnt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            u = leftt[u];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">'R'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(rightt[u] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                rightt[u] = cnt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            u = rightt[u];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(h_val[u]) failed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    val[u] = v;</span><br><span class=\"line\">    h_val[u] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">read_input</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(h_val, <span class=\"literal\">false</span>, <span class=\"keyword\">sizeof</span>(h_val));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(leftt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(leftt));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(rightt, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(rightt));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    root = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    failed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    leftt[root] = <span class=\"number\">0</span>, rightt[root] = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, s) == EOF) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(s, <span class=\"string\">\"()\"</span>) == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"built_in\">sscanf</span>(s + <span class=\"number\">1</span>, <span class=\"string\">\"%d\"</span>, &amp;v);</span><br><span class=\"line\">        addnode(<span class=\"built_in\">strchr</span>(s, <span class=\"string\">','</span>) + <span class=\"number\">1</span>, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(read_input())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(failed) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"not complete\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> bfs();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva725-Division-暴力枚举","date":"2018-12-17T11:41:14.000Z","_content":"求满足$$\\frac{abcde}{fghij} = N$$的所有$abcde$ 和 $fghij$的值，其中$2 <= N <= 79。$\n刘汝佳老师：``即使采用暴力法求解问题，对问题进行一定的分析往往会让算法更简介、高效。``\n受益匪浅。\n<!--more-->\n## 链接\n[Uva725-Division](https://vjudge.net/problem/UVA-725)\n\n## 题解\n一开始直接DFS暴力出来0~9的不同排列，判断是否满足条件，TL了。看了刘汝佳老师的解法，只枚举$fghij$，然后算出$abcde$，再判断是否所有数字都不相同。而且当$abcde$ 和 $fghij$加起来超过10位时可以终止枚举。复杂度大大降低。\n\n## 代码-循环枚举\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 17 Dec 07:05:55 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nchar buff[100];\nbool flag;\nstruct Node{\n    Node(int a, int b):a(a), b(b){}\n    int a, b;\n};\nvector<Node> vec;\nint cnt = 0;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        if(n == 0) break;\n        if(cnt++) cout << endl;\n        vec.clear();\n        for(int a = 1234; ; a++){\n            int b = n * a;\n            //cout << a << \" \" << b << endl;\n            sprintf(buff, \"%05d%05d\", a, b);\n            if(strlen(buff) > 10) break;\n            sort(buff, buff + 10);\n            flag = false;\n            for(int i = 0; i < 10; i++){\n                if(buff[i] != '0' + i){\n                    flag = true;\n                    break;\n                }\n            }\n            if(!flag) vec.push_back(Node(a, b));\n        }\n\n        int len = vec.size();\n        if(len == 0) cout << \"There are no solutions for \" << n << \".\" << endl;\n        else{\n            for(auto x : vec){\n                cout << setfill('0') << setw(5) << x.b;\n                cout << \" / \";\n                cout << setfill('0') << setw(5) << x.a;\n                cout << \" = \";\n                cout << n << endl;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n## 代码-DFS枚举\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 16 Dec 17:39:29 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nbool vis[10];\nbool test[10];\nvector<int> vec;\nint a, b;\nstruct Node{\n    Node(int u, int v):u(u), v(v){}\n    int u, v;\n};\nvector<Node> ans;\nbool flag;\n\nbool ok(){\n    a = 0;\n    for(int i = 0; i < 5; i++){\n        a *= 10;\n        a += vec[i];\n    }\n    b = a * n;\n    vector<int> tmp;\n    int b2 = b;\n    for(int i = 0; i < 5; i++){\n        tmp.push_back(vec[i]);\n        tmp.push_back(b2 % 10);\n        b2 /= 10;\n    }\n    if(b2){\n        flag = true;\n        return false;\n    }\n\n    memset(test, 0, sizeof(test));\n    int cnt = 0;\n    for(int i = 0; i < 10; i++){\n        int val = tmp[i];\n        if(!test[val]){\n            cnt++;\n            test[val] = 1;\n        }\n    }\n    if(cnt == 10) return true;\n    else return false;\n\n}\n\nvoid dfs(){\n    if(flag) return; // over 10 bits, no need to enumerate\n    if(vec.size() == 5){\n        if(ok()){\n            ans.push_back(Node(b, a));\n        }\n        return;\n    }\n    for(int i = 0; i <= 9; i++){\n        if(!vis[i]){\n            vec.push_back(i);\n            vis[i] = 1;\n            dfs();\n            vec.pop_back();\n            vis[i] = 0;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 0;\n    while(cin >> n){\n        if(n == 0) break;\n\n        cnt++;\n        if(cnt > 1) cout << endl;\n        \n        memset(vis, 0, sizeof(vis));\n        ans.clear();\n        vec.clear();\n        flag = false;\n\n        dfs();\n        if(ans.size() == 0){\n            cout << \"There are no solutions for \" << n << \".\" << endl;\n        }\n        else{\n            for(auto x : ans){\n                cout << right << setfill('0') << setw(5) << x.u << \" / \";\n                cout << right << setfill('0') << setw(5) << x.v << \" = \" << n << endl;\n            }\n        }\n    }\n    return 0;\n}\n```","source":"_posts/Uva725-Division.md","raw":"---\ntitle: Uva725-Division-暴力枚举\ndate: 2018-12-17 19:41:14\ncategories:\n- ACM\n- 暴力枚举\ntags:\n- 暴力枚举\n---\n求满足$$\\frac{abcde}{fghij} = N$$的所有$abcde$ 和 $fghij$的值，其中$2 <= N <= 79。$\n刘汝佳老师：``即使采用暴力法求解问题，对问题进行一定的分析往往会让算法更简介、高效。``\n受益匪浅。\n<!--more-->\n## 链接\n[Uva725-Division](https://vjudge.net/problem/UVA-725)\n\n## 题解\n一开始直接DFS暴力出来0~9的不同排列，判断是否满足条件，TL了。看了刘汝佳老师的解法，只枚举$fghij$，然后算出$abcde$，再判断是否所有数字都不相同。而且当$abcde$ 和 $fghij$加起来超过10位时可以终止枚举。复杂度大大降低。\n\n## 代码-循环枚举\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 17 Dec 07:05:55 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nchar buff[100];\nbool flag;\nstruct Node{\n    Node(int a, int b):a(a), b(b){}\n    int a, b;\n};\nvector<Node> vec;\nint cnt = 0;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\n    while(cin >> n){\n        if(n == 0) break;\n        if(cnt++) cout << endl;\n        vec.clear();\n        for(int a = 1234; ; a++){\n            int b = n * a;\n            //cout << a << \" \" << b << endl;\n            sprintf(buff, \"%05d%05d\", a, b);\n            if(strlen(buff) > 10) break;\n            sort(buff, buff + 10);\n            flag = false;\n            for(int i = 0; i < 10; i++){\n                if(buff[i] != '0' + i){\n                    flag = true;\n                    break;\n                }\n            }\n            if(!flag) vec.push_back(Node(a, b));\n        }\n\n        int len = vec.size();\n        if(len == 0) cout << \"There are no solutions for \" << n << \".\" << endl;\n        else{\n            for(auto x : vec){\n                cout << setfill('0') << setw(5) << x.b;\n                cout << \" / \";\n                cout << setfill('0') << setw(5) << x.a;\n                cout << \" = \";\n                cout << n << endl;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n## 代码-DFS枚举\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Sun 16 Dec 17:39:29 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nbool vis[10];\nbool test[10];\nvector<int> vec;\nint a, b;\nstruct Node{\n    Node(int u, int v):u(u), v(v){}\n    int u, v;\n};\nvector<Node> ans;\nbool flag;\n\nbool ok(){\n    a = 0;\n    for(int i = 0; i < 5; i++){\n        a *= 10;\n        a += vec[i];\n    }\n    b = a * n;\n    vector<int> tmp;\n    int b2 = b;\n    for(int i = 0; i < 5; i++){\n        tmp.push_back(vec[i]);\n        tmp.push_back(b2 % 10);\n        b2 /= 10;\n    }\n    if(b2){\n        flag = true;\n        return false;\n    }\n\n    memset(test, 0, sizeof(test));\n    int cnt = 0;\n    for(int i = 0; i < 10; i++){\n        int val = tmp[i];\n        if(!test[val]){\n            cnt++;\n            test[val] = 1;\n        }\n    }\n    if(cnt == 10) return true;\n    else return false;\n\n}\n\nvoid dfs(){\n    if(flag) return; // over 10 bits, no need to enumerate\n    if(vec.size() == 5){\n        if(ok()){\n            ans.push_back(Node(b, a));\n        }\n        return;\n    }\n    for(int i = 0; i <= 9; i++){\n        if(!vis[i]){\n            vec.push_back(i);\n            vis[i] = 1;\n            dfs();\n            vec.pop_back();\n            vis[i] = 0;\n        }\n    }\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    int cnt = 0;\n    while(cin >> n){\n        if(n == 0) break;\n\n        cnt++;\n        if(cnt > 1) cout << endl;\n        \n        memset(vis, 0, sizeof(vis));\n        ans.clear();\n        vec.clear();\n        flag = false;\n\n        dfs();\n        if(ans.size() == 0){\n            cout << \"There are no solutions for \" << n << \".\" << endl;\n        }\n        else{\n            for(auto x : ans){\n                cout << right << setfill('0') << setw(5) << x.u << \" / \";\n                cout << right << setfill('0') << setw(5) << x.v << \" = \" << n << endl;\n            }\n        }\n    }\n    return 0;\n}\n```","slug":"Uva725-Division","published":1,"updated":"2018-12-17T12:10:09.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslroh004ib8ou3o82hm7z","content":"<p>求满足$$\\frac{abcde}{fghij} = N$$的所有$abcde$ 和 $fghij$的值，其中$2 &lt;= N &lt;= 79。$<br>刘汝佳老师：<code>即使采用暴力法求解问题，对问题进行一定的分析往往会让算法更简介、高效。</code><br>受益匪浅。<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-725\" target=\"_blank\" rel=\"noopener\">Uva725-Division</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一开始直接DFS暴力出来0~9的不同排列，判断是否满足条件，TL了。看了刘汝佳老师的解法，只枚举$fghij$，然后算出$abcde$，再判断是否所有数字都不相同。而且当$abcde$ 和 $fghij$加起来超过10位时可以终止枚举。复杂度大大降低。</p>\n<h2 id=\"代码-循环枚举\"><a href=\"#代码-循环枚举\" class=\"headerlink\" title=\"代码-循环枚举\"></a>代码-循环枚举</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon 17 Dec 07:05:55 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buff[<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b):a(a), b(b)&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Node&gt; vec;</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt++) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> a = <span class=\"number\">1234</span>; ; a++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = n * a;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"built_in\">sprintf</span>(buff, <span class=\"string\">\"%05d%05d\"</span>, a, b);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">strlen</span>(buff) &gt; <span class=\"number\">10</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            sort(buff, buff + <span class=\"number\">10</span>);</span><br><span class=\"line\">            flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(buff[i] != <span class=\"string\">'0'</span> + i)&#123;</span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!flag) vec.push_back(Node(a, b));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = vec.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"There are no solutions for \"</span> &lt;&lt; n &lt;&lt; <span class=\"string\">\".\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : vec)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; setfill(<span class=\"string\">'0'</span>) &lt;&lt; setw(<span class=\"number\">5</span>) &lt;&lt; x.b;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" / \"</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; setfill(<span class=\"string\">'0'</span>) &lt;&lt; setw(<span class=\"number\">5</span>) &lt;&lt; x.a;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" = \"</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; n &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码-DFS枚举\"><a href=\"#代码-DFS枚举\" class=\"headerlink\" title=\"代码-DFS枚举\"></a>代码-DFS枚举</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun 16 Dec 17:39:29 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> test[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v):u(u), v(v)&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> u, v;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Node&gt; ans;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">        a *= <span class=\"number\">10</span>;</span><br><span class=\"line\">        a += vec[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b = a * n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b2 = b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">        tmp.push_back(vec[i]);</span><br><span class=\"line\">        tmp.push_back(b2 % <span class=\"number\">10</span>);</span><br><span class=\"line\">        b2 /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b2)&#123;</span><br><span class=\"line\">        flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(test, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(test));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> val = tmp[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!test[val])&#123;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">            test[val] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt == <span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">return</span>; <span class=\"comment\">// over 10 bits, no need to enumerate</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vec.size() == <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ok())&#123;</span><br><span class=\"line\">            ans.push_back(Node(b, a));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">9</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i])&#123;</span><br><span class=\"line\">            vec.push_back(i);</span><br><span class=\"line\">            vis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs();</span><br><span class=\"line\">            vec.pop_back();</span><br><span class=\"line\">            vis[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">1</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        ans.clear();</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        dfs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans.size() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"There are no solutions for \"</span> &lt;&lt; n &lt;&lt; <span class=\"string\">\".\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : ans)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; right &lt;&lt; setfill(<span class=\"string\">'0'</span>) &lt;&lt; setw(<span class=\"number\">5</span>) &lt;&lt; x.u &lt;&lt; <span class=\"string\">\" / \"</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; right &lt;&lt; setfill(<span class=\"string\">'0'</span>) &lt;&lt; setw(<span class=\"number\">5</span>) &lt;&lt; x.v &lt;&lt; <span class=\"string\">\" = \"</span> &lt;&lt; n &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>求满足$$\\frac{abcde}{fghij} = N$$的所有$abcde$ 和 $fghij$的值，其中$2 &lt;= N &lt;= 79。$<br>刘汝佳老师：<code>即使采用暴力法求解问题，对问题进行一定的分析往往会让算法更简介、高效。</code><br>受益匪浅。<br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-725\" target=\"_blank\" rel=\"noopener\">Uva725-Division</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一开始直接DFS暴力出来0~9的不同排列，判断是否满足条件，TL了。看了刘汝佳老师的解法，只枚举$fghij$，然后算出$abcde$，再判断是否所有数字都不相同。而且当$abcde$ 和 $fghij$加起来超过10位时可以终止枚举。复杂度大大降低。</p>\n<h2 id=\"代码-循环枚举\"><a href=\"#代码-循环枚举\" class=\"headerlink\" title=\"代码-循环枚举\"></a>代码-循环枚举</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon 17 Dec 07:05:55 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buff[<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b):a(a), b(b)&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Node&gt; vec;</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt++) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> a = <span class=\"number\">1234</span>; ; a++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> b = n * a;</span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"built_in\">sprintf</span>(buff, <span class=\"string\">\"%05d%05d\"</span>, a, b);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">strlen</span>(buff) &gt; <span class=\"number\">10</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            sort(buff, buff + <span class=\"number\">10</span>);</span><br><span class=\"line\">            flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(buff[i] != <span class=\"string\">'0'</span> + i)&#123;</span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!flag) vec.push_back(Node(a, b));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = vec.size();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"There are no solutions for \"</span> &lt;&lt; n &lt;&lt; <span class=\"string\">\".\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : vec)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; setfill(<span class=\"string\">'0'</span>) &lt;&lt; setw(<span class=\"number\">5</span>) &lt;&lt; x.b;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" / \"</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; setfill(<span class=\"string\">'0'</span>) &lt;&lt; setw(<span class=\"number\">5</span>) &lt;&lt; x.a;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" = \"</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; n &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"代码-DFS枚举\"><a href=\"#代码-DFS枚举\" class=\"headerlink\" title=\"代码-DFS枚举\"></a>代码-DFS枚举</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Sun 16 Dec 17:39:29 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> test[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> u, <span class=\"keyword\">int</span> v):u(u), v(v)&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> u, v;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Node&gt; ans;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">        a *= <span class=\"number\">10</span>;</span><br><span class=\"line\">        a += vec[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b = a * n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; tmp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b2 = b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)&#123;</span><br><span class=\"line\">        tmp.push_back(vec[i]);</span><br><span class=\"line\">        tmp.push_back(b2 % <span class=\"number\">10</span>);</span><br><span class=\"line\">        b2 /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b2)&#123;</span><br><span class=\"line\">        flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(test, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(test));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> val = tmp[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!test[val])&#123;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">            test[val] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt == <span class=\"number\">10</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">return</span>; <span class=\"comment\">// over 10 bits, no need to enumerate</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vec.size() == <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ok())&#123;</span><br><span class=\"line\">            ans.push_back(Node(b, a));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">9</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i])&#123;</span><br><span class=\"line\">            vec.push_back(i);</span><br><span class=\"line\">            vis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs();</span><br><span class=\"line\">            vec.pop_back();</span><br><span class=\"line\">            vis[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt; <span class=\"number\">1</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        ans.clear();</span><br><span class=\"line\">        vec.clear();</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        dfs();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans.size() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"There are no solutions for \"</span> &lt;&lt; n &lt;&lt; <span class=\"string\">\".\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> x : ans)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; right &lt;&lt; setfill(<span class=\"string\">'0'</span>) &lt;&lt; setw(<span class=\"number\">5</span>) &lt;&lt; x.u &lt;&lt; <span class=\"string\">\" / \"</span>;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; right &lt;&lt; setfill(<span class=\"string\">'0'</span>) &lt;&lt; setw(<span class=\"number\">5</span>) &lt;&lt; x.v &lt;&lt; <span class=\"string\">\" = \"</span> &lt;&lt; n &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"线段树单点更新模板","date":"2018-05-06T13:47:10.000Z","_content":"之前一直在用大白上的线段树单点更新模板，最近渐渐发现有一些不太舒服的地方，一方面是大白上的模板会强行把线段树建成一个满二叉树，这样虽然比较好理解一些，但同时也会因为要考虑多出来的那些点的影响而相对麻烦。另一方面是因为大家貌似都不用大白上的线段树模板= =||，这样搜题解以及和队友交流的时候会存在一些障碍（其实这一方面是主要原因），所以最后通过权衡还是选择了一个自己觉得通用性比较好也比较好实现的模板。[参考博客链接](http://www.hysonn.com/2017/01/26/segtree/)\nPs:关于线段树区间更新目前正在学习中，之后再补上关于区间更新的模板。\n<!-- more -->\n## 基于最大值查询的线段树模板\n```C++\n//首先定义线段树的结构体\nstruct SegTree{\n    int vl, vr;         //每个tree[k]对应一个节点，其中vl, vr是节点对应的区间\n    int mv;             //表示节点维护的数据，视情况而定，以维护区间最大值为例\n}tree[maxn << 2];       //绝对安全的情况是建议开四倍数据量的大小\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\n```\n## 例题实现\n[HDU-1754--I Hate It(线段树单点更新入门题)](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint n, m;\nstruct SegTree{\n    int vl, vr;\n    int mv;\n}tree[maxn << 2];\n\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)//doubt\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\t\n    while(~scanf(\"%d%d\", &n, &m)){\n        char c[10];\n        int a, b;\n        for(int i = 1; i <= n; i++){\n            scanf(\"%d\", &d[i]);\n        }\n        build(1, 1, n);\n        for(int i = 1; i <= m; i++){\n            scanf(\"%s%d%d\", c, &a, &b);\n            if(c[0] == 'Q')\n                printf(\"%d\\n\", query(1, a, b));\n            else if(c[0] == 'U')\n            update(1, a, b);\n        }\n\t\t\n\t}\n\t\n    return 0;\n}\n```\n\n","source":"_posts/segtree-template.md","raw":"---\ntitle: 线段树单点更新模板\ndate: 2018-05-06 21:47:10\ncategories:\n- Template\ntags:\n- 线段树单点更新\n---\n之前一直在用大白上的线段树单点更新模板，最近渐渐发现有一些不太舒服的地方，一方面是大白上的模板会强行把线段树建成一个满二叉树，这样虽然比较好理解一些，但同时也会因为要考虑多出来的那些点的影响而相对麻烦。另一方面是因为大家貌似都不用大白上的线段树模板= =||，这样搜题解以及和队友交流的时候会存在一些障碍（其实这一方面是主要原因），所以最后通过权衡还是选择了一个自己觉得通用性比较好也比较好实现的模板。[参考博客链接](http://www.hysonn.com/2017/01/26/segtree/)\nPs:关于线段树区间更新目前正在学习中，之后再补上关于区间更新的模板。\n<!-- more -->\n## 基于最大值查询的线段树模板\n```C++\n//首先定义线段树的结构体\nstruct SegTree{\n    int vl, vr;         //每个tree[k]对应一个节点，其中vl, vr是节点对应的区间\n    int mv;             //表示节点维护的数据，视情况而定，以维护区间最大值为例\n}tree[maxn << 2];       //绝对安全的情况是建议开四倍数据量的大小\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\n```\n## 例题实现\n[HDU-1754--I Hate It(线段树单点更新入门题)](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 7;\nint n, m;\nstruct SegTree{\n    int vl, vr;\n    int mv;\n}tree[maxn << 2];\n\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    if(l == r){\n        tree[k].mv = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv);\n}\n\nvoid update(int k, int pos, int val){\n    if(tree[k].vl == tree[k].vr){\n        tree[k].mv = val;\n        return;\n    }\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(pos <= mid)//doubt\n        update(k << 1, pos, val);\n    else\n        update(k << 1 | 1, pos, val);\n    tree[k].mv = max(tree[k << 1].mv, tree[k << 1 | 1].mv); \n}\n\nint query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr)\n        return tree[k].mv;\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return max(query(k << 1, l, mid), query(k << 1 | 1, mid + 1, r));\n\t\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n\t\n    while(~scanf(\"%d%d\", &n, &m)){\n        char c[10];\n        int a, b;\n        for(int i = 1; i <= n; i++){\n            scanf(\"%d\", &d[i]);\n        }\n        build(1, 1, n);\n        for(int i = 1; i <= m; i++){\n            scanf(\"%s%d%d\", c, &a, &b);\n            if(c[0] == 'Q')\n                printf(\"%d\\n\", query(1, a, b));\n            else if(c[0] == 'U')\n            update(1, a, b);\n        }\n\t\t\n\t}\n\t\n    return 0;\n}\n```\n\n","slug":"segtree-template","published":1,"updated":"2018-11-13T12:06:32.426Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslroj004mb8ous4w8khc7","content":"<p>之前一直在用大白上的线段树单点更新模板，最近渐渐发现有一些不太舒服的地方，一方面是大白上的模板会强行把线段树建成一个满二叉树，这样虽然比较好理解一些，但同时也会因为要考虑多出来的那些点的影响而相对麻烦。另一方面是因为大家貌似都不用大白上的线段树模板= =||，这样搜题解以及和队友交流的时候会存在一些障碍（其实这一方面是主要原因），所以最后通过权衡还是选择了一个自己觉得通用性比较好也比较好实现的模板。<a href=\"http://www.hysonn.com/2017/01/26/segtree/\" target=\"_blank\" rel=\"noopener\">参考博客链接</a><br>Ps:关于线段树区间更新目前正在学习中，之后再补上关于区间更新的模板。<br><a id=\"more\"></a></p>\n<h2 id=\"基于最大值查询的线段树模板\"><a href=\"#基于最大值查询的线段树模板\" class=\"headerlink\" title=\"基于最大值查询的线段树模板\"></a>基于最大值查询的线段树模板</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先定义线段树的结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;         <span class=\"comment\">//每个tree[k]对应一个节点，其中vl, vr是节点对应的区间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mv;             <span class=\"comment\">//表示节点维护的数据，视情况而定，以维护区间最大值为例</span></span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];       <span class=\"comment\">//绝对安全的情况是建议开四倍数据量的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].mv = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].vl == tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].mv = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].mv;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(query(k &lt;&lt; <span class=\"number\">1</span>, l, mid), query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r));</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例题实现\"><a href=\"#例题实现\" class=\"headerlink\" title=\"例题实现\"></a>例题实现</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1754\" target=\"_blank\" rel=\"noopener\">HDU-1754–I Hate It(线段树单点更新入门题)</a><br>AC代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">2e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mv;</span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].mv = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].vl == tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].mv = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= mid)<span class=\"comment\">//doubt</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].mv;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(query(k &lt;&lt; <span class=\"number\">1</span>, l, mid), query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r));</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;d[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%d%d\"</span>, c, &amp;a, &amp;b);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, query(<span class=\"number\">1</span>, a, b));</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'U'</span>)</span><br><span class=\"line\">            update(<span class=\"number\">1</span>, a, b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>之前一直在用大白上的线段树单点更新模板，最近渐渐发现有一些不太舒服的地方，一方面是大白上的模板会强行把线段树建成一个满二叉树，这样虽然比较好理解一些，但同时也会因为要考虑多出来的那些点的影响而相对麻烦。另一方面是因为大家貌似都不用大白上的线段树模板= =||，这样搜题解以及和队友交流的时候会存在一些障碍（其实这一方面是主要原因），所以最后通过权衡还是选择了一个自己觉得通用性比较好也比较好实现的模板。<a href=\"http://www.hysonn.com/2017/01/26/segtree/\" target=\"_blank\" rel=\"noopener\">参考博客链接</a><br>Ps:关于线段树区间更新目前正在学习中，之后再补上关于区间更新的模板。<br></p>","more":"<p></p>\n<h2 id=\"基于最大值查询的线段树模板\"><a href=\"#基于最大值查询的线段树模板\" class=\"headerlink\" title=\"基于最大值查询的线段树模板\"></a>基于最大值查询的线段树模板</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先定义线段树的结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;         <span class=\"comment\">//每个tree[k]对应一个节点，其中vl, vr是节点对应的区间</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mv;             <span class=\"comment\">//表示节点维护的数据，视情况而定，以维护区间最大值为例</span></span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];       <span class=\"comment\">//绝对安全的情况是建议开四倍数据量的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].mv = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].vl == tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].mv = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].mv;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(query(k &lt;&lt; <span class=\"number\">1</span>, l, mid), query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r));</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例题实现\"><a href=\"#例题实现\" class=\"headerlink\" title=\"例题实现\"></a>例题实现</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1754\" target=\"_blank\" rel=\"noopener\">HDU-1754–I Hate It(线段树单点更新入门题)</a><br>AC代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">2e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mv;</span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].mv = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> pos, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].vl == tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].mv = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= mid)<span class=\"comment\">//doubt</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, pos, val);</span><br><span class=\"line\">    tree[k].mv = max(tree[k &lt;&lt; <span class=\"number\">1</span>].mv, tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].mv); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].mv;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(query(k &lt;&lt; <span class=\"number\">1</span>, l, mid), query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r));</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;d[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s%d%d\"</span>, c, &amp;a, &amp;b);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, query(<span class=\"number\">1</span>, a, b));</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c[<span class=\"number\">0</span>] == <span class=\"string\">'U'</span>)</span><br><span class=\"line\">            update(<span class=\"number\">1</span>, a, b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"sscanf & sprintf","date":"2018-09-15T14:32:35.000Z","_content":"关于$sscanf$和$sprintf$用法的总结。\n<!--more-->\n## sscanf\nint sscanf（const char * str，const char * format，...）从字符串中读取格式化的输入。\n### Example\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main () {\n   int day, year;\n   char weekday[20], month[20], dtm[100];\n\n   strcpy( dtm, \"Saturday March 25 1989\" );\n   sscanf( dtm, \"%s %s %d  %d\", weekday, month, &day, &year );\n\n   printf(\"%s %d, %d = %s\\n\", month, day, year, weekday );\n    \n   return(0);\n}\n```\n### Output\n```\nMarch 25, 1989 = Saturday\n```\n## sprintf\nint sprintf（char * str，const char * format，...）将格式化的输出发送到str指向的字符串。\n### Example\n```C\n#include <stdio.h>\n#include <math.h>\n\nint main () {\n   char str[80];\n\n   sprintf(str, \"Value of Pi = %f\", M_PI);\n   puts(str);\n   \n   return(0);\n}\n```\n### Output\n```\nValue of Pi = 3.141593\n```","source":"_posts/sscanf-sprintf.md","raw":"---\ntitle: sscanf & sprintf\ndate: 2018-09-15 22:32:35\ncategories:\n- C++\ntags:\n- 总结\n---\n关于$sscanf$和$sprintf$用法的总结。\n<!--more-->\n## sscanf\nint sscanf（const char * str，const char * format，...）从字符串中读取格式化的输入。\n### Example\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main () {\n   int day, year;\n   char weekday[20], month[20], dtm[100];\n\n   strcpy( dtm, \"Saturday March 25 1989\" );\n   sscanf( dtm, \"%s %s %d  %d\", weekday, month, &day, &year );\n\n   printf(\"%s %d, %d = %s\\n\", month, day, year, weekday );\n    \n   return(0);\n}\n```\n### Output\n```\nMarch 25, 1989 = Saturday\n```\n## sprintf\nint sprintf（char * str，const char * format，...）将格式化的输出发送到str指向的字符串。\n### Example\n```C\n#include <stdio.h>\n#include <math.h>\n\nint main () {\n   char str[80];\n\n   sprintf(str, \"Value of Pi = %f\", M_PI);\n   puts(str);\n   \n   return(0);\n}\n```\n### Output\n```\nValue of Pi = 3.141593\n```","slug":"sscanf-sprintf","published":1,"updated":"2018-11-13T12:02:06.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrol004qb8ouv27clv5c","content":"<p>关于$sscanf$和$sprintf$用法的总结。<br><a id=\"more\"></a></p>\n<h2 id=\"sscanf\"><a href=\"#sscanf\" class=\"headerlink\" title=\"sscanf\"></a>sscanf</h2><p>int sscanf（const char <em> str，const char </em> format，…）从字符串中读取格式化的输入。</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> day, year;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> weekday[<span class=\"number\">20</span>], month[<span class=\"number\">20</span>], dtm[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( dtm, <span class=\"string\">\"Saturday March 25 1989\"</span> );</span><br><span class=\"line\">   <span class=\"built_in\">sscanf</span>( dtm, <span class=\"string\">\"%s %s %d  %d\"</span>, weekday, month, &amp;day, &amp;year );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d, %d = %s\\n\"</span>, month, day, year, weekday );</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">March 25, 1989 = Saturday</span><br></pre></td></tr></table></figure>\n<h2 id=\"sprintf\"><a href=\"#sprintf\" class=\"headerlink\" title=\"sprintf\"></a>sprintf</h2><p>int sprintf（char <em> str，const char </em> format，…）将格式化的输出发送到str指向的字符串。</p>\n<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> str[<span class=\"number\">80</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">sprintf</span>(str, <span class=\"string\">\"Value of Pi = %f\"</span>, M_PI);</span><br><span class=\"line\">   <span class=\"built_in\">puts</span>(str);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output-1\"><a href=\"#Output-1\" class=\"headerlink\" title=\"Output\"></a>Output</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of Pi = 3.141593</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>关于$sscanf$和$sprintf$用法的总结。<br></p>","more":"<p></p>\n<h2 id=\"sscanf\"><a href=\"#sscanf\" class=\"headerlink\" title=\"sscanf\"></a>sscanf</h2><p>int sscanf（const char <em> str，const char </em> format，…）从字符串中读取格式化的输入。</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> day, year;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> weekday[<span class=\"number\">20</span>], month[<span class=\"number\">20</span>], dtm[<span class=\"number\">100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">strcpy</span>( dtm, <span class=\"string\">\"Saturday March 25 1989\"</span> );</span><br><span class=\"line\">   <span class=\"built_in\">sscanf</span>( dtm, <span class=\"string\">\"%s %s %d  %d\"</span>, weekday, month, &amp;day, &amp;year );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s %d, %d = %s\\n\"</span>, month, day, year, weekday );</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">March 25, 1989 = Saturday</span><br></pre></td></tr></table></figure>\n<h2 id=\"sprintf\"><a href=\"#sprintf\" class=\"headerlink\" title=\"sprintf\"></a>sprintf</h2><p>int sprintf（char <em> str，const char </em> format，…）将格式化的输出发送到str指向的字符串。</p>\n<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">char</span> str[<span class=\"number\">80</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">sprintf</span>(str, <span class=\"string\">\"Value of Pi = %f\"</span>, M_PI);</span><br><span class=\"line\">   <span class=\"built_in\">puts</span>(str);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Output-1\"><a href=\"#Output-1\" class=\"headerlink\" title=\"Output\"></a>Output</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Value of Pi = 3.141593</span><br></pre></td></tr></table></figure>"},{"title":"线段树区间更新模板","date":"2018-05-07T16:08:11.000Z","_content":"线段树区间更新中比较重要的一个概念是延迟标记，即lazy思想，当要对某一个区间中的所有节点进行更新时，先找到包含该区间所有节点的那一个（或多个）节点，只对它（们）进行更新，同时保存更新的值lazy。当进行区间查询时，若查询的区间的大小在lazy标记区间之内则直接返回，否则将lazy值向下进行传递，直到包含查询的区间。通过这种方式，可以用更新整个区间的值来代替更新区间中的每一个节点，从而避免了很多不必要的操作，提高了效率。说起来可能比较抽象，详见代码。\n[参考链接](https://www.zybuluo.com/lychee123/note/731591)\n<!-- more -->\n## 基于区间和的线段树区间更新模板\n```C++\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;//延迟标记\n}tree[maxn << 2];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;//延迟标记初始化为0\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n//更新下层区间的值，即将lazy向下进行传递，这里是区别于单点更新的最主要的地方\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);//区间长度乘以当前标记\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;//标记传递后清空为0\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\n```\n## 例题实现\n[POJ-3468--A Simple Problem with Integers](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nint n, q;\n\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;\n}tree[maxn << 2];\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n    pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n        return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    char s[10];\n    int a, b, c;\n    scanf(\"%d%d\", &n, &q);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", d + i);\n    build(1, 1, n);\n    while(q--){\n        scanf(\"%s\", s);\n        if(s[0] == 'Q'){\n            scanf(\"%d%d\", &a, &b);\n            printf(\"%lld\\n\", query(1, a, b));\n        }\n        else if(s[0] == 'C'){\n            scanf(\"%d%d%d\", &a, &b, &c);\n            update(1, a, b, c);\n        }\n    }\n\t\n    return 0;\n}\n\n```","source":"_posts/segtree-intval.md","raw":"---\ntitle: 线段树区间更新模板\ndate: 2018-05-08 00:08:11\ncategories:\n- Template\ntags:\n- 线段树区间更新\n---\n线段树区间更新中比较重要的一个概念是延迟标记，即lazy思想，当要对某一个区间中的所有节点进行更新时，先找到包含该区间所有节点的那一个（或多个）节点，只对它（们）进行更新，同时保存更新的值lazy。当进行区间查询时，若查询的区间的大小在lazy标记区间之内则直接返回，否则将lazy值向下进行传递，直到包含查询的区间。通过这种方式，可以用更新整个区间的值来代替更新区间中的每一个节点，从而避免了很多不必要的操作，提高了效率。说起来可能比较抽象，详见代码。\n[参考链接](https://www.zybuluo.com/lychee123/note/731591)\n<!-- more -->\n## 基于区间和的线段树区间更新模板\n```C++\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;//延迟标记\n}tree[maxn << 2];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;//延迟标记初始化为0\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n//更新下层区间的值，即将lazy向下进行传递，这里是区别于单点更新的最主要的地方\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);//区间长度乘以当前标记\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;//标记传递后清空为0\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n    return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\n```\n## 例题实现\n[POJ-3468--A Simple Problem with Integers](http://acm.hdu.edu.cn/showproblem.php?pid=1754)\nAC代码\n```C++\n//#include <bits/stdc++.h>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\nint n, q;\n\nstruct SegTree{\n    int vl, vr;\n    long long sum;\n    long long lazy;\n}tree[maxn << 2];\nint d[maxn];\n\nvoid build(int k, int l, int r){\n    tree[k].vl = l;\n    tree[k].vr = r;\n    tree[k].lazy = 0;\n    if(l == r){\n        tree[k].sum = d[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(k << 1, l, mid);\n    build(k << 1 | 1, mid + 1, r);\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nvoid pushdown(int k){\n    tree[k << 1].lazy += tree[k].lazy;\n    tree[k << 1 | 1].lazy += tree[k].lazy;\n    tree[k << 1].sum += tree[k].lazy * (tree[k << 1].vr - tree[k << 1].vl + 1);\n    tree[k << 1 | 1].sum += tree[k].lazy * (tree[k << 1 | 1].vr - tree[k << 1 | 1].vl + 1);\n    tree[k].lazy = 0;\n}\n\nvoid update(int k, int l, int r, int val){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        tree[k].lazy += val;\n        tree[k].sum += val * (tree[k].vr - tree[k].vl + 1);\n        return;\n    }\n    if(tree[k].lazy != 0)\n        pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        update(k << 1, l, r, val);\n    else if(l > mid)\n        update(k << 1 | 1, l, r, val);\n    else{\n        update(k << 1, l, mid, val);\n        update(k << 1 | 1, mid + 1, r, val);\n    }\n    tree[k].sum = tree[k << 1].sum + tree[k << 1 | 1].sum;\n}\n\nlong long query(int k, int l, int r){\n    if(l <= tree[k].vl && r >= tree[k].vr){\n        return tree[k].sum;\n    }\n    if(tree[k].lazy)\n    pushdown(k);\n    int mid = (tree[k].vl + tree[k].vr) / 2;\n    if(r <= mid)\n        return query(k << 1, l, r);\n    if(l > mid)\n        return query(k << 1 | 1, l, r);\n        return query(k << 1, l, mid) + query(k << 1 | 1, mid + 1, r);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    char s[10];\n    int a, b, c;\n    scanf(\"%d%d\", &n, &q);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", d + i);\n    build(1, 1, n);\n    while(q--){\n        scanf(\"%s\", s);\n        if(s[0] == 'Q'){\n            scanf(\"%d%d\", &a, &b);\n            printf(\"%lld\\n\", query(1, a, b));\n        }\n        else if(s[0] == 'C'){\n            scanf(\"%d%d%d\", &a, &b, &c);\n            update(1, a, b, c);\n        }\n    }\n\t\n    return 0;\n}\n\n```","slug":"segtree-intval","published":1,"updated":"2018-11-13T12:06:45.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslron004tb8ou4stwjxoo","content":"<p>线段树区间更新中比较重要的一个概念是延迟标记，即lazy思想，当要对某一个区间中的所有节点进行更新时，先找到包含该区间所有节点的那一个（或多个）节点，只对它（们）进行更新，同时保存更新的值lazy。当进行区间查询时，若查询的区间的大小在lazy标记区间之内则直接返回，否则将lazy值向下进行传递，直到包含查询的区间。通过这种方式，可以用更新整个区间的值来代替更新区间中的每一个节点，从而避免了很多不必要的操作，提高了效率。说起来可能比较抽象，详见代码。<br><a href=\"https://www.zybuluo.com/lychee123/note/731591\" target=\"_blank\" rel=\"noopener\">参考链接</a><br><a id=\"more\"></a></p>\n<h2 id=\"基于区间和的线段树区间更新模板\"><a href=\"#基于区间和的线段树区间更新模板\" class=\"headerlink\" title=\"基于区间和的线段树区间更新模板\"></a>基于区间和的线段树区间更新模板</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> lazy;<span class=\"comment\">//延迟标记</span></span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;<span class=\"comment\">//延迟标记初始化为0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].sum = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//更新下层区间的值，即将lazy向下进行传递，这里是区别于单点更新的最主要的地方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);<span class=\"comment\">//区间长度乘以当前标记</span></span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;<span class=\"comment\">//标记传递后清空为0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].lazy += val;</span><br><span class=\"line\">        tree[k].sum += val * (tree[k].vr - tree[k].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy != <span class=\"number\">0</span>)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, mid, val);</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, mid) + query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例题实现\"><a href=\"#例题实现\" class=\"headerlink\" title=\"例题实现\"></a>例题实现</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1754\" target=\"_blank\" rel=\"noopener\">POJ-3468–A Simple Problem with Integers</a><br>AC代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> lazy;</span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].sum = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].lazy += val;</span><br><span class=\"line\">        tree[k].sum += val * (tree[k].vr - tree[k].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy != <span class=\"number\">0</span>)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, mid, val);</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy)</span><br><span class=\"line\">    pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, mid) + query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;q);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, d + i);</span><br><span class=\"line\">    build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(q--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;a, &amp;b);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(<span class=\"number\">1</span>, a, b));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class=\"line\">            update(<span class=\"number\">1</span>, a, b, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>线段树区间更新中比较重要的一个概念是延迟标记，即lazy思想，当要对某一个区间中的所有节点进行更新时，先找到包含该区间所有节点的那一个（或多个）节点，只对它（们）进行更新，同时保存更新的值lazy。当进行区间查询时，若查询的区间的大小在lazy标记区间之内则直接返回，否则将lazy值向下进行传递，直到包含查询的区间。通过这种方式，可以用更新整个区间的值来代替更新区间中的每一个节点，从而避免了很多不必要的操作，提高了效率。说起来可能比较抽象，详见代码。<br><a href=\"https://www.zybuluo.com/lychee123/note/731591\" target=\"_blank\" rel=\"noopener\">参考链接</a><br></p>","more":"<p></p>\n<h2 id=\"基于区间和的线段树区间更新模板\"><a href=\"#基于区间和的线段树区间更新模板\" class=\"headerlink\" title=\"基于区间和的线段树区间更新模板\"></a>基于区间和的线段树区间更新模板</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> lazy;<span class=\"comment\">//延迟标记</span></span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;<span class=\"comment\">//延迟标记初始化为0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].sum = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//更新下层区间的值，即将lazy向下进行传递，这里是区别于单点更新的最主要的地方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);<span class=\"comment\">//区间长度乘以当前标记</span></span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;<span class=\"comment\">//标记传递后清空为0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].lazy += val;</span><br><span class=\"line\">        tree[k].sum += val * (tree[k].vr - tree[k].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy != <span class=\"number\">0</span>)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, mid, val);</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, mid) + query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例题实现\"><a href=\"#例题实现\" class=\"headerlink\" title=\"例题实现\"></a>例题实现</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1754\" target=\"_blank\" rel=\"noopener\">POJ-3468–A Simple Problem with Integers</a><br>AC代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SegTree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vl, vr;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> lazy;</span><br><span class=\"line\">&#125;tree[maxn &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> d[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    tree[k].vl = l;</span><br><span class=\"line\">    tree[k].vr = r;</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[k].sum = d[l];</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span>, l, mid);</span><br><span class=\"line\">    build(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].lazy += tree[k].lazy;</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum += tree[k].lazy * (tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vr - tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[k].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        tree[k].lazy += val;</span><br><span class=\"line\">        tree[k].sum += val * (tree[k].vr - tree[k].vl + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy != <span class=\"number\">0</span>)</span><br><span class=\"line\">        pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r, val);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span>, l, mid, val);</span><br><span class=\"line\">        update(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree[k].sum = tree[k &lt;&lt; <span class=\"number\">1</span>].sum + tree[k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>].sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &lt;= tree[k].vl &amp;&amp; r &gt;= tree[k].vr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[k].sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tree[k].lazy)</span><br><span class=\"line\">    pushdown(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (tree[k].vl + tree[k].vr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r &lt;= mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l &gt; mid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, l, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query(k &lt;&lt; <span class=\"number\">1</span>, l, mid) + query(k &lt;&lt; <span class=\"number\">1</span> | <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;q);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, d + i);</span><br><span class=\"line\">    build(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(q--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, s);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;a, &amp;b);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>, query(<span class=\"number\">1</span>, a, b));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class=\"line\">            update(<span class=\"number\">1</span>, a, b, c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"stringstream-类型转换&&字符分割","date":"2018-08-08T14:07:28.000Z","_content":"继续填坑٩(•̤̀ᵕ•̤́๑)，这次是stringstream的内容，最初是看到它可以把字符串直接输出成int类型，惊了，但是一直不是很懂。在网上查了很多资料，才终于差不多理解。stringstream是C++提供的一个字符串流，和cin，cout输入输出流类似，只不过它不是从从键盘或文件输入，也不是输出到屏幕或文件中，而是接受一个对象的输入，或把缓存区的内容输出到一个对象中。具体可以用在类型转换和字符分割中。\n<!-- more -->\n## 基本方法(操作)\n```C++\nclear()－用来清空流标志(输入，输出标志)\nstr()－获得当前流中的内容\nstr(\"content\")－设置流的内容（或清空流的内容）\noperator <<－添加内容到stringstream对象\noperator >>－从stringstream流缓存区中输出内容\n```\n## 应用\n### 类型转换\n```C++\nint a;\nstring s;\nstringstream ss;\n//int型转换为字符串类型\nss << a;　//将a输入流中（输入模式）\nss >> s;　//将流中的数值输出到字符串s中（输出模式）\n\n//字符串类型转换为int型\nss << s;　//将字符串输入到流中\nss >> a;　//将流中的字符串输出到int型变量a中\n\n//注意：如果做多次数据转换须调用clear()和str(\"\")来清空输入输出标志和内容\nint a = 0, b = 0;\nstringstream ss;\nss << \"123\";\nss >> a;\nss.clear();\nss.str(\"\");\nss << \"456\";\nss >> b;\ncout << \"a:\" << a << endl;\ncout << \"b:\" << b << endl;\ncout << \"ss:\" << ss.str() << endl;\n\n//运行结果,不加clear()和str(\"\");\na:123\nb:0\nss:123\n//原因：不加clear()和str(\"\")，流处于输出模式无法接收新内容\"456\"且未被清空，所以ss仍为\"123\"，又由于缓存区的内容已输出到a中，所以b中无内容。\n\n//运行结果，加clear()但不加str(\"\");\na:123\nb:456\nss:123456\n//原因：加入clear()清空模式，可以接收新内容\"456\"，所以ss:123456。缓存区依次缓存\"123\"，\"456\"并分别输出到a, b，所以a:123, b:456\n\n//运行结果，加clear()和str(\"\");\na:123\nb:456\nss:456\n//原因：clear()清空模式，str(\"\")清空ss对象的内容。\n```\n### 支持char*的输入和输出\n```C++\nchar ch[20];\nstringstream ss;\nss << 2333;\nss >> ch; //直接将数输出到ch字符数组中\n```\n### 字符分割\n```C++\nstringstream ss(\"hello hi hey\");\nstring word;\nwhile(ss >> word){\n    cout << word << endl;\n}\n\n//运行结果\nhello\nhi\nhey\n\n```\n## 三种给stringstream对象赋初值的方式\n```C++\nstringstream ss(\"123\"); //创建的时候赋初值\nss.str(\"123\"); //str()函数赋值\nss << \"123\"; //操作符\"<<\"添加内容（需注意当前模式）\n```","source":"_posts/stringstream.md","raw":"---\ntitle: stringstream-类型转换&&字符分割\ndate: 2018-08-08 22:07:28\ncategories:\n- C++\ntags:\n- 字符串\n---\n继续填坑٩(•̤̀ᵕ•̤́๑)，这次是stringstream的内容，最初是看到它可以把字符串直接输出成int类型，惊了，但是一直不是很懂。在网上查了很多资料，才终于差不多理解。stringstream是C++提供的一个字符串流，和cin，cout输入输出流类似，只不过它不是从从键盘或文件输入，也不是输出到屏幕或文件中，而是接受一个对象的输入，或把缓存区的内容输出到一个对象中。具体可以用在类型转换和字符分割中。\n<!-- more -->\n## 基本方法(操作)\n```C++\nclear()－用来清空流标志(输入，输出标志)\nstr()－获得当前流中的内容\nstr(\"content\")－设置流的内容（或清空流的内容）\noperator <<－添加内容到stringstream对象\noperator >>－从stringstream流缓存区中输出内容\n```\n## 应用\n### 类型转换\n```C++\nint a;\nstring s;\nstringstream ss;\n//int型转换为字符串类型\nss << a;　//将a输入流中（输入模式）\nss >> s;　//将流中的数值输出到字符串s中（输出模式）\n\n//字符串类型转换为int型\nss << s;　//将字符串输入到流中\nss >> a;　//将流中的字符串输出到int型变量a中\n\n//注意：如果做多次数据转换须调用clear()和str(\"\")来清空输入输出标志和内容\nint a = 0, b = 0;\nstringstream ss;\nss << \"123\";\nss >> a;\nss.clear();\nss.str(\"\");\nss << \"456\";\nss >> b;\ncout << \"a:\" << a << endl;\ncout << \"b:\" << b << endl;\ncout << \"ss:\" << ss.str() << endl;\n\n//运行结果,不加clear()和str(\"\");\na:123\nb:0\nss:123\n//原因：不加clear()和str(\"\")，流处于输出模式无法接收新内容\"456\"且未被清空，所以ss仍为\"123\"，又由于缓存区的内容已输出到a中，所以b中无内容。\n\n//运行结果，加clear()但不加str(\"\");\na:123\nb:456\nss:123456\n//原因：加入clear()清空模式，可以接收新内容\"456\"，所以ss:123456。缓存区依次缓存\"123\"，\"456\"并分别输出到a, b，所以a:123, b:456\n\n//运行结果，加clear()和str(\"\");\na:123\nb:456\nss:456\n//原因：clear()清空模式，str(\"\")清空ss对象的内容。\n```\n### 支持char*的输入和输出\n```C++\nchar ch[20];\nstringstream ss;\nss << 2333;\nss >> ch; //直接将数输出到ch字符数组中\n```\n### 字符分割\n```C++\nstringstream ss(\"hello hi hey\");\nstring word;\nwhile(ss >> word){\n    cout << word << endl;\n}\n\n//运行结果\nhello\nhi\nhey\n\n```\n## 三种给stringstream对象赋初值的方式\n```C++\nstringstream ss(\"123\"); //创建的时候赋初值\nss.str(\"123\"); //str()函数赋值\nss << \"123\"; //操作符\"<<\"添加内容（需注意当前模式）\n```","slug":"stringstream","published":1,"updated":"2018-11-13T12:02:16.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrop004yb8ouu74czu79","content":"<p>继续填坑٩(•̤̀ᵕ•̤́๑)，这次是stringstream的内容，最初是看到它可以把字符串直接输出成int类型，惊了，但是一直不是很懂。在网上查了很多资料，才终于差不多理解。stringstream是C++提供的一个字符串流，和cin，cout输入输出流类似，只不过它不是从从键盘或文件输入，也不是输出到屏幕或文件中，而是接受一个对象的输入，或把缓存区的内容输出到一个对象中。具体可以用在类型转换和字符分割中。<br><a id=\"more\"></a></p>\n<h2 id=\"基本方法-操作\"><a href=\"#基本方法-操作\" class=\"headerlink\" title=\"基本方法(操作)\"></a>基本方法(操作)</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear()－用来清空流标志(输入，输出标志)</span><br><span class=\"line\">str()－获得当前流中的内容</span><br><span class=\"line\">str(<span class=\"string\">\"content\"</span>)－设置流的内容（或清空流的内容）</span><br><span class=\"line\"><span class=\"keyword\">operator</span> &lt;&lt;－添加内容到<span class=\"built_in\">stringstream</span>对象</span><br><span class=\"line\"><span class=\"keyword\">operator</span> &gt;&gt;－从<span class=\"built_in\">stringstream</span>流缓存区中输出内容</span><br></pre></td></tr></table></figure>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\"><span class=\"comment\">//int型转换为字符串类型</span></span><br><span class=\"line\">ss &lt;&lt; a;　<span class=\"comment\">//将a输入流中（输入模式）</span></span><br><span class=\"line\">ss &gt;&gt; s;　<span class=\"comment\">//将流中的数值输出到字符串s中（输出模式）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//字符串类型转换为int型</span></span><br><span class=\"line\">ss &lt;&lt; s;　<span class=\"comment\">//将字符串输入到流中</span></span><br><span class=\"line\">ss &gt;&gt; a;　<span class=\"comment\">//将流中的字符串输出到int型变量a中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意：如果做多次数据转换须调用clear()和str(\"\")来清空输入输出标志和内容</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">ss &gt;&gt; a;</span><br><span class=\"line\">ss.clear();</span><br><span class=\"line\">ss.str(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"456\"</span>;</span><br><span class=\"line\">ss &gt;&gt; b;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a:\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"b:\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ss:\"</span> &lt;&lt; ss.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果,不加clear()和str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">0</span></span><br><span class=\"line\">ss:<span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"comment\">//原因：不加clear()和str(\"\")，流处于输出模式无法接收新内容\"456\"且未被清空，所以ss仍为\"123\"，又由于缓存区的内容已输出到a中，所以b中无内容。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果，加clear()但不加str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">456</span></span><br><span class=\"line\">ss:<span class=\"number\">123456</span></span><br><span class=\"line\"><span class=\"comment\">//原因：加入clear()清空模式，可以接收新内容\"456\"，所以ss:123456。缓存区依次缓存\"123\"，\"456\"并分别输出到a, b，所以a:123, b:456</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果，加clear()和str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">456</span></span><br><span class=\"line\">ss:<span class=\"number\">456</span></span><br><span class=\"line\"><span class=\"comment\">//原因：clear()清空模式，str(\"\")清空ss对象的内容。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"支持char-的输入和输出\"><a href=\"#支持char-的输入和输出\" class=\"headerlink\" title=\"支持char*的输入和输出\"></a>支持char*的输入和输出</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> ch[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">ss &lt;&lt; <span class=\"number\">2333</span>;</span><br><span class=\"line\">ss &gt;&gt; ch; <span class=\"comment\">//直接将数输出到ch字符数组中</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符分割\"><a href=\"#字符分割\" class=\"headerlink\" title=\"字符分割\"></a>字符分割</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">\"hello hi hey\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> word;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(ss &gt;&gt; word)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; word &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果</span></span><br><span class=\"line\">hello</span><br><span class=\"line\">hi</span><br><span class=\"line\">hey</span><br></pre></td></tr></table></figure>\n<h2 id=\"三种给stringstream对象赋初值的方式\"><a href=\"#三种给stringstream对象赋初值的方式\" class=\"headerlink\" title=\"三种给stringstream对象赋初值的方式\"></a>三种给stringstream对象赋初值的方式</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">\"123\"</span>)</span></span>; <span class=\"comment\">//创建的时候赋初值</span></span><br><span class=\"line\">ss.str(<span class=\"string\">\"123\"</span>); <span class=\"comment\">//str()函数赋值</span></span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"123\"</span>; <span class=\"comment\">//操作符\"&lt;&lt;\"添加内容（需注意当前模式）</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>继续填坑٩(•̤̀ᵕ•̤́๑)，这次是stringstream的内容，最初是看到它可以把字符串直接输出成int类型，惊了，但是一直不是很懂。在网上查了很多资料，才终于差不多理解。stringstream是C++提供的一个字符串流，和cin，cout输入输出流类似，只不过它不是从从键盘或文件输入，也不是输出到屏幕或文件中，而是接受一个对象的输入，或把缓存区的内容输出到一个对象中。具体可以用在类型转换和字符分割中。<br></p>","more":"<p></p>\n<h2 id=\"基本方法-操作\"><a href=\"#基本方法-操作\" class=\"headerlink\" title=\"基本方法(操作)\"></a>基本方法(操作)</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear()－用来清空流标志(输入，输出标志)</span><br><span class=\"line\">str()－获得当前流中的内容</span><br><span class=\"line\">str(<span class=\"string\">\"content\"</span>)－设置流的内容（或清空流的内容）</span><br><span class=\"line\"><span class=\"keyword\">operator</span> &lt;&lt;－添加内容到<span class=\"built_in\">stringstream</span>对象</span><br><span class=\"line\"><span class=\"keyword\">operator</span> &gt;&gt;－从<span class=\"built_in\">stringstream</span>流缓存区中输出内容</span><br></pre></td></tr></table></figure>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\"><span class=\"comment\">//int型转换为字符串类型</span></span><br><span class=\"line\">ss &lt;&lt; a;　<span class=\"comment\">//将a输入流中（输入模式）</span></span><br><span class=\"line\">ss &gt;&gt; s;　<span class=\"comment\">//将流中的数值输出到字符串s中（输出模式）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//字符串类型转换为int型</span></span><br><span class=\"line\">ss &lt;&lt; s;　<span class=\"comment\">//将字符串输入到流中</span></span><br><span class=\"line\">ss &gt;&gt; a;　<span class=\"comment\">//将流中的字符串输出到int型变量a中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//注意：如果做多次数据转换须调用clear()和str(\"\")来清空输入输出标志和内容</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">ss &gt;&gt; a;</span><br><span class=\"line\">ss.clear();</span><br><span class=\"line\">ss.str(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"456\"</span>;</span><br><span class=\"line\">ss &gt;&gt; b;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a:\"</span> &lt;&lt; a &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"b:\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"ss:\"</span> &lt;&lt; ss.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果,不加clear()和str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">0</span></span><br><span class=\"line\">ss:<span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"comment\">//原因：不加clear()和str(\"\")，流处于输出模式无法接收新内容\"456\"且未被清空，所以ss仍为\"123\"，又由于缓存区的内容已输出到a中，所以b中无内容。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果，加clear()但不加str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">456</span></span><br><span class=\"line\">ss:<span class=\"number\">123456</span></span><br><span class=\"line\"><span class=\"comment\">//原因：加入clear()清空模式，可以接收新内容\"456\"，所以ss:123456。缓存区依次缓存\"123\"，\"456\"并分别输出到a, b，所以a:123, b:456</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果，加clear()和str(\"\");</span></span><br><span class=\"line\">a:<span class=\"number\">123</span></span><br><span class=\"line\">b:<span class=\"number\">456</span></span><br><span class=\"line\">ss:<span class=\"number\">456</span></span><br><span class=\"line\"><span class=\"comment\">//原因：clear()清空模式，str(\"\")清空ss对象的内容。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"支持char-的输入和输出\"><a href=\"#支持char-的输入和输出\" class=\"headerlink\" title=\"支持char*的输入和输出\"></a>支持char*的输入和输出</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> ch[<span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">ss &lt;&lt; <span class=\"number\">2333</span>;</span><br><span class=\"line\">ss &gt;&gt; ch; <span class=\"comment\">//直接将数输出到ch字符数组中</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符分割\"><a href=\"#字符分割\" class=\"headerlink\" title=\"字符分割\"></a>字符分割</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">\"hello hi hey\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> word;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(ss &gt;&gt; word)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; word &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行结果</span></span><br><span class=\"line\">hello</span><br><span class=\"line\">hi</span><br><span class=\"line\">hey</span><br></pre></td></tr></table></figure>\n<h2 id=\"三种给stringstream对象赋初值的方式\"><a href=\"#三种给stringstream对象赋初值的方式\" class=\"headerlink\" title=\"三种给stringstream对象赋初值的方式\"></a>三种给stringstream对象赋初值的方式</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span><span class=\"params\">(<span class=\"string\">\"123\"</span>)</span></span>; <span class=\"comment\">//创建的时候赋初值</span></span><br><span class=\"line\">ss.str(<span class=\"string\">\"123\"</span>); <span class=\"comment\">//str()函数赋值</span></span><br><span class=\"line\">ss &lt;&lt; <span class=\"string\">\"123\"</span>; <span class=\"comment\">//操作符\"&lt;&lt;\"添加内容（需注意当前模式）</span></span><br></pre></td></tr></table></figure>"},{"title":"ubuntu下vultr服务器搭建","date":"2018-04-13T11:09:32.000Z","_content":"工欲善其事必先利其器。\n前一段时间在[陶司机学长](http://logqtainia.github.io/)的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了...，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。\n觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。\n<!-- more -->\n## 注册vultr账号\n[链接](https://www.vultr.com/)\n## 创建vultr主机\n点击右上角的蓝色加号，创建新的vultr主机\n![p1](/p1.png)\n服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)\n![p2](/p2.png)\n服务器端系统选择，选择ubuntu\n![p3](/p3.png)\n服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。\n![p4](/p4.png)\n其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)\n![p5](/p5.png)\n接下来等待主机部署完成即可。\n## 服务器端配置\n服务器端，也就是你刚刚创建的那台主机。\n点击主机右侧\"...\"展开菜单，选择\"Server Details\"可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。\n![p6](/p6.png)\n打开终端，使用ssh远程登录到主机\n```\n$ ssh root@你的主机IP地址\n```\n之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。\n登录成功后使用一键配置脚本进行配置\n```\n$ wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n```\n终端中会出现如下界面，输入１选择安装shadowsocksR\n![p7](/p7.png)\n之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择\n```\n加密方式(method):none\n协议(protocol):auth_chain_a\n混淆(obfs):plain\n```\n服务器端配置完成，终端中输入exit退出ssh登录\n```\n$ exit\n```\n## 客户端配置\n客户端，也就是你的个人电脑。\n在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。\n```\n$ wget http://www.djangoz.com/ssr\n$ sudo mv ssr /usr/local/bin\n$ sudo chmod 766 /usr/local/bin/ssr\n$ ssr install\n$ ssr config\n```\n配置和服务器端保持一直即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项\n```\n    \"server\": \"11.22.33.44\",\n    \"server_ipv6\": \"::\",\n    \"server_port\": 1234,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\": 1080,\n\n    \"password\": \"123456789\",\n    \"method\": \"none\",\n    \"protocol\": \"auth_chain_a\",\n    \"protocol_param\": \"\",\n    \"obfs\": \"plain\",\n    \"obfs_param\": \"\",\n    \"speed_limit_per_con\": 0,\n    \"speed_limit_per_user\": 0,\n\n    \"additional_ports\" : {}, // only works under multi-user mode\n    \"additional_ports_only\" : false, // only works under multi-user mode\n    \"timeout\": 120,\n    \"udp_timeout\": 60,\n    \"dns_ipv6\": false,\n    \"connect_verbose_info\": 0,\n    \"redirect\": \"\",\n\n```\n以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令\n```\nssr start\nssr stop\n```\n## 可能的问题\n检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。\n* 依次打开ubuntu系统设置->网络->网络代理，设置如下\n![p8](/p8.png)\n* 推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)\nproxy SwitchyOmega配置如下\n![p９](/p9.png)\n* 有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)\n\nps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用","source":"_posts/vultr.md","raw":"---\ntitle: ubuntu下vultr服务器搭建\ndate: 2018-04-13 19:09:32\ncategories:\n- Messy article\ntags:\n- vultr服务器搭建\n---\n工欲善其事必先利其器。\n前一段时间在[陶司机学长](http://logqtainia.github.io/)的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了...，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。\n觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。\n<!-- more -->\n## 注册vultr账号\n[链接](https://www.vultr.com/)\n## 创建vultr主机\n点击右上角的蓝色加号，创建新的vultr主机\n![p1](/p1.png)\n服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)\n![p2](/p2.png)\n服务器端系统选择，选择ubuntu\n![p3](/p3.png)\n服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。\n![p4](/p4.png)\n其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)\n![p5](/p5.png)\n接下来等待主机部署完成即可。\n## 服务器端配置\n服务器端，也就是你刚刚创建的那台主机。\n点击主机右侧\"...\"展开菜单，选择\"Server Details\"可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。\n![p6](/p6.png)\n打开终端，使用ssh远程登录到主机\n```\n$ ssh root@你的主机IP地址\n```\n之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。\n登录成功后使用一键配置脚本进行配置\n```\n$ wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n```\n终端中会出现如下界面，输入１选择安装shadowsocksR\n![p7](/p7.png)\n之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择\n```\n加密方式(method):none\n协议(protocol):auth_chain_a\n混淆(obfs):plain\n```\n服务器端配置完成，终端中输入exit退出ssh登录\n```\n$ exit\n```\n## 客户端配置\n客户端，也就是你的个人电脑。\n在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。\n```\n$ wget http://www.djangoz.com/ssr\n$ sudo mv ssr /usr/local/bin\n$ sudo chmod 766 /usr/local/bin/ssr\n$ ssr install\n$ ssr config\n```\n配置和服务器端保持一直即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项\n```\n    \"server\": \"11.22.33.44\",\n    \"server_ipv6\": \"::\",\n    \"server_port\": 1234,\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\": 1080,\n\n    \"password\": \"123456789\",\n    \"method\": \"none\",\n    \"protocol\": \"auth_chain_a\",\n    \"protocol_param\": \"\",\n    \"obfs\": \"plain\",\n    \"obfs_param\": \"\",\n    \"speed_limit_per_con\": 0,\n    \"speed_limit_per_user\": 0,\n\n    \"additional_ports\" : {}, // only works under multi-user mode\n    \"additional_ports_only\" : false, // only works under multi-user mode\n    \"timeout\": 120,\n    \"udp_timeout\": 60,\n    \"dns_ipv6\": false,\n    \"connect_verbose_info\": 0,\n    \"redirect\": \"\",\n\n```\n以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令\n```\nssr start\nssr stop\n```\n## 可能的问题\n检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。\n* 依次打开ubuntu系统设置->网络->网络代理，设置如下\n![p8](/p8.png)\n* 推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)\nproxy SwitchyOmega配置如下\n![p９](/p9.png)\n* 有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)\n\nps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用","slug":"vultr","published":1,"updated":"2018-08-09T15:48:05.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslroq0051b8ou0mcau2yn","content":"<p>工欲善其事必先利其器。<br>前一段时间在<a href=\"http://logqtainia.github.io/\" target=\"_blank\" rel=\"noopener\">陶司机学长</a>的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了…，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。<br>觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。<br><a id=\"more\"></a></p>\n<h2 id=\"注册vultr账号\"><a href=\"#注册vultr账号\" class=\"headerlink\" title=\"注册vultr账号\"></a>注册vultr账号</h2><p><a href=\"https://www.vultr.com/\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"创建vultr主机\"><a href=\"#创建vultr主机\" class=\"headerlink\" title=\"创建vultr主机\"></a>创建vultr主机</h2><p>点击右上角的蓝色加号，创建新的vultr主机<br><img src=\"/2018/04/13/vultr/p1.png\" alt=\"p1\"><br>服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)<br><img src=\"/2018/04/13/vultr/p2.png\" alt=\"p2\"><br>服务器端系统选择，选择ubuntu<br><img src=\"/2018/04/13/vultr/p3.png\" alt=\"p3\"><br>服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。<br><img src=\"/2018/04/13/vultr/p4.png\" alt=\"p4\"><br>其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)<br><img src=\"/2018/04/13/vultr/p5.png\" alt=\"p5\"><br>接下来等待主机部署完成即可。</p>\n<h2 id=\"服务器端配置\"><a href=\"#服务器端配置\" class=\"headerlink\" title=\"服务器端配置\"></a>服务器端配置</h2><p>服务器端，也就是你刚刚创建的那台主机。<br>点击主机右侧”…”展开菜单，选择”Server Details”可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。<br><img src=\"/2018/04/13/vultr/p6.png\" alt=\"p6\"><br>打开终端，使用ssh远程登录到主机<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh root@你的主机IP地址</span><br></pre></td></tr></table></figure></p>\n<p>之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。<br>登录成功后使用一键配置脚本进行配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure></p>\n<p>终端中会出现如下界面，输入１选择安装shadowsocksR<br><img src=\"/2018/04/13/vultr/p7.png\" alt=\"p7\"><br>之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加密方式(method):none</span><br><span class=\"line\">协议(protocol):auth_chain_a</span><br><span class=\"line\">混淆(obfs):plain</span><br></pre></td></tr></table></figure></p>\n<p>服务器端配置完成，终端中输入exit退出ssh登录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ exit</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"客户端配置\"><a href=\"#客户端配置\" class=\"headerlink\" title=\"客户端配置\"></a>客户端配置</h2><p>客户端，也就是你的个人电脑。<br>在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget http://www.djangoz.com/ssr</span><br><span class=\"line\">$ sudo mv ssr /usr/local/bin</span><br><span class=\"line\">$ sudo chmod 766 /usr/local/bin/ssr</span><br><span class=\"line\">$ ssr install</span><br><span class=\"line\">$ ssr config</span><br></pre></td></tr></table></figure></p>\n<p>配置和服务器端保持一直即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;server&quot;: &quot;11.22.33.44&quot;,</span><br><span class=\"line\">&quot;server_ipv6&quot;: &quot;::&quot;,</span><br><span class=\"line\">&quot;server_port&quot;: 1234,</span><br><span class=\"line\">&quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">&quot;local_port&quot;: 1080,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;password&quot;: &quot;123456789&quot;,</span><br><span class=\"line\">&quot;method&quot;: &quot;none&quot;,</span><br><span class=\"line\">&quot;protocol&quot;: &quot;auth_chain_a&quot;,</span><br><span class=\"line\">&quot;protocol_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;obfs&quot;: &quot;plain&quot;,</span><br><span class=\"line\">&quot;obfs_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;speed_limit_per_con&quot;: 0,</span><br><span class=\"line\">&quot;speed_limit_per_user&quot;: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;additional_ports&quot; : &#123;&#125;, // only works under multi-user mode</span><br><span class=\"line\">&quot;additional_ports_only&quot; : false, // only works under multi-user mode</span><br><span class=\"line\">&quot;timeout&quot;: 120,</span><br><span class=\"line\">&quot;udp_timeout&quot;: 60,</span><br><span class=\"line\">&quot;dns_ipv6&quot;: false,</span><br><span class=\"line\">&quot;connect_verbose_info&quot;: 0,</span><br><span class=\"line\">&quot;redirect&quot;: &quot;&quot;,</span><br></pre></td></tr></table></figure></p>\n<p>以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssr start</span><br><span class=\"line\">ssr stop</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"可能的问题\"><a href=\"#可能的问题\" class=\"headerlink\" title=\"可能的问题\"></a>可能的问题</h2><p>检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。</p>\n<ul>\n<li>依次打开ubuntu系统设置-&gt;网络-&gt;网络代理，设置如下<br><img src=\"/2018/04/13/vultr/p8.png\" alt=\"p8\"></li>\n<li>推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)<br>proxy SwitchyOmega配置如下<br><img src=\"/2018/04/13/vultr/p9.png\" alt=\"p９\"></li>\n<li>有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)</li>\n</ul>\n<p>ps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用</p>\n","site":{"data":{}},"excerpt":"<p>工欲善其事必先利其器。<br>前一段时间在<a href=\"http://logqtainia.github.io/\" target=\"_blank\" rel=\"noopener\">陶司机学长</a>的帮助下搭了自己的梯子，因为实在是受不了某度的搜索引擎了…，某天电脑出了一个小问题，去某度搜，２个小时过去没有任何头绪，无奈挂了VPN软件搜谷歌，搜索结果的第一条就是解决办法，，，没有对比就没有伤害，google真是一家伟大的公司。<br>觉得靠免费的VPN软件不是长久之计（一方面是速度不理想，另一方面是考虑安全的问题），于是搭了梯子，终于可以愉快的用google了(•̀⌄•́)，用这篇博客记录一下搭建的过程。<br></p>","more":"<p></p>\n<h2 id=\"注册vultr账号\"><a href=\"#注册vultr账号\" class=\"headerlink\" title=\"注册vultr账号\"></a>注册vultr账号</h2><p><a href=\"https://www.vultr.com/\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"创建vultr主机\"><a href=\"#创建vultr主机\" class=\"headerlink\" title=\"创建vultr主机\"></a>创建vultr主机</h2><p>点击右上角的蓝色加号，创建新的vultr主机<br><img src=\"/2018/04/13/vultr/p1.png\" alt=\"p1\"><br>服务器位置选择，推荐选择新加坡，或者美国的服务器(日本服务器已基本被墙)<br><img src=\"/2018/04/13/vultr/p2.png\" alt=\"p2\"><br>服务器端系统选择，选择ubuntu<br><img src=\"/2018/04/13/vultr/p3.png\" alt=\"p3\"><br>服务器配置选择,配置越高价格也越高，一般最便宜的2.5刀/month就够用了，但是很难抢到，，，于是就选5刀/month的了。<br><img src=\"/2018/04/13/vultr/p4.png\" alt=\"p4\"><br>其它的选项不需要填写，点击支付就ok(ps:从2017年10月开始支持支付宝支付！！)<br><img src=\"/2018/04/13/vultr/p5.png\" alt=\"p5\"><br>接下来等待主机部署完成即可。</p>\n<h2 id=\"服务器端配置\"><a href=\"#服务器端配置\" class=\"headerlink\" title=\"服务器端配置\"></a>服务器端配置</h2><p>服务器端，也就是你刚刚创建的那台主机。<br>点击主机右侧”…”展开菜单，选择”Server Details”可以看到这台主机的一些信息。包括这台主机的IP地址(IP Address)、用户名(Username)、密码(Password)等，这些信息下面需要用到。<br><img src=\"/2018/04/13/vultr/p6.png\" alt=\"p6\"><br>打开终端，使用ssh远程登录到主机<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh root@你的主机IP地址</span><br></pre></td></tr></table></figure></p>\n<p>之后输入你的主机密码进行登录(可以在主机信息页面直接复制，粘贴到终端里时不会显示，但已存在,直接回车即可)。<br>登录成功后使用一键配置脚本进行配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure></p>\n<p>终端中会出现如下界面，输入１选择安装shadowsocksR<br><img src=\"/2018/04/13/vultr/p7.png\" alt=\"p7\"><br>之后会依次要求设置端口号(推荐设置8000以上)、密码、加密方式、协议、混淆等，下面给出我的几个主要配置选择<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加密方式(method):none</span><br><span class=\"line\">协议(protocol):auth_chain_a</span><br><span class=\"line\">混淆(obfs):plain</span><br></pre></td></tr></table></figure></p>\n<p>服务器端配置完成，终端中输入exit退出ssh登录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ exit</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"客户端配置\"><a href=\"#客户端配置\" class=\"headerlink\" title=\"客户端配置\"></a>客户端配置</h2><p>客户端，也就是你的个人电脑。<br>在终端中依次输入如下命令安装配置客户端的ssr(shadowsocksR)，注意此时一定要确保已经在终端中退出ssh登录，或者新打开一个终端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ wget http://www.djangoz.com/ssr</span><br><span class=\"line\">$ sudo mv ssr /usr/local/bin</span><br><span class=\"line\">$ sudo chmod 766 /usr/local/bin/ssr</span><br><span class=\"line\">$ ssr install</span><br><span class=\"line\">$ ssr config</span><br></pre></td></tr></table></figure></p>\n<p>配置和服务器端保持一直即可，下面给出示例，只需配置server、server_port、password、method、protocol、obfs这几项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;server&quot;: &quot;11.22.33.44&quot;,</span><br><span class=\"line\">&quot;server_ipv6&quot;: &quot;::&quot;,</span><br><span class=\"line\">&quot;server_port&quot;: 1234,</span><br><span class=\"line\">&quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\">&quot;local_port&quot;: 1080,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;password&quot;: &quot;123456789&quot;,</span><br><span class=\"line\">&quot;method&quot;: &quot;none&quot;,</span><br><span class=\"line\">&quot;protocol&quot;: &quot;auth_chain_a&quot;,</span><br><span class=\"line\">&quot;protocol_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;obfs&quot;: &quot;plain&quot;,</span><br><span class=\"line\">&quot;obfs_param&quot;: &quot;&quot;,</span><br><span class=\"line\">&quot;speed_limit_per_con&quot;: 0,</span><br><span class=\"line\">&quot;speed_limit_per_user&quot;: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;additional_ports&quot; : &#123;&#125;, // only works under multi-user mode</span><br><span class=\"line\">&quot;additional_ports_only&quot; : false, // only works under multi-user mode</span><br><span class=\"line\">&quot;timeout&quot;: 120,</span><br><span class=\"line\">&quot;udp_timeout&quot;: 60,</span><br><span class=\"line\">&quot;dns_ipv6&quot;: false,</span><br><span class=\"line\">&quot;connect_verbose_info&quot;: 0,</span><br><span class=\"line\">&quot;redirect&quot;: &quot;&quot;,</span><br></pre></td></tr></table></figure></p>\n<p>以后若想修改配置，在终端中输入ssr config即可(服务器端也要对应修改)，还有打开和关闭命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssr start</span><br><span class=\"line\">ssr stop</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"可能的问题\"><a href=\"#可能的问题\" class=\"headerlink\" title=\"可能的问题\"></a>可能的问题</h2><p>检查自己是否可以登录google、youtube、twitter等网站，若依旧不能可尝试用以下方法解决。</p>\n<ul>\n<li>依次打开ubuntu系统设置-&gt;网络-&gt;网络代理，设置如下<br><img src=\"/2018/04/13/vultr/p8.png\" alt=\"p8\"></li>\n<li>推荐使用chrome浏览器+proxy SwitchyOmega插件(可离线安装)<br>proxy SwitchyOmega配置如下<br><img src=\"/2018/04/13/vultr/p9.png\" alt=\"p９\"></li>\n<li>有可能申请的服务器的ip被墙，可通过在线网站验证是否可以ping通，若确认ip被墙，在你的vultr账户中申请更换即可(更换服务器位置，或只更换ip地址)</li>\n</ul>\n<p>ps:服务器端配置好后，windows、android端只需下载shadowsocksR软件并进行简单配置即可使用</p>"},{"title":"八皇后问题","date":"2018-12-20T15:16:17.000Z","_content":"八皇后问题，即在$8 \\times 8$的棋盘上放置8个皇后，使得它们互不攻击（皇后的攻击范围为同行同列和同对角线）。\n![queen](/queen.png)\n\n## 参考\n刘汝佳《算法竞赛入门经典》（第2版）\n\n## 解法\n比较容易想到的一个思路是把这个问题转换为“从64个格子中选八个格子”的问题。但是这一共有$C^8_64 = 4.426 \\times 10^9$种情况。我们可以考虑先排除一些明显不成立的情况，减少枚举量。首先八个皇后肯定是位于不同行不同列的，所以可以把这个问题看做求一个$0~7$的全排列问题。这样的话总的情况数为$8! = 40302$种，可以在1秒内完成检索。\n(i，C[i])和(j，C[j])分别表示两个皇后坐标，它们位于同一对角线上的条件：``i - C[i] == j - C[j] || i + C[i] == j + C[j]`` \n![diagonal](/diagonal.png)\n\n\n## 代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 8;\nbool vis[3][100]; //record visited columns and  diagonals\nint c[100]; //represent columns\nint cnt;\n\nvoid dfs(int n){\n    if(n == N){\n        cnt++;\n        for(int i = 0; i < N; i++){\n            cout << c[i] << \" \";\n        }\n        cout << endl;\n        return;\n    }\n    for(int i = 0; i < N; i++){\n        if(!vis[0][i] && !vis[1][n + i] && !vis[2][n - i + N]){ // n - i　could be negative number, so we plus N.\n            c[n] = i;\n            vis[0][i] = vis[1][n + c[n]] = vis[2][n - c[n] + N] = 1;\n            dfs(n + 1);\n            vis[0][i] = vis[1][n + c[n]] = vis[2][n - c[n] + N] = 0;\n        }\n    }\n}\n\nint main(){\n    memset(vis, 0, sizeof(vis));\n    memset(c, -1, sizeof(c));\n    cnt = 0;\n    dfs(0);\n    cout << endl;\n    cout << \"total number: \" << cnt << endl;\n    return 0;\n}\n```\n","source":"_posts/八皇后问题.md","raw":"---\ntitle: 八皇后问题\ndate: 2018-12-20 23:16:17\ncategories:\n- Summary\ntags:\n---\n八皇后问题，即在$8 \\times 8$的棋盘上放置8个皇后，使得它们互不攻击（皇后的攻击范围为同行同列和同对角线）。\n![queen](/queen.png)\n\n## 参考\n刘汝佳《算法竞赛入门经典》（第2版）\n\n## 解法\n比较容易想到的一个思路是把这个问题转换为“从64个格子中选八个格子”的问题。但是这一共有$C^8_64 = 4.426 \\times 10^9$种情况。我们可以考虑先排除一些明显不成立的情况，减少枚举量。首先八个皇后肯定是位于不同行不同列的，所以可以把这个问题看做求一个$0~7$的全排列问题。这样的话总的情况数为$8! = 40302$种，可以在1秒内完成检索。\n(i，C[i])和(j，C[j])分别表示两个皇后坐标，它们位于同一对角线上的条件：``i - C[i] == j - C[j] || i + C[i] == j + C[j]`` \n![diagonal](/diagonal.png)\n\n\n## 代码\n```C++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 8;\nbool vis[3][100]; //record visited columns and  diagonals\nint c[100]; //represent columns\nint cnt;\n\nvoid dfs(int n){\n    if(n == N){\n        cnt++;\n        for(int i = 0; i < N; i++){\n            cout << c[i] << \" \";\n        }\n        cout << endl;\n        return;\n    }\n    for(int i = 0; i < N; i++){\n        if(!vis[0][i] && !vis[1][n + i] && !vis[2][n - i + N]){ // n - i　could be negative number, so we plus N.\n            c[n] = i;\n            vis[0][i] = vis[1][n + c[n]] = vis[2][n - c[n] + N] = 1;\n            dfs(n + 1);\n            vis[0][i] = vis[1][n + c[n]] = vis[2][n - c[n] + N] = 0;\n        }\n    }\n}\n\nint main(){\n    memset(vis, 0, sizeof(vis));\n    memset(c, -1, sizeof(c));\n    cnt = 0;\n    dfs(0);\n    cout << endl;\n    cout << \"total number: \" << cnt << endl;\n    return 0;\n}\n```\n","slug":"八皇后问题","published":1,"updated":"2018-12-20T16:00:01.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslros0056b8ouj6mvsvjv","content":"<p>八皇后问题，即在$8 \\times 8$的棋盘上放置8个皇后，使得它们互不攻击（皇后的攻击范围为同行同列和同对角线）。<br><img src=\"/2018/12/20/八皇后问题/queen.png\" alt=\"queen\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>刘汝佳《算法竞赛入门经典》（第2版）</p>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><p>比较容易想到的一个思路是把这个问题转换为“从64个格子中选八个格子”的问题。但是这一共有$C^8_64 = 4.426 \\times 10^9$种情况。我们可以考虑先排除一些明显不成立的情况，减少枚举量。首先八个皇后肯定是位于不同行不同列的，所以可以把这个问题看做求一个$0~7$的全排列问题。这样的话总的情况数为$8! = 40302$种，可以在1秒内完成检索。<br>(i，C[i])和(j，C[j])分别表示两个皇后坐标，它们位于同一对角线上的条件：<code>i - C[i] == j - C[j] || i + C[i] == j + C[j]</code><br><img src=\"/2018/12/20/八皇后问题/diagonal.png\" alt=\"diagonal\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">3</span>][<span class=\"number\">100</span>]; <span class=\"comment\">//record visited columns and  diagonals</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c[<span class=\"number\">100</span>]; <span class=\"comment\">//represent columns</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == N)&#123;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; c[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[<span class=\"number\">0</span>][i] &amp;&amp; !vis[<span class=\"number\">1</span>][n + i] &amp;&amp; !vis[<span class=\"number\">2</span>][n - i + N])&#123; <span class=\"comment\">// n - i　could be negative number, so we plus N.</span></span><br><span class=\"line\">            c[n] = i;</span><br><span class=\"line\">            vis[<span class=\"number\">0</span>][i] = vis[<span class=\"number\">1</span>][n + c[n]] = vis[<span class=\"number\">2</span>][n - c[n] + N] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">            vis[<span class=\"number\">0</span>][i] = vis[<span class=\"number\">1</span>][n + c[n]] = vis[<span class=\"number\">2</span>][n - c[n] + N] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(c, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(c));</span><br><span class=\"line\">    cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"total number: \"</span> &lt;&lt; cnt &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>八皇后问题，即在$8 \\times 8$的棋盘上放置8个皇后，使得它们互不攻击（皇后的攻击范围为同行同列和同对角线）。<br><img src=\"/2018/12/20/八皇后问题/queen.png\" alt=\"queen\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>刘汝佳《算法竞赛入门经典》（第2版）</p>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><p>比较容易想到的一个思路是把这个问题转换为“从64个格子中选八个格子”的问题。但是这一共有$C^8_64 = 4.426 \\times 10^9$种情况。我们可以考虑先排除一些明显不成立的情况，减少枚举量。首先八个皇后肯定是位于不同行不同列的，所以可以把这个问题看做求一个$0~7$的全排列问题。这样的话总的情况数为$8! = 40302$种，可以在1秒内完成检索。<br>(i，C[i])和(j，C[j])分别表示两个皇后坐标，它们位于同一对角线上的条件：<code>i - C[i] == j - C[j] || i + C[i] == j + C[j]</code><br><img src=\"/2018/12/20/八皇后问题/diagonal.png\" alt=\"diagonal\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[<span class=\"number\">3</span>][<span class=\"number\">100</span>]; <span class=\"comment\">//record visited columns and  diagonals</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c[<span class=\"number\">100</span>]; <span class=\"comment\">//represent columns</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == N)&#123;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; c[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[<span class=\"number\">0</span>][i] &amp;&amp; !vis[<span class=\"number\">1</span>][n + i] &amp;&amp; !vis[<span class=\"number\">2</span>][n - i + N])&#123; <span class=\"comment\">// n - i　could be negative number, so we plus N.</span></span><br><span class=\"line\">            c[n] = i;</span><br><span class=\"line\">            vis[<span class=\"number\">0</span>][i] = vis[<span class=\"number\">1</span>][n + c[n]] = vis[<span class=\"number\">2</span>][n - c[n] + N] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">            vis[<span class=\"number\">0</span>][i] = vis[<span class=\"number\">1</span>][n + c[n]] = vis[<span class=\"number\">2</span>][n - c[n] + N] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(c, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span>(c));</span><br><span class=\"line\">    cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"total number: \"</span> &lt;&lt; cnt &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"二叉树中序和后序遍历->层序和先序遍历","date":"2018-09-21T16:39:20.000Z","_content":"给定一个二叉树的中序遍历和后序遍历求出其层序遍历和先序遍历。\n<!--more-->\n## 建成一棵二叉树\n```C++\nint in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];\n//把in_order[l1...r1]和post_order[l2...r2]建成一棵二叉树，返回树根\nint build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return 0;\n    int v = post_order[r2];\n    int pos = 0;\n    while(in_order[pos] != v) pos++;\n    int len = pos - l1;\n    lch[v] = build(l1, l1 + len - 1, l2, l2 + len - 1);\n    rch[v] = build(l1 + len + 1, r1, l2 + len, l2 - 1);\n    return v;\n}\n```\n## 层序遍历\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 21:39:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint in_order[maxn], post_order[maxn];\nstring line;\nint n;\nvector<int> vec[maxn];\n\nvoid read(int* s){\n    getline(cin, line);\n    stringstream ss;\n    ss.str(line);\n    n = 0;\n    int x;\n    \n    while(ss >> x){\n        s[n++] = x;\n    }\n}\n\nint findd(int x){\n    int i;\n    for(i = 0; i < n; i++){\n        if(in_order[i] == x) break;\n    }\n    return i;\n}\n\nvoid build(int l1, int r1, int l2, int r2, int l){\n    if(l1 > r1) return;\n    int v = post_order[r2];\n    vec[l].push_back(v);\n    int pos = findd(v);\n    int len = pos - l1;\n    build(l1, l1 + len - 1, l2, l2 + len - 1, l + 1);\n    build(l1 + len + 1, r1, l2 + len, r2 - 1, l + 1);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    read(in_order);\n    read(post_order);\n    build(0, n - 1, 0, n - 1, 0);\n    \n    for(int i = 0; i < n; i++){\n        for(size_t j = 0; j < vec[i].size(); j++){\n            if(i == 0 && j == 0) cout << vec[i][j];\n            else cout << \" \" << vec[i][j];\n        }\n    }\n    cout << endl;\n    return 0;\n}\n```\n## 先序遍历\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 21:39:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint in_order[maxn], post_order[maxn];\nstring line;\nint n;\nvector<int> vec;\n\nvoid read(int* s){\n    getline(cin, line);\n    stringstream ss;\n    ss.str(line);\n    n = 0;\n    int x;\n    \n    while(ss >> x){\n        s[n++] = x;\n    }\n}\n\nint findd(int x){\n    int i;\n    for(i = 0; i < n; i++){\n        if(in_order[i] == x) break;\n    }\n    return i;\n}\n\nvoid build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return;\n    int v = post_order[r2];\n    vec.push_back(v);\n    int pos = findd(v);\n    int len = pos - l1;\n    build(l1, l1 + len - 1, l2, l2 + len - 1);\n    build(l1 + len + 1, r1, l2 + len, r2 - 1);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    read(in_order);\n    read(post_order);\n    build(0, n - 1, 0, n - 1);\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n","source":"_posts/二叉树中序和后序遍历-层序和先序遍历.md","raw":"---\ntitle: 二叉树中序和后序遍历->层序和先序遍历\ndate: 2018-09-22 00:39:20\ncategories:\n- Template\ntags:\n- 二叉树\n---\n给定一个二叉树的中序遍历和后序遍历求出其层序遍历和先序遍历。\n<!--more-->\n## 建成一棵二叉树\n```C++\nint in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];\n//把in_order[l1...r1]和post_order[l2...r2]建成一棵二叉树，返回树根\nint build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return 0;\n    int v = post_order[r2];\n    int pos = 0;\n    while(in_order[pos] != v) pos++;\n    int len = pos - l1;\n    lch[v] = build(l1, l1 + len - 1, l2, l2 + len - 1);\n    rch[v] = build(l1 + len + 1, r1, l2 + len, l2 - 1);\n    return v;\n}\n```\n## 层序遍历\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 21:39:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint in_order[maxn], post_order[maxn];\nstring line;\nint n;\nvector<int> vec[maxn];\n\nvoid read(int* s){\n    getline(cin, line);\n    stringstream ss;\n    ss.str(line);\n    n = 0;\n    int x;\n    \n    while(ss >> x){\n        s[n++] = x;\n    }\n}\n\nint findd(int x){\n    int i;\n    for(i = 0; i < n; i++){\n        if(in_order[i] == x) break;\n    }\n    return i;\n}\n\nvoid build(int l1, int r1, int l2, int r2, int l){\n    if(l1 > r1) return;\n    int v = post_order[r2];\n    vec[l].push_back(v);\n    int pos = findd(v);\n    int len = pos - l1;\n    build(l1, l1 + len - 1, l2, l2 + len - 1, l + 1);\n    build(l1 + len + 1, r1, l2 + len, r2 - 1, l + 1);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    read(in_order);\n    read(post_order);\n    build(0, n - 1, 0, n - 1, 0);\n    \n    for(int i = 0; i < n; i++){\n        for(size_t j = 0; j < vec[i].size(); j++){\n            if(i == 0 && j == 0) cout << vec[i][j];\n            else cout << \" \" << vec[i][j];\n        }\n    }\n    cout << endl;\n    return 0;\n}\n```\n## 先序遍历\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Fri 21 Sep 21:39:43 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 107;\nint in_order[maxn], post_order[maxn];\nstring line;\nint n;\nvector<int> vec;\n\nvoid read(int* s){\n    getline(cin, line);\n    stringstream ss;\n    ss.str(line);\n    n = 0;\n    int x;\n    \n    while(ss >> x){\n        s[n++] = x;\n    }\n}\n\nint findd(int x){\n    int i;\n    for(i = 0; i < n; i++){\n        if(in_order[i] == x) break;\n    }\n    return i;\n}\n\nvoid build(int l1, int r1, int l2, int r2){\n    if(l1 > r1) return;\n    int v = post_order[r2];\n    vec.push_back(v);\n    int pos = findd(v);\n    int len = pos - l1;\n    build(l1, l1 + len - 1, l2, l2 + len - 1);\n    build(l1 + len + 1, r1, l2 + len, r2 - 1);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    \n    read(in_order);\n    read(post_order);\n    build(0, n - 1, 0, n - 1);\n    for(size_t i = 0; i < vec.size(); i++){\n        if(i == 0) cout << vec[i];\n        else cout << \" \" << vec[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n","slug":"二叉树中序和后序遍历-层序和先序遍历","published":1,"updated":"2018-11-13T12:06:16.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrot0059b8oupojkfwjw","content":"<p>给定一个二叉树的中序遍历和后序遍历求出其层序遍历和先序遍历。<br><a id=\"more\"></a></p>\n<h2 id=\"建成一棵二叉树\"><a href=\"#建成一棵二叉树\" class=\"headerlink\" title=\"建成一棵二叉树\"></a>建成一棵二叉树</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];</span><br><span class=\"line\"><span class=\"comment\">//把in_order[l1...r1]和post_order[l2...r2]建成一棵二叉树，返回树根</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l1, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> l2, <span class=\"keyword\">int</span> r2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1 &gt; r1) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = post_order[r2];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(in_order[pos] != v) pos++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = pos - l1;</span><br><span class=\"line\">    lch[v] = build(l1, l1 + len - <span class=\"number\">1</span>, l2, l2 + len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    rch[v] = build(l1 + len + <span class=\"number\">1</span>, r1, l2 + len, l2 - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Fri 21 Sep 21:39:43 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">107</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> in_order[maxn], post_order[maxn];</span><br><span class=\"line\"><span class=\"built_in\">string</span> line;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span>* s)</span></span>&#123;</span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, line);</span><br><span class=\"line\">    <span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">    ss.str(line);</span><br><span class=\"line\">    n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss &gt;&gt; x)&#123;</span><br><span class=\"line\">        s[n++] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findd</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(in_order[i] == x) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l1, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> l2, <span class=\"keyword\">int</span> r2, <span class=\"keyword\">int</span> l)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1 &gt; r1) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = post_order[r2];</span><br><span class=\"line\">    vec[l].push_back(v);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = findd(v);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = pos - l1;</span><br><span class=\"line\">    build(l1, l1 + len - <span class=\"number\">1</span>, l2, l2 + len - <span class=\"number\">1</span>, l + <span class=\"number\">1</span>);</span><br><span class=\"line\">    build(l1 + len + <span class=\"number\">1</span>, r1, l2 + len, r2 - <span class=\"number\">1</span>, l + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    read(in_order);</span><br><span class=\"line\">    read(post_order);</span><br><span class=\"line\">    build(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; vec[i].size(); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; vec[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; vec[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Fri 21 Sep 21:39:43 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">107</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> in_order[maxn], post_order[maxn];</span><br><span class=\"line\"><span class=\"built_in\">string</span> line;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span>* s)</span></span>&#123;</span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, line);</span><br><span class=\"line\">    <span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">    ss.str(line);</span><br><span class=\"line\">    n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss &gt;&gt; x)&#123;</span><br><span class=\"line\">        s[n++] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findd</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(in_order[i] == x) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l1, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> l2, <span class=\"keyword\">int</span> r2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1 &gt; r1) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = post_order[r2];</span><br><span class=\"line\">    vec.push_back(v);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = findd(v);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = pos - l1;</span><br><span class=\"line\">    build(l1, l1 + len - <span class=\"number\">1</span>, l2, l2 + len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    build(l1 + len + <span class=\"number\">1</span>, r1, l2 + len, r2 - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    read(in_order);</span><br><span class=\"line\">    read(post_order);</span><br><span class=\"line\">    build(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; vec.size(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; vec[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; vec[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>给定一个二叉树的中序遍历和后序遍历求出其层序遍历和先序遍历。<br></p>","more":"<p></p>\n<h2 id=\"建成一棵二叉树\"><a href=\"#建成一棵二叉树\" class=\"headerlink\" title=\"建成一棵二叉树\"></a>建成一棵二叉树</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> in_order[maxn], post_order[maxn], lch[maxn], rch[maxn];</span><br><span class=\"line\"><span class=\"comment\">//把in_order[l1...r1]和post_order[l2...r2]建成一棵二叉树，返回树根</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l1, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> l2, <span class=\"keyword\">int</span> r2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1 &gt; r1) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = post_order[r2];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(in_order[pos] != v) pos++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = pos - l1;</span><br><span class=\"line\">    lch[v] = build(l1, l1 + len - <span class=\"number\">1</span>, l2, l2 + len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    rch[v] = build(l1 + len + <span class=\"number\">1</span>, r1, l2 + len, l2 - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"层序遍历\"><a href=\"#层序遍历\" class=\"headerlink\" title=\"层序遍历\"></a>层序遍历</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Fri 21 Sep 21:39:43 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">107</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> in_order[maxn], post_order[maxn];</span><br><span class=\"line\"><span class=\"built_in\">string</span> line;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec[maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span>* s)</span></span>&#123;</span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, line);</span><br><span class=\"line\">    <span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">    ss.str(line);</span><br><span class=\"line\">    n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss &gt;&gt; x)&#123;</span><br><span class=\"line\">        s[n++] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findd</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(in_order[i] == x) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l1, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> l2, <span class=\"keyword\">int</span> r2, <span class=\"keyword\">int</span> l)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1 &gt; r1) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = post_order[r2];</span><br><span class=\"line\">    vec[l].push_back(v);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = findd(v);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = pos - l1;</span><br><span class=\"line\">    build(l1, l1 + len - <span class=\"number\">1</span>, l2, l2 + len - <span class=\"number\">1</span>, l + <span class=\"number\">1</span>);</span><br><span class=\"line\">    build(l1 + len + <span class=\"number\">1</span>, r1, l2 + len, r2 - <span class=\"number\">1</span>, l + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    read(in_order);</span><br><span class=\"line\">    read(post_order);</span><br><span class=\"line\">    build(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> j = <span class=\"number\">0</span>; j &lt; vec[i].size(); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span> &amp;&amp; j == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; vec[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; vec[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"先序遍历\"><a href=\"#先序遍历\" class=\"headerlink\" title=\"先序遍历\"></a>先序遍历</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Fri 21 Sep 21:39:43 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">107</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> in_order[maxn], post_order[maxn];</span><br><span class=\"line\"><span class=\"built_in\">string</span> line;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span>* s)</span></span>&#123;</span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, line);</span><br><span class=\"line\">    <span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">    ss.str(line);</span><br><span class=\"line\">    n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss &gt;&gt; x)&#123;</span><br><span class=\"line\">        s[n++] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findd</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(in_order[i] == x) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> l1, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> l2, <span class=\"keyword\">int</span> r2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l1 &gt; r1) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = post_order[r2];</span><br><span class=\"line\">    vec.push_back(v);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pos = findd(v);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = pos - l1;</span><br><span class=\"line\">    build(l1, l1 + len - <span class=\"number\">1</span>, l2, l2 + len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    build(l1 + len + <span class=\"number\">1</span>, r1, l2 + len, r2 - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    read(in_order);</span><br><span class=\"line\">    read(post_order);</span><br><span class=\"line\">    build(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; vec.size(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; vec[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; vec[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"欧拉路","date":"2018-11-04T12:54:42.000Z","_content":"有一条名为Pregel的河流经过Konigsberg城。城中有7座桥，把河中的两个岛与河岸连接起来。当地居民热衷于一个难题：是否存在一条线路，可以不重复的走遍7座桥。这就是著名的七桥问题。它由大数学家欧拉首先提出，并给出完美的解答，所以这样的一条路也叫欧拉道路。\n![Elur](/Elur.png)\n<!--more-->\n## 参考\n《算法竞赛入门经典（2）》\nPs：图片来自[维基百科](https://www.wikiwand.com/zh-hans/%E6%9F%AF%E5%B0%BC%E6%96%AF%E5%A0%A1%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98)\n## 欧拉路（欧拉回路）\n将七桥问题用图论的形式表达：能否从无向图中的一个结点出发走出一条道路，每条边恰好经过一次。\n可以发现，除起点和终点外其它点的“进”和“出”是对应的，即其它点的度数应为偶数。这也是判断欧拉路是否存在的充分条件--**如果一个无向图是连通的，且最多只有两个奇点，则一定存在欧拉道路。如果有两个奇点，则必须从其中一个奇点出发，另一个奇点终止；如果奇点不存在，则可以从任意点出发，最终一点会回到该点（欧拉回路）**\n类似的对有向图来说--**最多只能有两个点的入度不等于出度， 而且必须是其中一个点的出度恰好比入度大1（把它作为起点），另一个的入度比出度大1（把它作为终点）。还有一个前提条件：在忽略边的方向后，图必须是连通的**\n## 代码\n```C++\nvoid elur(int u){\n    for(int v = 0; v < n; v++){\n        if(G[u][v] && !vis[u][v]){\n            vis[u][v] = vis[v][u] = 1;\n            elur(v);\n        }\n        printf(\"%d %d\\n\", u, v);\n    }\n}\n\n//说明\n1.上面的代码适用于无向图，但是可以改为有向图：把vis[u][v] = vis[v][u] = 1改成vis[u][v] = 1\n2.上面的代码是逆序打印，可以把printf改为push，将边压栈，最后顺序打印。\n```\n","source":"_posts/欧拉回路.md","raw":"---\ntitle: 欧拉路\ndate: 2018-11-04 20:54:42\ncategories:\n- Summary\ntags:\n- 欧拉路\n---\n有一条名为Pregel的河流经过Konigsberg城。城中有7座桥，把河中的两个岛与河岸连接起来。当地居民热衷于一个难题：是否存在一条线路，可以不重复的走遍7座桥。这就是著名的七桥问题。它由大数学家欧拉首先提出，并给出完美的解答，所以这样的一条路也叫欧拉道路。\n![Elur](/Elur.png)\n<!--more-->\n## 参考\n《算法竞赛入门经典（2）》\nPs：图片来自[维基百科](https://www.wikiwand.com/zh-hans/%E6%9F%AF%E5%B0%BC%E6%96%AF%E5%A0%A1%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98)\n## 欧拉路（欧拉回路）\n将七桥问题用图论的形式表达：能否从无向图中的一个结点出发走出一条道路，每条边恰好经过一次。\n可以发现，除起点和终点外其它点的“进”和“出”是对应的，即其它点的度数应为偶数。这也是判断欧拉路是否存在的充分条件--**如果一个无向图是连通的，且最多只有两个奇点，则一定存在欧拉道路。如果有两个奇点，则必须从其中一个奇点出发，另一个奇点终止；如果奇点不存在，则可以从任意点出发，最终一点会回到该点（欧拉回路）**\n类似的对有向图来说--**最多只能有两个点的入度不等于出度， 而且必须是其中一个点的出度恰好比入度大1（把它作为起点），另一个的入度比出度大1（把它作为终点）。还有一个前提条件：在忽略边的方向后，图必须是连通的**\n## 代码\n```C++\nvoid elur(int u){\n    for(int v = 0; v < n; v++){\n        if(G[u][v] && !vis[u][v]){\n            vis[u][v] = vis[v][u] = 1;\n            elur(v);\n        }\n        printf(\"%d %d\\n\", u, v);\n    }\n}\n\n//说明\n1.上面的代码适用于无向图，但是可以改为有向图：把vis[u][v] = vis[v][u] = 1改成vis[u][v] = 1\n2.上面的代码是逆序打印，可以把printf改为push，将边压栈，最后顺序打印。\n```\n","slug":"欧拉回路","published":1,"updated":"2018-11-13T12:08:09.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrov005eb8oudsahffde","content":"<p>有一条名为Pregel的河流经过Konigsberg城。城中有7座桥，把河中的两个岛与河岸连接起来。当地居民热衷于一个难题：是否存在一条线路，可以不重复的走遍7座桥。这就是著名的七桥问题。它由大数学家欧拉首先提出，并给出完美的解答，所以这样的一条路也叫欧拉道路。<br><img src=\"/2018/11/04/欧拉回路/Elur.png\" alt=\"Elur\"><br><a id=\"more\"></a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《算法竞赛入门经典（2）》<br>Ps：图片来自<a href=\"https://www.wikiwand.com/zh-hans/%E6%9F%AF%E5%B0%BC%E6%96%AF%E5%A0%A1%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n<h2 id=\"欧拉路（欧拉回路）\"><a href=\"#欧拉路（欧拉回路）\" class=\"headerlink\" title=\"欧拉路（欧拉回路）\"></a>欧拉路（欧拉回路）</h2><p>将七桥问题用图论的形式表达：能否从无向图中的一个结点出发走出一条道路，每条边恰好经过一次。<br>可以发现，除起点和终点外其它点的“进”和“出”是对应的，即其它点的度数应为偶数。这也是判断欧拉路是否存在的充分条件–<strong>如果一个无向图是连通的，且最多只有两个奇点，则一定存在欧拉道路。如果有两个奇点，则必须从其中一个奇点出发，另一个奇点终止；如果奇点不存在，则可以从任意点出发，最终一点会回到该点（欧拉回路）</strong><br>类似的对有向图来说–<strong>最多只能有两个点的入度不等于出度， 而且必须是其中一个点的出度恰好比入度大1（把它作为起点），另一个的入度比出度大1（把它作为终点）。还有一个前提条件：在忽略边的方向后，图必须是连通的</strong></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">elur</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v = <span class=\"number\">0</span>; v &lt; n; v++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G[u][v] &amp;&amp; !vis[u][v])&#123;</span><br><span class=\"line\">            vis[u][v] = vis[v][u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            elur(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, u, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//说明</span></span><br><span class=\"line\"><span class=\"number\">1.</span>上面的代码适用于无向图，但是可以改为有向图：把vis[u][v] = vis[v][u] = <span class=\"number\">1</span>改成vis[u][v] = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2.</span>上面的代码是逆序打印，可以把<span class=\"built_in\">printf</span>改为push，将边压栈，最后顺序打印。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>有一条名为Pregel的河流经过Konigsberg城。城中有7座桥，把河中的两个岛与河岸连接起来。当地居民热衷于一个难题：是否存在一条线路，可以不重复的走遍7座桥。这就是著名的七桥问题。它由大数学家欧拉首先提出，并给出完美的解答，所以这样的一条路也叫欧拉道路。<br><img src=\"/2018/11/04/欧拉回路/Elur.png\" alt=\"Elur\"><br></p>","more":"<p></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《算法竞赛入门经典（2）》<br>Ps：图片来自<a href=\"https://www.wikiwand.com/zh-hans/%E6%9F%AF%E5%B0%BC%E6%96%AF%E5%A0%A1%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n<h2 id=\"欧拉路（欧拉回路）\"><a href=\"#欧拉路（欧拉回路）\" class=\"headerlink\" title=\"欧拉路（欧拉回路）\"></a>欧拉路（欧拉回路）</h2><p>将七桥问题用图论的形式表达：能否从无向图中的一个结点出发走出一条道路，每条边恰好经过一次。<br>可以发现，除起点和终点外其它点的“进”和“出”是对应的，即其它点的度数应为偶数。这也是判断欧拉路是否存在的充分条件–<strong>如果一个无向图是连通的，且最多只有两个奇点，则一定存在欧拉道路。如果有两个奇点，则必须从其中一个奇点出发，另一个奇点终止；如果奇点不存在，则可以从任意点出发，最终一点会回到该点（欧拉回路）</strong><br>类似的对有向图来说–<strong>最多只能有两个点的入度不等于出度， 而且必须是其中一个点的出度恰好比入度大1（把它作为起点），另一个的入度比出度大1（把它作为终点）。还有一个前提条件：在忽略边的方向后，图必须是连通的</strong></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">elur</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v = <span class=\"number\">0</span>; v &lt; n; v++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(G[u][v] &amp;&amp; !vis[u][v])&#123;</span><br><span class=\"line\">            vis[u][v] = vis[v][u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            elur(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, u, v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//说明</span></span><br><span class=\"line\"><span class=\"number\">1.</span>上面的代码适用于无向图，但是可以改为有向图：把vis[u][v] = vis[v][u] = <span class=\"number\">1</span>改成vis[u][v] = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2.</span>上面的代码是逆序打印，可以把<span class=\"built_in\">printf</span>改为push，将边压栈，最后顺序打印。</span><br></pre></td></tr></table></figure>"},{"title":"循环小数化为分数的方法","date":"2018-12-09T15:14:07.000Z","_content":"修数学双学位的朋友给我出了一道小学奥数题= =，一个以abc为循环节的小数0.abc...，（其中a，b，c都是0～9的整数，且互不相同）。假设它的真分数表达形式为$\\frac{m}{n}，0 < n < 100$，求这个范围里的所有的n的可能取值。然而我用程序暴力破解了2333。虽然被朋友谴责了，但是这就是程序猿的解决方式(逃\n下面先给出数学求解方式，最后附上暴力破解程序。\n<!--more-->\n## 参考链接\n[Wikiwand-循环小数](https://www.wikiwand.com/zh-cn/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0)\n[无限循环小数化分数](http://math001.com/decimal_to_fraction/)\n\n## 数学解法\n设x = 0.abcabcabc...，则1000x = abc.abcabcabc...。\n1000x - x = abc.abcabcabc... - 0.abcabcabc...，即999x = abc。所以$$x = \\frac{abc}{999}$$999的因子有1，3，9，27，37，111，333，999，因为a，b，c各不相同且0 < n < 100，所以n的可能取值为27和37。\n\n维基百科上关于计算更一般情况的解法：\n![wiki](/wiki.png)\n此外第二个参考链接的博主还提出了一种计算等比数列和的求解方式也很有意思。\n\n## 暴力解法\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 10 Dec 00:11:35 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\n\nbool ok(string s){\n    if(s[2] == s[5] && s[3] == s[6] && s[4] == s[7] && s[2] != s[3] && s[2] != s[4] && s[3] != s[4]){\n        return true;\n    }\n    return false;\n}\n\nint gcd(int a, int b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n\n    for(int m = 1; m < 100; m++){\n        for(int n = m + 1; n < 100; n++){\n            double x = (double)m / n;\n            stringstream ss;\n            ss << x;\n            ss >> s;\n            if(ok(s)){\n                int d = gcd(m, n);\n                cout << m / d << \" \" << n / d << \" \" << x << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n```","source":"_posts/循环小数化为分数的方法.md","raw":"---\ntitle: 循环小数化为分数的方法\ndate: 2018-12-09 23:14:07\ncategories:\n- Math\ntags:\n- Math\n---\n修数学双学位的朋友给我出了一道小学奥数题= =，一个以abc为循环节的小数0.abc...，（其中a，b，c都是0～9的整数，且互不相同）。假设它的真分数表达形式为$\\frac{m}{n}，0 < n < 100$，求这个范围里的所有的n的可能取值。然而我用程序暴力破解了2333。虽然被朋友谴责了，但是这就是程序猿的解决方式(逃\n下面先给出数学求解方式，最后附上暴力破解程序。\n<!--more-->\n## 参考链接\n[Wikiwand-循环小数](https://www.wikiwand.com/zh-cn/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0)\n[无限循环小数化分数](http://math001.com/decimal_to_fraction/)\n\n## 数学解法\n设x = 0.abcabcabc...，则1000x = abc.abcabcabc...。\n1000x - x = abc.abcabcabc... - 0.abcabcabc...，即999x = abc。所以$$x = \\frac{abc}{999}$$999的因子有1，3，9，27，37，111，333，999，因为a，b，c各不相同且0 < n < 100，所以n的可能取值为27和37。\n\n维基百科上关于计算更一般情况的解法：\n![wiki](/wiki.png)\n此外第二个参考链接的博主还提出了一种计算等比数列和的求解方式也很有意思。\n\n## 暴力解法\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Mon 10 Dec 00:11:35 CST 2018\n *\n */\n \n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\n\nbool ok(string s){\n    if(s[2] == s[5] && s[3] == s[6] && s[4] == s[7] && s[2] != s[3] && s[2] != s[4] && s[3] != s[4]){\n        return true;\n    }\n    return false;\n}\n\nint gcd(int a, int b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n\n    for(int m = 1; m < 100; m++){\n        for(int n = m + 1; n < 100; n++){\n            double x = (double)m / n;\n            stringstream ss;\n            ss << x;\n            ss >> s;\n            if(ok(s)){\n                int d = gcd(m, n);\n                cout << m / d << \" \" << n / d << \" \" << x << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n```","slug":"循环小数化为分数的方法","published":1,"updated":"2018-12-09T16:26:55.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrox005hb8ou0wtrrf6a","content":"<p>修数学双学位的朋友给我出了一道小学奥数题= =，一个以abc为循环节的小数0.abc…，（其中a，b，c都是0～9的整数，且互不相同）。假设它的真分数表达形式为$\\frac{m}{n}，0 &lt; n &lt; 100$，求这个范围里的所有的n的可能取值。然而我用程序暴力破解了2333。虽然被朋友谴责了，但是这就是程序猿的解决方式(逃<br>下面先给出数学求解方式，最后附上暴力破解程序。<br><a id=\"more\"></a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.wikiwand.com/zh-cn/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0\" target=\"_blank\" rel=\"noopener\">Wikiwand-循环小数</a><br><a href=\"http://math001.com/decimal_to_fraction/\" target=\"_blank\" rel=\"noopener\">无限循环小数化分数</a></p>\n<h2 id=\"数学解法\"><a href=\"#数学解法\" class=\"headerlink\" title=\"数学解法\"></a>数学解法</h2><p>设x = 0.abcabcabc…，则1000x = abc.abcabcabc…。<br>1000x - x = abc.abcabcabc… - 0.abcabcabc…，即999x = abc。所以$$x = \\frac{abc}{999}$$999的因子有1，3，9，27，37，111，333，999，因为a，b，c各不相同且0 &lt; n &lt; 100，所以n的可能取值为27和37。</p>\n<p>维基百科上关于计算更一般情况的解法：<br><img src=\"/2018/12/09/循环小数化为分数的方法/wiki.png\" alt=\"wiki\"><br>此外第二个参考链接的博主还提出了一种计算等比数列和的求解方式也很有意思。</p>\n<h2 id=\"暴力解法\"><a href=\"#暴力解法\" class=\"headerlink\" title=\"暴力解法\"></a>暴力解法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon 10 Dec 00:11:35 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s[<span class=\"number\">2</span>] == s[<span class=\"number\">5</span>] &amp;&amp; s[<span class=\"number\">3</span>] == s[<span class=\"number\">6</span>] &amp;&amp; s[<span class=\"number\">4</span>] == s[<span class=\"number\">7</span>] &amp;&amp; s[<span class=\"number\">2</span>] != s[<span class=\"number\">3</span>] &amp;&amp; s[<span class=\"number\">2</span>] != s[<span class=\"number\">4</span>] &amp;&amp; s[<span class=\"number\">3</span>] != s[<span class=\"number\">4</span>])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gcd(b, a % b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> m = <span class=\"number\">1</span>; m &lt; <span class=\"number\">100</span>; m++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n = m + <span class=\"number\">1</span>; n &lt; <span class=\"number\">100</span>; n++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">double</span> x = (<span class=\"keyword\">double</span>)m / n;</span><br><span class=\"line\">            <span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">            ss &lt;&lt; x;</span><br><span class=\"line\">            ss &gt;&gt; s;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ok(s))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> d = gcd(m, n);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; m / d &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; n / d &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; x &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>修数学双学位的朋友给我出了一道小学奥数题= =，一个以abc为循环节的小数0.abc…，（其中a，b，c都是0～9的整数，且互不相同）。假设它的真分数表达形式为$\\frac{m}{n}，0 &lt; n &lt; 100$，求这个范围里的所有的n的可能取值。然而我用程序暴力破解了2333。虽然被朋友谴责了，但是这就是程序猿的解决方式(逃<br>下面先给出数学求解方式，最后附上暴力破解程序。<br></p>","more":"<p></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.wikiwand.com/zh-cn/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0\" target=\"_blank\" rel=\"noopener\">Wikiwand-循环小数</a><br><a href=\"http://math001.com/decimal_to_fraction/\" target=\"_blank\" rel=\"noopener\">无限循环小数化分数</a></p>\n<h2 id=\"数学解法\"><a href=\"#数学解法\" class=\"headerlink\" title=\"数学解法\"></a>数学解法</h2><p>设x = 0.abcabcabc…，则1000x = abc.abcabcabc…。<br>1000x - x = abc.abcabcabc… - 0.abcabcabc…，即999x = abc。所以$$x = \\frac{abc}{999}$$999的因子有1，3，9，27，37，111，333，999，因为a，b，c各不相同且0 &lt; n &lt; 100，所以n的可能取值为27和37。</p>\n<p>维基百科上关于计算更一般情况的解法：<br><img src=\"/2018/12/09/循环小数化为分数的方法/wiki.png\" alt=\"wiki\"><br>此外第二个参考链接的博主还提出了一种计算等比数列和的求解方式也很有意思。</p>\n<h2 id=\"暴力解法\"><a href=\"#暴力解法\" class=\"headerlink\" title=\"暴力解法\"></a>暴力解法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Mon 10 Dec 00:11:35 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ok</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s[<span class=\"number\">2</span>] == s[<span class=\"number\">5</span>] &amp;&amp; s[<span class=\"number\">3</span>] == s[<span class=\"number\">6</span>] &amp;&amp; s[<span class=\"number\">4</span>] == s[<span class=\"number\">7</span>] &amp;&amp; s[<span class=\"number\">2</span>] != s[<span class=\"number\">3</span>] &amp;&amp; s[<span class=\"number\">2</span>] != s[<span class=\"number\">4</span>] &amp;&amp; s[<span class=\"number\">3</span>] != s[<span class=\"number\">4</span>])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gcd(b, a % b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ios::sync_with_stdio(false);</span></span><br><span class=\"line\">    <span class=\"comment\">//cin.tie(0);</span></span><br><span class=\"line\">    <span class=\"comment\">//cout.tie(0);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> m = <span class=\"number\">1</span>; m &lt; <span class=\"number\">100</span>; m++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> n = m + <span class=\"number\">1</span>; n &lt; <span class=\"number\">100</span>; n++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">double</span> x = (<span class=\"keyword\">double</span>)m / n;</span><br><span class=\"line\">            <span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">            ss &lt;&lt; x;</span><br><span class=\"line\">            ss &gt;&gt; s;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ok(s))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> d = gcd(m, n);</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; m / d &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; n / d &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; x &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Uva10562-Undraw the trees","date":"2018-11-12T23:33:42.000Z","_content":"看图写树。把类似如图所示的树用\"$(A(B()C(E()F())D(G())))$\"的形式输出出来。在奇怪的地方卡了好久= =，记录一下。\n![tree](/tree.png)\n<!--more-->\n## 链接\n[Uva10562-Undraw the trees](https://vjudge.net/problem/UVA-10562)\n\n## 题解\n直接递归输出。主要说一下自己的卡点：最开始代码34行部分写的是$r = y$，WA到怀疑人生，后来突然想到把字符串读入字符数组中时是覆盖操作，也就是说如果新读入的字符串的长度比已经缓存的要短的话，之前的字符串会有残留。例如，buf[10] = \"abcdef\"，然后再读入新的字符串\"xyz\"后，buf中的内容是\"xyz0ef\"（其中0表示字符串结束标志'\\0'）,自己也就是坑在了这个地方。解决方法有两种，一种是让$r = l$，然后遍历到'\\0'时结束,也就是注释的那种写法；另一种是每次都memset一下= =（经历这次事件后一定每次都记得memset...）。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 13 Nov 08:09:46 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200 + 7;\nchar mp[maxn][maxn];\nint t;\nint n;\n\nvoid dfs(int x, int y){\n    char c = mp[x][y];\n    cout << c << \"(\";\n    if(x + 1 < n && mp[x + 1][y] == '|'){\n        int l = y;\n        while(l > 0 && mp[x + 2][l - 1] == '-') l--;\n        int r = l;\n        while(mp[x + 2][r] == '-' && mp[x + 3][r] != '\\0') r++;\n        for(int i = l; i < r; i++){\n            if(!isspace(mp[x + 3][i])){\n                dfs(x + 3, i);\n            }\n        }\n        \n        /*\n        while(mp[x + 2][l] == '-' && mp[x + 3][l] != '\\0'){\n            if(!isspace(mp[x + 3][l])) dfs(x + 3, l);\n            l++;\n        }\n        */\n\n    }\n    cout << \")\";\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"../in.txt\", \"r\", stdin);\n    #endif\n    cin >> t;\n    getchar();\n    while(t--){\n        memset(mp, 0, sizeof(mp));\n        n = 0;\n        cout << \"(\";\n        while(fgets(mp[n], maxn, stdin)){\n            if(mp[n][0] == '#') break;\n            n++;\n        }\n        if(n){\n            for(int i = 0; i < maxn; i++){\n                if(mp[0][i] != ' '){\n                    dfs(0, i);\n                    break;\n                }\n            }\n        }\n        cout << \")\" << endl;\n    }\n    return 0;\n}\n```","source":"_posts/Uva10562-Undraw the trees.md","raw":"---\ntitle: Uva10562-Undraw the trees\ndate: 2018-11-13 07:33:42\ncategories:\n- ACM\n- 树\ntags:\n- 二叉树\n---\n看图写树。把类似如图所示的树用\"$(A(B()C(E()F())D(G())))$\"的形式输出出来。在奇怪的地方卡了好久= =，记录一下。\n![tree](/tree.png)\n<!--more-->\n## 链接\n[Uva10562-Undraw the trees](https://vjudge.net/problem/UVA-10562)\n\n## 题解\n直接递归输出。主要说一下自己的卡点：最开始代码34行部分写的是$r = y$，WA到怀疑人生，后来突然想到把字符串读入字符数组中时是覆盖操作，也就是说如果新读入的字符串的长度比已经缓存的要短的话，之前的字符串会有残留。例如，buf[10] = \"abcdef\"，然后再读入新的字符串\"xyz\"后，buf中的内容是\"xyz0ef\"（其中0表示字符串结束标志'\\0'）,自己也就是坑在了这个地方。解决方法有两种，一种是让$r = l$，然后遍历到'\\0'时结束,也就是注释的那种写法；另一种是每次都memset一下= =（经历这次事件后一定每次都记得memset...）。\n\n## 代码\n```C++\n/*\n *\n * Author : Aincrad\n *\n * Date : Tue 13 Nov 08:09:46 CST 2018\n *\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200 + 7;\nchar mp[maxn][maxn];\nint t;\nint n;\n\nvoid dfs(int x, int y){\n    char c = mp[x][y];\n    cout << c << \"(\";\n    if(x + 1 < n && mp[x + 1][y] == '|'){\n        int l = y;\n        while(l > 0 && mp[x + 2][l - 1] == '-') l--;\n        int r = l;\n        while(mp[x + 2][r] == '-' && mp[x + 3][r] != '\\0') r++;\n        for(int i = l; i < r; i++){\n            if(!isspace(mp[x + 3][i])){\n                dfs(x + 3, i);\n            }\n        }\n        \n        /*\n        while(mp[x + 2][l] == '-' && mp[x + 3][l] != '\\0'){\n            if(!isspace(mp[x + 3][l])) dfs(x + 3, l);\n            l++;\n        }\n        */\n\n    }\n    cout << \")\";\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"../in.txt\", \"r\", stdin);\n    #endif\n    cin >> t;\n    getchar();\n    while(t--){\n        memset(mp, 0, sizeof(mp));\n        n = 0;\n        cout << \"(\";\n        while(fgets(mp[n], maxn, stdin)){\n            if(mp[n][0] == '#') break;\n            n++;\n        }\n        if(n){\n            for(int i = 0; i < maxn; i++){\n                if(mp[0][i] != ' '){\n                    dfs(0, i);\n                    break;\n                }\n            }\n        }\n        cout << \")\" << endl;\n    }\n    return 0;\n}\n```","slug":"Uva10562-Undraw the trees","published":1,"updated":"2018-12-14T13:02:41.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslroy005mb8ou610xzm8j","content":"<p>看图写树。把类似如图所示的树用”$(A(B()C(E()F())D(G())))$”的形式输出出来。在奇怪的地方卡了好久= =，记录一下。<br><img src=\"/2018/11/13/Uva10562-Undraw the trees/tree.png\" alt=\"tree\"><br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-10562\" target=\"_blank\" rel=\"noopener\">Uva10562-Undraw the trees</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>直接递归输出。主要说一下自己的卡点：最开始代码34行部分写的是$r = y$，WA到怀疑人生，后来突然想到把字符串读入字符数组中时是覆盖操作，也就是说如果新读入的字符串的长度比已经缓存的要短的话，之前的字符串会有残留。例如，buf[10] = “abcdef”，然后再读入新的字符串”xyz”后，buf中的内容是”xyz0ef”（其中0表示字符串结束标志’\\0’）,自己也就是坑在了这个地方。解决方法有两种，一种是让$r = l$，然后遍历到’\\0’时结束,也就是注释的那种写法；另一种是每次都memset一下= =（经历这次事件后一定每次都记得memset…）。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 13 Nov 08:09:46 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">200</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> mp[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = mp[x][y];</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; c &lt;&lt; <span class=\"string\">\"(\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x + <span class=\"number\">1</span> &lt; n &amp;&amp; mp[x + <span class=\"number\">1</span>][y] == <span class=\"string\">'|'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = y;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &gt; <span class=\"number\">0</span> &amp;&amp; mp[x + <span class=\"number\">2</span>][l - <span class=\"number\">1</span>] == <span class=\"string\">'-'</span>) l--;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = l;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(mp[x + <span class=\"number\">2</span>][r] == <span class=\"string\">'-'</span> &amp;&amp; mp[x + <span class=\"number\">3</span>][r] != <span class=\"string\">'\\0'</span>) r++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = l; i &lt; r; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">isspace</span>(mp[x + <span class=\"number\">3</span>][i]))&#123;</span><br><span class=\"line\">                dfs(x + <span class=\"number\">3</span>, i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        while(mp[x + 2][l] == '-' &amp;&amp; mp[x + 3][l] != '\\0')&#123;</span></span><br><span class=\"line\"><span class=\"comment\">            if(!isspace(mp[x + 3][l])) dfs(x + 3, l);</span></span><br><span class=\"line\"><span class=\"comment\">            l++;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"../in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    getchar();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(mp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mp));</span><br><span class=\"line\">        n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"(\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fgets(mp[n], maxn, <span class=\"built_in\">stdin</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[n][<span class=\"number\">0</span>] == <span class=\"string\">'#'</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxn; i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mp[<span class=\"number\">0</span>][i] != <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">                    dfs(<span class=\"number\">0</span>, i);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\")\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>看图写树。把类似如图所示的树用”$(A(B()C(E()F())D(G())))$”的形式输出出来。在奇怪的地方卡了好久= =，记录一下。<br><img src=\"/2018/11/13/Uva10562-Undraw the trees/tree.png\" alt=\"tree\"><br></p>","more":"<p></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://vjudge.net/problem/UVA-10562\" target=\"_blank\" rel=\"noopener\">Uva10562-Undraw the trees</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>直接递归输出。主要说一下自己的卡点：最开始代码34行部分写的是$r = y$，WA到怀疑人生，后来突然想到把字符串读入字符数组中时是覆盖操作，也就是说如果新读入的字符串的长度比已经缓存的要短的话，之前的字符串会有残留。例如，buf[10] = “abcdef”，然后再读入新的字符串”xyz”后，buf中的内容是”xyz0ef”（其中0表示字符串结束标志’\\0’）,自己也就是坑在了这个地方。解决方法有两种，一种是让$r = l$，然后遍历到’\\0’时结束,也就是注释的那种写法；另一种是每次都memset一下= =（经历这次事件后一定每次都记得memset…）。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Author : Aincrad</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Date : Tue 13 Nov 08:09:46 CST 2018</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">200</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> mp[maxn][maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = mp[x][y];</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; c &lt;&lt; <span class=\"string\">\"(\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x + <span class=\"number\">1</span> &lt; n &amp;&amp; mp[x + <span class=\"number\">1</span>][y] == <span class=\"string\">'|'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = y;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &gt; <span class=\"number\">0</span> &amp;&amp; mp[x + <span class=\"number\">2</span>][l - <span class=\"number\">1</span>] == <span class=\"string\">'-'</span>) l--;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = l;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(mp[x + <span class=\"number\">2</span>][r] == <span class=\"string\">'-'</span> &amp;&amp; mp[x + <span class=\"number\">3</span>][r] != <span class=\"string\">'\\0'</span>) r++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = l; i &lt; r; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">isspace</span>(mp[x + <span class=\"number\">3</span>][i]))&#123;</span><br><span class=\"line\">                dfs(x + <span class=\"number\">3</span>, i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        while(mp[x + 2][l] == '-' &amp;&amp; mp[x + 3][l] != '\\0')&#123;</span></span><br><span class=\"line\"><span class=\"comment\">            if(!isspace(mp[x + 3][l])) dfs(x + 3, l);</span></span><br><span class=\"line\"><span class=\"comment\">            l++;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        freopen(<span class=\"string\">\"../in.txt\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    getchar();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(mp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(mp));</span><br><span class=\"line\">        n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"(\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fgets(mp[n], maxn, <span class=\"built_in\">stdin</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[n][<span class=\"number\">0</span>] == <span class=\"string\">'#'</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxn; i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mp[<span class=\"number\">0</span>][i] != <span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">                    dfs(<span class=\"number\">0</span>, i);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\")\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"python脚本-tab转空格","date":"2018-06-12T03:38:20.000Z","_content":"有一个一直比较麻烦的问题，平时写代码都是在gedit上写，然后设置了tab键是4个空格的位置，但是代码粘到博客里tab就变成了8个空格的位置，严重破坏了代码的美观！不能容忍！一直没有找到怎么在hexo里面设置，所以之前一直手动把tab换成4个空格QAQ，慢慢的觉得这样很傻，我为什么不写个程序帮我自动改＝＝，首选python！（人生苦短，我用python）。虽然对python不是很熟悉，但是边查边写应该问题不大，最终完成了，从此再也不用傻傻的手动转换了，幸福/(ㄒoㄒ)/~~代码量很小\n<!-- more -->\n## 简介\n就是把文档里的tab全部转换成4个空格，其余不变\n效果图：\n转换前\n![tab](/tab.png)\n转换后\n![space](/space.png)\n## 代码\n``` python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*- \n\ndef T2S():\n    str = raw_input(\"file name:\")\n    file_path = \"/home/aincrad/Desktop/\" + str\n    f = open(file_path, \"r\")\n    fnew = open(\"/home/aincrad/Desktop/new\", \"w\")\n    data = f.read()\n    for c in data:\n        if c == '\\t':\n            fnew.write(\"    \")\n        else:\n            fnew.write(c)\n    f.close()\n    fnew.close()\n    print \"Done\"\n\nif __name__ == \"__main__\":\n    T2S()\n```\n*说明:默认了需要转换的文件在桌面，运行程序后只需要输入文件名即可，之后会在桌面上生成名为new的转换后的文件。*\n","source":"_posts/tab-to-spaces.md","raw":"---\ntitle: python脚本-tab转空格\ndate: 2018-06-12 11:38:20\ncategories:\n- Messy article\ntags:\n- python\n---\n有一个一直比较麻烦的问题，平时写代码都是在gedit上写，然后设置了tab键是4个空格的位置，但是代码粘到博客里tab就变成了8个空格的位置，严重破坏了代码的美观！不能容忍！一直没有找到怎么在hexo里面设置，所以之前一直手动把tab换成4个空格QAQ，慢慢的觉得这样很傻，我为什么不写个程序帮我自动改＝＝，首选python！（人生苦短，我用python）。虽然对python不是很熟悉，但是边查边写应该问题不大，最终完成了，从此再也不用傻傻的手动转换了，幸福/(ㄒoㄒ)/~~代码量很小\n<!-- more -->\n## 简介\n就是把文档里的tab全部转换成4个空格，其余不变\n效果图：\n转换前\n![tab](/tab.png)\n转换后\n![space](/space.png)\n## 代码\n``` python\n#!/usr/bin/python\n# -*- coding: UTF-8 -*- \n\ndef T2S():\n    str = raw_input(\"file name:\")\n    file_path = \"/home/aincrad/Desktop/\" + str\n    f = open(file_path, \"r\")\n    fnew = open(\"/home/aincrad/Desktop/new\", \"w\")\n    data = f.read()\n    for c in data:\n        if c == '\\t':\n            fnew.write(\"    \")\n        else:\n            fnew.write(c)\n    f.close()\n    fnew.close()\n    print \"Done\"\n\nif __name__ == \"__main__\":\n    T2S()\n```\n*说明:默认了需要转换的文件在桌面，运行程序后只需要输入文件名即可，之后会在桌面上生成名为new的转换后的文件。*\n","slug":"tab-to-spaces","published":1,"updated":"2018-08-09T15:52:30.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpwslrp0005pb8oui8v7q07a","content":"<p>有一个一直比较麻烦的问题，平时写代码都是在gedit上写，然后设置了tab键是4个空格的位置，但是代码粘到博客里tab就变成了8个空格的位置，严重破坏了代码的美观！不能容忍！一直没有找到怎么在hexo里面设置，所以之前一直手动把tab换成4个空格QAQ，慢慢的觉得这样很傻，我为什么不写个程序帮我自动改＝＝，首选python！（人生苦短，我用python）。虽然对python不是很熟悉，但是边查边写应该问题不大，最终完成了，从此再也不用傻傻的手动转换了，幸福/(ㄒoㄒ)/~~代码量很小<br><a id=\"more\"></a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>就是把文档里的tab全部转换成4个空格，其余不变<br>效果图：<br>转换前<br><img src=\"/2018/06/12/tab-to-spaces/tab.png\" alt=\"tab\"><br>转换后<br><img src=\"/2018/06/12/tab-to-spaces/space.png\" alt=\"space\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*- </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">T2S</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    str = raw_input(<span class=\"string\">\"file name:\"</span>)</span><br><span class=\"line\">    file_path = <span class=\"string\">\"/home/aincrad/Desktop/\"</span> + str</span><br><span class=\"line\">    f = open(file_path, <span class=\"string\">\"r\"</span>)</span><br><span class=\"line\">    fnew = open(<span class=\"string\">\"/home/aincrad/Desktop/new\"</span>, <span class=\"string\">\"w\"</span>)</span><br><span class=\"line\">    data = f.read()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'\\t'</span>:</span><br><span class=\"line\">            fnew.write(<span class=\"string\">\"    \"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            fnew.write(c)</span><br><span class=\"line\">    f.close()</span><br><span class=\"line\">    fnew.close()</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Done\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    T2S()</span><br></pre></td></tr></table></figure>\n<p><em>说明:默认了需要转换的文件在桌面，运行程序后只需要输入文件名即可，之后会在桌面上生成名为new的转换后的文件。</em></p>\n","site":{"data":{}},"excerpt":"<p>有一个一直比较麻烦的问题，平时写代码都是在gedit上写，然后设置了tab键是4个空格的位置，但是代码粘到博客里tab就变成了8个空格的位置，严重破坏了代码的美观！不能容忍！一直没有找到怎么在hexo里面设置，所以之前一直手动把tab换成4个空格QAQ，慢慢的觉得这样很傻，我为什么不写个程序帮我自动改＝＝，首选python！（人生苦短，我用python）。虽然对python不是很熟悉，但是边查边写应该问题不大，最终完成了，从此再也不用傻傻的手动转换了，幸福/(ㄒoㄒ)/~~代码量很小<br></p>","more":"<p></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>就是把文档里的tab全部转换成4个空格，其余不变<br>效果图：<br>转换前<br><img src=\"/2018/06/12/tab-to-spaces/tab.png\" alt=\"tab\"><br>转换后<br><img src=\"/2018/06/12/tab-to-spaces/space.png\" alt=\"space\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*- </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">T2S</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    str = raw_input(<span class=\"string\">\"file name:\"</span>)</span><br><span class=\"line\">    file_path = <span class=\"string\">\"/home/aincrad/Desktop/\"</span> + str</span><br><span class=\"line\">    f = open(file_path, <span class=\"string\">\"r\"</span>)</span><br><span class=\"line\">    fnew = open(<span class=\"string\">\"/home/aincrad/Desktop/new\"</span>, <span class=\"string\">\"w\"</span>)</span><br><span class=\"line\">    data = f.read()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c == <span class=\"string\">'\\t'</span>:</span><br><span class=\"line\">            fnew.write(<span class=\"string\">\"    \"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            fnew.write(c)</span><br><span class=\"line\">    f.close()</span><br><span class=\"line\">    fnew.close()</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Done\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    T2S()</span><br></pre></td></tr></table></figure>\n<p><em>说明:默认了需要转换的文件在桌面，运行程序后只需要输入文件名即可，之后会在桌面上生成名为new的转换后的文件。</em></p>"}],"PostAsset":[{"_id":"source/_posts/Linear algebra-Dot product/1.gif","slug":"1.gif","post":"cjpwslrmf000yb8ou9kwqd76w","modified":1,"renderable":0},{"_id":"source/_posts/HDU1016-Prime-Ring-Problem-DFS/dfs.png","post":"cjpwslrm3000qb8oulspat00t","slug":"dfs.png","modified":1,"renderable":1},{"_id":"source/_posts/POJ1970-The-Game-DFS/Renju.png","post":"cjpwslrmn0015b8ouioynz3lo","slug":"Renju.png","modified":1,"renderable":1},{"_id":"source/_posts/Super-Mario/SuperMario.png","post":"cjpwslrmv001gb8ouvfcr1ia0","slug":"SuperMario.png","modified":1,"renderable":1},{"_id":"source/_posts/Uva12166-Equilibrium-Mobile/balance.png","post":"cjpwslrn70027b8ou0jlzv8n0","slug":"balance.png","modified":1,"renderable":1},{"_id":"source/_posts/Uva221-Urban-Elevations/building.png","post":"cjpwslrnn0030b8ougajoimbs","slug":"building.png","modified":1,"renderable":1},{"_id":"source/_posts/Uva839-二叉树的递归处理/tree.png","post":"cjpwslrnv003fb8ou7twenwm5","slug":"tree.png","modified":1,"renderable":1},{"_id":"source/_posts/欧拉回路/Elur.png","post":"cjpwslrov005eb8oudsahffde","slug":"Elur.png","modified":1,"renderable":1},{"_id":"source/_posts/循环小数化为分数的方法/wiki.png","post":"cjpwslrox005hb8ou0wtrrf6a","slug":"wiki.png","modified":1,"renderable":1},{"_id":"source/_posts/Uva10562-Undraw the trees/tree.png","post":"cjpwslroy005mb8ou610xzm8j","slug":"tree.png","modified":1,"renderable":1},{"_id":"source/_posts/Graph-Theory-The-shortest-path/gra.png","post":"cjpwslrgm000hb8ou8gn1nnul","slug":"gra.png","modified":1,"renderable":1},{"_id":"source/_posts/Graph-Theory-The-shortest-path/path.png","post":"cjpwslrgm000hb8ou8gn1nnul","slug":"path.png","modified":1,"renderable":1},{"_id":"source/_posts/HDU2050/line.jpg","post":"cjpwslrmq0017b8ou7t6erf0o","slug":"line.jpg","modified":1,"renderable":1},{"_id":"source/_posts/HDU2050/res.gif","post":"cjpwslrmq0017b8ou7t6erf0o","slug":"res.gif","modified":1,"renderable":1},{"_id":"source/_posts/Uva806-Spatial-Structures/1.png","post":"cjpwslrnq0037b8ouyjcg0wny","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Uva806-Spatial-Structures/2.png","post":"cjpwslrnq0037b8ouyjcg0wny","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/八皇后问题/diagonal.png","post":"cjpwslros0056b8ouj6mvsvjv","slug":"diagonal.png","modified":1,"renderable":1},{"_id":"source/_posts/八皇后问题/queen.png","post":"cjpwslros0056b8ouj6mvsvjv","slug":"queen.png","modified":1,"renderable":1},{"_id":"source/_posts/tab-to-spaces/space.png","post":"cjpwslrp0005pb8oui8v7q07a","slug":"space.png","modified":1,"renderable":1},{"_id":"source/_posts/tab-to-spaces/tab.png","post":"cjpwslrp0005pb8oui8v7q07a","slug":"tab.png","modified":1,"renderable":1},{"_id":"source/_posts/Linear algebra-Dot product/2.gif","slug":"2.gif","post":"cjpwslrmf000yb8ou9kwqd76w","modified":1,"renderable":0},{"_id":"source/_posts/Linear algebra-Dot product/3.gif","slug":"3.gif","post":"cjpwslrmf000yb8ou9kwqd76w","modified":1,"renderable":0},{"_id":"source/_posts/My-little-angel/moon1.jpg","post":"cjpwslrmz001qb8ou607a3db0","slug":"moon1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/My-little-angel/qxy1.jpg","post":"cjpwslrmz001qb8ou607a3db0","slug":"qxy1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/My-little-angel/together1.jpg","post":"cjpwslrmz001qb8ou607a3db0","slug":"together1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Uva1103-Ancient-Messages/1.png","post":"cjpwslrn1001tb8oubx1hnn3i","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Uva1103-Ancient-Messages/2.png","post":"cjpwslrn1001tb8oubx1hnn3i","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Uva1103-Ancient-Messages/hier.png","post":"cjpwslrn1001tb8oubx1hnn3i","slug":"hier.png","modified":1,"renderable":1},{"_id":"source/_posts/vultr/p1.png","post":"cjpwslroq0051b8ou0mcau2yn","slug":"p1.png","modified":1,"renderable":1},{"_id":"source/_posts/vultr/p2.png","post":"cjpwslroq0051b8ou0mcau2yn","slug":"p2.png","modified":1,"renderable":1},{"_id":"source/_posts/vultr/p3.png","post":"cjpwslroq0051b8ou0mcau2yn","slug":"p3.png","modified":1,"renderable":1},{"_id":"source/_posts/vultr/p4.png","post":"cjpwslroq0051b8ou0mcau2yn","slug":"p4.png","modified":1,"renderable":1},{"_id":"source/_posts/vultr/p5.png","post":"cjpwslroq0051b8ou0mcau2yn","slug":"p5.png","modified":1,"renderable":1},{"_id":"source/_posts/vultr/p6.png","post":"cjpwslroq0051b8ou0mcau2yn","slug":"p6.png","modified":1,"renderable":1},{"_id":"source/_posts/vultr/p7.png","post":"cjpwslroq0051b8ou0mcau2yn","slug":"p7.png","modified":1,"renderable":1},{"_id":"source/_posts/vultr/p8.png","post":"cjpwslroq0051b8ou0mcau2yn","slug":"p8.png","modified":1,"renderable":1},{"_id":"source/_posts/vultr/p9.png","post":"cjpwslroq0051b8ou0mcau2yn","slug":"p9.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjpwslrfp0000b8ou5zrin4p3","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrg5000cb8ouxjhdvgpy"},{"post_id":"cjpwslrfp0000b8ou5zrin4p3","category_id":"cjpwslrg40008b8oug2lchr1p","_id":"cjpwslrg5000eb8ou2t5seb80"},{"post_id":"cjpwslrfw0002b8ouu66rw5vs","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrg6000fb8ou0whlcsqp"},{"post_id":"cjpwslrfw0002b8ouu66rw5vs","category_id":"cjpwslrg5000ab8oupcphkwzw","_id":"cjpwslrg6000gb8ouv6s9luo6"},{"post_id":"cjpwslrgn000ib8ouv7o0x58t","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrgq000mb8ouu7o5uh1i"},{"post_id":"cjpwslrgn000ib8ouv7o0x58t","category_id":"cjpwslrg40008b8oug2lchr1p","_id":"cjpwslrgq000ob8oulqgauld4"},{"post_id":"cjpwslrgm000hb8ou8gn1nnul","category_id":"cjpwslrgo000jb8oudxyv7zw3","_id":"cjpwslrgq000pb8oulrkhmybi"},{"post_id":"cjpwslrm3000qb8oulspat00t","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrmr0018b8ouv8oz0lw8"},{"post_id":"cjpwslrm3000qb8oulspat00t","category_id":"cjpwslrme000wb8ouy8597y9g","_id":"cjpwslrmt001cb8oudg1mm8fe"},{"post_id":"cjpwslrmk0010b8ou94wu09fu","category_id":"cjpwslrgo000jb8oudxyv7zw3","_id":"cjpwslrmv001eb8ouicn2ypuk"},{"post_id":"cjpwslrmn0015b8ouioynz3lo","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrmw001ib8ou291jqvn3"},{"post_id":"cjpwslrmn0015b8ouioynz3lo","category_id":"cjpwslrme000wb8ouy8597y9g","_id":"cjpwslrmx001kb8oupxqd0n2o"},{"post_id":"cjpwslrm8000sb8ouy8nmc4t7","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrmz001ob8ouzy6s3y0h"},{"post_id":"cjpwslrm8000sb8ouy8nmc4t7","category_id":"cjpwslrmm0013b8ouuuwdlie7","_id":"cjpwslrn0001rb8oun84sdxiw"},{"post_id":"cjpwslrmq0017b8ou7t6erf0o","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrn2001vb8ou06tibpne"},{"post_id":"cjpwslrmq0017b8ou7t6erf0o","category_id":"cjpwslrg40008b8oug2lchr1p","_id":"cjpwslrn3001zb8oug7316p7g"},{"post_id":"cjpwslrmf000yb8ou9kwqd76w","category_id":"cjpwslrmr001ab8oul1ob0kap","_id":"cjpwslrn40021b8ourprbiem5"},{"post_id":"cjpwslrms001bb8ou4gary5ii","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrn60026b8oukeng6yoe"},{"post_id":"cjpwslrms001bb8ou4gary5ii","category_id":"cjpwslrmw001hb8ouvbwr7z4r","_id":"cjpwslrn80029b8ougln78kyc"},{"post_id":"cjpwslrmt001db8ouxs536i3u","category_id":"cjpwslrmz001nb8ouny1unkw0","_id":"cjpwslrn9002db8ou8igxla19"},{"post_id":"cjpwslrn1001tb8oubx1hnn3i","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrnb002gb8ouj9zr6hu6"},{"post_id":"cjpwslrn1001tb8oubx1hnn3i","category_id":"cjpwslrme000wb8ouy8597y9g","_id":"cjpwslrnc002kb8ou2fmfgtf4"},{"post_id":"cjpwslrmv001gb8ouvfcr1ia0","category_id":"cjpwslrn2001wb8ou2oal69xt","_id":"cjpwslrnd002mb8ouh9s2kh30"},{"post_id":"cjpwslrn30020b8ouvhcggz34","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrng002pb8ounexeb7wy"},{"post_id":"cjpwslrn30020b8ouvhcggz34","category_id":"cjpwslrme000wb8ouy8597y9g","_id":"cjpwslrnk002tb8oubtzitnbu"},{"post_id":"cjpwslrmx001jb8ouduano1jm","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrnm002wb8ou25wic3nw"},{"post_id":"cjpwslrmx001jb8ouduano1jm","category_id":"cjpwslrn50023b8oufd7gm84v","_id":"cjpwslrno0031b8ou55734gkc"},{"post_id":"cjpwslrn8002bb8ouzdglhurf","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrnp0034b8oumrcj0ypu"},{"post_id":"cjpwslrn8002bb8ouzdglhurf","category_id":"cjpwslrn50023b8oufd7gm84v","_id":"cjpwslrnr0039b8ouh0g31jv5"},{"post_id":"cjpwslrna002fb8ou7b3dkvo2","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrnu003cb8ou17751gg3"},{"post_id":"cjpwslrna002fb8ou7b3dkvo2","category_id":"cjpwslrg40008b8oug2lchr1p","_id":"cjpwslrnx003hb8ouxvgqrpnd"},{"post_id":"cjpwslrmy001mb8oumtzy81lm","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrny003kb8ouezpt65ni"},{"post_id":"cjpwslrmy001mb8oumtzy81lm","category_id":"cjpwslrn9002cb8ou4sj3fpw0","_id":"cjpwslrnz003ob8ou7wcq8p6x"},{"post_id":"cjpwslrmz001qb8ou607a3db0","category_id":"cjpwslrnc002jb8our9bl6w8t","_id":"cjpwslro1003sb8ouk8kaguw3"},{"post_id":"cjpwslrn2001yb8ouq4mwde44","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslro4003wb8ou1zgocec6"},{"post_id":"cjpwslrn2001yb8ouq4mwde44","category_id":"cjpwslrng002qb8oucjjufqdd","_id":"cjpwslro70040b8ouqscj4tk3"},{"post_id":"cjpwslrn50024b8oue8lm16mn","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslro90043b8ouh2lir2hj"},{"post_id":"cjpwslrn50024b8oue8lm16mn","category_id":"cjpwslrnm002zb8oufbyjusq9","_id":"cjpwslroc0048b8oucfulrqu7"},{"post_id":"cjpwslrn70027b8ou0jlzv8n0","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrof004bb8oulmjhvy8q"},{"post_id":"cjpwslrn70027b8ou0jlzv8n0","category_id":"cjpwslrnr0038b8outyy0s90h","_id":"cjpwslrog004gb8ouuu51vhbt"},{"post_id":"cjpwslrnv003fb8ou7twenwm5","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslroi004jb8ou3nt7v2kt"},{"post_id":"cjpwslrnv003fb8ou7twenwm5","category_id":"cjpwslrnr0038b8outyy0s90h","_id":"cjpwslrok004ob8ou407pm1dd"},{"post_id":"cjpwslrnx003jb8oudtro2355","category_id":"cjpwslrgo000jb8oudxyv7zw3","_id":"cjpwslrom004rb8ou05wrcded"},{"post_id":"cjpwslrnb002ib8ouq11cy7ct","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrop004wb8ou2tt3hyjh"},{"post_id":"cjpwslrnb002ib8ouq11cy7ct","category_id":"cjpwslrnw003gb8oudqp8rf7z","_id":"cjpwslroq004zb8ourb2nja76"},{"post_id":"cjpwslrny003nb8ouddclayfs","category_id":"cjpwslrn2001wb8ou2oal69xt","_id":"cjpwslror0052b8ou4hg7xjqx"},{"post_id":"cjpwslro0003rb8oueivv5tcr","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrot0057b8oun2l8prra"},{"post_id":"cjpwslro0003rb8oueivv5tcr","category_id":"cjpwslrnr0038b8outyy0s90h","_id":"cjpwslrou005ab8ouaqs553w4"},{"post_id":"cjpwslrnc002lb8ouvzdzhnec","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrow005fb8oubekagdnc"},{"post_id":"cjpwslrnc002lb8ouvzdzhnec","category_id":"cjpwslrnz003pb8ouinnw3076","_id":"cjpwslroy005ib8oue9jcfxo9"},{"post_id":"cjpwslro1003ub8oua1uv9n0x","category_id":"cjpwslrmz001nb8ouny1unkw0","_id":"cjpwslroz005nb8ouuw70x20r"},{"post_id":"cjpwslro5003zb8oujvevwxe8","category_id":"cjpwslrmz001nb8ouny1unkw0","_id":"cjpwslrp1005qb8ouwkmdovce"},{"post_id":"cjpwslrnf002nb8ouyujz548h","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp2005ub8ouwemq9ol9"},{"post_id":"cjpwslrnf002nb8ouyujz548h","category_id":"cjpwslrnz003pb8ouinnw3076","_id":"cjpwslrp2005vb8ou9w4ktg2r"},{"post_id":"cjpwslro70042b8ouw02cau2m","category_id":"cjpwslrnc002jb8our9bl6w8t","_id":"cjpwslrp3005yb8ouefmtlfm0"},{"post_id":"cjpwslroa0047b8ouxvmn12d7","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp30060b8oudus8t3s9"},{"post_id":"cjpwslroa0047b8ouxvmn12d7","category_id":"cjpwslrme000wb8ouy8597y9g","_id":"cjpwslrp30062b8ouzmm637z9"},{"post_id":"cjpwslrnh002sb8oum4jltxq5","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp40065b8oug7a48ka4"},{"post_id":"cjpwslrnh002sb8oum4jltxq5","category_id":"cjpwslrnr0038b8outyy0s90h","_id":"cjpwslrp40067b8ouygrthndd"},{"post_id":"cjpwslrod004ab8ouwj8qmwdg","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp4006ab8oupfm5dadu"},{"post_id":"cjpwslrof004fb8ouu54k4qgn","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp4006bb8ou9ndi0uor"},{"post_id":"cjpwslrof004fb8ouu54k4qgn","category_id":"cjpwslrnr0038b8outyy0s90h","_id":"cjpwslrp5006db8ouugcrfuo0"},{"post_id":"cjpwslrnl002vb8ou229sk2he","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp5006fb8outbvmxhgr"},{"post_id":"cjpwslrnl002vb8ou229sk2he","category_id":"cjpwslrof004eb8outmn0prte","_id":"cjpwslrp5006hb8ou4k8200gj"},{"post_id":"cjpwslroh004ib8ou3o82hm7z","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp5006ib8ou0bux1geb"},{"post_id":"cjpwslroh004ib8ou3o82hm7z","category_id":"cjpwslrng002qb8oucjjufqdd","_id":"cjpwslrp5006kb8ouojl2zh4s"},{"post_id":"cjpwslrol004qb8ouv27clv5c","category_id":"cjpwslrmz001nb8ouny1unkw0","_id":"cjpwslrp6006mb8ouij7b3998"},{"post_id":"cjpwslrnn0030b8ougajoimbs","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp6006pb8oucpb3acjb"},{"post_id":"cjpwslrnn0030b8ougajoimbs","category_id":"cjpwslrok004nb8ou7aok9lob","_id":"cjpwslrp6006rb8ou808wp9r7"},{"post_id":"cjpwslrop004yb8ouu74czu79","category_id":"cjpwslrmz001nb8ouny1unkw0","_id":"cjpwslrp6006tb8ouro41rq2l"},{"post_id":"cjpwslrno0033b8ou86ak73ir","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp7006wb8ou65273qu1"},{"post_id":"cjpwslrno0033b8ou86ak73ir","category_id":"cjpwslroo004vb8ouqldtr9c3","_id":"cjpwslrp7006xb8ou6aq5g0hh"},{"post_id":"cjpwslroq0051b8ou0mcau2yn","category_id":"cjpwslrn2001wb8ou2oal69xt","_id":"cjpwslrp7006zb8oujpqvmelw"},{"post_id":"cjpwslros0056b8ouj6mvsvjv","category_id":"cjpwslrgo000jb8oudxyv7zw3","_id":"cjpwslrp70071b8oubu8le6na"},{"post_id":"cjpwslrnq0037b8ouyjcg0wny","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp80073b8oulqn8we4y"},{"post_id":"cjpwslrnq0037b8ouyjcg0wny","category_id":"cjpwslrnr0038b8outyy0s90h","_id":"cjpwslrp80074b8ouhx7my4rs"},{"post_id":"cjpwslrov005eb8oudsahffde","category_id":"cjpwslrgo000jb8oudxyv7zw3","_id":"cjpwslrp80076b8ounkgxzu4u"},{"post_id":"cjpwslrns003bb8ougi22v46a","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp80078b8ouwsf05jjm"},{"post_id":"cjpwslrns003bb8ougi22v46a","category_id":"cjpwslrnz003pb8ouinnw3076","_id":"cjpwslrp8007ab8ouirtqqx3c"},{"post_id":"cjpwslrox005hb8ou0wtrrf6a","category_id":"cjpwslrmr001ab8oul1ob0kap","_id":"cjpwslrp9007db8ourqvjls2g"},{"post_id":"cjpwslroy005mb8ou610xzm8j","category_id":"cjpwslrfy0003b8ou7na3kcre","_id":"cjpwslrp9007eb8outio19es6"},{"post_id":"cjpwslroy005mb8ou610xzm8j","category_id":"cjpwslrnr0038b8outyy0s90h","_id":"cjpwslrp9007hb8ouf9ak0pq9"},{"post_id":"cjpwslroj004mb8ous4w8khc7","category_id":"cjpwslroy005jb8ounfp8ffhg","_id":"cjpwslrp9007jb8ou2tf8g6n7"},{"post_id":"cjpwslrp0005pb8oui8v7q07a","category_id":"cjpwslrn2001wb8ou2oal69xt","_id":"cjpwslrpa007lb8ouxkya3v8o"},{"post_id":"cjpwslron004tb8ou4stwjxoo","category_id":"cjpwslroy005jb8ounfp8ffhg","_id":"cjpwslrpa007mb8ouwlga8ht9"},{"post_id":"cjpwslrot0059b8oupojkfwjw","category_id":"cjpwslroy005jb8ounfp8ffhg","_id":"cjpwslrpa007ob8ou9ue9um8s"}],"PostTag":[{"post_id":"cjpwslrfp0000b8ou5zrin4p3","tag_id":"cjpwslrg00004b8oukkg7r6wk","_id":"cjpwslrg30007b8ou9k8d4080"},{"post_id":"cjpwslrfw0002b8ouu66rw5vs","tag_id":"cjpwslrg10006b8ouv66566b0","_id":"cjpwslrg5000bb8ouhuljlywf"},{"post_id":"cjpwslrfw0002b8ouu66rw5vs","tag_id":"cjpwslrg40009b8ou3ey4f1ob","_id":"cjpwslrg5000db8ou7tyv6jfc"},{"post_id":"cjpwslrgn000ib8ouv7o0x58t","tag_id":"cjpwslrg00004b8oukkg7r6wk","_id":"cjpwslrgp000lb8oum9e3yhn5"},{"post_id":"cjpwslrgm000hb8ou8gn1nnul","tag_id":"cjpwslrgp000kb8ou7vb4k1h1","_id":"cjpwslrgq000nb8oumwao3pgs"},{"post_id":"cjpwslrm3000qb8oulspat00t","tag_id":"cjpwslrmc000ub8ouff0e3ym2","_id":"cjpwslrmn0014b8ougq7y4sy4"},{"post_id":"cjpwslrm8000sb8ouy8nmc4t7","tag_id":"cjpwslrml0011b8ouygmkoruq","_id":"cjpwslrmz001pb8ouw87299on"},{"post_id":"cjpwslrm8000sb8ouy8nmc4t7","tag_id":"cjpwslrmr0019b8oufo76bpr6","_id":"cjpwslrn0001sb8ou7nfpto7e"},{"post_id":"cjpwslrm8000sb8ouy8nmc4t7","tag_id":"cjpwslrmv001fb8out57m1eeq","_id":"cjpwslrn2001xb8ou8dd6605t"},{"post_id":"cjpwslrmf000yb8ou9kwqd76w","tag_id":"cjpwslrmy001lb8ouovl5fqb4","_id":"cjpwslrn60025b8ou4y7dfaz3"},{"post_id":"cjpwslrmf000yb8ou9kwqd76w","tag_id":"cjpwslrn2001ub8oudwlqkdeu","_id":"cjpwslrn70028b8oud6ayutom"},{"post_id":"cjpwslrmk0010b8ou94wu09fu","tag_id":"cjpwslrn50022b8ou4m88z4a0","_id":"cjpwslrn9002eb8ou1trb419d"},{"post_id":"cjpwslrnc002lb8ouvzdzhnec","tag_id":"cjpwslrmv001fb8out57m1eeq","_id":"cjpwslrnh002rb8ou7xca2wuz"},{"post_id":"cjpwslrmn0015b8ouioynz3lo","tag_id":"cjpwslrn8002ab8ouyj4x60n4","_id":"cjpwslrnl002ub8ou2igmizpq"},{"post_id":"cjpwslrmn0015b8ouioynz3lo","tag_id":"cjpwslrmc000ub8ouff0e3ym2","_id":"cjpwslrnm002yb8ouia10s576"},{"post_id":"cjpwslrmn0015b8ouioynz3lo","tag_id":"cjpwslrnb002hb8ou7bs1wta5","_id":"cjpwslrno0032b8ouu18o82ll"},{"post_id":"cjpwslrnf002nb8ouyujz548h","tag_id":"cjpwslrmv001fb8out57m1eeq","_id":"cjpwslrnp0036b8oulykm0alj"},{"post_id":"cjpwslrmq0017b8ou7t6erf0o","tag_id":"cjpwslrml0011b8ouygmkoruq","_id":"cjpwslrns003ab8oux65go849"},{"post_id":"cjpwslrmq0017b8ou7t6erf0o","tag_id":"cjpwslrng002ob8ouqy6senix","_id":"cjpwslrnv003eb8oupipdzaku"},{"post_id":"cjpwslrmq0017b8ou7t6erf0o","tag_id":"cjpwslrnm002xb8ous0q7eb6m","_id":"cjpwslrnx003ib8ouke76z0h6"},{"post_id":"cjpwslrmq0017b8ou7t6erf0o","tag_id":"cjpwslrg00004b8oukkg7r6wk","_id":"cjpwslrny003lb8ou8xkm4yhb"},{"post_id":"cjpwslrns003bb8ougi22v46a","tag_id":"cjpwslrmv001fb8out57m1eeq","_id":"cjpwslro0003qb8ouq22yolhx"},{"post_id":"cjpwslrms001bb8ou4gary5ii","tag_id":"cjpwslrn8002ab8ouyj4x60n4","_id":"cjpwslro1003tb8ou2oiwf369"},{"post_id":"cjpwslrms001bb8ou4gary5ii","tag_id":"cjpwslrnv003db8oucu73oeil","_id":"cjpwslro4003xb8ousd9akz93"},{"post_id":"cjpwslrnx003jb8oudtro2355","tag_id":"cjpwslrn50022b8ou4m88z4a0","_id":"cjpwslro70041b8ou43clm325"},{"post_id":"cjpwslrmt001db8ouxs536i3u","tag_id":"cjpwslrny003mb8ouxnpo7dof","_id":"cjpwslroa0045b8oukmh5fc0i"},{"post_id":"cjpwslrmv001gb8ouvfcr1ia0","tag_id":"cjpwslro4003vb8oujjvxzqk1","_id":"cjpwslrod0049b8ou0v52l0e8"},{"post_id":"cjpwslroa0047b8ouxvmn12d7","tag_id":"cjpwslrmc000ub8ouff0e3ym2","_id":"cjpwslrof004db8ou6rvgu9t2"},{"post_id":"cjpwslrmx001jb8ouduano1jm","tag_id":"cjpwslro90044b8ouv8l83537","_id":"cjpwslrog004hb8ou5dzzlqg6"},{"post_id":"cjpwslrmx001jb8ouduano1jm","tag_id":"cjpwslrmc000ub8ouff0e3ym2","_id":"cjpwslroj004kb8ouqum8a21q"},{"post_id":"cjpwslrod004ab8ouwj8qmwdg","tag_id":"cjpwslrnm002xb8ous0q7eb6m","_id":"cjpwslrol004pb8outstk9m1i"},{"post_id":"cjpwslrmy001mb8oumtzy81lm","tag_id":"cjpwslrmc000ub8ouff0e3ym2","_id":"cjpwslrom004sb8ou3syfpqha"},{"post_id":"cjpwslrmy001mb8oumtzy81lm","tag_id":"cjpwslrof004cb8ougj8mnt6j","_id":"cjpwslrop004xb8oum1vk9av5"},{"post_id":"cjpwslrol004qb8ouv27clv5c","tag_id":"cjpwslrmy001lb8ouovl5fqb4","_id":"cjpwslroq0050b8ouc4h1eyl4"},{"post_id":"cjpwslrmz001qb8ou607a3db0","tag_id":"cjpwslroj004lb8ou0o7hox2x","_id":"cjpwslros0055b8oubeyu1wpn"},{"post_id":"cjpwslrn1001tb8oubx1hnn3i","tag_id":"cjpwslrmc000ub8ouff0e3ym2","_id":"cjpwslrot0058b8ou8l9cu51z"},{"post_id":"cjpwslrn1001tb8oubx1hnn3i","tag_id":"cjpwslroo004ub8oumg2a73j7","_id":"cjpwslrov005db8out1y4gohs"},{"post_id":"cjpwslrn2001yb8ouq4mwde44","tag_id":"cjpwslror0053b8oux7thm9kc","_id":"cjpwslrow005gb8ouzndqawym"},{"post_id":"cjpwslrov005eb8oudsahffde","tag_id":"cjpwslro90044b8ouv8l83537","_id":"cjpwslroy005kb8oucuf0k6nv"},{"post_id":"cjpwslrn30020b8ouvhcggz34","tag_id":"cjpwslrmc000ub8ouff0e3ym2","_id":"cjpwslroz005ob8ouwq2n6qtw"},{"post_id":"cjpwslrn30020b8ouvhcggz34","tag_id":"cjpwslrov005cb8ouvhycra1q","_id":"cjpwslrp1005rb8ouuwe2aq8c"},{"post_id":"cjpwslrn50024b8oue8lm16mn","tag_id":"cjpwslroy005lb8ou4si54i44","_id":"cjpwslrp3005zb8ourac70oqz"},{"post_id":"cjpwslrn50024b8oue8lm16mn","tag_id":"cjpwslrny003mb8ouxnpo7dof","_id":"cjpwslrp30061b8oua24nbm4a"},{"post_id":"cjpwslrn70027b8ou0jlzv8n0","tag_id":"cjpwslrg00004b8oukkg7r6wk","_id":"cjpwslrp40064b8ou4y6k6jos"},{"post_id":"cjpwslrn70027b8ou0jlzv8n0","tag_id":"cjpwslrp3005xb8ouh1c9n9u0","_id":"cjpwslrp40066b8oub40k7frv"},{"post_id":"cjpwslrn8002bb8ouzdglhurf","tag_id":"cjpwslro90044b8ouv8l83537","_id":"cjpwslrp40069b8ouqsocdpr0"},{"post_id":"cjpwslrna002fb8ou7b3dkvo2","tag_id":"cjpwslrp40068b8ouvkde6env","_id":"cjpwslrp5006eb8oumh5mz5v9"},{"post_id":"cjpwslrnb002ib8ouq11cy7ct","tag_id":"cjpwslrp4006cb8ouknk6uifp","_id":"cjpwslrp6006lb8ou2rdvdenb"},{"post_id":"cjpwslrnb002ib8ouq11cy7ct","tag_id":"cjpwslrp5006gb8ou9zw82wrd","_id":"cjpwslrp6006nb8ouagvwqp4t"},{"post_id":"cjpwslrnh002sb8oum4jltxq5","tag_id":"cjpwslrp3005xb8ouh1c9n9u0","_id":"cjpwslrp6006qb8oua4poq8xq"},{"post_id":"cjpwslrnh002sb8oum4jltxq5","tag_id":"cjpwslrmc000ub8ouff0e3ym2","_id":"cjpwslrp6006sb8oue87i58e1"},{"post_id":"cjpwslrnl002vb8ou229sk2he","tag_id":"cjpwslrp6006ob8ouzl2tyj31","_id":"cjpwslrp7006vb8ouruqzfezh"},{"post_id":"cjpwslrnn0030b8ougajoimbs","tag_id":"cjpwslrp6006ub8oupkd9c1kg","_id":"cjpwslrp70070b8oujx05owml"},{"post_id":"cjpwslrno0033b8ou86ak73ir","tag_id":"cjpwslrp7006yb8ou5o7n0j2n","_id":"cjpwslrp80077b8ouabkdkksm"},{"post_id":"cjpwslrno0033b8ou86ak73ir","tag_id":"cjpwslrp70072b8ou1x79ewef","_id":"cjpwslrp80079b8ou7izcrknf"},{"post_id":"cjpwslrnq0037b8ouyjcg0wny","tag_id":"cjpwslrp80075b8ouh7w5nkcs","_id":"cjpwslrp9007cb8ouo8gu85l3"},{"post_id":"cjpwslrnv003fb8ou7twenwm5","tag_id":"cjpwslrp3005xb8ouh1c9n9u0","_id":"cjpwslrp9007gb8ouh24cfds1"},{"post_id":"cjpwslrnv003fb8ou7twenwm5","tag_id":"cjpwslrmc000ub8ouff0e3ym2","_id":"cjpwslrp9007ib8ouuvqxo9ha"},{"post_id":"cjpwslrny003nb8ouddclayfs","tag_id":"cjpwslrp9007fb8oudfxp30nb","_id":"cjpwslrpa007pb8ouafxmva5m"},{"post_id":"cjpwslrny003nb8ouddclayfs","tag_id":"cjpwslrpa007kb8ouqifx1qhh","_id":"cjpwslrpb007qb8ou58234v7x"},{"post_id":"cjpwslrny003nb8ouddclayfs","tag_id":"cjpwslrmy001lb8ouovl5fqb4","_id":"cjpwslrpb007sb8ouf2v3ikel"},{"post_id":"cjpwslro0003rb8oueivv5tcr","tag_id":"cjpwslrpa007nb8ouu3bnaep9","_id":"cjpwslrpb007tb8ou41rpjpjc"},{"post_id":"cjpwslro1003ub8oua1uv9n0x","tag_id":"cjpwslrpb007rb8ou0jij8flm","_id":"cjpwslrpc007vb8ouuwd0xa4i"},{"post_id":"cjpwslro5003zb8oujvevwxe8","tag_id":"cjpwslrpb007ub8oueeraejk6","_id":"cjpwslrpc007xb8ouw70fsq9t"},{"post_id":"cjpwslro70042b8ouw02cau2m","tag_id":"cjpwslrpc007wb8ou3rebjpk6","_id":"cjpwslrpd007zb8ou63ejychs"},{"post_id":"cjpwslro70042b8ouw02cau2m","tag_id":"cjpwslrmy001lb8ouovl5fqb4","_id":"cjpwslrpd0080b8ourwrse7dn"},{"post_id":"cjpwslrof004fb8ouu54k4qgn","tag_id":"cjpwslrp3005xb8ouh1c9n9u0","_id":"cjpwslrpd0082b8ouz91iyctn"},{"post_id":"cjpwslrof004fb8ouu54k4qgn","tag_id":"cjpwslrmv001fb8out57m1eeq","_id":"cjpwslrpd0083b8oui1c2fikl"},{"post_id":"cjpwslroh004ib8ou3o82hm7z","tag_id":"cjpwslror0053b8oux7thm9kc","_id":"cjpwslrpe0085b8ouyvp9qq7m"},{"post_id":"cjpwslroj004mb8ous4w8khc7","tag_id":"cjpwslrpe0084b8ouh91i0f2d","_id":"cjpwslrpe0087b8oumpiuss8h"},{"post_id":"cjpwslron004tb8ou4stwjxoo","tag_id":"cjpwslrpe0086b8ouju87svc3","_id":"cjpwslrpe0089b8ounp4o8tvn"},{"post_id":"cjpwslrop004yb8ouu74czu79","tag_id":"cjpwslrpe0088b8oudjolhcn2","_id":"cjpwslrpf008bb8ouf48iivo9"},{"post_id":"cjpwslroq0051b8ou0mcau2yn","tag_id":"cjpwslrpf008ab8oufdfjwtro","_id":"cjpwslrpf008db8ouv4qpr1ne"},{"post_id":"cjpwslrot0059b8oupojkfwjw","tag_id":"cjpwslrp3005xb8ouh1c9n9u0","_id":"cjpwslrpg008fb8ou3lkuwc20"},{"post_id":"cjpwslrox005hb8ou0wtrrf6a","tag_id":"cjpwslrpf008eb8ou3pjcnujn","_id":"cjpwslrpg008hb8ou51q1fvsf"},{"post_id":"cjpwslroy005mb8ou610xzm8j","tag_id":"cjpwslrp3005xb8ouh1c9n9u0","_id":"cjpwslrph008jb8ouwovmv4ov"},{"post_id":"cjpwslrp0005pb8oui8v7q07a","tag_id":"cjpwslrpg008ib8ouls832add","_id":"cjpwslrph008kb8ouzahlybm7"}],"Tag":[{"name":"思维","_id":"cjpwslrg00004b8oukkg7r6wk"},{"name":"前缀和","_id":"cjpwslrg10006b8ouv66566b0"},{"name":"后缀和","_id":"cjpwslrg40009b8ou3ey4f1ob"},{"name":"图论","_id":"cjpwslrgp000kb8ou7vb4k1h1"},{"name":"DFS","_id":"cjpwslrmc000ub8ouff0e3ym2"},{"name":"HDU","_id":"cjpwslrml0011b8ouygmkoruq"},{"name":"状态压缩DP","_id":"cjpwslrmr0019b8oufo76bpr6"},{"name":"BFS","_id":"cjpwslrmv001fb8out57m1eeq"},{"name":"总结","_id":"cjpwslrmy001lb8ouovl5fqb4"},{"name":"Liner algebra","_id":"cjpwslrn2001ub8oudwlqkdeu"},{"name":"C语言","_id":"cjpwslrn50022b8ou4m88z4a0"},{"name":"POJ","_id":"cjpwslrn8002ab8ouyj4x60n4"},{"name":"迷宫问题","_id":"cjpwslrnb002hb8ou7bs1wta5"},{"name":"线切割平面","_id":"cjpwslrng002ob8ouqy6senix"},{"name":"math","_id":"cjpwslrnm002xb8ous0q7eb6m"},{"name":"线段树","_id":"cjpwslrnv003db8oucu73oeil"},{"name":"STL","_id":"cjpwslrny003mb8ouxnpo7dof"},{"name":"Game","_id":"cjpwslro4003vb8oujjvxzqk1"},{"name":"欧拉路","_id":"cjpwslro90044b8ouv8l83537"},{"name":"拓扑排序","_id":"cjpwslrof004cb8ougj8mnt6j"},{"name":"Lover","_id":"cjpwslroj004lb8ou0o7hox2x"},{"name":"全局思维","_id":"cjpwslroo004ub8oumg2a73j7"},{"name":"暴力枚举","_id":"cjpwslror0053b8oux7thm9kc"},{"name":"全局思想","_id":"cjpwslrov005cb8ouvhycra1q"},{"name":"stack","_id":"cjpwslroy005lb8ou4si54i44"},{"name":"二叉树","_id":"cjpwslrp3005xb8ouh1c9n9u0"},{"name":"逆向思维","_id":"cjpwslrp40068b8ouvkde6env"},{"name":"链表","_id":"cjpwslrp4006cb8ouknk6uifp"},{"name":"栈","_id":"cjpwslrp5006gb8ou9zw82wrd"},{"name":"Stack","_id":"cjpwslrp6006ob8ouzl2tyj31"},{"name":"离散化","_id":"cjpwslrp6006ub8oupkd9c1kg"},{"name":"DP","_id":"cjpwslrp7006yb8ou5o7n0j2n"},{"name":"01背包","_id":"cjpwslrp70072b8ou1x79ewef"},{"name":"四分树","_id":"cjpwslrp80075b8ouh7w5nkcs"},{"name":"mathjax","_id":"cjpwslrp9007fb8oudfxp30nb"},{"name":"hexo插入数学公式","_id":"cjpwslrpa007kb8ouqifx1qhh"},{"name":"树","_id":"cjpwslrpa007nb8ouu3bnaep9"},{"name":"C++","_id":"cjpwslrpb007rb8ou0jij8flm"},{"name":"排列","_id":"cjpwslrpb007ub8oueeraejk6"},{"name":"生活","_id":"cjpwslrpc007wb8ou3rebjpk6"},{"name":"线段树单点更新","_id":"cjpwslrpe0084b8ouh91i0f2d"},{"name":"线段树区间更新","_id":"cjpwslrpe0086b8ouju87svc3"},{"name":"字符串","_id":"cjpwslrpe0088b8oudjolhcn2"},{"name":"vultr服务器搭建","_id":"cjpwslrpf008ab8oufdfjwtro"},{"name":"Math","_id":"cjpwslrpf008eb8ou3pjcnujn"},{"name":"python","_id":"cjpwslrpg008ib8ouls832add"}]}}