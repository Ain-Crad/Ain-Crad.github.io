---
title: 八数码问题
date: 2018-12-26 23:07:55
categories:
- Summary
tags:
---
八数码问题，最开始是在人工智能基础课上学的，然而我已无力吐槽这门课了，现在我才回想起来原来她当时所讲的open表其实就是栈和队列。而当时那些手算看起来很简单的搜索算法，实际写起来还是会有很多坑的，如果现在再重新学这门课我应该会有很多新的思考和认识吧。
![EightDigital](/EightDigital.png)
## 八数码问题
编号为$1-8$的八个正方形滑块被摆成3行3列，其中有一个格子留空。每次可以把与空格相邻的滑块移到空格中，它原来的位置就成了新的空格。给定初始局面和目标局面，计算最少的移动步数。
因为是计算最少移动步数，所以用BFS来搜索比较合适。但是和一般的图搜索不太一样，这里没有显式的结点。可以想到把每一个“状态”看做图的一个结点，然后根据合法的移动方式去扩展其它结点，直到到达目标状态。
还有一个问题是如何标记已经访问过的状态，以避免对同一个结点做多次访问。在显式的图搜索里我们一般会开一个vis数组来标记，但是这里如果要用vis数组的话，要开到九维，$9_9$，这对空间的消耗太大了。于是我们可以考虑用哈希，每一个状态对应一个整型数，一共的状态数是$9! = 362880$种。这样我们用一个vis数组就可以表示出来了。
*下面的代码是用STL里的map实现的哈希，稍微做了简化，没有用到vis数组，因为我通过map的find函数也可以知道当前状态是否被访问过。*

## 代码
```C++
/*
 *
 * Author : Aincrad
 *
 * Date : Wed 26 Dec 08:39:43 CST 2018
 *
 */

#include <bits/stdc++.h>

using namespace std;

typedef int State[9];
State st, ed;
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};
map<int, int> mp;
struct Node{
	Node(int* d = NULL, int dis = -1, int id = -1):d(d), dis(dis), id(id){}
	int* d;
	int dis;
	int id;
};
queue<Node> que;
int StartVal, EndVal;
int pos, x, y;
int ans;
int pre[1000000];
int* data[1000000];
int cnt;
int num;

int Trans(int* d){
	int sum = 0;
	for(int i = 0; i < 9; i++){
		sum *= 10;
		sum += d[i];
	}
	return sum;
}

bool Match(int* d){
	int val = Trans(d);
	if(val == EndVal) return true;
	else return false;
}

void PrintPath(){
	int* ptr;
	vector<int> vec;
	while(num > 0){
		vec.push_back(num);
		num = pre[num];
	}
	reverse(vec.begin(), vec.end());
	for(int x : vec){
		ptr = data[x];
		for(int i = 0; i < 9; i++){
			cout << ptr[i];
			if((i + 1) % 3 == 0) cout << "\n";
			else cout << " ";
		}
		cout << endl;
		cnt = pre[cnt];
	}
}

void bfs(){
	mp.clear();
	que.push(Node(st, 0, ++cnt));
	int val = Trans(st);
	mp[val] = cnt;
	data[cnt] = st;
	while(!que.empty()){
		Node nd = que.front();
		que.pop();
		if(Match(nd.d)){
			ans = nd.dis;
			num = nd.id;
			break;
		}
		for(int i = 0; i < 9; i++){
			if(nd.d[i] == 0){
				pos = i;
				break;
			}
		}
		x = pos / 3, y = pos % 3;
		for(int i = 0; i < 4; i++){
			int nx = x + dx[i], ny = y + dy[i];
			if(nx >= 0 && nx < 3 && ny >= 0 && ny < 3){
				Node ist;
				ist.d = new int[9];
				for(int i = 0; i < 9; i++){
					ist.d[i] = nd.d[i];
				}
				ist.dis = nd.dis + 1;
				int v = ist.d[pos], p2 = nx * 3 + ny;
				ist.d[pos] = ist.d[p2];
				ist.d[p2] = v;
				val = Trans(ist.d);
				if(mp.find(val) == mp.end()){
					ist.id = ++cnt;
					que.push(Node(ist.d, ist.dis, ist.id));
					mp[val] = cnt;
					data[cnt] = ist.d;
					pre[cnt] = nd.id;
				}
			}
		} 
	}
}

int main(){
	#ifndef ONLINE_JUDGE
		freopen("in.txt", "r", stdin);
	#endif
	for(int i = 0; i < 9; i++){
		cin >> st[i];
	}
	for(int i = 0; i < 9; i++){
		cin >> ed[i];
	}
	cnt = 0;
	memset(pre, -1, sizeof(pre));
	StartVal = Trans(st);
	EndVal = Trans(ed);
	ans = -1;
	bfs();
	PrintPath();
	cout << ans << endl;
	return 0;
}

```